/* Generated by SharpKit 5 v5.4.5 */
if (typeof($CreateException)=='undefined') 
{
    var $CreateException = function(ex, error) 
    {
        if(error==null)
            error = new Error();
        if(ex==null)
            ex = new System.Exception.ctor();       
        error.message = ex.message;
        for (var p in ex)
           error[p] = ex[p];
        return error;
    }
}

if (typeof ($CreateAnonymousDelegate) == 'undefined') {
    var $CreateAnonymousDelegate = function (target, func) {
        if (target == null || func == null)
            return func;
        var delegate = function () {
            return func.apply(target, arguments);
        };
        delegate.func = func;
        delegate.target = target;
        delegate.isDelegate = true;
        return delegate;
    }
}

function $CombineDelegates(del1,del2)
{
    if(del1 == null)
        return del2;
    if(del2 == null)
        return del1;
    var del=$CreateMulticastDelegateFunction();
    del.delegates = [];
    if(del1.isMulticastDelegate)
    {
        for(var i=0;i < del1.delegates.length;i++)
            del.delegates.push(del1.delegates[i]);
    }
    else
    {
        del.delegates.push(del1);
    }
    if(del2.isMulticastDelegate)
    {
        for(var i=0;i < del2.delegates.length;i++)
            del.delegates.push(del2.delegates[i]);
    }
    else
    {
        del.delegates.push(del2);
    }
    return del;
};

function $CreateMulticastDelegateFunction()
{
    var del2 = null;
    
    var del=function()
    {
        var x=undefined;
        for(var i=0;i < del2.delegates.length;i++)
        {
            var del3=del2.delegates[i];
            x = del3.apply(null,arguments);
        }
        return x;
    };
    del.isMulticastDelegate = true;
    del2 = del;   
    
    return del;
};

function $RemoveDelegate(delOriginal,delToRemove)
{
    if(delToRemove == null || delOriginal == null)
        return delOriginal;
    if(delOriginal.isMulticastDelegate)
    {
        if(delToRemove.isMulticastDelegate)
            throw new Error("Multicast to multicast delegate removal is not implemented yet");
        var del=$CreateMulticastDelegateFunction();
        for(var i=0;i < delOriginal.delegates.length;i++)
        {
            var del2=delOriginal.delegates[i];
            if(del2 != delToRemove)
            {
                if(del.delegates == null)
                    del.delegates = [];
                del.delegates.push(del2);
            }
        }
        if(del.delegates == null)
            return null;
        if(del.delegates.length == 1)
            return del.delegates[0];
        return del;
    }
    else
    {
        if(delToRemove.isMulticastDelegate)
            throw new Error("single to multicast delegate removal is not supported");
        if(delOriginal == delToRemove)
            return null;
        return delOriginal;
    }
};

if (typeof($CreateDelegate)=='undefined'){
    if(typeof($iKey)=='undefined') var $iKey = 0;
    if(typeof($pKey)=='undefined') var $pKey = String.fromCharCode(1);
    var $CreateDelegate = function(target, func){
        if (target == null || func == null) 
            return func;
        if(func.target==target && func.func==func)
            return func;
        if (target.$delegateCache == null)
            target.$delegateCache = {};
        if (func.$key == null)
            func.$key = $pKey + String(++$iKey);
        var delegate;
        if(target.$delegateCache!=null)
            delegate = target.$delegateCache[func.$key];
        if (delegate == null){
            delegate = function(){
                return func.apply(target, arguments);
            };
            delegate.func = func;
            delegate.target = target;
            delegate.isDelegate = true;
            if(target.$delegateCache!=null)
                target.$delegateCache[func.$key] = delegate;
        }
        return delegate;
    }
}

if (typeof(Int32Array) == "undefined")
    var Int32Array = Array;
if (typeof(Float64Array) == "undefined")
    var Float64Array = Array;
if (typeof(Float32Array) == "undefined")
    var Float32Array = Array;
if (typeof($CreateAnonymousObject)=='undefined') 
{
    var $CreateAnonymousObject = function(json)
    {
        var obj = new System.Object.ctor();
        obj.d = json;
        for(var p in json){
            obj['get_'+p] = new Function('return this.d.'+p+';');
        }
        return obj;
    }
}


if (typeof(JsTypes) == "undefined")
    var JsTypes = [];
var Microsoft$Msagl$Layout$LargeGraphLayout$LgLevel = {
    fullname: "Microsoft.Msagl.Layout.LargeGraphLayout.LgLevel",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (zoomLevel, geomGraph){
            this._railDictionary = new System.Collections.Generic.Dictionary$2.ctor$$IEqualityComparer$1(System.Tuple$2.ctor, Microsoft.Msagl.Layout.LargeGraphLayout.Rail.ctor, new Microsoft.Msagl.Layout.LargeGraphLayout.LgData.CurveRailComparer.ctor());
            this._railsOfEdges = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor, Microsoft.Msagl.Core.DataStructures.Set$1.ctor);
            this.HighlightedRails = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Layout.LargeGraphLayout.Rail.ctor);
            this.ZoomLevel = 0;
            this._geomGraph = null;
            this._railTree = null;
            this.tileTableForStatistic = new System.Collections.Generic.Dictionary$2.ctor(System.Tuple$2.ctor, Microsoft.Msagl.Layout.LargeGraphLayout.LgLevel.TileStatistic.ctor);
            System.Object.ctor.call(this);
            this._geomGraph = geomGraph;
            this.ZoomLevel = zoomLevel;
        },
        CreateRailTree: function (){
            this._railTree = new Microsoft.Msagl.Core.Geometry.RTree$1.ctor$$IEnumerable$1(Microsoft.Msagl.Layout.LargeGraphLayout.Rail.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Layout.LargeGraphLayout.Rail.ctor, System.Collections.Generic.KeyValuePair$2.ctor, this._railDictionary.get_Values(), $CreateAnonymousDelegate(this, function (rail){
                return new System.Collections.Generic.KeyValuePair$2.ctor$$TKey$$TValue(Microsoft.Msagl.Core.Geometry.Rectangle.ctor, Microsoft.Msagl.Layout.LargeGraphLayout.Rail.ctor, rail.get_BoundingBox(), rail);
            })));
            System.Console.WriteLine$$String$$Object$$Object$$Object("edges = {0}, rails = {1}, edge segments = {2}", this._railsOfEdges.get_Count(), this._railDictionary.get_Count(), System.Linq.Enumerable.Sum$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.DataStructures.Set$1.ctor, this._railsOfEdges.get_Values(), $CreateAnonymousDelegate(this, function (s){
                return s.get_Count();
            })));
        },
        AssociateEdgeAndRail: function (edge, rail){
            var railSet;
            if (!(function (){
                var $1 = {
                    Value: railSet
                };
                var $res = this._railsOfEdges.TryGetValue(edge, $1);
                railSet = $1.Value;
                return $res;
            }).call(this)){
                this._railsOfEdges.set_Item$$TKey(edge, railSet = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Layout.LargeGraphLayout.Rail.ctor));
            }
            railSet.Insert(rail);
        },
        FillRailDictionaryForEdge: function (edge){
            var setOfRails = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Layout.LargeGraphLayout.Rail.ctor);
            this._railsOfEdges.set_Item$$TKey(edge, setOfRails);
            this.FillRailDictionaryForEdgeCurve(edge.get_Curve(), setOfRails);
            this.FillRailDictionaryForArrowSource(edge.get_EdgeGeometry().get_SourceArrowhead(), edge.get_Curve(), setOfRails);
            this.FillRailDictionaryForArrowTarget(edge.get_EdgeGeometry().get_TargetArrowhead(), edge.get_Curve(), setOfRails);
        },
        FillRailDictionaryForArrowSource: function (sourceArrowhead, curve, railSet){
            if (sourceArrowhead == null)
                return;
            railSet.Insert(this._railDictionary.get_Item$$TKey(new System.Tuple$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, curve.get_Start(), sourceArrowhead.get_TipPosition())));
        },
        FillRailDictionaryForArrowTarget: function (targetArrowhead, curve, railSet){
            if (targetArrowhead == null)
                return;
            railSet.Insert(this._railDictionary.get_Item$$TKey(new System.Tuple$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, curve.get_End(), targetArrowhead.get_TipPosition())));
        },
        FillRailDictionaryForEdgeCurve: function (curve, railSet){
            var cc = As(curve, Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor);
            if (cc != null){
                var $it1 = cc.get_Segments().GetEnumerator();
                while ($it1.MoveNext()){
                    var seg = $it1.get_Current();
                    this.FillRailDictionaryForSeg(seg, railSet);
                }
            }
            else
                this.FillRailDictionaryForSeg(curve, railSet);
        },
        FillRailDictionaryForSeg: function (seg, railSet){
            var tuple = new System.Tuple$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, seg.get_Start(), seg.get_End());
            railSet.Insert(this._railDictionary.get_Item$$TKey(tuple));
        },
        RegisterRailsOfEdge: function (edgeInfo){
            var curve = As(edgeInfo.get_Edge().get_Curve(), Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor);
            if (curve != null){
                var $it2 = curve.get_Segments().GetEnumerator();
                while ($it2.MoveNext()){
                    var seg = $it2.get_Current();
                    this.RegisterElementaryRail(edgeInfo, seg);
                }
            }
            else
                this.RegisterElementaryRail(edgeInfo, edgeInfo.get_Edge().get_Curve());
            this.RegisterRailsForArrowheads(edgeInfo);
        },
        RegisterRailsForArrowheads: function (edgeInfo){
            var edgeGeom = edgeInfo.get_Edge().get_EdgeGeometry();
            if (edgeGeom.get_SourceArrowhead() != null){
                var tuple = new System.Tuple$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, edgeGeom.get_SourceArrowhead().get_TipPosition(), edgeGeom.get_Curve().get_Start());
                var rail;
                if ((function (){
                    var $1 = {
                        Value: rail
                    };
                    var $res = this._railDictionary.TryGetValue(tuple, $1);
                    rail = $1.Value;
                    return $res;
                }).call(this)){
                    if (rail.TopRankedEdgeInfoOfTheRail.get_Rank() < edgeInfo.get_Rank())
                        rail.TopRankedEdgeInfoOfTheRail = edgeInfo;
                }
                else
                    this._railDictionary.set_Item$$TKey(tuple, new Microsoft.Msagl.Layout.LargeGraphLayout.Rail.ctor$$Arrowhead$$Point$$LgEdgeInfo$$Int32(edgeGeom.get_SourceArrowhead(), edgeGeom.get_Curve().get_Start(), edgeInfo, this.ZoomLevel));
            }
            if (edgeGeom.get_TargetArrowhead() != null){
                var tuple = new System.Tuple$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, edgeGeom.get_TargetArrowhead().get_TipPosition(), edgeGeom.get_Curve().get_End());
                var rail;
                if ((function (){
                    var $1 = {
                        Value: rail
                    };
                    var $res = this._railDictionary.TryGetValue(tuple, $1);
                    rail = $1.Value;
                    return $res;
                }).call(this)){
                    if (rail.TopRankedEdgeInfoOfTheRail.get_Rank() < edgeInfo.get_Rank())
                        this._railDictionary.set_Item$$TKey(tuple, new Microsoft.Msagl.Layout.LargeGraphLayout.Rail.ctor$$Arrowhead$$Point$$LgEdgeInfo$$Int32(edgeGeom.get_TargetArrowhead(), edgeGeom.get_Curve().get_End(), edgeInfo, this.ZoomLevel));
                }
                else
                    this._railDictionary.set_Item$$TKey(tuple, new Microsoft.Msagl.Layout.LargeGraphLayout.Rail.ctor$$Arrowhead$$Point$$LgEdgeInfo$$Int32(edgeGeom.get_TargetArrowhead(), edgeGeom.get_Curve().get_End(), edgeInfo, this.ZoomLevel));
            }
        },
        RegisterElementaryRail: function (edgeInfo, seg){
            var rail;
            var tuple = new System.Tuple$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, seg.get_Start(), seg.get_End());
            if ((function (){
                var $1 = {
                    Value: rail
                };
                var $res = this._railDictionary.TryGetValue(tuple, $1);
                rail = $1.Value;
                return $res;
            }).call(this)){
                if (rail.TopRankedEdgeInfoOfTheRail.get_Rank() < edgeInfo.get_Rank())
                    rail.TopRankedEdgeInfoOfTheRail = edgeInfo;
            }
            else
                this._railDictionary.set_Item$$TKey(tuple, new Microsoft.Msagl.Layout.LargeGraphLayout.Rail.ctor$$ICurve$$LgEdgeInfo$$Int32(seg, edgeInfo, this.ZoomLevel));
        },
        GetRailsIntersectionVisRect: function (visibleRectange){
            var ret = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Layout.LargeGraphLayout.Rail.ctor);
            var $it3 = this._railTree.GetAllIntersecting(visibleRectange).GetEnumerator();
            while ($it3.MoveNext()){
                var rail = $it3.get_Current();
                ret.Insert(rail);
            }
            return ret;
        },
        GetEdgesPassingThroughRail: function (rail){
            return System.Linq.Enumerable.ToList$1(Microsoft.Msagl.Core.Layout.Edge.ctor, (System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.Collections.Generic.KeyValuePair$2.ctor, Microsoft.Msagl.Core.Layout.Edge.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(System.Collections.Generic.KeyValuePair$2.ctor, this._railsOfEdges, $CreateAnonymousDelegate(this, function (kv){
                return kv.get_Value().Contains$$T(rail);
            })), $CreateAnonymousDelegate(this, function (kv){
                return kv.get_Key();
            }))));
        },
        RunLevelStatistics: function (nodes){
            System.Console.WriteLine$$String("running stats");
            var $it4 = this._railDictionary.get_Values().GetEnumerator();
            while ($it4.MoveNext()){
                var rail = $it4.get_Current();
                this.CreateStatisticsForRail(rail);
            }
            this.RunStatisticsForNodes(nodes);
            var numberOfTiles = this.ZoomLevel * this.ZoomLevel;
            var averageRailsForTile = 0;
            var averageVerticesForTile = 0;
            var maxVerticesPerTile = 0;
            var maxRailsPerTile = 0;
            var maxTotalPerTile = 0;
            var $it5 = this.tileTableForStatistic.get_Values().GetEnumerator();
            while ($it5.MoveNext()){
                var tileStatistic = $it5.get_Current();
                averageVerticesForTile += tileStatistic.vertices / numberOfTiles;
                averageRailsForTile += tileStatistic.rails / numberOfTiles;
                if (maxRailsPerTile < tileStatistic.rails)
                    maxRailsPerTile = tileStatistic.rails;
                if (maxVerticesPerTile < tileStatistic.vertices)
                    maxVerticesPerTile = tileStatistic.vertices;
                if (maxTotalPerTile < tileStatistic.vertices + tileStatistic.rails)
                    maxTotalPerTile = tileStatistic.vertices + tileStatistic.rails;
            }
            System.Console.WriteLine$$String$$Object$$Object$$Object("level {0}: average rails per tile {1}\naverage verts per tile {2}, total average per tile {1}.\n", this.ZoomLevel, averageRailsForTile, averageVerticesForTile);
            System.Console.WriteLine$$String$$Object$$Object$$Object("max rails per tile {0}\nmax verts per tile {1}, total max per tile {2}.\n", maxRailsPerTile, maxVerticesPerTile, maxTotalPerTile);
            System.Console.WriteLine$$String("done with stats");
        },
        RunStatisticsForNodes: function (nodes){
            var $it6 = nodes.GetEnumerator();
            while ($it6.MoveNext()){
                var node = $it6.get_Current();
                this.CreateStatisticsForNode(node);
            }
        },
        CreateStatisticsForNode: function (node){
            var $it7 = this.GetCurveTiles(node.get_BoundaryCurve()).GetEnumerator();
            while ($it7.MoveNext()){
                var tile = $it7.get_Current();
                tile.vertices++;
            }
        },
        CreateStatisticsForRail: function (rail){
            var arrowhead = As(rail.Geometry, Microsoft.Msagl.Core.Layout.Arrowhead.ctor);
            if (arrowhead != null)
                this.CreateStatisticsForArrowhead(arrowhead);
            else {
                var $it8 = this.GetCurveTiles(As(rail.Geometry, Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor)).GetEnumerator();
                while ($it8.MoveNext()){
                    var t = $it8.get_Current();
                    t.rails++;
                }
            }
        },
        CreateStatisticsForArrowhead: function (arrowhead){
            var tile = this.GetOrCreateTileStatistic(arrowhead.get_TipPosition());
            tile.rails++;
        },
        GetOrCreateTileStatistic: function (p){
            var t = Microsoft.Msagl.Layout.LargeGraphLayout.DeviceIndependendZoomCalculatorForNodes.PointToTuple(this._geomGraph.get_LeftBottom(), p, this.GetGridSize());
            var ts;
            if ((function (){
                var $1 = {
                    Value: ts
                };
                var $res = this.tileTableForStatistic.TryGetValue(t, $1);
                ts = $1.Value;
                return $res;
            }).call(this))
                return ts;
            this.tileTableForStatistic.set_Item$$TKey(t, ts = (function (){
                var $v1 = new Microsoft.Msagl.Layout.LargeGraphLayout.LgLevel.TileStatistic.ctor();
                $v1.rails = 0;
                $v1.vertices = 0;
                return $v1;
            }).call(this));
            return ts;
        },
        GetCurveTiles: function (curve){
            var tiles = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Layout.LargeGraphLayout.LgLevel.TileStatistic.ctor);
            var n = 64;
            var s = curve.get_ParStart();
            var e = curve.get_ParEnd();
            var d = (e - s) / 63;
            for (var i = 0; i < 64; i++){
                var t = s + i * d;
                var ts = this.GetOrCreateTileStatistic(curve.get_Item$$Double(t));
                tiles.Insert(ts);
            }
            return tiles;
        },
        GetGridSize: function (){
            return System.Math.Max$$Double$$Double(this._geomGraph.get_Width(), this._geomGraph.get_Height()) / this.ZoomLevel;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$LargeGraphLayout$LgLevel);
var Microsoft$Msagl$Layout$LargeGraphLayout$LgLevel$TileStatistic = {
    fullname: "Microsoft.Msagl.Layout.LargeGraphLayout.LgLevel.TileStatistic",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.vertices = 0;
            this.rails = 0;
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$LargeGraphLayout$LgLevel$TileStatistic);
var System$ExtensionsForSharpKit = {
    fullname: "System.ExtensionsForSharpKit",
    baseTypeName: "System.Object",
    staticDefinition: {
        Trim_SharpKit: function (me, chars){
            var start = 0,end = me.length - 1;
            for (; start < me.length; start++){
                var found = false;
                for (var i = 0; i < chars.length && !found; i++)
                    if (me.charAt(start) == chars[i])
                        found = true;
                if (!found)
                    break;
            }
            for (; end >= 0; end--){
                var found = false;
                for (var i = 0; i < chars.length && !found; i++)
                    if (me.charAt(end) == chars[i])
                        found = true;
                if (!found)
                    break;
            }
            return me.substr(start, end - start + 1);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(System$ExtensionsForSharpKit);
var SharpKitExtensions$Regex_SharpKit = {
    fullname: "SharpKitExtensions.Regex_SharpKit",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (pattern){
            this.m_JSRegex = null;
            System.Object.ctor.call(this);
            this.m_JSRegex = new RegExp(pattern);
        },
        Match: function (input, start){
            input = input.substr(start);
            var result = this.m_JSRegex.exec(input);
            var ret = new SharpKitExtensions.Match_SharpKit.ctor(result);
            return ret;
        }
    }
};
JsTypes.push(SharpKitExtensions$Regex_SharpKit);
var SharpKitExtensions$Match_SharpKit = {
    fullname: "SharpKitExtensions.Match_SharpKit",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (res){
            this.m_JSResult = null;
            System.Object.ctor.call(this);
            this.m_JSResult = res;
        },
        Success$$: "System.Boolean",
        get_Success: function (){
            return this.m_JSResult != null;
        },
        Value$$: "System.String",
        get_Value: function (){
            return this.m_JSResult[0];
        },
        Length$$: "System.Int32",
        get_Length: function (){
            return this.m_JSResult[0].length;
        }
    }
};
JsTypes.push(SharpKitExtensions$Match_SharpKit);
var SharpKitExtensions$StringWriter_SharpKit = {
    fullname: "SharpKitExtensions.StringWriter_SharpKit",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.m_SB = null;
            System.Object.ctor.call(this);
            this.m_SB = new System.Text.StringBuilder.ctor();
        },
        WriteLine: function (str){
            this.m_SB.Append$$String(str);
            this.m_SB.Append$$String("\n");
        },
        Flush: function (){
        },
        Close: function (){
        },
        Write: function (str){
            this.m_SB.Append$$String(str);
        },
        toString: function (){
            return this.m_SB.toString();
        }
    }
};
JsTypes.push(SharpKitExtensions$StringWriter_SharpKit);
var Test$Test = {
    fullname: "Test.Test",
    baseTypeName: "System.Object",
    staticDefinition: {
        RunTest: function (){
            System.Console.Write$$Object(Test.Test.TestInner.TestInnerEnum.A);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Test$Test);
var Test$Test$TestEnum = {
    fullname: "Test.Test.TestEnum",
    staticDefinition: {
        C: 0,
        D: 1
    },
    Kind: "Enum"
};
JsTypes.push(Test$Test$TestEnum);
var Test$Test$TestInner = {
    fullname: "Test.Test.TestInner",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Test$Test$TestInner);
var Microsoft$Msagl$Core$AlgorithmBase = {
    fullname: "Microsoft.Msagl.Core.AlgorithmBase",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Core.AlgorithmBase.threadStaticCancelToken = null;
            Microsoft.Msagl.Core.AlgorithmBase.LocalProgressStepSizeDefault = 0.05;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.cancelToken = null;
            this.progressRatio = 0;
            this.localProgressStepSize = 0.05;
            this.localProgressSpecified = false;
            this.localStepCount = 0;
            this.stageStartRatio = 0;
            this.stageEndRatio = 1;
            this.ProgressChanged = null;
            System.Object.ctor.call(this);
        },
        Run: function (){
            this.progressRatio = 0;
            this.localStepCount = 0;
            this.cancelToken = Microsoft.Msagl.Core.AlgorithmBase.threadStaticCancelToken;
            this.ThrowIfCanceled();
            this.ProgressSteps(0);
            this.RunInternal();
            if (!this.get_IsCanceled()){
                this.ProgressComplete();
            }
        },
        Run$$CancelToken: function (cancelToken){
            this.progressRatio = 0;
            this.localStepCount = 0;
            var oldCancelToken = this.SetCancelToken(cancelToken);
            try{
                this.ProgressSteps(0);
                this.RunInternal();
                if (!this.get_IsCanceled()){
                    this.ProgressComplete();
                }
            }
            finally{
                Microsoft.Msagl.Core.AlgorithmBase.threadStaticCancelToken = oldCancelToken;
            }
        },
        SetCancelToken: function (cancelToken){
            this.cancelToken = cancelToken;
            this.ThrowIfCanceled();
            var oldCancelToken = Microsoft.Msagl.Core.AlgorithmBase.threadStaticCancelToken;
            Microsoft.Msagl.Core.AlgorithmBase.threadStaticCancelToken = cancelToken;
            return oldCancelToken;
        },
        Cancel: function (){
            if (this.cancelToken != null){
                this.cancelToken.set_Canceled(true);
            }
        },
        IsCanceled$$: "System.Boolean",
        get_IsCanceled: function (){
            return this.cancelToken != null && this.cancelToken.get_Canceled();
        },
        ThrowIfCanceled: function (){
            if (this.cancelToken != null){
                this.cancelToken.ThrowIfCanceled();
            }
        },
        CancelToken$$: "Microsoft.Msagl.Core.CancelToken",
        get_CancelToken: function (){
            return this.cancelToken;
        },
        add_ProgressChanged: function (value){
            this.ProgressChanged = $CombineDelegates(this.ProgressChanged, value);
        },
        remove_ProgressChanged: function (value){
            this.ProgressChanged = $RemoveDelegate(this.ProgressChanged, value);
        },
        StartListenToLocalProgress: function (expectedSteps, stageRatio){
            this.localProgressStepSize = stageRatio / System.Math.Max$$Int32$$Int32(1, expectedSteps);
            this.localProgressSpecified = true;
            this.localStepCount = 0;
            this.stageStartRatio = 0;
            this.stageEndRatio = 1;
        },
        StartListenToProgress: function (childAlgorithm, stageRatio){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(childAlgorithm, "childAlgorithm");
            childAlgorithm.add_ProgressChanged($CreateDelegate(this, this.NotifyProgressChanged));
            this.stageStartRatio = this.progressRatio;
            this.stageEndRatio = this.progressRatio + stageRatio;
        },
        StopListenToProgress: function (childAlgorithm){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(childAlgorithm, "childAlgorithm");
            childAlgorithm.remove_ProgressChanged($CreateDelegate(this, this.NotifyProgressChanged));
            this.progressRatio = this.stageEndRatio;
            this.stageStartRatio = 0;
            this.stageEndRatio = 1;
        },
        RunChildAlgorithm: function (childAlgorithm, stageRatio){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(childAlgorithm, "childAlgorithm");
            try{
                this.StartListenToProgress(childAlgorithm, stageRatio);
                childAlgorithm.Run();
            }
            finally{
                this.StopListenToProgress(childAlgorithm);
            }
        },
        ProgressComplete: function (){
            this.ThrowIfCanceled();
            if (this.progressRatio != 1){
                this.progressRatio = 1;
                this.NotifyProgressChanged(this, new Microsoft.Msagl.Core.ProgressChangedEventArgs.ctor$$Double(this.progressRatio));
            }
        },
        ProgressStep: function (){
            this.ProgressSteps(1);
        },
        ProgressSteps: function (stepsTaken){
            this.ThrowIfCanceled();
            this.localStepCount += stepsTaken;
            if (this.localProgressSpecified){
                this.progressRatio = this.progressRatio + (this.localProgressStepSize * stepsTaken);
            }
            else {
                var Limit = 0.85;
                var HalfLife = 50;
                var Numerator = 42.5;
                this.progressRatio = Limit - (Numerator / (HalfLife + this.localStepCount));
            }
            if (System.Math.Round$$Double$$Int32(this.progressRatio, 6) == 1){
                this.progressRatio = 1;
            }
            this.NotifyProgressChanged(this, new Microsoft.Msagl.Core.ProgressChangedEventArgs.ctor$$Double(this.progressRatio));
        },
        NotifyProgressChanged: function (sender, args){
            if (this.ProgressChanged != null){
                var stageRatio = this.stageEndRatio - this.stageStartRatio;
                var stageProgress = stageRatio * args.get_RatioComplete();
                this.ProgressChanged(this, new Microsoft.Msagl.Core.ProgressChangedEventArgs.ctor$$Double(this.stageStartRatio + stageProgress));
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$AlgorithmBase);
var Microsoft$Msagl$Core$DataStructures$CollectionUtilities = {
    fullname: "Microsoft.Msagl.Core.DataStructures.CollectionUtilities",
    baseTypeName: "System.Object",
    staticDefinition: {
        SafeAdd$2: function (T, TC, dictionary, key, value){
            if (!dictionary.ContainsKey(key))
                dictionary.Add(key, value);
        },
        AddToMap$3: function (TS, T, TC, dictionary, key, value){
            var tc;
            if (!(function (){
                var $1 = {
                    Value: tc
                };
                var $res = dictionary.TryGetValue(key, $1);
                tc = $1.Value;
                return $res;
            })())
                dictionary.set_Item$$TKey(key, tc = new TC());
            tc.Add(value);
        },
        RemoveFromMap$3: function (TS, T, TC, dictionary, key, value){
            var tc = dictionary.get_Item$$TKey(key);
            tc.Remove(value);
            if (tc.get_Count() == 0)
                dictionary.Remove(key);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$DataStructures$CollectionUtilities);
var Microsoft$Msagl$Core$DataStructures$GenericBinaryHeapPriorityQueueWithTimestamp$1 = {
    fullname: "Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueueWithTimestamp$1",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (T){
            Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueueWithTimestamp$1.InitialHeapCapacity = 16;
        },
        Test: function (){
            var q = new Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueue$1.ctor(System.Int32.ctor);
            q.Enqueue(2, 2);
            q.Enqueue(1, 1);
            q.Enqueue(9, 9);
            q.Enqueue(8, 8);
            q.Enqueue(5, 5);
            q.Enqueue(3, 3);
            q.Enqueue(4, 4);
            q.Enqueue(7, 7);
            q.Enqueue(6, 6);
            q.Enqueue(0, 0);
            q.DecreasePriority(4, 2.5);
            while (q.IsEmpty() == false)
                System.Console.WriteLine$$Int32(q.Dequeue());
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IEnumerable$1"],
    Kind: "Class",
    definition: {
        ctor: function (T){
            this.T = T;
            this.A = null;
            this.timestamp = 0;
            this.cache = null;
            this.heapSize = 0;
            System.Object.ctor.call(this);
            this.cache = new System.Collections.Generic.Dictionary$2.ctor(this.T, Microsoft.Msagl.Core.DataStructures.GenericHeapElementWithTimestamp$1.ctor);
            this.A = new Array(17);
        },
        NextTimestamp$$: "System.UInt64",
        get_NextTimestamp: function (){
            return ++this.timestamp;
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this.heapSize;
        },
        ContainsElement: function (key){
            return this.cache.ContainsKey(key);
        },
        SwapWithParent: function (i){
            var parent = this.A[i >> 1];
            this.PutAtI(i >> 1, this.A[i]);
            this.PutAtI(i, parent);
        },
        Enqueue: function (element, priority){
            if (this.heapSize == this.A.length - 1){
                var newA = new Array(this.A.length * 2);
                System.Array.Copy(this.A, 1, newA, 1, this.heapSize);
                this.A = newA;
            }
            this.heapSize++;
            var i = this.heapSize;
            var h;
            this.A[i] = (function ($p1){
                this.cache.set_Item$$TKey(element, $p1);
                return $p1;
            }).call(this, h = new Microsoft.Msagl.Core.DataStructures.GenericHeapElementWithTimestamp$1.ctor(this.T, i, priority, element, this.get_NextTimestamp()));
            while (i > 1 && this.A[i >> 1].ComparePriority(this.A[i]) > 0){
                this.SwapWithParent(i);
                i >>= 1;
            }
            System.Diagnostics.Debug.Assert$$Boolean(this.A[i] == h);
            this.A[i] = h;
        },
        IsEmpty: function (){
            return this.heapSize == 0;
        },
        PutAtI: function (i, h){
            this.A[i] = h;
            h.indexToA = i;
        },
        Dequeue: function (){
            if (this.heapSize == 0)
                throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            var ret = this.A[1].v;
            this.MoveQueueOneStepForward(ret);
            return ret;
        },
        Dequeue$$Double: function (priority){
            if (this.heapSize == 0)
                throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            var ret = this.A[1].v;
            priority.Value = this.A[1].priority;
            this.MoveQueueOneStepForward(ret);
            return ret;
        },
        MoveQueueOneStepForward: function (ret){
            this.cache.Remove(ret);
            this.PutAtI(1, this.A[this.heapSize]);
            var i = 1;
            while (true){
                var smallest = i;
                var l = i << 1;
                if (l <= this.heapSize && this.A[l].ComparePriority(this.A[i]) < 0)
                    smallest = l;
                var r = l + 1;
                if (r <= this.heapSize && this.A[r].ComparePriority(this.A[smallest]) < 0)
                    smallest = r;
                if (smallest != i)
                    this.SwapWithParent(smallest);
                else
                    break;
                i = smallest;
            }
            this.heapSize--;
        },
        DecreasePriority: function (element, newPriority){
            var h;
            if (!(function (){
                var $1 = {
                    Value: h
                };
                var $res = this.cache.TryGetValue(element, $1);
                h = $1.Value;
                return $res;
            }).call(this))
                return;
            h.priority = newPriority;
            var i = h.indexToA;
            while (i > 1){
                if (this.A[i].ComparePriority(this.A[i >> 1]) < 0)
                    this.SwapWithParent(i);
                else
                    break;
                i >>= 1;
            }
        },
        GetEnumerator: function (){
            var $yield = [];
            for (var i = 1; i <= this.heapSize; i++)
                $yield.push(this.A[i].v);
            return $yield.GetEnumerator();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$DataStructures$GenericBinaryHeapPriorityQueueWithTimestamp$1);
var Microsoft$Msagl$Core$DataStructures$GenericHeapElementWithTimestamp$1 = {
    fullname: "Microsoft.Msagl.Core.DataStructures.GenericHeapElementWithTimestamp$1",
    baseTypeName: "Microsoft.Msagl.Core.DataStructures.GenericHeapElement$1",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (T, index, priority, v, timestamp){
            this.T = T;
            this._Timestamp = 0;
            Microsoft.Msagl.Core.DataStructures.GenericHeapElement$1.ctor.call(this, this.T, index, priority, v);
            this.set_Timestamp(timestamp);
        },
        Timestamp$$: "System.UInt64",
        get_Timestamp: function (){
            return this._Timestamp;
        },
        set_Timestamp: function (value){
            this._Timestamp = value;
        },
        ComparePriority: function (other){
            var cmp = this.priority.CompareTo$$Double(other.priority);
            return (cmp != 0) ? cmp : other.get_Timestamp().CompareTo$$UInt64(this.get_Timestamp());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$DataStructures$GenericHeapElementWithTimestamp$1);
var Microsoft$Msagl$Core$DataStructures$Size = {
    fullname: "Microsoft.Msagl.Core.DataStructures.Size",
    baseTypeName: "System.ValueType",
    staticDefinition: {
        op_Division: function (s, d){
            return new Microsoft.Msagl.Core.DataStructures.Size.ctor$$Double$$Double(s.get_Width() / d, s.get_Height() / d);
        },
        op_Multiply: function (s, d){
            return new Microsoft.Msagl.Core.DataStructures.Size.ctor$$Double$$Double(s.get_Width() * d, s.get_Height() * d);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Struct",
    definition: {
        ctor$$Double$$Double: function (width, height){
            this.width = 0;
            this.height = 0;
            System.ValueType.ctor.call(this);
            this.width = width;
            this.height = height;
        },
        Width$$: "System.Double",
        get_Width: function (){
            return this.width;
        },
        set_Width: function (value){
            this.width = value;
        },
        Height$$: "System.Double",
        get_Height: function (){
            return this.height;
        },
        set_Height: function (value){
            this.height = value;
        },
        Pad: function (padding){
            this.width += 2 * padding;
            this.height += 2 * padding;
        },
        ctor: function (){
            this.width = 0;
            this.height = 0;
            System.ValueType.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$DataStructures$Size);
var Microsoft$Msagl$Core$Geometry$ApproximateComparer = {
    fullname: "Microsoft.Msagl.Core.Geometry.ApproximateComparer",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Core.Geometry.ApproximateComparer.squareOfDistanceEpsilon = System.Math.Pow(10, -Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_DistanceEpsilonPrecision() * 2);
            Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon = System.Math.Pow(10, -Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_DistanceEpsilonPrecision());
            Microsoft.Msagl.Core.Geometry.ApproximateComparer.distXEps = 0.0001;
            Microsoft.Msagl.Core.Geometry.ApproximateComparer.tolerance = 1E-08;
            Microsoft.Msagl.Core.Geometry.ApproximateComparer.userDefinedTolerance = Microsoft.Msagl.Core.Geometry.ApproximateComparer.tolerance;
        },
        Close$$Point$$Point$$Double: function (pointA, pointB, tolerance){
            return (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(pointA, pointB)).get_Length() <= tolerance;
        },
        Close$$Point$$Point: function (pointA, pointB){
            return Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point$$Double(pointA, pointB, Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon);
        },
        Close$$Double$$Double: function (a, b){
            return System.Math.Abs$$Double(a - b) <= Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon;
        },
        Close$$Rectangle$$Rectangle$$Double: function (rect1, rect2, tolerance){
            return Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point$$Double(rect1.get_LeftBottom(), rect2.get_LeftBottom(), tolerance) && Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point$$Double(rect1.get_RightTop(), rect2.get_RightTop(), tolerance);
        },
        Close$$Rectangle$$Rectangle: function (rect1, rect2){
            return Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Rectangle$$Rectangle$$Double(rect1, rect2, Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon);
        },
        Compare: function (numberA, numberB){
            var c = numberA - numberB;
            if (c <= -Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return -1;
            if (c >= Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return 1;
            return 0;
        },
        Greater: function (numberA, numberB){
            return Microsoft.Msagl.Core.Geometry.ApproximateComparer.Compare(numberA, numberB) > 0;
        },
        GreaterOrEqual: function (numberA, numberB){
            return Microsoft.Msagl.Core.Geometry.ApproximateComparer.Compare(numberA, numberB) >= 0;
        },
        Less: function (numberA, numberB){
            return Microsoft.Msagl.Core.Geometry.ApproximateComparer.Compare(numberA, numberB) < 0;
        },
        LessOrEqual: function (numberA, numberB){
            return Microsoft.Msagl.Core.Geometry.ApproximateComparer.Compare(numberA, numberB) <= 0;
        },
        CloseIntersections: function (intersectionPoint0, intersectionPoint1){
            var c = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(intersectionPoint0, intersectionPoint1);
            return Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(c, c) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_IntersectionEpsilon() * Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_IntersectionEpsilon();
        },
        Sign: function (value){
            if (value > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return 1;
            if (value < -Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return -1;
            return 0;
        },
        SquareOfDistanceEpsilon$$: "System.Double",
        get_SquareOfDistanceEpsilon: function (){
            return Microsoft.Msagl.Core.Geometry.ApproximateComparer.squareOfDistanceEpsilon;
        },
        DistanceEpsilonPrecision$$: "System.Int32",
        get_DistanceEpsilonPrecision: function (){
            return 6;
        },
        IntersectionEpsilon$$: "System.Double",
        get_IntersectionEpsilon: function (){
            return Microsoft.Msagl.Core.Geometry.ApproximateComparer.distXEps;
        },
        set_IntersectionEpsilon: function (value){
            Microsoft.Msagl.Core.Geometry.ApproximateComparer.distXEps = value;
        },
        Tolerance$$: "System.Double",
        get_Tolerance: function (){
            return Microsoft.Msagl.Core.Geometry.ApproximateComparer.tolerance;
        },
        set_Tolerance: function (value){
            Microsoft.Msagl.Core.Geometry.ApproximateComparer.tolerance = value;
        },
        UserDefinedTolerance$$: "System.Double",
        get_UserDefinedTolerance: function (){
            return Microsoft.Msagl.Core.Geometry.ApproximateComparer.userDefinedTolerance;
        },
        set_UserDefinedTolerance: function (value){
            Microsoft.Msagl.Core.Geometry.ApproximateComparer.userDefinedTolerance = value;
        },
        NumberOfDigitsToRound$$: "System.Int32",
        get_NumberOfDigitsToRound: function (){
            return Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_DistanceEpsilonPrecision();
        },
        Round$$Point: function (point){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Double(point.get_X()), Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Double(point.get_Y()));
        },
        Round$$Point$$Int32: function (point, numberDigitsToRound){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(System.Math.Round$$Double$$Int32(point.get_X(), numberDigitsToRound), System.Math.Round$$Double$$Int32(point.get_Y(), numberDigitsToRound));
        },
        Round$$Double: function (value){
            return System.Math.Round$$Double$$Int32(value, Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_NumberOfDigitsToRound());
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$ApproximateComparer);
var Microsoft$Msagl$Core$Geometry$ConvexHull = {
    fullname: "Microsoft.Msagl.Core.Geometry.ConvexHull",
    baseTypeName: "System.Object",
    staticDefinition: {
        CalculateConvexHull: function (pointsOfTheBody){
            var convexHull = new Microsoft.Msagl.Core.Geometry.ConvexHull.ctor(pointsOfTheBody);
            return convexHull.Calculate();
        },
        CreateConvexHullAsClosedPolyline: function (points){
            var convexHull = (function (){
                var $v3 = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor$$IEnumerable$1$Point(Microsoft.Msagl.Core.Geometry.ConvexHull.CalculateConvexHull(points));
                $v3.set_Closed(true);
                return $v3;
            })();
            return convexHull;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (bodyPoints){
            this.hullPoints = null;
            this.pivot = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.stack = null;
            this.comparer = null;
            System.Object.ctor.call(this);
            this.SetPivotAndAllocateHullPointsArray(bodyPoints);
        },
        SetPivotAndAllocateHullPointsArray: function (bodyPoints){
            this.pivot = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, 1.79769313486232E+308);
            var pivotIndex = -1;
            var n = 0;
            var $it9 = bodyPoints.GetEnumerator();
            while ($it9.MoveNext()){
                var point = $it9.get_Current();
                if (point.get_Y() < this.pivot.get_Y()){
                    this.pivot = point;
                    pivotIndex = n;
                }
                else if (point.get_Y() == this.pivot.get_Y())if (point.get_X() > this.pivot.get_X()){
                    this.pivot = point;
                    pivotIndex = n;
                }
                n++;
            }
            if (n >= 1){
                this.hullPoints = new Array(n - 1);
                n = 0;
                var $it10 = bodyPoints.GetEnumerator();
                while ($it10.MoveNext()){
                    var point = $it10.get_Current();
                    if (n != pivotIndex)
                        this.hullPoints[n++] = new Microsoft.Msagl.Core.Geometry.HullPoint.ctor(point);
                    else
                        pivotIndex = -1;
                }
            }
        },
        StackTopPoint$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_StackTopPoint: function (){
            return this.stack.get_Point();
        },
        StackSecondPoint$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_StackSecondPoint: function (){
            return this.stack.get_Next().get_Point();
        },
        Calculate: function (){
            if (this.pivot.get_Y() == 1.79769313486232E+308)
                return new Array(0);
            if (this.hullPoints.length == 0)
                return [this.pivot];
            this.SortAllPointsWithoutPivot();
            this.Scan();
            return this.EnumerateStack();
        },
        EnumerateStack: function (){
            var $yield = [];
            var stackCell = this.stack;
            while (stackCell != null){
                $yield.push(stackCell.get_Point());
                stackCell = stackCell.get_Next();
            }
            return $yield;
        },
        Scan: function (){
            var i = 0;
            while (this.hullPoints[i].get_Deleted())
                i++;
            this.stack = new Microsoft.Msagl.Core.Geometry.HullStack.ctor(this.pivot);
            this.Push(i++);
            if (i < this.hullPoints.length){
                if (!this.hullPoints[i].get_Deleted())
                    this.Push(i++);
                else
                    i++;
            }
            while (i < this.hullPoints.length){
                if (!this.hullPoints[i].get_Deleted()){
                    if (this.LeftTurn(i))
                        this.Push(i++);
                    else
                        this.Pop();
                }
                else
                    i++;
            }
            while (this.StackHasMoreThanTwoPoints() && !this.LeftTurnToPivot())
                this.Pop();
        },
        LeftTurnToPivot: function (){
            return Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(this.get_StackSecondPoint(), this.get_StackTopPoint(), this.pivot) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise;
        },
        StackHasMoreThanTwoPoints: function (){
            return this.stack.get_Next() != null && this.stack.get_Next().get_Next() != null;
        },
        Pop: function (){
            this.stack = this.stack.get_Next();
        },
        LeftTurn: function (i){
            if (this.stack.get_Next() == null)
                return true;
            var orientation = Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientationWithIntersectionEpsilon(this.get_StackSecondPoint(), this.get_StackTopPoint(), this.hullPoints[i].get_Point());
            if (orientation == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise)
                return true;
            if (orientation == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise)
                return false;
            return this.BackSwitchOverPivot(this.hullPoints[i].get_Point());
        },
        BackSwitchOverPivot: function (point){
            if (this.stack.get_Next().get_Next() != null)
                return false;
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.Point.op_Equality(this.get_StackSecondPoint(), this.pivot));
            return this.get_StackTopPoint().get_X() > this.pivot.get_X() + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon && point.get_X() < this.pivot.get_X() - Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon;
        },
        Push: function (p){
            var t = (function (){
                var $v2 = new Microsoft.Msagl.Core.Geometry.HullStack.ctor(this.hullPoints[p].get_Point());
                $v2.set_Next(this.stack);
                return $v2;
            }).call(this);
            this.stack = t;
        },
        SortAllPointsWithoutPivot: function (){
            this.comparer = new Microsoft.Msagl.Core.Geometry.HullPointComparer.ctor(this.pivot);
            System.Array.Sort$1$$T$Array$$IComparer$1(Microsoft.Msagl.Core.Geometry.HullPoint.ctor, this.hullPoints, this.comparer);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$ConvexHull);
var Microsoft$Msagl$Core$Geometry$HullPoint = {
    fullname: "Microsoft.Msagl.Core.Geometry.HullPoint",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (point){
            this.point = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.deleted = false;
            System.Object.ctor.call(this);
            this.set_Point(point);
        },
        Point$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Point: function (){
            return this.point;
        },
        set_Point: function (value){
            this.point = value;
        },
        Deleted$$: "System.Boolean",
        get_Deleted: function (){
            return this.deleted;
        },
        set_Deleted: function (value){
            this.deleted = value;
        },
        toString: function (){
            return this.point + (this.get_Deleted() ? "X" : "");
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$HullPoint);
var Microsoft$Msagl$Core$Geometry$HullPointComparer = {
    fullname: "Microsoft.Msagl.Core.Geometry.HullPointComparer",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IComparer$1"],
    Kind: "Class",
    definition: {
        ctor: function (pivotPoint){
            this.pivot = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            System.Object.ctor.call(this);
            this.pivot = pivotPoint;
        },
        Compare: function (i, j){
            if (i == j)
                return 0;
            if (i == null)
                return -1;
            if (j == null)
                return 1;
            switch (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientationWithIntersectionEpsilon(this.pivot, i.get_Point(), j.get_Point())){
                case Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise:
                    return -1;
                case Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise:
                    return 1;
                case Microsoft.Msagl.Core.Geometry.TriangleOrientation.Collinear:
                    {
                    var piDelX = i.get_Point().get_X() - this.pivot.get_X();
                    var pjDelX = j.get_Point().get_X() - this.pivot.get_X();
                    if (piDelX > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon && pjDelX < -Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                        return -1;
                    }
                    if (piDelX < -Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon && pjDelX > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                        return 1;
                    }
                    var pi = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(i.get_Point(), this.pivot);
                    var pj = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(j.get_Point(), this.pivot);
                    var iMinJ = pi.get_L1() - pj.get_L1();
                    if (iMinJ < 0){
                        i.set_Deleted(true);
                        return -1;
                    }
                    if (iMinJ > 0){
                        j.set_Deleted(true);
                        return 1;
                    }
                    if (i.GetHashCode() < j.GetHashCode())
                        i.set_Deleted(true);
                    else
                        j.set_Deleted(true);
                    return 0;
                    }
            }
            throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$HullPointComparer);
var Microsoft$Msagl$Core$Geometry$HullStack = {
    fullname: "Microsoft.Msagl.Core.Geometry.HullStack",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (hullPoint){
            this.hullPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.next = null;
            System.Object.ctor.call(this);
            this.set_Point(hullPoint);
        },
        Point$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Point: function (){
            return this.hullPoint;
        },
        set_Point: function (value){
            this.hullPoint = value;
        },
        Next$$: "Microsoft.Msagl.Core.Geometry.HullStack",
        get_Next: function (){
            return this.next;
        },
        set_Next: function (value){
            this.next = value;
        },
        toString: function (){
            return this.hullPoint.toString();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$HullStack);
var Microsoft$Msagl$Core$Geometry$Curves$RoundedRect = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.RoundedRect",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Core.Geometry.Curves.ICurve"],
    Kind: "Class",
    definition: {
        ctor: function (){
            this.curve = null;
            this.dirtyBounds = true;
            this.cachedBounds = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
            this._RadiusX = 0;
            this._RadiusY = 0;
            System.Object.ctor.call(this);
        },
        Curve$$: "Microsoft.Msagl.Core.Geometry.Curves.Curve",
        get_Curve: function (){
            return this.curve;
        },
        RadiusX$$: "System.Double",
        get_RadiusX: function (){
            return this._RadiusX;
        },
        set_RadiusX: function (value){
            this._RadiusX = value;
        },
        RadiusY$$: "System.Double",
        get_RadiusY: function (){
            return this._RadiusY;
        },
        set_RadiusY: function (value){
            this._RadiusY = value;
        },
        ctor$$Rectangle$$Double$$Double: function (bounds, radiusX, radiusY){
            this.curve = null;
            this.dirtyBounds = true;
            this.cachedBounds = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
            this._RadiusX = 0;
            this._RadiusY = 0;
            System.Object.ctor.call(this);
            this.set_RadiusX(radiusX);
            this.set_RadiusY(radiusY);
            this.curve = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor$$Int32(8);
            Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateRectangleWithRoundedCorners$$Curve$$Double$$Double$$Double$$Double$$Point(this.curve, bounds.get_Width(), bounds.get_Height(), radiusX, radiusY, bounds.get_Center());
        },
        FitTo: function (target){
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Rectangle$$Rectangle$$Double(target, this.get_BoundingBox(), Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_UserDefinedTolerance())){
                return this.Clone();
            }
            return new Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.ctor$$Rectangle$$Double$$Double(target, this.get_RadiusX(), this.get_RadiusY());
        },
        Item$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Item$$Double: function (t){
            return this.curve.get_Item$$Double(t);
        },
        Derivative: function (t){
            return this.curve.Derivative(t);
        },
        SecondDerivative: function (t){
            return this.curve.SecondDerivative(t);
        },
        ThirdDerivative: function (t){
            return this.curve.ThirdDerivative(t);
        },
        ParallelogramNodeOverICurve$$: "Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve",
        get_ParallelogramNodeOverICurve: function (){
            return this.curve.get_ParallelogramNodeOverICurve();
        },
        BoundingBox$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_BoundingBox: function (){
            if (this.dirtyBounds){
                this.cachedBounds = this.curve.get_BoundingBox();
                this.dirtyBounds = false;
            }
            return this.cachedBounds;
        },
        ParStart$$: "System.Double",
        get_ParStart: function (){
            return this.curve.get_ParStart();
        },
        ParEnd$$: "System.Double",
        get_ParEnd: function (){
            return this.curve.get_ParEnd();
        },
        Trim: function (start, end){
            return this.curve.Trim(start, end);
        },
        TrimWithWrap: function (start, end){
            return this.curve.TrimWithWrap(start, end);
        },
        Translate: function (delta){
            this.curve.Translate(delta);
            this.dirtyBounds = true;
        },
        ScaleFromOrigin: function (xScale, yScale){
            var bounds = this.curve.get_BoundingBox();
            var lt = Microsoft.Msagl.Core.Geometry.Point.Scale(xScale, yScale, bounds.get_LeftTop());
            var rb = Microsoft.Msagl.Core.Geometry.Point.Scale(xScale, yScale, bounds.get_RightBottom());
            return new Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.ctor$$Rectangle$$Double$$Double(new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(lt, rb), this.get_RadiusX(), this.get_RadiusY());
        },
        Start$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Start: function (){
            return this.curve.get_Start();
        },
        End$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_End: function (){
            return this.curve.get_End();
        },
        Reverse: function (){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        OffsetCurve: function (offset, dir){
            return this.curve.OffsetCurve(offset, dir);
        },
        LengthPartial: function (start, end){
            return this.curve.LengthPartial(start, end);
        },
        Length$$: "System.Double",
        get_Length: function (){
            return this.curve.get_Length();
        },
        GetParameterAtLength: function (length){
            return this.curve.GetParameterAtLength(length);
        },
        Transform: function (transformation){
            var bounds = this.curve.get_BoundingBox();
            var lt = Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(transformation, bounds.get_LeftTop());
            var rb = Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(transformation, bounds.get_RightBottom());
            var transBounds = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(lt, rb);
            return new Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.ctor$$Rectangle$$Double$$Double(transBounds, this.get_RadiusX(), this.get_RadiusY());
        },
        ClosestParameterWithinBounds: function (targetPoint, low, high){
            return this.get_Curve().ClosestParameterWithinBounds(targetPoint, low, high);
        },
        ClosestParameter: function (targetPoint){
            return this.curve.ClosestParameter(targetPoint);
        },
        Clone: function (){
            var newRect = new Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.ctor();
            newRect.set_RadiusX(this.get_RadiusX());
            newRect.set_RadiusY(this.get_RadiusY());
            newRect.curve = Cast(this.curve.Clone(), Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor);
            return newRect;
        },
        LeftDerivative: function (t){
            return this.curve.LeftDerivative(t);
        },
        RightDerivative: function (t){
            return this.curve.RightDerivative(t);
        },
        Curvature: function (t){
            return this.curve.Curvature(t);
        },
        CurvatureDerivative: function (t){
            return this.curve.CurvatureDerivative(t);
        },
        CurvatureSecondDerivative: function (t){
            return this.curve.CurvatureSecondDerivative(t);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$RoundedRect);
var Microsoft$Msagl$Core$Geometry$ColumnPacking$1 = {
    fullname: "Microsoft.Msagl.Core.Geometry.ColumnPacking$1",
    baseTypeName: "Microsoft.Msagl.Core.Geometry.Packing",
    staticDefinition: {
        cctor: function (TData){
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (TData, rectangles, maxHeight){
            this.TData = TData;
            this.orderedRectangles = null;
            this.maxHeight = 0;
            Microsoft.Msagl.Core.Geometry.Packing.ctor.call(this);
            this.orderedRectangles = rectangles;
            this.maxHeight = maxHeight;
        },
        RunInternal: function (){
            this.set_PackedHeight((function ($p2){
                this.set_PackedWidth($p2);
                return $p2;
            }).call(this, 0));
            var columnPosition = 0;
            var columnHeight = 0;
            var $it11 = this.orderedRectangles.GetEnumerator();
            while ($it11.MoveNext()){
                var current = $it11.get_Current();
                var r = current.get_Rectangle();
                if (columnHeight + r.get_Height() > this.maxHeight){
                    columnPosition = this.get_PackedWidth();
                    columnHeight = 0;
                }
                r = (function ($p3){
                    current.set_Rectangle($p3);
                    return $p3;
                }).call(this, new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Double$$Double$$Point(columnPosition, columnHeight, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(r.get_Width(), r.get_Height())));
                this.set_PackedWidth(System.Math.Max$$Double$$Double(this.get_PackedWidth(), columnPosition + r.get_Width()));
                columnHeight += r.get_Height();
                this.set_PackedHeight(System.Math.Max$$Double$$Double(this.get_PackedHeight(), columnHeight));
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$ColumnPacking$1);
var Microsoft$Msagl$Core$Geometry$OptimalColumnPacking$1 = {
    fullname: "Microsoft.Msagl.Core.Geometry.OptimalColumnPacking$1",
    baseTypeName: "Microsoft.Msagl.Core.Geometry.OptimalPacking$1",
    staticDefinition: {
        cctor: function (TData){
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (TData, rectangles, aspectRatio){
            this.TData = TData;
            Microsoft.Msagl.Core.Geometry.OptimalPacking$1.ctor.call(this, this.TData, System.Linq.Enumerable.ToList$1(Microsoft.Msagl.Core.Geometry.RectangleToPack$1.ctor, rectangles), aspectRatio);
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(rectangles, "rectangles");
            System.Diagnostics.Debug.Assert$$Boolean$$String(System.Linq.Enumerable.Any$1$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.RectangleToPack$1.ctor, rectangles), "Expected more than one rectangle in rectangles");
            System.Diagnostics.Debug.Assert$$Boolean$$String(aspectRatio > 0, "aspect ratio should be greater than 0");
            this.createPacking = $CreateAnonymousDelegate(this, function (rs, height){
                return new Microsoft.Msagl.Core.Geometry.ColumnPacking$1.ctor(this.TData, rs, height);
            });
        },
        RunInternal: function (){
            var minRectHeight = 1.79769313486232E+308;
            var maxRectHeight = 0;
            var totalHeight = 0;
            var $it12 = this.rectangles.GetEnumerator();
            while ($it12.MoveNext()){
                var rtp = $it12.get_Current();
                var r = rtp.get_Rectangle();
                System.Diagnostics.Debug.Assert$$Boolean$$String(r.get_Width() > 0, "Width must be greater than 0");
                System.Diagnostics.Debug.Assert$$Boolean$$String(r.get_Height() > 0, "Height must be greater than 0");
                totalHeight += r.get_Height();
                minRectHeight = System.Math.Min$$Double$$Double(minRectHeight, r.get_Height());
                maxRectHeight = System.Math.Max$$Double$$Double(maxRectHeight, r.get_Height());
            }
            this.Pack$$Double$$Double$$Double(maxRectHeight, totalHeight, minRectHeight);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$OptimalColumnPacking$1);
var Microsoft$Msagl$Core$Geometry$OptimalPacking$1 = {
    fullname: "Microsoft.Msagl.Core.Geometry.OptimalPacking$1",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (TData){
            Microsoft.Msagl.Core.Geometry.OptimalPacking$1.MaxSteps = 1000;
        },
        GoldenSectionSearch: function (f, x1, x2, x3, precision){
            System.Diagnostics.Debug.Assert$$Boolean$$String((System.Math.Abs$$Double(x3 - x1) - precision) / precision <= 1000.1, "precision would violate the limit imposed by MaxSteps");
            if (System.Math.Abs$$Double(x1 - x3) < precision){
                return f(x1) < f(x3) ? x1 : x3;
            }
            System.Diagnostics.Debug.Assert$$Boolean$$String(x1 < x2 && x2 < x3 || x3 < x2 && x2 < x1, "x2 not bounded by x1 and x3");
            var x4 = Microsoft.Msagl.Core.Geometry.OptimalPacking$1.GetGoldenSectionStep(x2, x3);
            var fx2 = f(x2);
            var fx4 = f(x4);
            var leftSearch = function (){
                return Microsoft.Msagl.Core.Geometry.OptimalPacking$1.GoldenSectionSearch(f, x4, x2, x1, precision);
            };
            var rightSearch = function (){
                return Microsoft.Msagl.Core.Geometry.OptimalPacking$1.GoldenSectionSearch(f, x2, x4, x3, precision);
            };
            if (fx4 < fx2){
                System.Diagnostics.Debug.Assert$$Boolean$$String(System.Math.Abs$$Double(x2 - x3) < System.Math.Abs$$Double(x1 - x3), "Search region not narrowing!");
                return rightSearch();
            }
            if (fx4 > fx2){
                System.Diagnostics.Debug.Assert$$Boolean$$String(System.Math.Abs$$Double(x4 - x1) < System.Math.Abs$$Double(x1 - x3), "Search region not narrowing!");
                return leftSearch();
            }
            var right = rightSearch();
            var left = leftSearch();
            return f(left) < f(right) ? left : right;
        },
        GetGoldenSectionStep: function (x1, x2){
            if (x1 < x2){
                return x1 + Microsoft.Msagl.Core.Geometry.PackingConstants.GoldenRatioRemainder * (x2 - x1);
            }
            return x1 - Microsoft.Msagl.Core.Geometry.PackingConstants.GoldenRatioRemainder * (x1 - x2);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (TData, rectangles, aspectRatio){
            this.TData = TData;
            this.desiredAspectRatio = 1.2;
            this.bestPackingCost = 0;
            this.bestPacking = null;
            this.rectangles = null;
            this.cachedCosts = new System.Collections.Generic.Dictionary$2.ctor(System.Double.ctor, System.Double.ctor);
            this.createPacking = null;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.rectangles = rectangles;
            this.desiredAspectRatio = aspectRatio;
        },
        PackedWidth$$: "System.Double",
        get_PackedWidth: function (){
            if (this.bestPacking != null){
                return this.bestPacking.get_PackedWidth();
            }
            return 0;
        },
        PackedHeight$$: "System.Double",
        get_PackedHeight: function (){
            if (this.bestPacking != null){
                return this.bestPacking.get_PackedHeight();
            }
            return 0;
        },
        Pack$$Double$$Double$$Double: function (lowerBound, upperBound, minGranularity){
            var c0 = Microsoft.Msagl.Core.Geometry.OptimalPacking$1.GetGoldenSectionStep(lowerBound, upperBound);
            var precision = System.Math.Max$$Double$$Double(minGranularity / 10, (upperBound - lowerBound) / 1000);
            upperBound += precision;
            this.bestPackingCost = 1.79769313486232E+308;
            if (this.rectangles.get_Count() == 1){
                this.Pack$$Double(lowerBound);
            }
            else if (this.rectangles.get_Count() == 2){
                this.Pack$$Double(lowerBound);
                this.Pack$$Double(upperBound);
            }
            else if (this.rectangles.get_Count() > 2){
                Microsoft.Msagl.Core.Geometry.OptimalPacking$1.GoldenSectionSearch($CreateDelegate(this, this.Pack$$Double), lowerBound, c0, upperBound, precision);
            }
            this.bestPacking.Run();
        },
        Pack$$Double: function (limit){
            var cost;
            if (!(function (){
                var $1 = {
                    Value: cost
                };
                var $res = this.cachedCosts.TryGetValue(limit, $1);
                cost = $1.Value;
                return $res;
            }).call(this)){
                var packing = this.createPacking(this.rectangles, limit);
                packing.Run();
                this.cachedCosts.set_Item$$TKey(limit, cost = System.Math.Abs$$Double(packing.get_PackedAspectRatio() - this.desiredAspectRatio));
                if (cost < this.bestPackingCost){
                    this.bestPackingCost = cost;
                    this.bestPacking = packing;
                }
            }
            return cost;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$OptimalPacking$1);
var Microsoft$Msagl$Core$Geometry$OptimalPacking$PackingFactory$1 = {
    fullname: "Microsoft.Msagl.Core.Geometry.OptimalPacking.PackingFactory$1",
    Kind: "Delegate",
    definition: {
        ctor: function (TData, obj, func){
            this.TData = TData;
            System.MulticastDelegate.ctor.call(this, obj, func);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$OptimalPacking$PackingFactory$1);
var Microsoft$Msagl$Core$Geometry$OptimalRectanglePacking$1 = {
    fullname: "Microsoft.Msagl.Core.Geometry.OptimalRectanglePacking$1",
    baseTypeName: "Microsoft.Msagl.Core.Geometry.OptimalPacking$1",
    staticDefinition: {
        cctor: function (TData){
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (TData, rectangles, aspectRatio){
            this.TData = TData;
            Microsoft.Msagl.Core.Geometry.OptimalPacking$1.ctor.call(this, this.TData, System.Linq.Enumerable.ToList$1(Microsoft.Msagl.Core.Geometry.RectangleToPack$1.ctor, Microsoft.Msagl.Core.Geometry.RectanglePacking$1.SortRectangles(rectangles)), aspectRatio);
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(rectangles, "rectangles");
            System.Diagnostics.Debug.Assert$$Boolean$$String(System.Linq.Enumerable.Any$1$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.RectangleToPack$1.ctor, rectangles), "Expected more than one rectangle in rectangles");
            System.Diagnostics.Debug.Assert$$Boolean$$String(aspectRatio > 0, "aspect ratio should be greater than 0");
            this.createPacking = $CreateAnonymousDelegate(this, function (rs, width){
                return new Microsoft.Msagl.Core.Geometry.RectanglePacking$1.ctor(this.TData, rs, width, true);
            });
        },
        RunInternal: function (){
            var minRectWidth = 1.79769313486232E+308;
            var maxRectWidth = 0;
            var totalWidth = 0;
            var $it13 = this.rectangles.GetEnumerator();
            while ($it13.MoveNext()){
                var r = $it13.get_Current();
                System.Diagnostics.Debug.Assert$$Boolean$$String(r.get_Rectangle().get_Width() > 0, "Width must be greater than 0");
                System.Diagnostics.Debug.Assert$$Boolean$$String(r.get_Rectangle().get_Height() > 0, "Height must be greater than 0");
                var width = r.get_Rectangle().get_Width();
                totalWidth += width;
                minRectWidth = System.Math.Min$$Double$$Double(minRectWidth, width);
                maxRectWidth = System.Math.Max$$Double$$Double(maxRectWidth, width);
            }
            this.Pack$$Double$$Double$$Double(maxRectWidth, totalWidth, minRectWidth);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$OptimalRectanglePacking$1);
var Microsoft$Msagl$Core$Geometry$BorderInfo = {
    fullname: "Microsoft.Msagl.Core.Geometry.BorderInfo",
    baseTypeName: "System.ValueType",
    staticDefinition: {
        DefaultFreeWeight$$: "System.Double",
        get_DefaultFreeWeight: function (){
            return 1E-06;
        },
        DefaultFixedWeight$$: "System.Double",
        get_DefaultFixedWeight: function (){
            return 100000000;
        },
        NoFixedPosition$$: "System.Double",
        get_NoFixedPosition: function (){
            return NaN;
        },
        op_Equality: function (left, right){
            return left.Equals$$Object(right);
        },
        op_Inequality: function (left, right){
            return !(Microsoft.Msagl.Core.Geometry.BorderInfo.op_Equality(left, right));
        },
        op_LessThan: function (left, right){
            if (left.get_FixedPosition() < right.get_FixedPosition()){
                return true;
            }
            if (left.get_FixedPosition() > right.get_FixedPosition()){
                return false;
            }
            if (left.get_Weight() < right.get_Weight()){
                return true;
            }
            if (left.get_Weight() > right.get_Weight()){
                return false;
            }
            return (left.get_InnerMargin() < right.get_InnerMargin());
        },
        op_GreaterThan: function (left, right){
            return Microsoft.Msagl.Core.Geometry.BorderInfo.op_LessThan(right, left);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Struct",
    definition: {
        ctor$$Double: function (innerMargin){
            this.borderWeight = 0;
            this._InnerMargin = 0;
            this._FixedPosition = 0;
            Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double$$Double$$Double.call(this, innerMargin, Microsoft.Msagl.Core.Geometry.BorderInfo.get_NoFixedPosition(), Microsoft.Msagl.Core.Geometry.BorderInfo.get_DefaultFreeWeight());
        },
        InnerMargin$$: "System.Double",
        get_InnerMargin: function (){
            return this._InnerMargin;
        },
        set_InnerMargin: function (value){
            this._InnerMargin = value;
        },
        FixedPosition$$: "System.Double",
        get_FixedPosition: function (){
            return this._FixedPosition;
        },
        set_FixedPosition: function (value){
            this._FixedPosition = value;
        },
        Weight$$: "System.Double",
        get_Weight: function (){
            return this.borderWeight;
        },
        set_Weight: function (value){
            if (value <= 0){
                throw $CreateException(new System.ArgumentOutOfRangeException.ctor$$String$$String("value", "Weight must be greater than zero"), new Error());
            }
            this.borderWeight = value;
        },
        IsFixedPosition$$: "System.Boolean",
        get_IsFixedPosition: function (){
            return !System.Double.IsNaN(this.get_FixedPosition()) && (this.get_Weight() > 0);
        },
        SetFixed: function (position, weight){
            this.set_FixedPosition(position);
            this.set_Weight(weight);
        },
        SetUnfixed: function (){
            this.set_FixedPosition(Microsoft.Msagl.Core.Geometry.BorderInfo.get_NoFixedPosition());
            this.set_Weight(Microsoft.Msagl.Core.Geometry.BorderInfo.get_DefaultFreeWeight());
        },
        ctor$$Double$$Double$$Double: function (innerMargin, fixedPosition, weight){
            this.borderWeight = 0;
            this._InnerMargin = 0;
            this._FixedPosition = 0;
            Microsoft.Msagl.Core.Geometry.BorderInfo.ctor.call(this);
            this.set_InnerMargin(innerMargin);
            this.set_FixedPosition(fixedPosition);
            this.set_Weight(weight);
        },
        EnsureWeight: function (){
            System.Diagnostics.Debug.Assert$$Boolean$$String(this.get_Weight() > 0, "BorderInfo.Weight must be > 0.0; use DefaultFreeWeight or DefaultFixedWeight or a parameterized ctor");
            if (0 == this.get_Weight()){
                this.set_Weight(Microsoft.Msagl.Core.Geometry.BorderInfo.get_DefaultFreeWeight());
                if (0 == this.get_FixedPosition()){
                    this.set_FixedPosition(Microsoft.Msagl.Core.Geometry.BorderInfo.get_NoFixedPosition());
                }
            }
        },
        toString: function (){
            return System.String.Format$$IFormatProvider$$String$$Object$Array(System.Globalization.CultureInfo.get_InvariantCulture(), "m {0:F5} p {1:F5} w {2:F5}", [this.get_InnerMargin(), this.get_FixedPosition(), this.get_Weight()]);
        },
        GetHashCode: function (){
            return this.get_InnerMargin().GetHashCode() ^ this.get_FixedPosition().GetHashCode() ^ this.get_Weight().GetHashCode();
        },
        Equals$$Object: function (obj){
            if (!(Is(obj, Microsoft.Msagl.Core.Geometry.BorderInfo.ctor)))
                return false;
            var bi = Cast(obj, Microsoft.Msagl.Core.Geometry.BorderInfo.ctor);
            return (bi.get_FixedPosition() == this.get_FixedPosition()) && (bi.get_Weight() == this.get_Weight()) && (bi.get_InnerMargin() == this.get_InnerMargin());
        },
        ctor: function (){
            this.borderWeight = 0;
            this._InnerMargin = 0;
            this._FixedPosition = 0;
            System.ValueType.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$BorderInfo);
var Microsoft$Msagl$Core$Geometry$PointNodesList = {
    fullname: "Microsoft.Msagl.Core.Geometry.PointNodesList",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IEnumerator$1", "System.Collections.Generic.IEnumerable$1"],
    Kind: "Class",
    definition: {
        ctor$$Site: function (pointNode){
            this.current = null;
            this.head = null;
            System.Object.ctor.call(this);
            this.head = pointNode;
        },
        Head$$: "Microsoft.Msagl.Core.Geometry.Site",
        get_Head: function (){
            return this.head;
        },
        ctor: function (){
            this.current = null;
            this.head = null;
            System.Object.ctor.call(this);
        },
        Current$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Current: function (){
            return this.current.get_Point();
        },
        Dispose: function (){
            System.GC.SuppressFinalize(this);
        },
        MoveNext: function (){
            if (this.current != null){
                if (this.current.get_Next() != null){
                    this.current = this.current.get_Next();
                    return true;
                }
                else
                    return false;
            }
            else {
                this.current = this.get_Head();
                return true;
            }
        },
        Reset: function (){
            this.current = null;
        },
        GetEnumerator: function (){
            return this;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$PointNodesList);
var Microsoft$Msagl$Core$Geometry$PointPair = {
    fullname: "Microsoft.Msagl.Core.Geometry.PointPair",
    baseTypeName: "System.Object",
    staticDefinition: {
        IsLess: function (p1, p2){
            if (p1.get_Y() < p2.get_Y())
                return true;
            if (p1.get_Y() > p2.get_Y())
                return false;
            return p1.get_X() < p2.get_X();
        },
        op_Equality: function (pair0, pair1){
            return (Microsoft.Msagl.Core.Geometry.Point.op_Equality(pair0.first, pair1.first) && Microsoft.Msagl.Core.Geometry.Point.op_Equality(pair0.second, pair1.second));
        },
        op_Inequality: function (pair0, pair1){
            return !(Microsoft.Msagl.Core.Geometry.PointPair.op_Equality(pair0, pair1));
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.IComparable$1"],
    Kind: "Class",
    definition: {
        ctor: function (first, second){
            this.first = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.second = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._hashKey = null;
            System.Object.ctor.call(this);
            if (Microsoft.Msagl.Core.Geometry.PointPair.IsLess(first, second)){
                this.first = first;
                this.second = second;
            }
            else {
                this.first = second;
                this.second = first;
            }
            this._hashKey = this.first.get_X() + "," + this.first.get_Y() + ";" + this.second.get_X() + "," + this.second.get_Y();
        },
        First$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_First: function (){
            return this.first;
        },
        Second$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Second: function (){
            return this.second;
        },
        Length$$: "System.Double",
        get_Length: function (){
            return (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.first, this.second)).get_Length();
        },
        CompareTo: function (other){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(other, "other");
            var cr = this.first.CompareTo(other.first);
            if (cr != 0)
                return cr;
            return this.second.CompareTo(other.second);
        },
        GetHashCode: function (){
            var hc = (this.first.GetHashCode()) | 0;
            return (((hc << 5 | hc >> 27) + (this.second.GetHashCode()) | 0)) | 0;
        },
        Equals$$Object: function (obj){
            var otherPair = As(obj, Microsoft.Msagl.Core.Geometry.PointPair.ctor);
            if (System.Object.ReferenceEquals(otherPair, null))
                return false;
            return Microsoft.Msagl.Core.Geometry.PointPair.op_Equality(otherPair, this);
        },
        toString: function (){
            return this.first + " " + this.second;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$PointPair);
var Microsoft$Msagl$Core$Geometry$Packing = {
    fullname: "Microsoft.Msagl.Core.Geometry.Packing",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this._PackedWidth = 0;
            this._PackedHeight = 0;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
        },
        PackedWidth$$: "System.Double",
        get_PackedWidth: function (){
            return this._PackedWidth;
        },
        set_PackedWidth: function (value){
            this._PackedWidth = value;
        },
        PackedHeight$$: "System.Double",
        get_PackedHeight: function (){
            return this._PackedHeight;
        },
        set_PackedHeight: function (value){
            this._PackedHeight = value;
        },
        PackedAspectRatio$$: "System.Double",
        get_PackedAspectRatio: function (){
            return this.get_PackedWidth() / this.get_PackedHeight();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Packing);
var Microsoft$Msagl$Core$Geometry$PackingConstants = {
    fullname: "Microsoft.Msagl.Core.Geometry.PackingConstants",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Core.Geometry.PackingConstants.GoldenRatio = (1 + System.Math.Sqrt(5)) / 2;
            Microsoft.Msagl.Core.Geometry.PackingConstants.GoldenRatioRemainder = 2 - Microsoft.Msagl.Core.Geometry.PackingConstants.GoldenRatio;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$PackingConstants);
var Microsoft$Msagl$Core$Geometry$RectangleToPack$1 = {
    fullname: "Microsoft.Msagl.Core.Geometry.RectangleToPack$1",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (TData, rectangle, data){
            this.TData = TData;
            this._Rectangle = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
            this._Data = null;
            System.Object.ctor.call(this);
            this.set_Rectangle(rectangle);
            this.set_Data(data);
        },
        Rectangle$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_Rectangle: function (){
            return this._Rectangle;
        },
        set_Rectangle: function (value){
            this._Rectangle = value;
        },
        Data$$: "`0",
        get_Data: function (){
            return this._Data;
        },
        set_Data: function (value){
            this._Data = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$RectangleToPack$1);
var Microsoft$Msagl$Core$Geometry$RectanglePacking$1 = {
    fullname: "Microsoft.Msagl.Core.Geometry.RectanglePacking$1",
    baseTypeName: "Microsoft.Msagl.Core.Geometry.Packing",
    staticDefinition: {
        cctor: function (TData){
        },
        SortRectangles: function (rectangles){
            return System.Linq.Enumerable.ThenBy$2$$IOrderedEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.RectangleToPack$1.ctor, System.Double.ctor, System.Linq.Enumerable.OrderByDescending$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.RectangleToPack$1.ctor, System.Double.ctor, rectangles, function (r){
                return r.get_Rectangle().get_Height();
            }), function (r){
                return r.get_Rectangle().get_Width();
            });
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (TData, rectangles, wrapWidth, rectanglesPresorted){
            this.TData = TData;
            this.rectanglesByDescendingHeight = null;
            this.wrapWidth = 0;
            Microsoft.Msagl.Core.Geometry.Packing.ctor.call(this);
            this.rectanglesByDescendingHeight = rectanglesPresorted ? rectangles : Microsoft.Msagl.Core.Geometry.RectanglePacking$1.SortRectangles(rectangles);
            this.wrapWidth = wrapWidth;
        },
        RunInternal: function (){
            this.Pack(this.rectanglesByDescendingHeight.GetEnumerator());
        },
        Pack: function (rectangleEnumerator){
            this.set_PackedHeight((function ($p4){
                this.set_PackedWidth($p4);
                return $p4;
            }).call(this, 0));
            var stack = new System.Collections.Generic.Stack$1.ctor(Microsoft.Msagl.Core.Geometry.RectangleToPack$1.ctor);
            var wrap = false;
            var verticalPosition = 0;
            var packedWidth = 0;
            var packedHeight = 0;
            while (wrap || rectangleEnumerator.MoveNext()){
                var current = rectangleEnumerator.get_Current();
                var parent = stack.get_Count() > 0 ? stack.Peek() : null;
                var r = current.get_Rectangle();
                if (parent == null || parent.get_Rectangle().get_Right() + r.get_Width() <= this.wrapWidth && verticalPosition + r.get_Height() <= parent.get_Rectangle().get_Top()){
                    r = (function ($p5){
                        current.set_Rectangle($p5);
                        return $p5;
                    }).call(this, new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Double$$Double$$Point(parent == null ? 0 : parent.get_Rectangle().get_Right(), verticalPosition, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(r.get_Width(), r.get_Height())));
                    packedWidth = System.Math.Max$$Double$$Double(packedWidth, r.get_Right());
                    packedHeight = System.Math.Max$$Double$$Double(packedHeight, r.get_Top());
                    stack.Push(current);
                    wrap = false;
                }
                else {
                    verticalPosition = parent.get_Rectangle().get_Top();
                    stack.Pop();
                    wrap = true;
                }
            }
            this.set_PackedWidth(packedWidth);
            this.set_PackedHeight(packedHeight);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$RectanglePacking$1);
var Microsoft$Msagl$Core$Geometry$IntervalNode$1 = {
    fullname: "Microsoft.Msagl.Core.Geometry.IntervalNode$1",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (TData){
            Microsoft.Msagl.Core.Geometry.IntervalNode$1.GroupSplitThreshold = 2;
        },
        VisitTreeStatic: function (intervalNode, hitTest, hitInterval){
            if (intervalNode.get_Interval().Intersects(hitInterval)){
                if (hitTest(intervalNode.get_UserData()) == Microsoft.Msagl.Core.Geometry.HitTestBehavior.Continue){
                    if (intervalNode.get_Left() != null){
                        if (Microsoft.Msagl.Core.Geometry.IntervalNode$1.VisitTreeStatic(intervalNode.get_Left(), hitTest, hitInterval) == Microsoft.Msagl.Core.Geometry.HitTestBehavior.Continue && Microsoft.Msagl.Core.Geometry.IntervalNode$1.VisitTreeStatic(intervalNode.get_Right(), hitTest, hitInterval) == Microsoft.Msagl.Core.Geometry.HitTestBehavior.Continue){
                            return Microsoft.Msagl.Core.Geometry.HitTestBehavior.Continue;
                        }
                        return Microsoft.Msagl.Core.Geometry.HitTestBehavior.Stop;
                    }
                    return Microsoft.Msagl.Core.Geometry.HitTestBehavior.Continue;
                }
                return Microsoft.Msagl.Core.Geometry.HitTestBehavior.Stop;
            }
            return Microsoft.Msagl.Core.Geometry.HitTestBehavior.Continue;
        },
        CreateIntervalNodeOnEnumeration: function (nodes){
            if (nodes == null)
                return null;
            var nodeList = new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.IntervalNode$1.ctor, nodes);
            return Microsoft.Msagl.Core.Geometry.IntervalNode$1.CreateIntervalNodeOnListOfNodes(nodeList);
        },
        CreateIntervalNodeOnData: function (dataEnumeration, intervalDelegate){
            if (dataEnumeration == null || intervalDelegate == null)
                return null;
            var nodeList = new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.IntervalNode$1.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(this.TData, Microsoft.Msagl.Core.Geometry.IntervalNode$1.ctor, dataEnumeration, function (d){
                return new Microsoft.Msagl.Core.Geometry.IntervalNode$1.ctor$$TData$$Interval(this.TData, d, intervalDelegate(d));
            }));
            return Microsoft.Msagl.Core.Geometry.IntervalNode$1.CreateIntervalNodeOnListOfNodes(nodeList);
        },
        CreateIntervalNodeOnListOfNodes: function (nodes){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(nodes, "nodes");
            if (nodes.get_Count() == 0)
                return null;
            if (nodes.get_Count() == 1)
                return nodes.get_Item$$Int32(0);
            var b0 = nodes.get_Item$$Int32(0).get_Interval();
            var seed0 = 1;
            var seed1 = (function (){
                var $1 = {
                    Value: b0
                };
                var $2 = {
                    Value: seed0
                };
                var $res = Microsoft.Msagl.Core.Geometry.IntervalNode$1.ChooseSeeds(nodes, $1, $2);
                b0 = $1.Value;
                seed0 = $2.Value;
                return $res;
            })();
            var gr0 = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.IntervalNode$1.ctor);
            var gr1 = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.IntervalNode$1.ctor);
            gr0.Add(nodes.get_Item$$Int32(seed0));
            gr1.Add(nodes.get_Item$$Int32(seed1));
            var box0 = nodes.get_Item$$Int32(seed0).get_Interval();
            var box1 = nodes.get_Item$$Int32(seed1).get_Interval();
            (function (){
                var $1 = {
                    Value: box0
                };
                var $2 = {
                    Value: box1
                };
                var $res = Microsoft.Msagl.Core.Geometry.IntervalNode$1.DivideNodes(nodes, seed0, seed1, gr0, gr1, $1, $2, 2);
                box0 = $1.Value;
                box1 = $2.Value;
                return $res;
            })();
            var ret = (function (){
                var $v5 = new Microsoft.Msagl.Core.Geometry.IntervalNode$1.ctor$$Int32(this.TData, nodes.get_Count());
                $v5.set_Interval(new Microsoft.Msagl.Layout.LargeGraphLayout.Interval.ctor$$Interval$$Interval(box0, box1));
                $v5.set_Left(Microsoft.Msagl.Core.Geometry.IntervalNode$1.CreateIntervalNodeOnListOfNodes(gr0));
                $v5.set_Right(Microsoft.Msagl.Core.Geometry.IntervalNode$1.CreateIntervalNodeOnListOfNodes(gr1));
                return $v5;
            })();
            return ret;
        },
        ChooseSeeds: function (nodes, b0, seed0){
            var area = new Microsoft.Msagl.Layout.LargeGraphLayout.Interval.ctor$$Interval$$Interval(b0.Value, nodes.get_Item$$Int32(seed0.Value).get_Interval()).get_Length();
            for (var i = 2; i < nodes.get_Count(); i++){
                var area0 = new Microsoft.Msagl.Layout.LargeGraphLayout.Interval.ctor$$Interval$$Interval(b0.Value, nodes.get_Item$$Int32(i).get_Interval()).get_Length();
                if (area0 > area){
                    seed0.Value = i;
                    area = area0;
                }
            }
            var seed1 = 0;
            for (var i = 0; i < nodes.get_Count(); i++){
                if (i != seed0.Value){
                    seed1 = i;
                    break;
                }
            }
            area = new Microsoft.Msagl.Layout.LargeGraphLayout.Interval.ctor$$Interval$$Interval(nodes.get_Item$$Int32(seed0.Value).get_Interval(), nodes.get_Item$$Int32(seed1).get_Interval()).get_Length();
            for (var i = 0; i < nodes.get_Count(); i++){
                if (i == seed0.Value)
                    continue;
                var area1 = new Microsoft.Msagl.Layout.LargeGraphLayout.Interval.ctor$$Interval$$Interval(nodes.get_Item$$Int32(seed0.Value).get_Interval(), nodes.get_Item$$Int32(i).get_Interval()).get_Length();
                if (area1 > area){
                    seed1 = i;
                    area = area1;
                }
            }
            return seed1;
        },
        DivideNodes: function (nodes, seed0, seed1, gr0, gr1, box0, box1, groupSplitThreshold){
            for (var i = 0; i < nodes.get_Count(); i++){
                if (i == seed0 || i == seed1)
                    continue;
                var box0_ = new Microsoft.Msagl.Layout.LargeGraphLayout.Interval.ctor$$Interval$$Interval(box0.Value, nodes.get_Item$$Int32(i).get_Interval());
                var delta0 = box0_.get_Length() - box0.Value.get_Length();
                var box1_ = new Microsoft.Msagl.Layout.LargeGraphLayout.Interval.ctor$$Interval$$Interval(box1.Value, nodes.get_Item$$Int32(i).get_Interval());
                var delta1 = box1_.get_Length() - box1.Value.get_Length();
                if (gr0.get_Count() * groupSplitThreshold < gr1.get_Count()){
                    gr0.Add(nodes.get_Item$$Int32(i));
                    box0.Value = box0_;
                }
                else if (gr1.get_Count() * groupSplitThreshold < gr0.get_Count()){
                    gr1.Add(nodes.get_Item$$Int32(i));
                    box1.Value = box1_;
                }
                else if (delta0 < delta1){
                    gr0.Add(nodes.get_Item$$Int32(i));
                    box0.Value = box0_;
                }
                else if (delta1 < delta0){
                    gr1.Add(nodes.get_Item$$Int32(i));
                    box1.Value = box1_;
                }
                else if (box0.Value.get_Length() < box1.Value.get_Length()){
                    gr0.Add(nodes.get_Item$$Int32(i));
                    box0.Value = box0_;
                }
                else {
                    gr1.Add(nodes.get_Item$$Int32(i));
                    box1.Value = box1_;
                }
            }
        },
        TraverseHierarchy: function (node, visitor){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(node, "node");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(visitor, "visitor");
            visitor(node);
            if (node.get_Left() != null)
                Microsoft.Msagl.Core.Geometry.IntervalNode$1.TraverseHierarchy(node.get_Left(), visitor);
            if (node.get_Right() != null)
                Microsoft.Msagl.Core.Geometry.IntervalNode$1.TraverseHierarchy(node.get_Right(), visitor);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (TData){
            this.TData = TData;
            this.left = null;
            this.right = null;
            this.interval = null;
            this._Count = 0;
            this._UserData = null;
            this._Parent = null;
            System.Object.ctor.call(this);
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this._Count;
        },
        set_Count: function (value){
            this._Count = value;
        },
        ctor$$TData$$Interval: function (TData, data, rect){
            this.TData = TData;
            this.left = null;
            this.right = null;
            this.interval = null;
            this._Count = 0;
            this._UserData = null;
            this._Parent = null;
            System.Object.ctor.call(this);
            this.set_UserData(data);
            this.set_Interval(rect);
            this.set_Count(1);
        },
        ctor$$Int32: function (TData, count){
            this.TData = TData;
            this.left = null;
            this.right = null;
            this.interval = null;
            this._Count = 0;
            this._UserData = null;
            this._Parent = null;
            System.Object.ctor.call(this);
            this.set_Count(count);
        },
        Interval$$: "Microsoft.Msagl.Layout.LargeGraphLayout.Interval",
        get_Interval: function (){
            return this.interval;
        },
        set_Interval: function (value){
            this.interval = value;
        },
        IsLeaf$$: "System.Boolean",
        get_IsLeaf: function (){
            return this.left == null;
        },
        Left$$: "Microsoft.Msagl.Core.Geometry.IntervalNode`1[[`0]]",
        get_Left: function (){
            return this.left;
        },
        set_Left: function (value){
            if (this.left != null && this.left.get_Parent() == this)
                this.left.set_Parent(null);
            this.left = value;
            if (this.left != null)
                this.left.set_Parent(this);
        },
        Right$$: "Microsoft.Msagl.Core.Geometry.IntervalNode`1[[`0]]",
        get_Right: function (){
            return this.right;
        },
        set_Right: function (value){
            if (this.right != null && this.right.get_Parent() == this)
                this.right.set_Parent(null);
            this.right = value;
            if (this.right != null)
                this.right.set_Parent(this);
        },
        UserData$$: "`0",
        get_UserData: function (){
            return this._UserData;
        },
        set_UserData: function (value){
            this._UserData = value;
        },
        Parent$$: "Microsoft.Msagl.Core.Geometry.IntervalNode`1[[`0]]",
        get_Parent: function (){
            return this._Parent;
        },
        set_Parent: function (value){
            this._Parent = value;
        },
        IsLeftChild$$: "System.Boolean",
        get_IsLeftChild: function (){
            System.Diagnostics.Debug.Assert$$Boolean(this.get_Parent() != null);
            return this.Equals$$Object(this.get_Parent().get_Left());
        },
        FirstHitNode$$Double$$Func$3: function (point, hitTestFordoubleDelegate){
            if (this.interval.Contains(point)){
                if (this.get_IsLeaf()){
                    if (hitTestFordoubleDelegate != null){
                        return hitTestFordoubleDelegate(point, this.get_UserData()) == Microsoft.Msagl.Core.Geometry.HitTestBehavior.Stop ? this : null;
                    }
                    return this;
                }
                return (this.get_Left().FirstHitNode$$Double$$Func$3(point, hitTestFordoubleDelegate) != null ? this.get_Left().FirstHitNode$$Double$$Func$3(point, hitTestFordoubleDelegate) : this.get_Right().FirstHitNode$$Double$$Func$3(point, hitTestFordoubleDelegate));
            }
            return null;
        },
        FirstIntersectedNode: function (r){
            if (r.Intersects(this.interval)){
                if (this.get_IsLeaf())
                    return this;
                return (this.get_Left().FirstIntersectedNode(r) != null ? this.get_Left().FirstIntersectedNode(r) : this.get_Right().FirstIntersectedNode(r));
            }
            return null;
        },
        FirstHitNode$$Double: function (point){
            if (this.interval.Contains(point)){
                if (this.get_IsLeaf())
                    return this;
                return (this.get_Left().FirstHitNode$$Double(point) != null ? this.get_Left().FirstHitNode$$Double(point) : this.get_Right().FirstHitNode$$Double(point));
            }
            return null;
        },
        AllHitItems$$Interval$$Func$2: function (intervalPar, hitTestAccept){
            var $yield = [];
            var stack = new System.Collections.Generic.Stack$1.ctor(Microsoft.Msagl.Core.Geometry.IntervalNode$1.ctor);
            stack.Push(this);
            while (stack.get_Count() > 0){
                var node = stack.Pop();
                if (node.get_Interval().Intersects(intervalPar)){
                    if (node.get_IsLeaf()){
                        if ((null == hitTestAccept) || hitTestAccept(node.get_UserData())){
                            $yield.push(node.get_UserData());
                        }
                    }
                    else {
                        stack.Push(node.left);
                        stack.Push(node.right);
                    }
                }
            }
            return $yield;
        },
        AllHitItems$$Double: function (point){
            var $yield = [];
            var stack = new System.Collections.Generic.Stack$1.ctor(Microsoft.Msagl.Core.Geometry.IntervalNode$1.ctor);
            stack.Push(this);
            while (stack.get_Count() > 0){
                var node = stack.Pop();
                if (node.get_Interval().Contains(point)){
                    if (node.get_IsLeaf())
                        $yield.push(node.get_UserData());
                    else {
                        stack.Push(node.left);
                        stack.Push(node.right);
                    }
                }
            }
            return $yield;
        },
        VisitTree: function (hitTest, hitInterval){
            Microsoft.Msagl.Core.Geometry.IntervalNode$1.VisitTreeStatic(this, hitTest, hitInterval);
        },
        Clone: function (){
            var ret = (function (){
                var $v4 = new Microsoft.Msagl.Core.Geometry.IntervalNode$1.ctor$$Int32(this.TData, this.get_Count());
                $v4.set_UserData(this.get_UserData());
                $v4.set_Interval(this.get_Interval());
                return $v4;
            }).call(this);
            if (this.get_Left() != null)
                ret.set_Left(this.get_Left().Clone());
            if (this.get_Right() != null)
                ret.set_Right(this.get_Right().Clone());
            return ret;
        },
        GetNodeItemsIntersectingInterval: function (intervalPar){
            return System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.IntervalNode$1.ctor, this.TData, this.GetLeafIntervalNodesIntersectingInterval(intervalPar), $CreateAnonymousDelegate(this, function (node){
                return node.get_UserData();
            }));
        },
        GetLeafIntervalNodesIntersectingInterval: function (intervalPar){
            var $yield = [];
            var stack = new System.Collections.Generic.Stack$1.ctor(Microsoft.Msagl.Core.Geometry.IntervalNode$1.ctor);
            stack.Push(this);
            while (stack.get_Count() > 0){
                var node = stack.Pop();
                if (node.get_Interval().Intersects(intervalPar)){
                    if (node.get_IsLeaf()){
                        $yield.push(node);
                    }
                    else {
                        stack.Push(node.left);
                        stack.Push(node.right);
                    }
                }
            }
            return $yield;
        },
        GetAllLeaves: function (){
            return System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.IntervalNode$1.ctor, this.TData, this.GetAllLeafNodes(), $CreateAnonymousDelegate(this, function (n){
                return n.get_UserData();
            }));
        },
        GetAllLeafNodes: function (){
            return this.EnumIntervalNodes(true);
        },
        GetAllNodes: function (){
            return this.EnumIntervalNodes(false);
        },
        EnumIntervalNodes: function (leafOnly){
            var $yield = [];
            var stack = new System.Collections.Generic.Stack$1.ctor(Microsoft.Msagl.Core.Geometry.IntervalNode$1.ctor);
            stack.Push(this);
            while (stack.get_Count() > 0){
                var node = stack.Pop();
                if (node.get_IsLeaf() || !leafOnly){
                    $yield.push(node);
                }
                if (!node.get_IsLeaf()){
                    stack.Push(node.left);
                    stack.Push(node.right);
                }
            }
            return $yield;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$IntervalNode$1);
var Microsoft$Msagl$Core$Geometry$IntervalNodeUtils = {
    fullname: "Microsoft.Msagl.Core.Geometry.IntervalNodeUtils",
    baseTypeName: "System.Object",
    staticDefinition: {
        CrossIntervalNodes$2$$IntervalNode$1$$IntervalNode$1$$Action$2: function (TA, TB, a, b, action){
            if (!a.interval.Intersects(b.interval))
                return;
            if (a.get_Left() == null){
                if (b.get_Left() == null)
                    action(a.get_UserData(), b.get_UserData());
                else {
                    Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.CrossIntervalNodes$2$$IntervalNode$1$$IntervalNode$1$$Action$2(TA, TB, a, b.get_Left(), action);
                    Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.CrossIntervalNodes$2$$IntervalNode$1$$IntervalNode$1$$Action$2(TA, TB, a, b.get_Right(), action);
                }
            }
            else {
                if (b.get_Left() != null){
                    Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.CrossIntervalNodes$2$$IntervalNode$1$$IntervalNode$1$$Action$2(TA, TB, a.get_Left(), b.get_Left(), action);
                    Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.CrossIntervalNodes$2$$IntervalNode$1$$IntervalNode$1$$Action$2(TA, TB, a.get_Left(), b.get_Right(), action);
                    Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.CrossIntervalNodes$2$$IntervalNode$1$$IntervalNode$1$$Action$2(TA, TB, a.get_Right(), b.get_Left(), action);
                    Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.CrossIntervalNodes$2$$IntervalNode$1$$IntervalNode$1$$Action$2(TA, TB, a.get_Right(), b.get_Right(), action);
                }
                else {
                    Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.CrossIntervalNodes$2$$IntervalNode$1$$IntervalNode$1$$Action$2(TA, TB, a.get_Left(), b, action);
                    Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.CrossIntervalNodes$2$$IntervalNode$1$$IntervalNode$1$$Action$2(TA, TB, a.get_Right(), b, action);
                }
            }
        },
        CrossIntervalNodes$1$$IntervalNode$1$$IntervalNode$1$$Action$2: function (TA, a, b, action){
            if (!a.interval.Intersects(b.interval))
                return;
            if (System.Object.Equals$$Object$$Object(a, b))
                Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.HandleEquality$1(TA, a, action);
            else if (a.get_Left() == null){
                if (b.get_Left() == null){
                    action(a.get_UserData(), b.get_UserData());
                }
                else {
                    Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.CrossIntervalNodes$1$$IntervalNode$1$$IntervalNode$1$$Action$2(TA, a, b.get_Left(), action);
                    Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.CrossIntervalNodes$1$$IntervalNode$1$$IntervalNode$1$$Action$2(TA, a, b.get_Right(), action);
                }
            }
            else {
                if (b.get_Left() != null){
                    Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.CrossIntervalNodes$1$$IntervalNode$1$$IntervalNode$1$$Action$2(TA, a.get_Left(), b.get_Left(), action);
                    Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.CrossIntervalNodes$1$$IntervalNode$1$$IntervalNode$1$$Action$2(TA, a.get_Left(), b.get_Right(), action);
                    Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.CrossIntervalNodes$1$$IntervalNode$1$$IntervalNode$1$$Action$2(TA, a.get_Right(), b.get_Left(), action);
                    Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.CrossIntervalNodes$1$$IntervalNode$1$$IntervalNode$1$$Action$2(TA, a.get_Right(), b.get_Right(), action);
                }
                else {
                    Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.CrossIntervalNodes$1$$IntervalNode$1$$IntervalNode$1$$Action$2(TA, a.get_Left(), b, action);
                    Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.CrossIntervalNodes$1$$IntervalNode$1$$IntervalNode$1$$Action$2(TA, a.get_Right(), b, action);
                }
            }
        },
        FindIntersectionWithProperty$1: function (TA, a, b, property){
            if (!a.interval.Intersects(b.interval))
                return false;
            if (System.Object.Equals$$Object$$Object(a, b))
                return Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.HandleEqualityCheck$1(TA, a, property);
            if (a.get_Left() == null){
                if (b.get_Left() == null)
                    return property(a.get_UserData(), b.get_UserData());
                if (Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.FindIntersectionWithProperty$1(TA, a, b.get_Left(), property))
                    return true;
                if (Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.FindIntersectionWithProperty$1(TA, a, b.get_Right(), property))
                    return true;
            }
            else {
                if (b.get_Left() != null){
                    if (Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.FindIntersectionWithProperty$1(TA, a.get_Left(), b.get_Left(), property))
                        return true;
                    if (Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.FindIntersectionWithProperty$1(TA, a.get_Left(), b.get_Right(), property))
                        return true;
                    if (Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.FindIntersectionWithProperty$1(TA, a.get_Right(), b.get_Left(), property))
                        return true;
                    if (Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.FindIntersectionWithProperty$1(TA, a.get_Right(), b.get_Right(), property))
                        return true;
                }
                else {
                    if (Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.FindIntersectionWithProperty$1(TA, a.get_Left(), b, property))
                        return true;
                    if (Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.FindIntersectionWithProperty$1(TA, a.get_Right(), b, property))
                        return true;
                }
            }
            return false;
        },
        HandleEqualityCheck$1: function (TA, a, func){
            if (a.get_Left() == null)
                return false;
            return Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.FindIntersectionWithProperty$1(TA, a.get_Left(), a.get_Left(), func) || Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.FindIntersectionWithProperty$1(TA, a.get_Left(), a.get_Right(), func) || Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.FindIntersectionWithProperty$1(TA, a.get_Right(), a.get_Right(), func);
        },
        HandleEquality$1: function (TA, a, action){
            if (a.get_Left() == null)
                return;
            Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.CrossIntervalNodes$1$$IntervalNode$1$$IntervalNode$1$$Action$2(TA, a.get_Left(), a.get_Left(), action);
            Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.CrossIntervalNodes$1$$IntervalNode$1$$IntervalNode$1$$Action$2(TA, a.get_Left(), a.get_Right(), action);
            Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.CrossIntervalNodes$1$$IntervalNode$1$$IntervalNode$1$$Action$2(TA, a.get_Right(), a.get_Right(), action);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$IntervalNodeUtils);
var Microsoft$Msagl$Core$Geometry$IntervalRTree$1 = {
    fullname: "Microsoft.Msagl.Core.Geometry.IntervalRTree$1",
    baseTypeName: "System.Object",
    staticDefinition: {
        GetNodeRects: function (nodes){
            return System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.Collections.Generic.KeyValuePair$2.ctor, Microsoft.Msagl.Core.Geometry.IntervalNode$1.ctor, nodes, function (v){
                return new Microsoft.Msagl.Core.Geometry.IntervalNode$1.ctor$$TData$$Interval(this.TData, v.get_Value(), v.get_Key());
            });
        },
        AddNodeToTreeRecursive: function (newNode, existingNode){
            if (existingNode.get_IsLeaf()){
                existingNode.set_Left(new Microsoft.Msagl.Core.Geometry.IntervalNode$1.ctor$$TData$$Interval(this.TData, existingNode.get_UserData(), existingNode.get_Interval()));
                existingNode.set_Right(newNode);
                existingNode.set_Count(2);
                existingNode.set_UserData(Default(this.TData));
            }
            else {
                existingNode.set_Count(existingNode.get_Count() + 1);
                var leftBox;
                var rightBox;
                if (2 * existingNode.get_Left().get_Count() < existingNode.get_Right().get_Count()){
                    Microsoft.Msagl.Core.Geometry.IntervalRTree$1.AddNodeToTreeRecursive(newNode, existingNode.get_Left());
                    existingNode.get_Left().set_Interval(new Microsoft.Msagl.Layout.LargeGraphLayout.Interval.ctor$$Interval$$Interval(existingNode.get_Left().get_Interval(), newNode.get_Interval()));
                }
                else if (2 * existingNode.get_Right().get_Count() < existingNode.get_Left().get_Count()){
                    Microsoft.Msagl.Core.Geometry.IntervalRTree$1.AddNodeToTreeRecursive(newNode, existingNode.get_Right());
                    existingNode.get_Right().set_Interval(new Microsoft.Msagl.Layout.LargeGraphLayout.Interval.ctor$$Interval$$Interval(existingNode.get_Right().get_Interval(), newNode.get_Interval()));
                }
                else {
                    leftBox = new Microsoft.Msagl.Layout.LargeGraphLayout.Interval.ctor$$Interval$$Interval(existingNode.get_Left().get_Interval(), newNode.get_Interval());
                    var delLeft = leftBox.get_Length() - existingNode.get_Left().get_Interval().get_Length();
                    rightBox = new Microsoft.Msagl.Layout.LargeGraphLayout.Interval.ctor$$Interval$$Interval(existingNode.get_Right().get_Interval(), newNode.get_Interval());
                    var delRight = rightBox.get_Length() - existingNode.get_Right().get_Interval().get_Length();
                    if (delLeft < delRight){
                        Microsoft.Msagl.Core.Geometry.IntervalRTree$1.AddNodeToTreeRecursive(newNode, existingNode.get_Left());
                        existingNode.get_Left().set_Interval(leftBox);
                    }
                    else if (delLeft > delRight){
                        Microsoft.Msagl.Core.Geometry.IntervalRTree$1.AddNodeToTreeRecursive(newNode, existingNode.get_Right());
                        existingNode.get_Right().set_Interval(rightBox);
                    }
                    else {
                        if (leftBox.get_Length() < rightBox.get_Length()){
                            Microsoft.Msagl.Core.Geometry.IntervalRTree$1.AddNodeToTreeRecursive(newNode, existingNode.get_Left());
                            existingNode.get_Left().set_Interval(leftBox);
                        }
                        else {
                            Microsoft.Msagl.Core.Geometry.IntervalRTree$1.AddNodeToTreeRecursive(newNode, existingNode.get_Right());
                            existingNode.get_Right().set_Interval(rightBox);
                        }
                    }
                }
            }
            existingNode.set_Interval(new Microsoft.Msagl.Layout.LargeGraphLayout.Interval.ctor$$Interval$$Interval(existingNode.get_Left().get_Interval(), existingNode.get_Right().get_Interval()));
        },
        TreeIsCorrect: function (node){
            if (node == null)
                return true;
            var ret = node.get_Left() != null && node.get_Right() != null || node.get_Left() == null && node.get_Right() == null;
            if (!ret)
                return false;
            return Microsoft.Msagl.Core.Geometry.IntervalRTree$1.TreeIsCorrect(node.get_Left()) && Microsoft.Msagl.Core.Geometry.IntervalRTree$1.TreeIsCorrect(node.get_Right());
        },
        UpdateParent: function (parent){
            for (var node = parent.get_Parent(); node != null; node = node.get_Parent()){
                node.set_Count(node.get_Count() - 1);
                node.set_Interval(new Microsoft.Msagl.Layout.LargeGraphLayout.Interval.ctor$$Interval$$Interval(node.get_Left().get_Interval(), node.get_Right().get_Interval()));
            }
        },
        TransferFromSibling: function (parent, sibling){
            parent.set_UserData(sibling.get_UserData());
            parent.set_Left(sibling.get_Left());
            parent.set_Right(sibling.get_Right());
            parent.set_Count(parent.get_Count() - 1);
            parent.set_Interval(sibling.get_Interval());
        },
        RebuildUnderNodeWithoutLeaf: function (nodeForRebuild, leaf){
            System.Diagnostics.Debug.Assert$$Boolean(leaf.get_IsLeaf());
            System.Diagnostics.Debug.Assert$$Boolean(!nodeForRebuild.get_IsLeaf());
            var newNode = Microsoft.Msagl.Core.Geometry.IntervalNode$1.CreateIntervalNodeOnEnumeration(System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.IntervalNode$1.ctor, nodeForRebuild.GetAllLeafNodes(), function (n){
                return !(n.Equals$$Object(leaf));
            }));
            nodeForRebuild.set_Count(newNode.get_Count());
            nodeForRebuild.set_Left(newNode.get_Left());
            nodeForRebuild.set_Right(newNode.get_Right());
            nodeForRebuild.set_Interval(new Microsoft.Msagl.Layout.LargeGraphLayout.Interval.ctor$$Interval$$Interval(newNode.get_Left().interval, newNode.get_Right().interval));
        },
        FindTopUnbalancedNode: function (node){
            for (var parent = node.get_Parent(); parent != null; parent = parent.get_Parent())
                if (!Microsoft.Msagl.Core.Geometry.IntervalRTree$1.Balanced(parent))
                    return parent;
            return null;
        },
        Balanced: function (rectangleNode){
            return 2 * rectangleNode.get_Left().get_Count() >= rectangleNode.get_Right().get_Count() && 2 * rectangleNode.get_Right().get_Count() >= rectangleNode.get_Left().get_Count();
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$IEnumerable$1: function (TData, rectsAndData){
            this.TData = TData;
            this.rootNode = null;
            System.Object.ctor.call(this);
            this.rootNode = Microsoft.Msagl.Core.Geometry.IntervalNode$1.CreateIntervalNodeOnEnumeration(Microsoft.Msagl.Core.Geometry.IntervalRTree$1.GetNodeRects(rectsAndData));
        },
        RootNode$$: "Microsoft.Msagl.Core.Geometry.IntervalNode`1[[`0]]",
        get_RootNode: function (){
            return this.rootNode;
        },
        set_RootNode: function (value){
            this.rootNode = value;
        },
        ctor$$IntervalNode$1: function (TData, rootNode){
            this.TData = TData;
            this.rootNode = null;
            System.Object.ctor.call(this);
            this.rootNode = rootNode;
        },
        ctor: function (TData){
            this.TData = TData;
            this.rootNode = null;
            System.Object.ctor.call(this);
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this.rootNode == null ? 0 : this.rootNode.get_Count();
        },
        Add$$Interval$$TData: function (key, value){
            this.Add$$IntervalNode$1(new Microsoft.Msagl.Core.Geometry.IntervalNode$1.ctor$$TData$$Interval(this.TData, value, key));
        },
        Add$$IntervalNode$1: function (node){
            if (this.rootNode == null)
                this.rootNode = node;
            else if (this.get_Count() <= 2)
                this.rootNode = Microsoft.Msagl.Core.Geometry.IntervalNode$1.CreateIntervalNodeOnEnumeration(System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Geometry.IntervalNode$1.ctor, this.rootNode.GetAllLeafNodes(), [node]));
            else
                Microsoft.Msagl.Core.Geometry.IntervalRTree$1.AddNodeToTreeRecursive(node, this.rootNode);
        },
        Rebuild: function (){
            this.rootNode = Microsoft.Msagl.Core.Geometry.IntervalNode$1.CreateIntervalNodeOnEnumeration(this.rootNode.GetAllLeafNodes());
        },
        GetAllLeaves: function (){
            return this.rootNode != null && this.get_Count() > 0 ? this.rootNode.GetAllLeaves() : new Array(0);
        },
        GetAllIntersecting: function (queryRegion){
            return this.rootNode == null || this.get_Count() == 0 ? new Array(0) : this.rootNode.GetNodeItemsIntersectingInterval(queryRegion);
        },
        GetAllLeavesIntersectingInterval: function (queryRegion){
            return this.rootNode == null || this.get_Count() == 0 ? new Array(0) : this.rootNode.GetLeafIntervalNodesIntersectingInterval(queryRegion);
        },
        IsIntersecting: function (queryRegion){
            return System.Linq.Enumerable.Any$1$$IEnumerable$1(this.TData, this.GetAllIntersecting(queryRegion));
        },
        Contains: function (rectangle, userData){
            if (this.rootNode == null)
                return false;
            return System.Linq.Enumerable.Any$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.IntervalNode$1.ctor, this.rootNode.GetLeafIntervalNodesIntersectingInterval(rectangle), $CreateAnonymousDelegate(this, function (node){
                return node.get_UserData().Equals$$Object(userData);
            }));
        },
        Remove: function (rectangle, userData){
            if (this.rootNode == null){
                return Default(this.TData);
            }
            var ret = System.Linq.Enumerable.FirstOrDefault$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.IntervalNode$1.ctor, this.rootNode.GetLeafIntervalNodesIntersectingInterval(rectangle), $CreateAnonymousDelegate(this, function (node){
                return node.get_UserData().Equals$$Object(userData);
            }));
            if (ret == null)
                return Default(this.TData);
            if (this.get_RootNode().get_Count() == 1)
                this.set_RootNode(null);
            else
                this.RemoveLeaf(ret);
            return ret.get_UserData();
        },
        RemoveLeaf: function (leaf){
            System.Diagnostics.Debug.Assert$$Boolean(leaf.get_IsLeaf());
            var unbalancedNode = Microsoft.Msagl.Core.Geometry.IntervalRTree$1.FindTopUnbalancedNode(leaf);
            if (unbalancedNode != null){
                Microsoft.Msagl.Core.Geometry.IntervalRTree$1.RebuildUnderNodeWithoutLeaf(unbalancedNode, leaf);
                Microsoft.Msagl.Core.Geometry.IntervalRTree$1.UpdateParent(unbalancedNode);
            }
            else {
                var parent = leaf.get_Parent();
                if (parent == null){
                    System.Diagnostics.Debug.Assert$$Boolean(this.rootNode == leaf);
                    this.rootNode = new Microsoft.Msagl.Core.Geometry.IntervalNode$1.ctor(this.TData);
                }
                else {
                    Microsoft.Msagl.Core.Geometry.IntervalRTree$1.TransferFromSibling(parent, leaf.get_IsLeftChild() ? parent.get_Right() : parent.get_Left());
                    Microsoft.Msagl.Core.Geometry.IntervalRTree$1.UpdateParent(parent);
                }
            }
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.IntervalRTree$1.TreeIsCorrect(this.get_RootNode()));
        },
        Clean: function (){
            this.set_RootNode(null);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$IntervalRTree$1);
var Microsoft$Msagl$Core$Geometry$RectangleNodeUtils = {
    fullname: "Microsoft.Msagl.Core.Geometry.RectangleNodeUtils",
    baseTypeName: "System.Object",
    staticDefinition: {
        CrossRectangleNodes$2$$RectangleNode$1$$RectangleNode$1$$Action$2: function (TA, TB, a, b, action){
            if (!a.rectangle.Intersects(b.rectangle))
                return;
            if (a.get_Left() == null){
                if (b.get_Left() == null)
                    action(a.get_UserData(), b.get_UserData());
                else {
                    Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$2$$RectangleNode$1$$RectangleNode$1$$Action$2(TA, TB, a, b.get_Left(), action);
                    Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$2$$RectangleNode$1$$RectangleNode$1$$Action$2(TA, TB, a, b.get_Right(), action);
                }
            }
            else {
                if (b.get_Left() != null){
                    Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$2$$RectangleNode$1$$RectangleNode$1$$Action$2(TA, TB, a.get_Left(), b.get_Left(), action);
                    Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$2$$RectangleNode$1$$RectangleNode$1$$Action$2(TA, TB, a.get_Left(), b.get_Right(), action);
                    Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$2$$RectangleNode$1$$RectangleNode$1$$Action$2(TA, TB, a.get_Right(), b.get_Left(), action);
                    Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$2$$RectangleNode$1$$RectangleNode$1$$Action$2(TA, TB, a.get_Right(), b.get_Right(), action);
                }
                else {
                    Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$2$$RectangleNode$1$$RectangleNode$1$$Action$2(TA, TB, a.get_Left(), b, action);
                    Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$2$$RectangleNode$1$$RectangleNode$1$$Action$2(TA, TB, a.get_Right(), b, action);
                }
            }
        },
        CrossRectangleNodes$1$$RectangleNode$1$$RectangleNode$1$$Action$2: function (TA, a, b, action){
            if (!a.rectangle.Intersects(b.rectangle))
                return;
            if (System.Object.Equals$$Object$$Object(a, b))
                Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.HandleEquality$1(TA, a, action);
            else if (a.get_Left() == null){
                if (b.get_Left() == null){
                    action(a.get_UserData(), b.get_UserData());
                }
                else {
                    Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$1$$RectangleNode$1$$RectangleNode$1$$Action$2(TA, a, b.get_Left(), action);
                    Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$1$$RectangleNode$1$$RectangleNode$1$$Action$2(TA, a, b.get_Right(), action);
                }
            }
            else {
                if (b.get_Left() != null){
                    Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$1$$RectangleNode$1$$RectangleNode$1$$Action$2(TA, a.get_Left(), b.get_Left(), action);
                    Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$1$$RectangleNode$1$$RectangleNode$1$$Action$2(TA, a.get_Left(), b.get_Right(), action);
                    Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$1$$RectangleNode$1$$RectangleNode$1$$Action$2(TA, a.get_Right(), b.get_Left(), action);
                    Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$1$$RectangleNode$1$$RectangleNode$1$$Action$2(TA, a.get_Right(), b.get_Right(), action);
                }
                else {
                    Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$1$$RectangleNode$1$$RectangleNode$1$$Action$2(TA, a.get_Left(), b, action);
                    Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$1$$RectangleNode$1$$RectangleNode$1$$Action$2(TA, a.get_Right(), b, action);
                }
            }
        },
        FindIntersectionWithProperty$1: function (TA, a, b, property){
            if (!a.rectangle.Intersects(b.rectangle))
                return false;
            if (System.Object.Equals$$Object$$Object(a, b))
                return Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.HandleEqualityCheck$1(TA, a, property);
            if (a.get_Left() == null){
                if (b.get_Left() == null)
                    return property(a.get_UserData(), b.get_UserData());
                if (Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.FindIntersectionWithProperty$1(TA, a, b.get_Left(), property))
                    return true;
                if (Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.FindIntersectionWithProperty$1(TA, a, b.get_Right(), property))
                    return true;
            }
            else {
                if (b.get_Left() != null){
                    if (Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.FindIntersectionWithProperty$1(TA, a.get_Left(), b.get_Left(), property))
                        return true;
                    if (Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.FindIntersectionWithProperty$1(TA, a.get_Left(), b.get_Right(), property))
                        return true;
                    if (Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.FindIntersectionWithProperty$1(TA, a.get_Right(), b.get_Left(), property))
                        return true;
                    if (Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.FindIntersectionWithProperty$1(TA, a.get_Right(), b.get_Right(), property))
                        return true;
                }
                else {
                    if (Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.FindIntersectionWithProperty$1(TA, a.get_Left(), b, property))
                        return true;
                    if (Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.FindIntersectionWithProperty$1(TA, a.get_Right(), b, property))
                        return true;
                }
            }
            return false;
        },
        HandleEqualityCheck$1: function (TA, a, func){
            if (a.get_Left() == null)
                return false;
            return Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.FindIntersectionWithProperty$1(TA, a.get_Left(), a.get_Left(), func) || Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.FindIntersectionWithProperty$1(TA, a.get_Left(), a.get_Right(), func) || Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.FindIntersectionWithProperty$1(TA, a.get_Right(), a.get_Right(), func);
        },
        HandleEquality$1: function (TA, a, action){
            if (a.get_Left() == null)
                return;
            Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$1$$RectangleNode$1$$RectangleNode$1$$Action$2(TA, a.get_Left(), a.get_Left(), action);
            Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$1$$RectangleNode$1$$RectangleNode$1$$Action$2(TA, a.get_Left(), a.get_Right(), action);
            Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$1$$RectangleNode$1$$RectangleNode$1$$Action$2(TA, a.get_Right(), a.get_Right(), action);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$RectangleNodeUtils);
var Microsoft$Msagl$Core$Geometry$Site = {
    fullname: "Microsoft.Msagl.Core.Geometry.Site",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.previouisBezierCoefficient = 0.5;
            this.nextBezierCoefficient = 0.5;
            this.previousTangentCoefficient = 0.333333333333333;
            this.nextTangentCoefficient = 0.333333333333333;
            this.point = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.prev = null;
            this.next = null;
            System.Object.ctor.call(this);
        },
        PreviousBezierSegmentFitCoefficient$$: "System.Double",
        get_PreviousBezierSegmentFitCoefficient: function (){
            return this.previouisBezierCoefficient;
        },
        set_PreviousBezierSegmentFitCoefficient: function (value){
            this.previouisBezierCoefficient = value;
        },
        NextBezierSegmentFitCoefficient$$: "System.Double",
        get_NextBezierSegmentFitCoefficient: function (){
            return this.nextBezierCoefficient;
        },
        set_NextBezierSegmentFitCoefficient: function (value){
            this.nextBezierCoefficient = value;
        },
        PreviousTangentCoefficient$$: "System.Double",
        get_PreviousTangentCoefficient: function (){
            return this.previousTangentCoefficient;
        },
        set_PreviousTangentCoefficient: function (value){
            this.previousTangentCoefficient = value;
        },
        NextTangentCoefficient$$: "System.Double",
        get_NextTangentCoefficient: function (){
            return this.nextTangentCoefficient;
        },
        set_NextTangentCoefficient: function (value){
            this.nextTangentCoefficient = value;
        },
        Point$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Point: function (){
            return this.point;
        },
        set_Point: function (value){
            this.point = value;
        },
        Previous$$: "Microsoft.Msagl.Core.Geometry.Site",
        get_Previous: function (){
            return this.prev;
        },
        set_Previous: function (value){
            this.prev = value;
        },
        Next$$: "Microsoft.Msagl.Core.Geometry.Site",
        get_Next: function (){
            return this.next;
        },
        set_Next: function (value){
            this.next = value;
        },
        ctor$$Point: function (sitePoint){
            this.previouisBezierCoefficient = 0.5;
            this.nextBezierCoefficient = 0.5;
            this.previousTangentCoefficient = 0.333333333333333;
            this.nextTangentCoefficient = 0.333333333333333;
            this.point = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.prev = null;
            this.next = null;
            System.Object.ctor.call(this);
            this.point = sitePoint;
        },
        ctor$$Site$$Point: function (previousSite, sitePoint){
            this.previouisBezierCoefficient = 0.5;
            this.nextBezierCoefficient = 0.5;
            this.previousTangentCoefficient = 0.333333333333333;
            this.nextTangentCoefficient = 0.333333333333333;
            this.point = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.prev = null;
            this.next = null;
            System.Object.ctor.call(this);
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(previousSite, "pr");
            this.point = sitePoint;
            this.prev = previousSite;
            previousSite.next = this;
        },
        ctor$$Site$$Point$$Site: function (previousSite, sitePoint, nextSite){
            this.previouisBezierCoefficient = 0.5;
            this.nextBezierCoefficient = 0.5;
            this.previousTangentCoefficient = 0.333333333333333;
            this.nextTangentCoefficient = 0.333333333333333;
            this.point = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.prev = null;
            this.next = null;
            System.Object.ctor.call(this);
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(previousSite, "pr");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(nextSite, "ne");
            this.prev = previousSite;
            this.point = sitePoint;
            this.next = nextSite;
            previousSite.next = this;
            this.next.prev = this;
        },
        Turn$$: "System.Double",
        get_Turn: function (){
            if (this.get_Next() == null || this.get_Previous() == null)
                return 0;
            return Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(this.get_Previous().get_Point(), this.get_Point(), this.get_Next().get_Point());
        },
        Clone: function (){
            var s = new Microsoft.Msagl.Core.Geometry.Site.ctor();
            s.set_PreviousBezierSegmentFitCoefficient(this.get_PreviousBezierSegmentFitCoefficient());
            s.set_Point(this.get_Point());
            return s;
        },
        toString: function (){
            return this.get_Point().toString();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Site);
var Microsoft$Msagl$Core$GraphAlgorithms$MinimumSpanningTreeByPrim = {
    fullname: "Microsoft.Msagl.Core.GraphAlgorithms.MinimumSpanningTreeByPrim",
    baseTypeName: "System.Object",
    staticDefinition: {
        Test: function (){
        },
        GetEdges: function (count){
            var $yield = [];
            for (var i = 0; i < count; i++)
                for (var j = i + 1; j < count; j++){
                    $yield.push(new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(i, j));
                }
            return $yield;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (graph, weight, root){
            this.graph = null;
            this.weight = null;
            this.root = 0;
            this.q = null;
            this.treeNodes = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(System.Int32.ctor);
            this.hedgehog = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, Microsoft.Msagl.Core.GraphAlgorithms.IEdge.ctor);
            System.Object.ctor.call(this);
            this.graph = graph;
            this.weight = weight;
            this.root = root;
            this.q = new Microsoft.Msagl.Core.DataStructures.BinaryHeapPriorityQueue.ctor(graph.get_NodeCount());
        },
        NodeIsInTree: function (i){
            return this.treeNodes.Contains$$T(i);
        },
        GetTreeEdges: function (){
            var ret = new System.Collections.Generic.List$1.ctor$$Int32(Microsoft.Msagl.Core.GraphAlgorithms.IEdge.ctor, this.graph.get_NodeCount() - 1);
            this.Init();
            while (ret.get_Count() < this.graph.get_NodeCount() - 1 && this.q.get_Count() > 0)
                this.AddEdgeToTree(ret);
            return ret;
        },
        AddEdgeToTree: function (ret){
            var v = this.q.Dequeue();
            var e = this.hedgehog.get_Item$$TKey(v);
            this.treeNodes.Insert(v);
            ret.Add(e);
            this.UpdateOutEdgesOfV(v);
            this.UpdateInEdgesOfV(v);
        },
        UpdateOutEdgesOfV: function (v){
            var $it14 = this.graph.OutEdges(v).GetEnumerator();
            while ($it14.MoveNext()){
                var outEdge = $it14.get_Current();
                var u = outEdge.get_Target();
                if (this.NodeIsInTree(u))
                    continue;
                var oldEdge;
                if ((function (){
                    var $1 = {
                        Value: oldEdge
                    };
                    var $res = this.hedgehog.TryGetValue(u, $1);
                    oldEdge = $1.Value;
                    return $res;
                }).call(this)){
                    var oldWeight = this.weight(oldEdge);
                    var newWeight = this.weight(outEdge);
                    if (newWeight < oldWeight){
                        this.q.DecreasePriority(u, newWeight);
                        this.hedgehog.set_Item$$TKey(u, outEdge);
                    }
                }
                else {
                    this.q.Enqueue(u, this.weight(outEdge));
                    this.hedgehog.set_Item$$TKey(u, outEdge);
                }
            }
        },
        UpdateInEdgesOfV: function (v){
            var $it15 = this.graph.InEdges(v).GetEnumerator();
            while ($it15.MoveNext()){
                var inEdge = $it15.get_Current();
                var u = inEdge.get_Source();
                if (this.NodeIsInTree(u))
                    continue;
                var oldEdge;
                if ((function (){
                    var $1 = {
                        Value: oldEdge
                    };
                    var $res = this.hedgehog.TryGetValue(u, $1);
                    oldEdge = $1.Value;
                    return $res;
                }).call(this)){
                    var oldWeight = this.weight(oldEdge);
                    var newWeight = this.weight(inEdge);
                    if (newWeight < oldWeight){
                        this.q.DecreasePriority(u, newWeight);
                        this.hedgehog.set_Item$$TKey(u, inEdge);
                    }
                }
                else {
                    this.q.Enqueue(u, this.weight(inEdge));
                    this.hedgehog.set_Item$$TKey(u, inEdge);
                }
            }
        },
        Init: function (){
            this.treeNodes.Insert(this.root);
            var $it16 = this.graph.OutEdges(this.root).GetEnumerator();
            while ($it16.MoveNext()){
                var outEdge = $it16.get_Current();
                var w = this.weight(outEdge);
                this.q.Enqueue(outEdge.get_Target(), w);
                this.hedgehog.set_Item$$TKey(outEdge.get_Target(), outEdge);
            }
            var $it17 = this.graph.InEdges(this.root).GetEnumerator();
            while ($it17.MoveNext()){
                var inEdge = $it17.get_Current();
                var w = this.weight(inEdge);
                this.q.Enqueue(inEdge.get_Source(), w);
                this.hedgehog.set_Item$$TKey(inEdge.get_Source(), inEdge);
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$GraphAlgorithms$MinimumSpanningTreeByPrim);
var Microsoft$Msagl$Core$Layout$Arrowhead = {
    fullname: "Microsoft.Msagl.Core.Layout.Arrowhead",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Core.Layout.Arrowhead.DefaultArrowheadLength = 10;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.length = 10;
            this._Width = 0;
            this._TipPosition = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._Offset = 0;
            System.Object.ctor.call(this);
        },
        Length$$: "System.Double",
        get_Length: function (){
            return this.length;
        },
        set_Length: function (value){
            this.length = value;
        },
        Width$$: "System.Double",
        get_Width: function (){
            return this._Width;
        },
        set_Width: function (value){
            this._Width = value;
        },
        TipPosition$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_TipPosition: function (){
            return this._TipPosition;
        },
        set_TipPosition: function (value){
            this._TipPosition = value;
        },
        Offset$$: "System.Double",
        get_Offset: function (){
            return this._Offset;
        },
        set_Offset: function (value){
            this._Offset = value;
        },
        Clone: function (){
            return (function (){
                var $v6 = new Microsoft.Msagl.Core.Layout.Arrowhead.ctor();
                $v6.set_Length(this.length);
                $v6.set_Width(this.get_Width());
                $v6.set_TipPosition(this.get_TipPosition());
                $v6.set_Offset(this.get_Offset());
                return $v6;
            }).call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$Arrowhead);
var Microsoft$Msagl$Core$Layout$Arrowheads = {
    fullname: "Microsoft.Msagl.Core.Layout.Arrowheads",
    baseTypeName: "System.Object",
    staticDefinition: {
        CalculateArrowheads: function (edgeGeometry){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(edgeGeometry, "edgeGeometry");
            if (edgeGeometry.get_SourceArrowhead() == null && edgeGeometry.get_TargetArrowhead() == null)
                return true;
            var parStart,parEnd;
            if (!(function (){
                var $1 = {
                    Value: parStart
                };
                var $res = Microsoft.Msagl.Core.Layout.Arrowheads.FindTrimStartForArrowheadAtSource(edgeGeometry, $1);
                parStart = $1.Value;
                return $res;
            })())
                return false;
            if (!(function (){
                var $1 = {
                    Value: parEnd
                };
                var $res = Microsoft.Msagl.Core.Layout.Arrowheads.FindTrimEndForArrowheadAtTarget(edgeGeometry, $1);
                parEnd = $1.Value;
                return $res;
            })())
                return false;
            if (parStart > parEnd - Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_IntersectionEpsilon() || Microsoft.Msagl.Core.Geometry.ApproximateComparer.CloseIntersections(edgeGeometry.get_Curve().get_Item$$Double(parStart), edgeGeometry.get_Curve().get_Item$$Double(parEnd)))
                return false;
            var c = edgeGeometry.get_Curve().Trim(parStart, parEnd);
            if (c == null)
                return false;
            if (edgeGeometry.get_SourceArrowhead() != null)
                edgeGeometry.get_SourceArrowhead().set_TipPosition(Microsoft.Msagl.Core.Layout.Arrowheads.PlaceTip(c.get_Start(), edgeGeometry.get_Curve().get_Start(), edgeGeometry.get_SourceArrowhead().get_Offset()));
            if (edgeGeometry.get_TargetArrowhead() != null)
                edgeGeometry.get_TargetArrowhead().set_TipPosition(Microsoft.Msagl.Core.Layout.Arrowheads.PlaceTip(c.get_End(), edgeGeometry.get_Curve().get_End(), edgeGeometry.get_TargetArrowhead().get_Offset()));
            edgeGeometry.set_Curve(c);
            return true;
        },
        GetIntersectionsWithArrowheadCircle: function (curve, arrowheadLength, circleCenter){
            System.Diagnostics.Debug.Assert$$Boolean(arrowheadLength > 0);
            var e = new Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor$$Double$$Double$$Point(arrowheadLength, arrowheadLength, circleCenter);
            return Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(e, curve, true);
        },
        FindTrimEndForArrowheadAtTarget: function (edgeGeometry, p){
            var eps = Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon * Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon;
            p.Value = edgeGeometry.get_Curve().get_ParEnd();
            if (edgeGeometry.get_TargetArrowhead() == null || edgeGeometry.get_TargetArrowhead().get_Length() <= Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return true;
            var curve = edgeGeometry.get_Curve();
            var arrowheadLength = edgeGeometry.get_TargetArrowhead().get_Length();
            var newCurveEnd;
            var intersections;
            var reps = 10;
            do{
                reps--;
                if (reps == 0)
                    return false;
                intersections = Microsoft.Msagl.Core.Layout.Arrowheads.GetIntersectionsWithArrowheadCircle(curve, arrowheadLength, curve.get_End());
                p.Value = intersections.get_Count() != 0 ? System.Linq.Enumerable.Max$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.ctor, intersections, function (x){
                    return x.get_Par1();
                }) : curve.get_ParEnd();
                newCurveEnd = edgeGeometry.get_Curve().get_Item$$Double(p.Value);
                arrowheadLength /= 2;
            }
            while (((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(newCurveEnd, curve.get_Start())).get_LengthSquared() < eps || intersections.get_Count() == 0))
            return true;
        },
        FindTrimStartForArrowheadAtSource: function (edgeGeometry, p){
            p.Value = 0;
            if (edgeGeometry.get_SourceArrowhead() == null || edgeGeometry.get_SourceArrowhead().get_Length() <= Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return true;
            var eps = Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon * Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon;
            System.Diagnostics.Debug.Assert$$Boolean((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(edgeGeometry.get_Curve().get_End(), edgeGeometry.get_Curve().get_Start())).get_LengthSquared() > eps);
            var arrowheadLength = edgeGeometry.get_SourceArrowhead().get_Length();
            var newStart;
            var curve = edgeGeometry.get_Curve();
            var intersections;
            var reps = 10;
            do{
                reps--;
                if (reps == 0)
                    return false;
                intersections = Microsoft.Msagl.Core.Layout.Arrowheads.GetIntersectionsWithArrowheadCircle(curve, arrowheadLength, curve.get_Start());
                p.Value = intersections.get_Count() != 0 ? System.Linq.Enumerable.Min$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.ctor, intersections, function (x){
                    return x.get_Par1();
                }) : curve.get_ParStart();
                newStart = curve.get_Item$$Double(p.Value);
                arrowheadLength /= 2;
            }
            while ((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(newStart, curve.get_End())).get_LengthSquared() < eps || intersections.get_Count() == 0)
            return true;
        },
        PlaceTip: function (arrowBase, arrowTip, offset){
            if (System.Math.Abs$$Double(offset) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                return arrowTip;
            var d = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(arrowBase, arrowTip);
            var dLen = d.get_Length();
            if (dLen < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                return arrowTip;
            return Microsoft.Msagl.Core.Geometry.Point.op_Addition(arrowTip, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(offset, (Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(d, dLen))));
        },
        TrimSplineAndCalculateArrowheads$$Edge$$ICurve$$Boolean$$Boolean: function (edge, spline, narrowestInterval, keepOriginalSpline){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(edge, "edge");
            return Microsoft.Msagl.Core.Layout.Arrowheads.TrimSplineAndCalculateArrowheads$$EdgeGeometry$$ICurve$$ICurve$$ICurve$$Boolean$$Boolean(edge.get_EdgeGeometry(), edge.get_Source().get_BoundaryCurve(), edge.get_Target().get_BoundaryCurve(), spline, narrowestInterval, keepOriginalSpline);
        },
        TrimSplineAndCalculateArrowheads$$EdgeGeometry$$ICurve$$ICurve$$ICurve$$Boolean$$Boolean: function (edgeGeometry, sourceBoundary, targetBoundary, spline, narrowestInterval, keepOriginalSpline){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(spline, "spline");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(edgeGeometry, "edgeGeometry");
            edgeGeometry.set_Curve(Microsoft.Msagl.Core.Geometry.Curves.Curve.TrimEdgeSplineWithNodeBoundaries(sourceBoundary, targetBoundary, spline, narrowestInterval));
            if (edgeGeometry.get_Curve() == null)
                return false;
            if ((edgeGeometry.get_SourceArrowhead() == null || edgeGeometry.get_SourceArrowhead().get_Length() < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon) && (edgeGeometry.get_TargetArrowhead() == null || edgeGeometry.get_TargetArrowhead().get_Length() < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon))
                return true;
            var success = false;
            var sourceArrowheadSavedLength = edgeGeometry.get_SourceArrowhead() != null ? edgeGeometry.get_SourceArrowhead().get_Length() : 0;
            var targetArrowheadSavedLength = edgeGeometry.get_TargetArrowhead() != null ? edgeGeometry.get_TargetArrowhead().get_Length() : 0;
            var len = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(edgeGeometry.get_Curve().get_End(), edgeGeometry.get_Curve().get_Start())).get_Length();
            if (edgeGeometry.get_SourceArrowhead() != null)
                edgeGeometry.get_SourceArrowhead().set_Length(System.Math.Min$$Double$$Double(len, sourceArrowheadSavedLength));
            if (edgeGeometry.get_TargetArrowhead() != null)
                edgeGeometry.get_TargetArrowhead().set_Length(System.Math.Min$$Double$$Double(len, targetArrowheadSavedLength));
            var count = 10;
            while ((edgeGeometry.get_SourceArrowhead() != null && edgeGeometry.get_SourceArrowhead().get_Length() > Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_IntersectionEpsilon() || edgeGeometry.get_TargetArrowhead() != null && edgeGeometry.get_TargetArrowhead().get_Length() > Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_IntersectionEpsilon()) && !success){
                success = Microsoft.Msagl.Core.Layout.Arrowheads.CalculateArrowheads(edgeGeometry);
                if (!success){
                    if (edgeGeometry.get_SourceArrowhead() != null)
                        edgeGeometry.get_SourceArrowhead().set_Length(edgeGeometry.get_SourceArrowhead().get_Length() * 0.5);
                    if (edgeGeometry.get_TargetArrowhead() != null)
                        edgeGeometry.get_TargetArrowhead().set_Length(edgeGeometry.get_TargetArrowhead().get_Length() * 0.5);
                }
                count--;
                if (count == 0)
                    break;
            }
            if (!success){
                if (edgeGeometry.get_SourceArrowhead() != null)
                    edgeGeometry.get_SourceArrowhead().set_TipPosition(spline.get_Start());
                if (edgeGeometry.get_TargetArrowhead() != null)
                    edgeGeometry.get_TargetArrowhead().set_TipPosition(spline.get_End());
            }
            if (edgeGeometry.get_SourceArrowhead() != null)
                edgeGeometry.get_SourceArrowhead().set_Length(sourceArrowheadSavedLength);
            if (edgeGeometry.get_TargetArrowhead() != null)
                edgeGeometry.get_TargetArrowhead().set_Length(targetArrowheadSavedLength);
            return success;
        },
        CreateBigEnoughSpline: function (edge){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(edge, "edge");
            var a = edge.get_Source().get_Center();
            var b = edge.get_Target().get_Center();
            var bMinA = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b, a);
            var l = bMinA.get_Length();
            var perp;
            if (l < 0.001){
                perp = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(1, 0);
                b = Microsoft.Msagl.Core.Geometry.Point.op_Addition(a, perp.Rotate(1.5707963267949));
            }
            else {
                perp = bMinA.Rotate(1.5707963267949);
            }
            var maxArrowLength = 1;
            if (edge.get_EdgeGeometry().get_SourceArrowhead() != null){
                maxArrowLength += edge.get_EdgeGeometry().get_SourceArrowhead().get_Length();
            }
            if (edge.get_EdgeGeometry().get_TargetArrowhead() != null){
                maxArrowLength += edge.get_EdgeGeometry().get_TargetArrowhead().get_Length();
            }
            perp = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(perp.Normalize(), 1.5), maxArrowLength);
            var i = 1;
            do{
                var seg = Microsoft.Msagl.Core.Geometry.Curves.Curve.CreateBezierSeg$$Point$$Point$$Point$$Int32(a, b, perp, i);
                if (Microsoft.Msagl.Core.Layout.Arrowheads.TrimSplineAndCalculateArrowheads$$EdgeGeometry$$ICurve$$ICurve$$ICurve$$Boolean$$Boolean(edge.get_EdgeGeometry(), edge.get_Source().get_BoundaryCurve(), edge.get_Target().get_BoundaryCurve(), seg, false, false)){
                    break;
                }
                i *= 2;
                var stop = 10000;
                if (i >= stop){
                    Microsoft.Msagl.Core.Layout.Arrowheads.CreateEdgeCurveWithNoTrimming(edge, a, b);
                    return;
                }
            }
            while (true)
        },
        CreateEdgeCurveWithNoTrimming: function (edge, a, b){
            var ab = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b, a);
            ab = ab.Normalize();
            var lineStart = a;
            var lineEnd = b;
            var targetArrow = edge.get_EdgeGeometry().get_TargetArrowhead();
            if (targetArrow != null){
                targetArrow.set_TipPosition(b);
                lineEnd = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(ab, targetArrow.get_Length()));
            }
            var sourceArrow = edge.get_EdgeGeometry().get_SourceArrowhead();
            if (sourceArrow != null){
                sourceArrow.set_TipPosition(a);
                lineStart = Microsoft.Msagl.Core.Geometry.Point.op_Addition(a, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(ab, sourceArrow.get_Length()));
            }
            edge.set_Curve(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(lineStart, lineEnd));
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$Arrowheads);
var Microsoft$Msagl$Core$Layout$CurvePort = {
    fullname: "Microsoft.Msagl.Core.Layout.CurvePort",
    baseTypeName: "Microsoft.Msagl.Core.Layout.Port",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$ICurve$$Double: function (curve, parameter){
            this.parameter = 0;
            this.curve = null;
            Microsoft.Msagl.Core.Layout.Port.ctor.call(this);
            this.curve = curve;
            this.parameter = parameter;
        },
        ctor: function (){
            this.parameter = 0;
            this.curve = null;
            Microsoft.Msagl.Core.Layout.Port.ctor.call(this);
        },
        Parameter$$: "System.Double",
        get_Parameter: function (){
            return this.parameter;
        },
        set_Parameter: function (value){
            this.parameter = value;
        },
        Curve$$: "Microsoft.Msagl.Core.Geometry.Curves.ICurve",
        get_Curve: function (){
            return this.curve;
        },
        set_Curve: function (value){
            this.curve = value;
        },
        Location$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Location: function (){
            return this.get_Curve().get_Item$$Double(this.parameter);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$CurvePort);
var Microsoft$Msagl$Core$Layout$EdgeCollection = {
    fullname: "Microsoft.Msagl.Core.Layout.EdgeCollection",
    baseTypeName: "System.Object",
    staticDefinition: {
        AddEdgeToNodes: function (item){
            if (item.get_Source() != item.get_Target()){
                item.get_Source().AddOutEdge(item);
                item.get_Target().AddInEdge(item);
            }
            else {
                item.get_Target().AddSelfEdge(item);
            }
        },
        DetouchEdge: function (item){
            var source = item.get_Source();
            var target = item.get_Target();
            if (source != target){
                source.RemoveOutEdge(item);
                target.RemoveInEdge(item);
            }
            else {
                source.RemoveSelfEdge(item);
            }
            item.set_GeometryParent(null);
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IEnumerable$1"],
    Kind: "Class",
    definition: {
        ctor: function (graph){
            this.edges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor);
            this.graph = null;
            System.Object.ctor.call(this);
            this.graph = graph;
        },
        Add: function (item){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(item, "item");
            item.set_GeometryParent(this.graph);
            this.edges.Add(item);
            Microsoft.Msagl.Core.Layout.EdgeCollection.AddEdgeToNodes(item);
        },
        Clear: function (){
            this.edges.Clear();
            var $it18 = this.graph.get_Nodes().GetEnumerator();
            while ($it18.MoveNext()){
                var node = $it18.get_Current();
                (Cast(node.get_OutEdges(), Microsoft.Msagl.Core.DataStructures.Set$1.ctor)).Clear();
                (Cast(node.get_InEdges(), Microsoft.Msagl.Core.DataStructures.Set$1.ctor)).Clear();
                (Cast(node.get_SelfEdges(), Microsoft.Msagl.Core.DataStructures.Set$1.ctor)).Clear();
            }
        },
        Contains: function (item){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(item, "item");
            return this.edges.Contains(item);
        },
        CopyTo: function (array, arrayIndex){
            this.edges.CopyTo(array, arrayIndex);
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this.edges.get_Count();
        },
        IsReadOnly$$: "System.Boolean",
        get_IsReadOnly: function (){
            return false;
        },
        Remove: function (item){
            if (item == null || !this.edges.Contains(item))
                return false;
            Microsoft.Msagl.Core.Layout.EdgeCollection.DetouchEdge(item);
            return this.edges.Remove(item);
        },
        GetEnumerator: function (){
            return this.edges.GetEnumerator();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$EdgeCollection);
var Microsoft$Msagl$Core$Layout$EdgeLabelPlacement = {
    fullname: "Microsoft.Msagl.Core.Layout.EdgeLabelPlacement",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.MinGranularity = 5;
            Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.MaxGranularity = 50;
            Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.LowerEdgeBound = 500;
            Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.UpperEdgeBound = 3000;
        },
        StartIndex: function (label, points){
            return System.Math.Min$$Int32$$Int32(points.get_Count() - 1, System.Math.Max$$Int32$$Int32(0, (System.Math.Floor$$Double(points.get_Count() * label.get_PlacementOffset())) | 0));
        },
        CalculateCenterNotSure: function (label){
            var cen = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            var $it24 = label.get_InnerPoints().GetEnumerator();
            while ($it24.MoveNext()){
                var p = $it24.get_Current();
                cen = Microsoft.Msagl.Core.Geometry.Point.op_Addition(cen, p);
            }
            var $it25 = label.get_OuterPoints().GetEnumerator();
            while ($it25.MoveNext()){
                var p = $it25.get_Current();
                cen = Microsoft.Msagl.Core.Geometry.Point.op_Addition(cen, p);
            }
            label.set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(cen, (label.get_InnerPoints().get_Count() + label.get_OuterPoints().get_Count())));
        },
        GetLabelBounds: function (point, derivative, widthHeight, side){
            var o = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(derivative.Rotate(1.5707963267949).Normalize(), side), 2);
            var labelPos = Microsoft.Msagl.Core.Geometry.Point.op_Addition(point, o);
            var left = (o.get_X() > 0) ? labelPos.get_X() : labelPos.get_X() - widthHeight.get_X();
            var bottom = (o.get_Y() > 0 ? labelPos.get_Y() : labelPos.get_Y() - widthHeight.get_Y());
            if (System.Math.Abs$$Double(o.get_X()) < 0.75){
                var horizontalAngle = System.Math.Acos(System.Math.Abs$$Double(o.get_Y()) / o.get_Length());
                var horizontalShift = o.get_Length() / System.Math.Sin(horizontalAngle);
                var verticalShift = o.get_Length() / System.Math.Cos(horizontalAngle);
                left += (o.get_X() > 0 ? -1 : 1) * System.Math.Min$$Double$$Double(horizontalShift, widthHeight.get_X() / 2);
                bottom += (o.get_Y() > 0 ? 1 : -1) * verticalShift;
            }
            else if (System.Math.Abs$$Double(o.get_Y()) < 0.75){
                var verticalAngle = System.Math.Acos(System.Math.Abs$$Double(o.get_X()) / o.get_Length());
                var verticalShift = o.get_Length() / System.Math.Sin(verticalAngle);
                var horizontalShift = o.get_Length() / System.Math.Cos(verticalAngle);
                left += (o.get_X() > 0 ? 1 : -1) * horizontalShift;
                bottom += (o.get_Y() > 0 ? -1 : 1) * System.Math.Min$$Double$$Double(verticalShift, widthHeight.get_Y() / 2);
            }
            return new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Double$$Double$$Point(left, bottom, widthHeight);
        },
        SetLabelBounds: function (label, bounds){
            var innerPoints = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            var outerPoints = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            innerPoints.Add(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(bounds.get_LeftTop().get_X(), bounds.get_LeftTop().get_Y()));
            innerPoints.Add(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(bounds.get_RightTop().get_X(), bounds.get_RightTop().get_Y()));
            outerPoints.Add(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(bounds.get_LeftBottom().get_X(), bounds.get_LeftBottom().get_Y()));
            outerPoints.Add(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(bounds.get_RightBottom().get_X(), bounds.get_RightBottom().get_Y()));
            label.set_InnerPoints(innerPoints);
            label.set_OuterPoints(outerPoints);
        },
        GetPossibleSides: function (side, derivative){
            if (derivative.get_Length() == 0){
                side = Microsoft.Msagl.Core.Layout.Label.PlacementSide.Any;
            }
            switch (side){
                case Microsoft.Msagl.Core.Layout.Label.PlacementSide.Port:
                    return new Float64Array([-1]);
                case Microsoft.Msagl.Core.Layout.Label.PlacementSide.Starboard:
                    return new Float64Array([1]);
                case Microsoft.Msagl.Core.Layout.Label.PlacementSide.Top:
                    if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(derivative.get_X(), 0)){
                    return Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.GetPossibleSides(Microsoft.Msagl.Core.Layout.Label.PlacementSide.Left, derivative);
                }
                    return new Float64Array([derivative.get_X() < 0 ? 1 : -1]);
                case Microsoft.Msagl.Core.Layout.Label.PlacementSide.Bottom:
                    if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(derivative.get_X(), 0)){
                    return Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.GetPossibleSides(Microsoft.Msagl.Core.Layout.Label.PlacementSide.Right, derivative);
                }
                    return new Float64Array([derivative.get_X() < 0 ? -1 : 1]);
                case Microsoft.Msagl.Core.Layout.Label.PlacementSide.Left:
                    if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(derivative.get_Y(), 0)){
                    return Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.GetPossibleSides(Microsoft.Msagl.Core.Layout.Label.PlacementSide.Top, derivative);
                }
                    return new Float64Array([derivative.get_Y() < 0 ? -1 : 1]);
                case Microsoft.Msagl.Core.Layout.Label.PlacementSide.Right:
                    if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(derivative.get_Y(), 0)){
                    return Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.GetPossibleSides(Microsoft.Msagl.Core.Layout.Label.PlacementSide.Bottom, derivative);
                }
                    return new Float64Array([derivative.get_Y() < 0 ? 1 : -1]);
                default:
                    return new Float64Array([-1, 1]);
            }
        },
        ExpandingSearch: function (start, min, max){
            var $yield = [];
            System.Diagnostics.Debug.Assert$$Boolean(start >= min);
            System.Diagnostics.Debug.Assert$$Boolean(start < max);
            System.Diagnostics.Debug.Assert$$Boolean(min < max);
            var upper;
            var lower = upper = start + 1;
            while (lower > min || upper < max){
                if (lower > min)
                    $yield.push(--lower);
                if (upper < max)
                    $yield.push(upper++);
            }
            return $yield;
        },
        PointSetLength: function (ps){
            var l = 0;
            var q = null;
            var $it28 = System.Linq.Enumerable.OrderBy$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.PointSet.ctor, System.Double.ctor, ps, function (p){
                return p.Key;
            }).GetEnumerator();
            while ($it28.MoveNext()){
                var p = $it28.get_Current();
                if (Microsoft.Msagl.Core.Geometry.Point.op_Inequality(q, null)){
                    l += (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(Cast(q, Microsoft.Msagl.Core.Geometry.Point.ctor), p.Center)).get_Length();
                }
                q = p.Center;
            }
            return l;
        },
        GetSidesAndEdgeCurve: function (label, e, curvePoints, index, sides){
            var curve = (e.get_Curve() != null ? e.get_Curve() : new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(e.get_Source().get_Center(), e.get_Target().get_Center()));
            var initialDer = curve.Derivative(curvePoints.get_Item$$Int32(index).get_Key());
            sides.Value = Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.GetPossibleSides(label.get_Side(), initialDer);
            return curve;
        },
        SubdivideCurveSegment: function (list, curve, delta2, start, end){
            if (list.get_Count() > 64)
                return;
            var startPoint = curve.get_Item$$Double(start);
            var endPoint = curve.get_Item$$Double(end);
            if ((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(startPoint, endPoint)).get_LengthSquared() > delta2){
                var mid = (start + end) / 2;
                Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.SubdivideCurveSegment(list, curve, delta2, start, mid);
                Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.SubdivideCurveSegment(list, curve, delta2, mid, end);
            }
            else {
                list.Add(new System.Collections.Generic.KeyValuePair$2.ctor$$TKey$$TValue(System.Double.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, start, startPoint));
            }
        },
        CurvePoints: function (curve, granularity){
            var points = new System.Collections.Generic.List$1.ctor(System.Collections.Generic.KeyValuePair$2.ctor);
            var delta = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(curve.get_End(), curve.get_Start())).get_LengthSquared() / (granularity * granularity);
            Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.SubdivideCurveSegment(points, curve, delta, curve.get_ParStart(), curve.get_ParEnd());
            points.Sort$$IComparer$1(new Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.PointComparer.ctor());
            if (System.Linq.Enumerable.Last$1$$IEnumerable$1(System.Collections.Generic.KeyValuePair$2.ctor, points).get_Key() < curve.get_ParEnd()){
                points.Add(new System.Collections.Generic.KeyValuePair$2.ctor$$TKey$$TValue(System.Double.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, curve.get_ParEnd(), curve.get_End()));
            }
            return points;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$GeometryGraph: function (graph){
            this.labels = null;
            this.obstacleMaps = new Array(3);
            this.labelObstacleMap = null;
            this.edgePoints = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor, System.Collections.Generic.List$1.ctor);
            this.granularity = 5;
            this._ScaleCollisionGranularity = false;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.InitObstacles(graph);
            this.labels = graph.CollectAllLabels();
        },
        CollisionGranularity$$: "System.Int32",
        get_CollisionGranularity: function (){
            return this.granularity;
        },
        set_CollisionGranularity: function (value){
            this.granularity = value;
        },
        ScaleCollisionGranularity$$: "System.Boolean",
        get_ScaleCollisionGranularity: function (){
            return this._ScaleCollisionGranularity;
        },
        set_ScaleCollisionGranularity: function (value){
            this._ScaleCollisionGranularity = value;
        },
        InitObstacles: function (graph){
            var allClusters = graph.get_RootCluster().AllClustersDepthFirst();
            this.InitializeObstacles(System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Layout.Node.ctor, graph.get_Nodes(), System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Cluster.ctor, Microsoft.Msagl.Core.Layout.Node.ctor, allClusters, $CreateAnonymousDelegate(this, function (c){
                return c;
            }))), graph.get_Edges());
        },
        ctor$$GeometryGraph$$ICollection$1$Label: function (graph, labels){
            this.labels = null;
            this.obstacleMaps = new Array(3);
            this.labelObstacleMap = null;
            this.edgePoints = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor, System.Collections.Generic.List$1.ctor);
            this.granularity = 5;
            this._ScaleCollisionGranularity = false;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.InitObstacles(graph);
            this.labels = labels;
        },
        ctor$$IEnumerable$1$Node$$IEnumerable$1$Edge: function (nodes, edges){
            this.labels = null;
            this.obstacleMaps = new Array(3);
            this.labelObstacleMap = null;
            this.edgePoints = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor, System.Collections.Generic.List$1.ctor);
            this.granularity = 5;
            this._ScaleCollisionGranularity = false;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.InitializeObstacles(nodes, edges);
            this.labels = System.Linq.Enumerable.ToList$1(Microsoft.Msagl.Core.Layout.Label.ctor, System.Linq.Enumerable.SelectMany$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, Microsoft.Msagl.Core.Layout.Label.ctor, edges, $CreateAnonymousDelegate(this, function (e){
                return e.get_Labels();
            })));
        },
        InitializeObstacles: function (nodes, edges){
            var edgeList = System.Linq.Enumerable.ToList$1(Microsoft.Msagl.Core.Layout.Edge.ctor, edges);
            var modifiedGranularity = this.GetModifiedGranularity(edgeList);
            var edgeObstacles = this.GetEdgeObstacles(edges, modifiedGranularity);
            var edgeObstacleMap = new Microsoft.Msagl.Core.Geometry.RTree$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Layout.IObstacle.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.IObstacle.ctor, System.Collections.Generic.KeyValuePair$2.ctor, edgeObstacles, $CreateAnonymousDelegate(this, function (e){
                return new System.Collections.Generic.KeyValuePair$2.ctor$$TKey$$TValue(Microsoft.Msagl.Core.Geometry.Rectangle.ctor, Microsoft.Msagl.Core.Layout.IObstacle.ctor, e.get_Rectangle(), e);
            })));
            var nodeObstacles = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.IObstacle.ctor);
            var $it19 = nodes.GetEnumerator();
            while ($it19.MoveNext()){
                var v = $it19.get_Current();
                nodeObstacles.Add(new Microsoft.Msagl.Core.Layout.RectangleObstacle.ctor$$Rectangle$$Object(v.get_BoundingBox(), v));
            }
            var nodeObstacleMap = new Microsoft.Msagl.Core.Geometry.RTree$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Layout.IObstacle.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.IObstacle.ctor, System.Collections.Generic.KeyValuePair$2.ctor, nodeObstacles, $CreateAnonymousDelegate(this, function (n){
                return new System.Collections.Generic.KeyValuePair$2.ctor$$TKey$$TValue(Microsoft.Msagl.Core.Geometry.Rectangle.ctor, Microsoft.Msagl.Core.Layout.IObstacle.ctor, n.get_Rectangle(), n);
            })));
            this.obstacleMaps[1] = nodeObstacleMap;
            this.obstacleMaps[2] = edgeObstacleMap;
        },
        GetEdgeObstacles: function (edges, modifiedGranularity){
            var edgeObstacles = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.IObstacle.ctor);
            var $it20 = edges.GetEnumerator();
            while ($it20.MoveNext()){
                var e = $it20.get_Current();
                var curvePoints = Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.CurvePoints((e.get_Curve() != null ? e.get_Curve() : new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(e.get_Source().get_Center(), e.get_Target().get_Center())), modifiedGranularity);
                this.edgePoints.set_Item$$TKey(e, curvePoints);
                var $it21 = curvePoints.GetEnumerator();
                while ($it21.MoveNext()){
                    var p = $it21.get_Current();
                    edgeObstacles.Add(new Microsoft.Msagl.Core.Layout.PortObstacle.ctor$$Point(p.get_Value()));
                }
                this.ProgressStep();
            }
            return edgeObstacles;
        },
        GetModifiedGranularity: function (edgeList){
            var modifiedGranularity = this.get_CollisionGranularity();
            if (this.get_ScaleCollisionGranularity())
                modifiedGranularity = Microsoft.Msagl.Core.Layout.LayoutAlgorithmHelpers.LinearInterpolation$$Int32$$Int32$$Int32$$Int32$$Int32(edgeList.get_Count(), 500, 3000, this.get_CollisionGranularity(), 50);
            return modifiedGranularity;
        },
        AddLabelObstacle: function (label){
            if (this.labelObstacleMap == null){
                this.labelObstacleMap = new Microsoft.Msagl.Core.Geometry.RTree$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Layout.IObstacle.ctor, [new System.Collections.Generic.KeyValuePair$2.ctor$$TKey$$TValue(Microsoft.Msagl.Core.Geometry.Rectangle.ctor, Microsoft.Msagl.Core.Layout.IObstacle.ctor, label.get_Rectangle(), label)]);
                this.obstacleMaps[0] = this.labelObstacleMap;
            }
            else
                this.labelObstacleMap.Add$$Rectangle$$TData(label.get_Rectangle(), label);
        },
        RunInternal: function (){
            var lbs = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Layout.Label.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Label.ctor, this.labels, $CreateAnonymousDelegate(this, function (l){
                return l != null;
            })));
            this.StartListenToLocalProgress(lbs.length, 1);
            var sortedLabels = System.Linq.Enumerable.ThenBy$2$$IOrderedEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Label.ctor, System.Int32.ctor, System.Linq.Enumerable.OrderByDescending$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Label.ctor, System.Double.ctor, lbs, $CreateAnonymousDelegate(this, function (l){
                return System.Math.Abs$$Double(0.5 - l.get_PlacementOffset());
            })), $CreateAnonymousDelegate(this, function (l){
                return this.edgePoints.get_Item$$TKey((Cast(l.get_GeometryParent(), Microsoft.Msagl.Core.Layout.Edge.ctor))).get_Count();
            }));
            var $it22 = sortedLabels.GetEnumerator();
            while ($it22.MoveNext()){
                var label = $it22.get_Current();
                this.PlaceLabel(label);
                this.ProgressStep();
            }
        },
        PlaceLabel: function (label){
            var placed = false;
            if (label.get_PlacementStrategyPriority() != null){
                var $it23 = label.get_PlacementStrategyPriority().GetEnumerator();
                while ($it23.MoveNext()){
                    var s = $it23.get_Current();
                    placed = s == Microsoft.Msagl.Core.Layout.Label.PlacementStrategy.AlongCurve && this.PlaceEdgeLabelOnCurve(label) || s == Microsoft.Msagl.Core.Layout.Label.PlacementStrategy.Horizontal && this.PlaceEdgeLabelHorizontally(label);
                    if (placed)
                        break;
                }
            }
            if (placed)
                Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.CalculateCenterNotSure(label);
            else
                this.PlaceLabelAtFirstPosition(label);
        },
        PlaceLabelAtFirstPosition: function (label){
            var edge = Cast(label.get_GeometryParent(), Microsoft.Msagl.Core.Layout.Edge.ctor);
            var curve = (edge.get_Curve() != null ? edge.get_Curve() : new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(edge.get_Source().get_Center(), edge.get_Target().get_Center()));
            var points = this.edgePoints.get_Item$$TKey(edge);
            var index = Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.StartIndex(label, points);
            var point = points.get_Item$$Int32(index).get_Value();
            var derivative = curve.Derivative(points.get_Item$$Int32(index).get_Key());
            if (derivative.get_Length() < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance()){
                derivative = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(1, 1);
            }
            var widthHeight = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(label.get_Width(), label.get_Height());
            var side = System.Linq.Enumerable.First$1$$IEnumerable$1(System.Double.ctor, Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.GetPossibleSides(label.get_Side(), derivative));
            var bounds = Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.GetLabelBounds(point, derivative, widthHeight, side);
            Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.SetLabelBounds(label, bounds);
        },
        PlaceEdgeLabelHorizontally: function (label){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(label, "label");
            var e = Cast(label.get_GeometryParent(), Microsoft.Msagl.Core.Layout.Edge.ctor);
            label.set_InnerPoints(null);
            var curvePoints = this.edgePoints.get_Item$$TKey(e);
            var wh = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(label.get_Width(), label.get_Height());
            var bestConflictIndex = -1;
            var bestRectangle = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
            var $it26 = Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.ExpandingSearch(Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.StartIndex(label, curvePoints), 0, curvePoints.get_Count()).GetEnumerator();
            while ($it26.MoveNext()){
                var index = $it26.get_Current();
                var cp = curvePoints.get_Item$$Int32(index);
                var curve = (e.get_Curve() != null ? e.get_Curve() : new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(e.get_Source().get_Center(), e.get_Target().get_Center()));
                var der = curve.Derivative(cp.get_Key());
                if (der.get_LengthSquared() < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                    continue;
                for (var $i28 = 0,$t28 = Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.GetPossibleSides(label.get_Side(), der),$l28 = $t28.length,side = $t28[$i28]; $i28 < $l28; $i28++, side = $t28[$i28]){
                    var queryRect = Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.GetLabelBounds(cp.get_Value(), der, wh, side);
                    var conflictIndex = this.ConflictIndex$$Rectangle$$Label(queryRect, label);
                    if (conflictIndex > bestConflictIndex){
                        bestConflictIndex = conflictIndex;
                        bestRectangle = queryRect;
                        if (bestConflictIndex == 2147483647)
                            break;
                    }
                }
                if (bestConflictIndex == 2147483647)
                    break;
            }
            if (bestConflictIndex >= 0){
                Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.SetLabelBounds(label, bestRectangle);
                var r = new Microsoft.Msagl.Core.Layout.RectangleObstacle.ctor$$Rectangle(bestRectangle);
                this.AddLabelObstacle(r);
                if (bestConflictIndex == 0)
                    label.set_PlacementResult(Microsoft.Msagl.Core.Layout.LabelPlacementResult.OverlapsOtherLabels);
                else if (bestConflictIndex == 1)
                    label.set_PlacementResult(Microsoft.Msagl.Core.Layout.LabelPlacementResult.OverlapsNodes);
                else if (bestConflictIndex == 2)
                    label.set_PlacementResult(Microsoft.Msagl.Core.Layout.LabelPlacementResult.OverlapsEdges);
                else
                    label.set_PlacementResult(Microsoft.Msagl.Core.Layout.LabelPlacementResult.OverlapsNothing);
                return true;
            }
            return false;
        },
        PlaceEdgeLabelOnCurve: function (label){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(label, "label");
            var edge = Cast(label.get_GeometryParent(), Microsoft.Msagl.Core.Layout.Edge.ctor);
            label.set_InnerPoints(null);
            var curvePoints = this.edgePoints.get_Item$$TKey(edge);
            var distanceFromCurve = 3;
            var radius = label.get_Height() / 2;
            var wh = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(radius, radius);
            var labelLength = label.get_Width();
            var $it29 = Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.ExpandingSearch(Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.StartIndex(label, curvePoints), 0, curvePoints.get_Count()).GetEnumerator();
            while ($it29.MoveNext()){
                var index = $it29.get_Current();
                var sides;
                var curve = (function (){
                    var $1 = {
                        Value: sides
                    };
                    var $res = Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.GetSidesAndEdgeCurve(label, edge, curvePoints, index, $1);
                    sides = $1.Value;
                    return $res;
                }).call(this);
                for (var $i31 = 0,$l31 = sides.length,side = sides[$i31]; $i31 < $l31; $i31++, side = sides[$i31]){
                    var placedPoints = new Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.PointSetList.ctor();
                    var coveredLength = 0;
                    (function (){
                        var $1 = {
                            Value: coveredLength
                        };
                        var $res = this.ProcessExpandingSearchOnSide(index, curvePoints, curve, side, radius, distanceFromCurve, wh, $1, placedPoints, labelLength);
                        coveredLength = $1.Value;
                        return $res;
                    }).call(this);
                    if (coveredLength >= labelLength){
                        this.CaseOfCoveredLengthGreaterThanLabelLength(label, placedPoints, coveredLength, labelLength, wh);
                        return true;
                    }
                }
            }
            return false;
        },
        CaseOfCoveredLengthGreaterThanLabelLength: function (label, placedPoints, coveredLength, labelLength, wh){
            var innerPoints = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            var outerPoints = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            var orderedPoints = System.Linq.Enumerable.ToList$1(Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.PointSet.ctor, placedPoints.Points);
            var excess = coveredLength - labelLength;
            if (excess > 0){
                var q = orderedPoints.get_Item$$Int32(orderedPoints.get_Count() - 1);
                var p = orderedPoints.get_Item$$Int32(orderedPoints.get_Count() - 2);
                var v = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(q.Center, p.Center);
                var length = v.get_Length();
                if (excess > length){
                    q = orderedPoints.get_Item$$Int32(0);
                    p = orderedPoints.get_Item$$Int32(1);
                    v = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(q.Center, p.Center);
                    length = v.get_Length();
                }
                System.Diagnostics.Debug.Assert$$Boolean(length > excess);
                var w = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(v, ((length - excess) / length));
                System.Diagnostics.Debug.Assert$$Boolean(System.Math.Abs$$Double((length - w.get_Length()) - excess) < 0.01);
                q.Center = Microsoft.Msagl.Core.Geometry.Point.op_Addition(p.Center, w);
                q.Inner = Microsoft.Msagl.Core.Geometry.Point.op_Addition(p.Inner, w);
                q.Outer = Microsoft.Msagl.Core.Geometry.Point.op_Addition(p.Outer, w);
            }
            var cl = Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.PointSetLength(orderedPoints);
            System.Diagnostics.Debug.Assert$$Boolean(System.Math.Abs$$Double(cl - labelLength) < 0.01);
            this.GoOverOrderedPointsAndAddLabelObstacels(orderedPoints, innerPoints, outerPoints, wh);
            label.set_InnerPoints(innerPoints);
            label.set_OuterPoints(outerPoints);
        },
        GoOverOrderedPointsAndAddLabelObstacels: function (orderedPoints, innerPoints, outerPoints, wh){
            var $it31 = orderedPoints.GetEnumerator();
            while ($it31.MoveNext()){
                var p = $it31.get_Current();
                var center = p.Center;
                innerPoints.Add(p.Inner);
                outerPoints.Add(p.Outer);
                var r = new Microsoft.Msagl.Core.Layout.RectangleObstacle.ctor$$Rectangle(new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Addition(center, wh), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(center, wh)));
                this.AddLabelObstacle(r);
            }
        },
        ProcessExpandingSearchOnSide: function (index, curvePoints, curve, side, radius, distanceFromCurve, wh, coveredLength, placedPoints, labelLength){
            var $it32 = Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.ExpandingSearch(index, 0, curvePoints.get_Count()).GetEnumerator();
            while ($it32.MoveNext()){
                var i = $it32.get_Current();
                var p = curvePoints.get_Item$$Int32(i);
                var der = curve.Derivative(p.get_Key());
                if (der.get_LengthSquared() < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                    continue;
                var o = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(der.Rotate(1.5707963267949).Normalize(), side);
                var labelPos = Microsoft.Msagl.Core.Geometry.Point.op_Addition(p.get_Value(), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point((radius + distanceFromCurve), o));
                if (!this.Conflict(labelPos, radius, wh)){
                    var ps = (function (){
                        var $v7 = new Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.PointSet.ctor();
                        $v7.Key = p.get_Key();
                        $v7.Center = labelPos;
                        $v7.Inner = Microsoft.Msagl.Core.Geometry.Point.op_Addition(p.get_Value(), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(distanceFromCurve, o));
                        $v7.Outer = Microsoft.Msagl.Core.Geometry.Point.op_Addition(p.get_Value(), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point((2 * radius + distanceFromCurve), o));
                        return $v7;
                    }).call(this);
                    coveredLength.Value = i <= index ? placedPoints.AddFirst(ps) : placedPoints.AddLast(ps);
                    System.Diagnostics.Debug.Assert$$Boolean(System.Math.Abs$$Double(Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.PointSetLength(placedPoints.Points) - coveredLength.Value) < 0.01);
                    if (coveredLength.Value >= labelLength){
                        break;
                    }
                }
                else {
                    break;
                }
            }
        },
        Conflict: function (labelPos, radius, wh){
            return this.ConflictIndex$$Point$$Double$$Point(labelPos, radius, wh) != 2147483647;
        },
        ConflictIndex$$Point$$Double$$Point: function (labelPos, radius, wh){
            var queryRect = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(labelPos, wh), Microsoft.Msagl.Core.Geometry.Point.op_Addition(labelPos, wh));
            var r2 = radius * radius;
            for (var i = 0; i < this.obstacleMaps.length; i++){
                if (this.obstacleMaps[i] == null)
                    continue;
                var $it33 = this.obstacleMaps[i].GetAllIntersecting(queryRect).GetEnumerator();
                while ($it33.MoveNext()){
                    var c = $it33.get_Current();
                    if (Is(c, Microsoft.Msagl.Core.Layout.PortObstacle.ctor)){
                        if ((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(labelPos, (Cast(c, Microsoft.Msagl.Core.Layout.PortObstacle.ctor)).Location)).get_LengthSquared() < r2)
                            return i;
                    }
                    else
                        return i;
                }
            }
            return 2147483647;
        },
        ConflictIndex$$Rectangle$$Label: function (queryRect, label){
            var edge = Cast(label.get_GeometryParent(), Microsoft.Msagl.Core.Layout.Edge.ctor);
            var source = edge.get_Source();
            var target = edge.get_Target();
            for (var i = 0; i < this.obstacleMaps.length; i++){
                if (this.obstacleMaps[i] == null)
                    continue;
                var $it34 = this.obstacleMaps[i].GetAllIntersecting(queryRect).GetEnumerator();
                while ($it34.MoveNext()){
                    var obstacle = $it34.get_Current();
                    if (i == 1){
                        var rectangleObstacle = As(obstacle, Microsoft.Msagl.Core.Layout.RectangleObstacle.ctor);
                        if (rectangleObstacle != null){
                            var cluster = As(rectangleObstacle.get_Data(), Microsoft.Msagl.Core.Layout.Cluster.ctor);
                            if (cluster != null && (source.IsDescendantOf(cluster) || target.IsDescendantOf(cluster))){
                                continue;
                            }
                        }
                    }
                    return i;
                }
            }
            return 2147483647;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$EdgeLabelPlacement);
var Microsoft$Msagl$Core$Layout$EdgeLabelPlacement$PointSet = {
    fullname: "Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.PointSet",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.Center = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.Inner = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.Key = 0;
            this.Outer = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$EdgeLabelPlacement$PointSet);
var Microsoft$Msagl$Core$Layout$EdgeLabelPlacement$PointSetList = {
    fullname: "Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.PointSetList",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.Points = new System.Collections.Generic.LinkedList$1.ctor(Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.PointSet.ctor);
            this.coveredLength = 0;
            System.Object.ctor.call(this);
        },
        AddFirst: function (p){
            if (this.Points.get_Count() != 0){
                var q = this.Points.get_First().get_Value();
                this.coveredLength += (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(p.Center, q.Center)).get_Length();
            }
            this.Points.AddFirst$$T(p);
            return this.coveredLength;
        },
        AddLast: function (p){
            if (this.Points.get_Count() != 0){
                var q = this.Points.get_Last().get_Value();
                this.coveredLength += (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(p.Center, q.Center)).get_Length();
            }
            this.Points.AddLast$$T(p);
            return this.coveredLength;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$EdgeLabelPlacement$PointSetList);
var Microsoft$Msagl$Core$Layout$EdgeLabelPlacement$PointComparer = {
    fullname: "Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.PointComparer",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IComparer$1"],
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        },
        Compare: function (x, y){
            if (x.get_Key() < y.get_Key()){
                return -1;
            }
            if (x.get_Key() > y.get_Key()){
                return 1;
            }
            return 0;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$EdgeLabelPlacement$PointComparer);
var Microsoft$Msagl$Core$Layout$HookUpAnywhereFromInsidePort = {
    fullname: "Microsoft.Msagl.Core.Layout.HookUpAnywhereFromInsidePort",
    baseTypeName: "Microsoft.Msagl.Core.Layout.Port",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$Func$1$ICurve$$Double: function (boundaryCurve, hookSize){
            this.curve = null;
            this.adjustmentAngle = 0.314159265358979;
            this.location = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.hookSize = 9;
            this._LoosePolyline = null;
            Microsoft.Msagl.Core.Layout.Port.ctor.call(this);
            this.curve = boundaryCurve;
            this.set_HookSize(hookSize);
        },
        ctor$$Func$1$ICurve: function (boundaryCurve){
            this.curve = null;
            this.adjustmentAngle = 0.314159265358979;
            this.location = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.hookSize = 9;
            this._LoosePolyline = null;
            Microsoft.Msagl.Core.Layout.Port.ctor.call(this);
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(boundaryCurve, "boundaryCurve");
            this.curve = boundaryCurve;
            this.location = this.curve().get_Start();
        },
        Location$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Location: function (){
            return this.location;
        },
        Curve$$: "Microsoft.Msagl.Core.Geometry.Curves.ICurve",
        get_Curve: function (){
            return this.curve();
        },
        set_Curve: function (value){
            throw $CreateException(new System.InvalidCastException.ctor(), new Error());
        },
        SetLocation: function (p){
            this.location = p;
        },
        LoosePolyline$$: "Microsoft.Msagl.Core.Geometry.Curves.Polyline",
        get_LoosePolyline: function (){
            return this._LoosePolyline;
        },
        set_LoosePolyline: function (value){
            this._LoosePolyline = value;
        },
        AdjustmentAngle$$: "System.Double",
        get_AdjustmentAngle: function (){
            return this.adjustmentAngle;
        },
        set_AdjustmentAngle: function (value){
            this.adjustmentAngle = value;
        },
        HookSize$$: "System.Double",
        get_HookSize: function (){
            return this.hookSize;
        },
        set_HookSize: function (value){
            this.hookSize = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$HookUpAnywhereFromInsidePort);
var Microsoft$Msagl$Core$Layout$IdealEdgeLengthSettings = {
    fullname: "Microsoft.Msagl.Core.Layout.IdealEdgeLengthSettings",
    baseTypeName: "System.ValueType",
    assemblyName: "Microsoft.Msagl",
    Kind: "Struct",
    definition: {
        ctor: function (){
            this.constrainedEdgeSeparation = 0;
            this._DefaultLength = 0;
            this._ProportionalToSymmetricDifference = false;
            this._ProportionalEdgeLengthAdjustment = 0;
            this._ProportionalEdgeLengthOffset = 0;
            this._EdgeDirectionConstraints = Microsoft.Msagl.Core.Geometry.Directions.None;
            System.ValueType.ctor.call(this);
        },
        DefaultLength$$: "System.Double",
        get_DefaultLength: function (){
            return this._DefaultLength;
        },
        set_DefaultLength: function (value){
            this._DefaultLength = value;
        },
        ProportionalToSymmetricDifference$$: "System.Boolean",
        get_ProportionalToSymmetricDifference: function (){
            return this._ProportionalToSymmetricDifference;
        },
        set_ProportionalToSymmetricDifference: function (value){
            this._ProportionalToSymmetricDifference = value;
        },
        ProportionalEdgeLengthAdjustment$$: "System.Double",
        get_ProportionalEdgeLengthAdjustment: function (){
            return this._ProportionalEdgeLengthAdjustment;
        },
        set_ProportionalEdgeLengthAdjustment: function (value){
            this._ProportionalEdgeLengthAdjustment = value;
        },
        ProportionalEdgeLengthOffset$$: "System.Double",
        get_ProportionalEdgeLengthOffset: function (){
            return this._ProportionalEdgeLengthOffset;
        },
        set_ProportionalEdgeLengthOffset: function (value){
            this._ProportionalEdgeLengthOffset = value;
        },
        EdgeDirectionConstraints$$: "Microsoft.Msagl.Core.Geometry.Directions",
        get_EdgeDirectionConstraints: function (){
            return this._EdgeDirectionConstraints;
        },
        set_EdgeDirectionConstraints: function (value){
            this._EdgeDirectionConstraints = value;
        },
        ConstrainedEdgeSeparation$$: "System.Double",
        get_ConstrainedEdgeSeparation: function (){
            return this.constrainedEdgeSeparation;
        },
        set_ConstrainedEdgeSeparation: function (value){
            this.constrainedEdgeSeparation = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$IdealEdgeLengthSettings);
var Microsoft$Msagl$Core$Layout$IObstacle = {
    fullname: "Microsoft.Msagl.Core.Layout.IObstacle",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Interface"
};
JsTypes.push(Microsoft$Msagl$Core$Layout$IObstacle);
var Microsoft$Msagl$Core$Layout$IsOpenChangeEventArgs = {
    fullname: "Microsoft.Msagl.Core.Layout.IsOpenChangeEventArgs",
    baseTypeName: "System.EventArgs",
    staticDefinition: {
        cctor: function (){
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (previousValue){
            this.PreviousValue = false;
            System.EventArgs.ctor.call(this);
            this.PreviousValue = previousValue;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$IsOpenChangeEventArgs);
var Microsoft$Msagl$Core$Layout$LabelPlacementResult = {
    fullname: "Microsoft.Msagl.Core.Layout.LabelPlacementResult",
    staticDefinition: {
        OverlapsOtherLabels: 0,
        OverlapsNodes: 1,
        OverlapsEdges: 2,
        OverlapsNothing: 2147483647
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Core$Layout$LabelPlacementResult);
var Microsoft$Msagl$Core$Layout$LgInfoBase = {
    fullname: "Microsoft.Msagl.Core.Layout.LgInfoBase",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.slidingZoomLevel = Infinity;
            this.zoomLevel = Infinity;
            this.rank = 0;
            System.Object.ctor.call(this);
        },
        SlidingZoomLevel$$: "System.Double",
        get_SlidingZoomLevel: function (){
            return this.slidingZoomLevel;
        },
        set_SlidingZoomLevel: function (value){
            this.slidingZoomLevel = value;
        },
        ZoomLevel$$: "System.Double",
        get_ZoomLevel: function (){
            return System.Math.Min$$Double$$Double(this.zoomLevel, this.get_SlidingZoomLevel());
        },
        set_ZoomLevel: function (value){
            this.zoomLevel = value;
        },
        Rank$$: "System.Double",
        get_Rank: function (){
            return this.rank;
        },
        set_Rank: function (value){
            this.rank = value;
        },
        ZoomLevelIsNotSet$$: "System.Boolean",
        get_ZoomLevelIsNotSet: function (){
            return this.get_ZoomLevel() == Infinity;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$LgInfoBase);
var Microsoft$Msagl$Core$Layout$LgNodeInfo = {
    fullname: "Microsoft.Msagl.Core.Layout.LgNodeInfo",
    baseTypeName: "Microsoft.Msagl.Core.Layout.LgInfoBase",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (geometryNode){
            this.Prev = null;
            this.Cost = 0;
            this.InQueue = false;
            this.Processed = false;
            this.scale = 1;
            this.Parent = null;
            this.connectedComponentId = -1;
            this._kind = Microsoft.Msagl.Core.Layout.LgNodeInfoKind.OutOfView;
            this._GeometryNode = null;
            Microsoft.Msagl.Core.Layout.LgInfoBase.ctor.call(this);
            this.set_GeometryNode(geometryNode);
        },
        GeometryNode$$: "Microsoft.Msagl.Core.Layout.Node",
        get_GeometryNode: function (){
            return this._GeometryNode;
        },
        set_GeometryNode: function (value){
            this._GeometryNode = value;
        },
        ScaleIsBigEnough$$: "System.Boolean",
        get_ScaleIsBigEnough: function (){
            return this.scale >= 0.8;
        },
        Scale$$: "System.Double",
        get_Scale: function (){
            return this.scale;
        },
        set_Scale: function (value){
            this.scale = value;
            this.get_GeometryNode().RaiseLayoutChangeEvent(value);
        },
        BoundaryCurve$$: "Microsoft.Msagl.Core.Geometry.Curves.ICurve",
        get_BoundaryCurve: function (){
            return this.get_GeometryNode().get_BoundaryCurve();
        },
        ConnectedComponentId$$: "System.Int32",
        get_ConnectedComponentId: function (){
            return this.connectedComponentId;
        },
        set_ConnectedComponentId: function (value){
            this.connectedComponentId = value;
        },
        Center$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Center: function (){
            return this.get_GeometryNode().get_Center();
        },
        Kind$$: "Microsoft.Msagl.Core.Layout.LgNodeInfoKind",
        get_Kind: function (){
            return this._kind;
        },
        set_Kind: function (value){
            this._kind = value;
        },
        BoundingBox$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_BoundingBox: function (){
            return this.get_GeometryNode().get_BoundaryCurve().get_BoundingBox();
        },
        toString: function (){
            return this.get_GeometryNode().toString();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$LgNodeInfo);
var Microsoft$Msagl$Core$Layout$LayoutAlgorithmHelpers = {
    fullname: "Microsoft.Msagl.Core.Layout.LayoutAlgorithmHelpers",
    baseTypeName: "System.Object",
    staticDefinition: {
        LinearInterpolation$$Int32$$Int32$$Int32$$Int32$$Int32: function (value, lowerThreshold, upperThreshold, minResult, maxResult){
            if (value < lowerThreshold)
                return minResult;
            if (value > upperThreshold)
                return maxResult;
            var fraction = (value - lowerThreshold) / (upperThreshold - lowerThreshold);
            return minResult + ((fraction * (maxResult - minResult))) | 0;
        },
        NegativeLinearInterpolation$$Int32$$Int32$$Int32$$Int32$$Int32: function (value, lowerThreshold, upperThreshold, minResult, maxResult){
            if (value < lowerThreshold)
                return maxResult;
            if (value > upperThreshold)
                return minResult;
            var fraction = (value - lowerThreshold) / (upperThreshold - lowerThreshold);
            return minResult + (((1 - fraction) * (maxResult - minResult))) | 0;
        },
        LinearInterpolation$$Double$$Double$$Double$$Double$$Double: function (value, lowerThreshold, upperThreshold, minResult, maxResult){
            if (value < lowerThreshold)
                return minResult;
            if (value > upperThreshold)
                return maxResult;
            var fraction = (value - lowerThreshold) / (upperThreshold - lowerThreshold);
            return minResult + (fraction * (maxResult - minResult));
        },
        NegativeLinearInterpolation$$Double$$Double$$Double$$Double$$Double: function (value, lowerThreshold, upperThreshold, minResult, maxResult){
            if (value < lowerThreshold)
                return maxResult;
            if (value > upperThreshold)
                return minResult;
            var fraction = (value - lowerThreshold) / (upperThreshold - lowerThreshold);
            return minResult + ((1 - fraction) * (maxResult - minResult));
        },
        ComputeDesiredEdgeLengths: function (settings, component){
            if (component == null){
                return;
            }
            var $it35 = component.get_Edges().GetEnumerator();
            while ($it35.MoveNext()){
                var e = $it35.get_Current();
                e.set_SourcePort(null);
                e.set_TargetPort(null);
                e.set_Length(System.Math.Max$$Double$$Double(settings.get_DefaultLength(), System.Math.Sqrt(2 * System.Math.Min$$Double$$Double(e.get_Source().get_BoundingBox().get_Width() * e.get_Source().get_BoundingBox().get_Height(), e.get_Target().get_BoundingBox().get_Width() * e.get_Target().get_BoundingBox().get_Height()))));
            }
            if (settings.get_ProportionalToSymmetricDifference()){
                Microsoft.Msagl.Core.Layout.LayoutAlgorithmHelpers.SetEdgeLengthsProportionalToSymmetricDifference(component, settings.get_ProportionalEdgeLengthOffset(), settings.get_ProportionalEdgeLengthAdjustment());
            }
        },
        SetEdgeLengthsProportionalToSymmetricDifference: function (graph, lengthInitialOffset, lengthAdjustment){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(graph, "graph");
            var neighbors = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.DataStructures.Set$1.ctor);
            var $it36 = graph.get_Nodes().GetEnumerator();
            while ($it36.MoveNext()){
                var u = $it36.get_Current();
                var ns = (function ($p6){
                    neighbors.set_Item$$TKey(u, $p6);
                    return $p6;
                })(new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor));
                var $it37 = u.get_OutEdges().GetEnumerator();
                while ($it37.MoveNext()){
                    var e = $it37.get_Current();
                    if (!(Is(e.get_Target(), Microsoft.Msagl.Core.Layout.Cluster.ctor))){
                        ns.Insert(e.get_Target());
                    }
                }
                var $it38 = u.get_InEdges().GetEnumerator();
                while ($it38.MoveNext()){
                    var e = $it38.get_Current();
                    if (!(Is(e.get_Source(), Microsoft.Msagl.Core.Layout.Cluster.ctor))){
                        ns.Insert(e.get_Source());
                    }
                }
            }
            var $it39 = graph.get_Edges().GetEnumerator();
            while ($it39.MoveNext()){
                var e = $it39.get_Current();
                if (!(Is(e.get_Source(), Microsoft.Msagl.Core.Layout.Cluster.ctor) || Is(e.get_Target(), Microsoft.Msagl.Core.Layout.Cluster.ctor))){
                    var u = neighbors.get_Item$$TKey(e.get_Source());
                    var v = neighbors.get_Item$$TKey(e.get_Target());
                    var l = System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Node.ctor, System.Linq.Enumerable.Union$1$$IEnumerable$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Node.ctor, u, v)) - System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Node.ctor, System.Linq.Enumerable.Intersect$1$$IEnumerable$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Node.ctor, u, v));
                    l = System.Math.Min$$Double$$Double(30, l);
                    e.set_Length(e.get_Length() * lengthInitialOffset + l * lengthAdjustment);
                }
            }
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$LayoutAlgorithmHelpers);
var Microsoft$Msagl$Core$Layout$LayoutChangeEventArgs = {
    fullname: "Microsoft.Msagl.Core.Layout.LayoutChangeEventArgs",
    baseTypeName: "System.EventArgs",
    staticDefinition: {
        cctor: function (){
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.DataBeforeChange = null;
            this.DataAfterChange = null;
            System.EventArgs.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$LayoutChangeEventArgs);
var Microsoft$Msagl$Core$Layout$LgNodeInfoKind = {
    fullname: "Microsoft.Msagl.Core.Layout.LgNodeInfoKind",
    staticDefinition: {
        OutOfView: 0,
        FullyVisible: 1,
        PathNode: 2,
        Satellite: 3
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Core$Layout$LgNodeInfoKind);
var Microsoft$Msagl$Core$Layout$NodeCollection = {
    fullname: "Microsoft.Msagl.Core.Layout.NodeCollection",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IList$1"],
    Kind: "Class",
    definition: {
        ctor: function (graph){
            this.nodes = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor);
            this.graph = null;
            System.Object.ctor.call(this);
            this.graph = graph;
        },
        Add: function (item){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(item, "node");
            this.nodes.Add(item);
            item.set_GeometryParent(this.graph);
        },
        Clear: function (){
            this.nodes.Clear();
        },
        Contains: function (item){
            return this.nodes.Contains(item);
        },
        CopyTo: function (array, arrayIndex){
            this.nodes.CopyTo$$T$Array$$Int32(array, arrayIndex);
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this.nodes.get_Count();
        },
        IsReadOnly$$: "System.Boolean",
        get_IsReadOnly: function (){
            return false;
        },
        Remove: function (item){
            if (item == null)
                return false;
            this.DetouchNode(item);
            return this.nodes.Remove(item);
        },
        DetouchNode: function (item){
            var nodeEdges = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Layout.Edge.ctor, item.get_Edges());
            for (var $i41 = 0,$l41 = nodeEdges.length,edge = nodeEdges[$i41]; $i41 < $l41; $i41++, edge = nodeEdges[$i41])
                this.graph.get_Edges().Remove(edge);
            item.set_GeometryParent(null);
        },
        GetEnumerator: function (){
            return this.nodes.GetEnumerator();
        },
        IndexOf: function (item){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(item, "item");
            return this.nodes.IndexOf$$T(item);
        },
        Insert: function (index, item){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(item, "item");
            this.nodes.Insert(index, item);
        },
        RemoveAt: function (index){
            var node = this.nodes.get_Item$$Int32(index);
            this.DetouchNode(node);
            this.nodes.RemoveAt(index);
        },
        Item$$: "Microsoft.Msagl.Core.Layout.Node",
        get_Item$$Int32: function (index){
            return this.nodes.get_Item$$Int32(index);
        },
        set_Item$$Int32: function (index, value){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(value, "value");
            var node = this.nodes.get_Item$$Int32(index);
            if (node != value){
                this.DetouchNode(node);
                value.set_GeometryParent(this.graph);
                this.nodes.set_Item$$Int32(index, value);
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$NodeCollection);
var Microsoft$Msagl$Core$Layout$PackingMethod = {
    fullname: "Microsoft.Msagl.Core.Layout.PackingMethod",
    staticDefinition: {
        Compact: 0,
        Columns: 1
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Core$Layout$PackingMethod);
var Microsoft$Msagl$Core$Layout$PortObstacle = {
    fullname: "Microsoft.Msagl.Core.Layout.PortObstacle",
    baseTypeName: "System.ValueType",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Core.Layout.IObstacle"],
    Kind: "Struct",
    definition: {
        ctor$$Point: function (c){
            this.Location = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            System.ValueType.ctor.call(this);
            this.Location = c;
        },
        Rectangle$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_Rectangle: function (){
            return new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point(this.Location);
        },
        ctor: function (){
            this.Location = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            System.ValueType.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$PortObstacle);
var Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$ConjugateGradient$SparseMatrix = {
    fullname: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix",
    baseTypeName: "System.Object",
    staticDefinition: {
        op_Multiply$$SparseMatrix$$Vector: function (m, vec){
            if (vec.array.length < m.get_NumCol())
                throw $CreateException(new System.ArgumentException.ctor$$String("vector must have as many entries as the matrix has columns"), new Error());
            var result = new Float64Array(m.get_NumRow());
            for (var row = 0; row < m.get_NumRow(); row++){
                var startPos = m.row_ptr[row];
                var endPos = m.row_ptr[row + 1];
                for (var i = startPos; i < endPos; i++){
                    var columnIndex = m.col_ind[i];
                    result[row] += vec.array[columnIndex] * m.values[i];
                }
            }
            return new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.ctor(result);
        },
        op_Multiply$$SparseMatrix$$Double$Array: function (m, vec){
            return (Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix.op_Multiply$$SparseMatrix$$Vector(m, new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.ctor(vec))).array;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$Double$Array$$Int32$Array$$Int32$Array$$Int32: function (valuesFlat, columnIndices, rowPointers, numberColumns){
            this.values = null;
            this.col_ind = null;
            this.row_ptr = null;
            this.numRow = 0;
            this._NumCol = 0;
            System.Object.ctor.call(this);
            this.values = valuesFlat;
            this.col_ind = columnIndices;
            this.row_ptr = rowPointers;
            this.set_NumCol(numberColumns);
        },
        Values: function (){
            return this.values;
        },
        ColInd: function (){
            return this.col_ind;
        },
        RowPtr: function (){
            return this.row_ptr;
        },
        NumRow$$: "System.Int32",
        get_NumRow: function (){
            return this.numRow;
        },
        set_NumRow: function (value){
            this.numRow = value;
        },
        NumCol$$: "System.Int32",
        get_NumCol: function (){
            return this._NumCol;
        },
        set_NumCol: function (value){
            this._NumCol = value;
        },
        ctor$$Int32$$Int32$$Int32: function (numValues, numRow, numCol){
            this.values = null;
            this.col_ind = null;
            this.row_ptr = null;
            this.numRow = 0;
            this._NumCol = 0;
            System.Object.ctor.call(this);
            this.values = new Float64Array(numValues);
            this.col_ind = new Int32Array(numValues);
            this.row_ptr = new Int32Array(numRow + 1);
            this.set_NumRow(numRow);
            this.set_NumCol(numCol);
        },
        DiagonalPreconditioner: function (){
            var result = new Float64Array(this.get_NumRow());
            for (var row = 0; row < this.get_NumRow(); row++){
                var startPos = this.row_ptr[row];
                var endPos = this.row_ptr[row + 1];
                for (var i = startPos; i < endPos; i++){
                    var columnIndex = this.col_ind[i];
                    if (row == columnIndex && this.values[i] != 0){
                        result[row] = 1 / this.values[i];
                    }
                }
            }
            return new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.ctor(result);
        },
        GetFullMatrix: function (){
            throw $CreateException(new System.NotSupportedException.ctor$$String("Multi-dimensional arrays are not supported"), new Error());
        },
        PrintMatrix: function (){
            var matrix = this.GetFullMatrix();
            var rowLength = matrix.GetLength(0);
            var colLength = matrix.GetLength(1);
            for (var i = 0; i < rowLength; i++){
                for (var j = 0; j < colLength; j++){
                    System.Console.Write$$String(System.String.Format$$String$$Object("{0} \t", matrix[i,j].ToString$$String("0.00")));
                }
                System.Console.Write$$String(System.Environment.get_NewLine() + System.Environment.get_NewLine());
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$ConjugateGradient$SparseMatrix);
var Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$ConjugateGradient$LinearSystemSolver = {
    fullname: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.LinearSystemSolver",
    baseTypeName: "System.Object",
    staticDefinition: {
        SolveConjugateGradient$$SparseMatrix$$Vector$$Vector$$Int32$$Double: function (A, b, x, iMax, epsilon){
            var r = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.op_Subtraction(b, (Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix.op_Multiply$$SparseMatrix$$Vector(A, x)));
            var d = r.Clone();
            var deltaNew = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.op_Multiply$$Vector$$Vector(r, r);
            var normRes = System.Math.Sqrt(deltaNew) / A.get_NumRow();
            var normRes0 = normRes;
            var i = 0;
            while ((i++) < iMax && normRes > epsilon * normRes0){
                var q = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix.op_Multiply$$SparseMatrix$$Vector(A, d);
                var alpha = deltaNew / (Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.op_Multiply$$Vector$$Vector(d, q));
                x.Add(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.op_Multiply$$Double$$Vector(alpha, d));
                r.Sub(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.op_Multiply$$Double$$Vector(alpha, q));
                var deltaOld = deltaNew;
                deltaNew = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.op_Multiply$$Vector$$Vector(r, r);
                normRes = System.Math.Sqrt(deltaNew) / A.get_NumRow();
                var beta = deltaNew / deltaOld;
                d = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.op_Addition(r, Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.op_Multiply$$Double$$Vector(beta, d));
            }
            return x;
        },
        SolvePrecondConjugateGradient$$SparseMatrix$$Vector$$Vector$$Int32$$Double: function (A, b, x, iMax, epsilon){
            var Minv = A.DiagonalPreconditioner();
            var r = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.op_Subtraction(b, (Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix.op_Multiply$$SparseMatrix$$Vector(A, x)));
            var d = Minv.CompProduct(r);
            var deltaNew = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.op_Multiply$$Vector$$Vector(r, d);
            var normRes = System.Math.Sqrt(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.op_Multiply$$Vector$$Vector(r, r)) / A.get_NumRow();
            var normRes0 = normRes;
            var i = 0;
            while ((i++) < iMax && normRes > epsilon * normRes0){
                var q = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix.op_Multiply$$SparseMatrix$$Vector(A, d);
                var alpha = deltaNew / (Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.op_Multiply$$Vector$$Vector(d, q));
                x.Add(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.op_Multiply$$Double$$Vector(alpha, d));
                r.Sub(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.op_Multiply$$Double$$Vector(alpha, q));
                var s = Minv.CompProduct(r);
                var deltaOld = deltaNew;
                normRes = System.Math.Sqrt(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.op_Multiply$$Vector$$Vector(r, r)) / A.get_NumRow();
                deltaNew = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.op_Multiply$$Vector$$Vector(r, s);
                var beta = deltaNew / deltaOld;
                d = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.op_Addition(s, Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.op_Multiply$$Double$$Vector(beta, d));
            }
            return x;
        },
        SolveConjugateGradient$$SparseMatrix$$Double$Array$$Double$Array$$Int32$$Double: function (A, b, x, iMax, epsilon){
            return Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.LinearSystemSolver.SolveConjugateGradient$$SparseMatrix$$Vector$$Vector$$Int32$$Double(A, new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.ctor(b), new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.ctor(x.Clone() instanceof Float64Array || x.Clone() == null ? x.Clone() : (function (){
                throw new Error("InvalidCastException");
            }
            ())), iMax, epsilon).array;
        },
        SolvePrecondConjugateGradient$$SparseMatrix$$Double$Array$$Double$Array$$Int32$$Double: function (A, b, x, iMax, epsilon){
            return Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.LinearSystemSolver.SolvePrecondConjugateGradient$$SparseMatrix$$Vector$$Vector$$Int32$$Double(A, new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.ctor(b), new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.ctor(x.Clone() instanceof Float64Array || x.Clone() == null ? x.Clone() : (function (){
                throw new Error("InvalidCastException");
            }
            ())), iMax, epsilon).array;
        },
        TestConjugateGradientMethod: function (){
            var values = new Float64Array([4, 1, 1, 3]);
            var col_ind = new Int32Array([0, 1, 0, 1]);
            var row_ptr = new Int32Array([0, 2, 4]);
            var b = new Float64Array([1, 2]);
            var xStart = new Float64Array([2, 1]);
            var A = new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix.ctor$$Double$Array$$Int32$Array$$Int32$Array$$Int32(values, col_ind, row_ptr, 2);
            var res = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.LinearSystemSolver.SolveConjugateGradient$$SparseMatrix$$Double$Array$$Double$Array$$Int32$$Double(A, b, xStart, 1000, 0.0001);
            System.Console.WriteLine$$String$$Object$$Object("Solution: x: {0}, y={1}", res[0], res[1]);
            res = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.LinearSystemSolver.SolvePrecondConjugateGradient$$SparseMatrix$$Double$Array$$Double$Array$$Int32$$Double(A, b, xStart, 1000, 0.0001);
            System.Console.WriteLine$$String$$Object$$Object("SolutionPreconditioned: x: {0}, y={1}", res[0], res[1]);
        },
        TestConjugateGradientMethod2: function (){
            var values = new Float64Array([4, 1, 1, 16, 1, 1, 64, 1, 1, 256, 1, 1, 1024, 1, 1, 4096, 1, 1, 16384, 1, 1, 65536, 1, 1, 262144, 1, 1, 1048576]);
            var colInd = new Int32Array([0, 1, 0, 1, 2, 1, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6, 5, 6, 7, 6, 7, 8, 7, 8, 9, 8, 9]);
            var rowPtr = new Int32Array([0, 2, 5, 8, 11, 14, 17, 20, 23, 26, 28]);
            var A = new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix.ctor$$Double$Array$$Int32$Array$$Int32$Array$$Int32(values, colInd, rowPtr, rowPtr.length - 1);
            var b = new Float64Array([5, 18, 66, 258, 1026, 4098, 16386, 65538, 262146, 1048577]);
            var result1 = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.LinearSystemSolver.SolvePrecondConjugateGradient$$SparseMatrix$$Double$Array$$Double$Array$$Int32$$Double(A, b, new Float64Array(10), 1000, 1E-06);
            var res = System.Linq.Enumerable.Aggregate$2$$IEnumerable$1$$TAccumulate$$Func$3(System.Double.ctor, System.String.ctor, result1, "", function (s, t){
                return System.String.Format$$String$$Object$$Object("{0},\t{1}", s, t);
            });
            System.Console.WriteLine$$String(res);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$ConjugateGradient$LinearSystemSolver);
var Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$ConjugateGradient$Vector = {
    fullname: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector",
    baseTypeName: "System.Object",
    staticDefinition: {
        op_Subtraction: function (a, b){
            var res = new Float64Array(a.array.length);
            for (var i = 0; i < a.array.length; i++){
                res[i] = a.array[i] - b.array[i];
            }
            return new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.ctor(res);
        },
        op_Addition: function (a, b){
            var res = new Float64Array(a.array.length);
            for (var i = 0; i < a.array.length; i++){
                res[i] = a.array[i] + b.array[i];
            }
            return new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.ctor(res);
        },
        op_Multiply$$Vector$$Vector: function (v1, v2){
            var res = 0;
            for (var i = 0; i < v1.array.length; i++){
                res += v1.array[i] * v2.array[i];
            }
            return res;
        },
        op_Multiply$$Double$$Vector: function (scalar, v){
            var res = new Float64Array(v.array.length);
            for (var i = 0; i < v.array.length; i++){
                res[i] = v.array[i] * scalar;
            }
            return new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.ctor(res);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (array){
            this.array = null;
            System.Object.ctor.call(this);
            this.array = array;
        },
        Sub: function (b){
            for (var i = 0; i < this.array.length; i++){
                this.array[i] -= b.array[i];
            }
        },
        Add: function (b){
            for (var i = 0; i < this.array.length; i++){
                this.array[i] += b.array[i];
            }
        },
        Clone: function (){
            return new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.ctor(this.array.Clone() instanceof Float64Array || this.array.Clone() == null ? this.array.Clone() : (function (){
                throw new Error("InvalidCastException");
            }
            ()));
        },
        CompProduct: function (v){
            var res = new Float64Array(this.array.length);
            for (var i = 0; i < this.array.length; i++){
                res[i] = this.array[i] * v.array[i];
            }
            return new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.ctor(res);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$ConjugateGradient$Vector);
var Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$InitialScaling = {
    fullname: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.InitialScaling",
    staticDefinition: {
        None: 0,
        Inch72Pixel: 1,
        AvgNodeSize: 2
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$InitialScaling);
var Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$IOverlapRemoval = {
    fullname: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.IOverlapRemoval",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Interface"
};
JsTypes.push(Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$IOverlapRemoval);
var Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$MST$MstLineSweeper = {
    fullname: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MST.MstLineSweeper",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (proximityEdges, nodeSizes, nodePositions){
            this._proximityEdges = null;
            this._nodeSizes = null;
            this._nodePositions = null;
            this._intervalTree = null;
            this._q = null;
            this._numberOfOverlaps = 0;
            System.Object.ctor.call(this);
            this._proximityEdges = proximityEdges;
            this._nodeSizes = nodeSizes;
            this._nodePositions = nodePositions;
            System.Diagnostics.Debug.Assert$$Boolean(nodePositions.length == nodeSizes.length);
            this._q = new Microsoft.Msagl.Core.DataStructures.BinaryHeapPriorityQueue.ctor(nodeSizes.length * 2);
        },
        Run: function (){
            this.InitQueue();
            this.FindOverlaps();
            return this._numberOfOverlaps;
        },
        FindOverlaps: function (){
            while (this._q.get_Count() > 0){
                var i = this._q.Dequeue();
                if (i < this._nodePositions.length){
                    this.FindOverlapsWithInterval(i);
                    this.AddIntervalToTree(i);
                }
                else {
                    i -= this._nodePositions.length;
                    this.RemoveIntervalFromTree(i);
                }
            }
        },
        RemoveIntervalFromTree: function (i){
            this._intervalTree.Remove(this.GetInterval(i), i);
        },
        AddIntervalToTree: function (i){
            var interval = this.GetInterval(i);
            if (this._intervalTree == null)
                this._intervalTree = new Microsoft.Msagl.Core.Geometry.IntervalRTree$1.ctor(System.Int32.ctor);
            this._intervalTree.Add$$Interval$$TData(interval, i);
        },
        FindOverlapsWithInterval: function (i){
            if (this._intervalTree == null)
                return;
            var interval = this.GetInterval(i);
            var $it41 = this._intervalTree.GetAllIntersecting(interval).GetEnumerator();
            while ($it41.MoveNext()){
                var j = $it41.get_Current();
                var tuple = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MST.OverlapRemoval.GetIdealEdgeLength$$Int32$$Int32$$Point$$Point$$Size$Array(i, j, this._nodePositions[i], this._nodePositions[j], this._nodeSizes);
                if (!(tuple.get_Item3() > 1))
                    return;
                this._proximityEdges.Add(tuple);
                this._numberOfOverlaps++;
            }
        },
        GetInterval: function (i){
            var w = this._nodeSizes[i].get_Width() / 2;
            var nodeCenterX = this._nodePositions[i].get_X();
            return new Microsoft.Msagl.Layout.LargeGraphLayout.Interval.ctor$$Double$$Double(nodeCenterX - w, nodeCenterX + w);
        },
        InitQueue: function (){
            for (var i = 0; i < this._nodeSizes.length; i++){
                var h = this._nodeSizes[i].get_Height() / 2;
                var nodeCenterY = this._nodePositions[i].get_Y();
                this._q.Enqueue(i, nodeCenterY - h);
                this._q.Enqueue(this._nodeSizes.length + i, nodeCenterY + h);
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$MST$MstLineSweeper);
var Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$OverlapRemovalSettings = {
    fullname: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.OverlapRemovalSettings",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.method = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MST.OverlapRemovalMethod.Pmst;
            this.epsilon = 0.01;
            this.iterationsMax = 1000;
            this.stopOnMaxIterat = false;
            this.nodeSeparation = 4;
            this.randomizationSeed = 1;
            this.initialScaling = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.InitialScaling.None;
            this.workInInches = false;
            this.randomizeAllPointsOnStart = false;
            this._StressSettings = null;
            System.Object.ctor.call(this);
            this.set_StressSettings(new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorizationSettings.ctor());
        },
        StressSettings$$: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorizationSettings",
        get_StressSettings: function (){
            return this._StressSettings;
        },
        set_StressSettings: function (value){
            this._StressSettings = value;
        },
        StopOnMaxIterat$$: "System.Boolean",
        get_StopOnMaxIterat: function (){
            return this.stopOnMaxIterat;
        },
        set_StopOnMaxIterat: function (value){
            this.stopOnMaxIterat = value;
        },
        Epsilon$$: "System.Double",
        get_Epsilon: function (){
            return this.epsilon;
        },
        set_Epsilon: function (value){
            this.epsilon = value;
        },
        IterationsMax$$: "System.Int32",
        get_IterationsMax: function (){
            return this.iterationsMax;
        },
        set_IterationsMax: function (value){
            this.iterationsMax = value;
        },
        NodeSeparation$$: "System.Double",
        get_NodeSeparation: function (){
            return this.nodeSeparation;
        },
        set_NodeSeparation: function (value){
            this.nodeSeparation = value;
        },
        RandomizationSeed$$: "System.Int32",
        get_RandomizationSeed: function (){
            return this.randomizationSeed;
        },
        set_RandomizationSeed: function (value){
            this.randomizationSeed = value;
        },
        RandomizeAllPointsOnStart$$: "System.Boolean",
        get_RandomizeAllPointsOnStart: function (){
            return this.randomizeAllPointsOnStart;
        },
        set_RandomizeAllPointsOnStart: function (value){
            this.randomizeAllPointsOnStart = value;
        },
        InitialScaling$$: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.InitialScaling",
        get_InitialScaling: function (){
            return this.initialScaling;
        },
        set_InitialScaling: function (value){
            this.initialScaling = value;
        },
        WorkInInches$$: "System.Boolean",
        get_WorkInInches: function (){
            return this.workInInches;
        },
        set_WorkInInches: function (value){
            this.workInInches = value;
        },
        Method$$: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MST.OverlapRemovalMethod",
        get_Method: function (){
            return this.method;
        },
        set_Method: function (value){
            this.method = value;
        },
        Clone: function (){
            var settings = new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.OverlapRemovalSettings.ctor();
            settings.set_Method(this.get_Method());
            settings.set_Epsilon(this.get_Epsilon());
            settings.set_IterationsMax(this.get_IterationsMax());
            settings.set_StopOnMaxIterat(this.get_StopOnMaxIterat());
            settings.set_NodeSeparation(this.get_NodeSeparation());
            settings.set_RandomizationSeed(this.get_RandomizationSeed());
            settings.set_RandomizeAllPointsOnStart(this.randomizeAllPointsOnStart);
            settings.set_InitialScaling(this.get_InitialScaling());
            settings.set_WorkInInches(this.get_WorkInInches());
            settings.set_StressSettings(new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorizationSettings.ctor());
            settings.get_StressSettings().set_MaxStressIterations(this.get_StressSettings().get_MaxStressIterations());
            settings.get_StressSettings().set_SolvingMethod(this.get_StressSettings().get_SolvingMethod());
            settings.get_StressSettings().set_UpdateMethod(this.get_StressSettings().get_UpdateMethod());
            settings.get_StressSettings().set_StressChangeTolerance(this.get_StressSettings().get_StressChangeTolerance());
            settings.get_StressSettings().set_CancelOnStressConvergence(this.get_StressSettings().get_CancelOnStressConvergence());
            settings.get_StressSettings().set_CancelOnStressMaxIteration(this.get_StressSettings().get_CancelOnStressMaxIteration());
            settings.get_StressSettings().set_ResidualTolerance(this.get_StressSettings().get_ResidualTolerance());
            settings.get_StressSettings().set_CancelAfterFirstConjugate(this.get_StressSettings().get_CancelAfterFirstConjugate());
            settings.get_StressSettings().set_MaxSolverIterations(this.get_StressSettings().get_MaxSolverIterations());
            settings.get_StressSettings().set_SolverMaxIteratMethod(this.get_StressSettings().get_SolverMaxIteratMethod());
            settings.get_StressSettings().set_Parallelize(this.get_StressSettings().get_Parallelize());
            settings.get_StressSettings().set_ParallelDegree(this.get_StressSettings().get_ParallelDegree());
            return settings;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$OverlapRemovalSettings);
var Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$ProximityOverlapRemoval = {
    fullname: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval._DebugMode = false;
        },
        DebugMode$$: "System.Boolean",
        get_DebugMode: function (){
            return Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval._DebugMode;
        },
        set_DebugMode: function (value){
            Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval._DebugMode = value;
        },
        InitStressWithGraph: function (majorizer, graph, nodePositions){
            majorizer.set_Positions(new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Point.ctor, nodePositions));
            majorizer.set_NodeVotings(new System.Collections.Generic.List$1.ctor$$Int32(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.NodeVoting.ctor, graph.get_Nodes().get_Count()));
            for (var i = 0; i < graph.get_Nodes().get_Count(); i++){
                var nodeVote = new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.NodeVoting.ctor$$Int32(i);
                var voteBlock = new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.VoteBlock.ctor(new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.Vote.ctor), 100);
                nodeVote.get_VotingBlocks().Add(voteBlock);
                majorizer.get_NodeVotings().Add(nodeVote);
            }
        },
        RandomizePoints: function (points, random, epsilon, randomizeAll){
            var pointSet = new System.Collections.Generic.HashSet$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            for (var i = 0; i < points.length; i++){
                var p = points[i];
                if (pointSet.Contains(p) || randomizeAll){
                    do{
                        var newX = p.get_X() + (2 * random.NextDouble() - 1) * epsilon;
                        var newY = p.get_Y() + (2 * random.NextDouble() - 1) + epsilon;
                        p = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(newX, newY);
                    }
                    while (pointSet.Contains(p))
                }
                points[i] = p;
                pointSet.Add(p);
            }
        },
        GetProximityEdgesWithDistance: function (originalGraph, cdt, targetSizes, desiredEdgeDistances){
            desiredEdgeDistances.Value = new System.Collections.Generic.List$1.ctor(System.Tuple$4.ctor);
            var numberOverlappingPairs = 0;
            var edgeSet = new System.Collections.Generic.HashSet$1.ctor(Microsoft.Msagl.Routing.CdtEdge.ctor);
            var $it42 = cdt.GetTriangles().GetEnumerator();
            while ($it42.MoveNext()){
                var triangle = $it42.get_Current();
                var $it43 = triangle.Edges.GetEnumerator();
                while ($it43.MoveNext()){
                    var triangleEdge = $it43.get_Current();
                    var site1 = triangleEdge.upperSite;
                    var site2 = triangleEdge.lowerSite;
                    var nodeId1 = site1.get_Owner();
                    var nodeId2 = site2.get_Owner();
                    if (edgeSet.Contains(triangleEdge))
                        continue;
                    edgeSet.Add(triangleEdge);
                    var point1 = site1.Point;
                    var point2 = site2.Point;
                    var t;
                    var distance = (function (){
                        var $1 = {
                            Value: t
                        };
                        var $res = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.GetIdealDistanceBetweenNodes(nodeId1, nodeId2, point1, point2, targetSizes, $1);
                        t = $1.Value;
                        return $res;
                    })();
                    if (t > 1)
                        numberOverlappingPairs++;
                    var nodeIdSmall = nodeId1;
                    var nodeIdBig = nodeId2;
                    if (nodeId1 > nodeId2){
                        nodeIdSmall = nodeId2;
                        nodeIdBig = nodeId1;
                    }
                    var tuple = new System.Tuple$4.ctor(System.Int32.ctor, System.Int32.ctor, System.Double.ctor, System.Double.ctor, nodeIdSmall, nodeIdBig, distance, t);
                    desiredEdgeDistances.Value.Add(tuple);
                }
            }
            return numberOverlappingPairs;
        },
        GetOverlapFactorBetweenNodes: function (nodeId1, nodeId2, point1, point2, nodeBoxes, tRes){
            return Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.GetIdealDistanceBetweenNodes(nodeId1, nodeId2, point1, point2, nodeBoxes, tRes);
        },
        GetIdealDistanceBetweenNodes: function (nodeId1, nodeId2, point1, point2, nodeBoxes, tRes){
            if (nodeBoxes == null)
                throw $CreateException(new System.ArgumentNullException.ctor$$String("nodeBoxes"), new Error());
            tRes.Value = -1;
            if (nodeBoxes.length <= nodeId1)
                return 0;
            if (nodeBoxes.length <= nodeId2)
                return 0;
            var expandMax = 1.5;
            var expandMin = 1;
            var machineAcc = 1E-16;
            var dist = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(point1, point2)).get_Length();
            var dx = System.Math.Abs$$Double(point1.get_X() - point2.get_X());
            var dy = System.Math.Abs$$Double(point1.get_Y() - point2.get_Y());
            var wx = (nodeBoxes[nodeId1].get_Width() / 2 + nodeBoxes[nodeId2].get_Width() / 2);
            var wy = (nodeBoxes[nodeId1].get_Height() / 2 + nodeBoxes[nodeId2].get_Height() / 2);
            var t;
            if (dx < machineAcc * wx){
                t = wy / dy;
            }
            else if (dy < machineAcc * wy){
                t = wx / dx;
            }
            else {
                t = System.Math.Min$$Double$$Double(wx / dx, wy / dy);
            }
            if (t > 1)
                t = System.Math.Max$$Double$$Double(t, 1.001);
            t = System.Math.Min$$Double$$Double(expandMax, t);
            t = System.Math.Max$$Double$$Double(expandMin, t);
            tRes.Value = t;
            return t * dist;
        },
        ShowCurrentMovementVectors: function (currentIteration, nodeSizes, nodePositions, newPositions, proximityEdgesWithDistance, finalGridVectors){
        },
        InitNodePositionsAndBoxes: function (overlapRemovalSettings, geometryGraph, nodePositions, nodeSizes){
            nodePositions.Value = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, geometryGraph.get_Nodes(), function (v){
                return v.get_Center();
            }));
            Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.RandomizePoints(nodePositions.Value, new System.Random.ctor$$Int32(overlapRemovalSettings.get_RandomizationSeed()), overlapRemovalSettings.get_Epsilon(), overlapRemovalSettings.get_RandomizeAllPointsOnStart());
            nodeSizes.Value = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.GetNodeSizesByPaddingWithHalfSeparation(geometryGraph, overlapRemovalSettings.get_NodeSeparation());
            return nodePositions.Value;
        },
        GetNodeSizesByPaddingWithHalfSeparation: function (geometryGraph, nodeSeparation){
            if (geometryGraph == null)
                return null;
            var nodeSizes = new Array(geometryGraph.get_Nodes().get_Count());
            var halfSep = nodeSeparation / 2;
            for (var i = 0; i < geometryGraph.get_Nodes().get_Count(); i++){
                nodeSizes[i] = geometryGraph.get_Nodes().get_Item$$Int32(i).get_BoundingBox().get_Size();
                nodeSizes[i].Pad(halfSep);
            }
            return nodeSizes;
        },
        AddStressFromProximityEdges: function (stressSolver, proximityEdgesWithDistance){
            var nodePairs = new System.Collections.Generic.HashSet$1.ctor(System.Tuple$2.ctor);
            var $it46 = proximityEdgesWithDistance.GetEnumerator();
            while ($it46.MoveNext()){
                var tuple = $it46.get_Current();
                var nodeId1 = tuple.get_Item1();
                var nodeId2 = tuple.get_Item2();
                if (nodeId1 > nodeId2){
                    nodeId1 = tuple.get_Item2();
                    nodeId2 = tuple.get_Item1();
                }
                var tup = new System.Tuple$2.ctor(System.Int32.ctor, System.Int32.ctor, nodeId1, nodeId2);
                if (nodePairs.Contains(tup))
                    continue;
                nodePairs.Add(tup);
                var distance = tuple.get_Item3();
                var weight = 1 / (distance * distance);
                var voteFromNode1 = new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.Vote.ctor$$Int32$$Double$$Double(nodeId1, distance, weight);
                var voteFromNode2 = new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.Vote.ctor$$Int32$$Double$$Double(nodeId2, distance, weight);
                if (tuple.get_Item4() <= 1){
                    stressSolver.get_NodeVotings().get_Item$$Int32(nodeId2).get_VotingBlocks().get_Item$$Int32(0).get_Votings().Add(voteFromNode1);
                    stressSolver.get_NodeVotings().get_Item$$Int32(nodeId1).get_VotingBlocks().get_Item$$Int32(0).get_Votings().Add(voteFromNode2);
                }
                else {
                    stressSolver.get_NodeVotings().get_Item$$Int32(nodeId2).get_VotingBlocks().get_Item$$Int32(1).get_Votings().Add(voteFromNode1);
                    stressSolver.get_NodeVotings().get_Item$$Int32(nodeId1).get_VotingBlocks().get_Item$$Int32(1).get_Votings().Add(voteFromNode2);
                }
            }
        },
        RemoveOverlaps: function (geometryGraph, nodeSeparation){
            var prism = (function (){
                var $v8 = new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.ctor$$GeometryGraph(geometryGraph);
                $v8.get_Settings().set_NodeSeparation(nodeSeparation);
                return $v8;
            })();
            prism.RemoveOverlap();
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.IOverlapRemoval"],
    Kind: "Class",
    definition: {
        ctor$$OverlapRemovalSettings: function (settings){
            this.trajectories = null;
            this.crossingsOverTime = new System.Collections.Generic.List$1.ctor(System.Int32.ctor);
            this.settings = null;
            this.lastCpuTime = new System.TimeSpan.ctor();
            this.nodeSizes = null;
            this.nodePositions = null;
            this.stressSolver = null;
            this.graph = null;
            this._LastRunIterations = 0;
            System.Object.ctor.call(this);
            this.set_Settings(settings);
        },
        Settings$$: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.OverlapRemovalSettings",
        get_Settings: function (){
            return this.settings;
        },
        set_Settings: function (value){
            this.settings = value;
            if (this.get_StressSolver() != null && value != null)
                this.get_StressSolver().set_Settings(value.get_StressSettings());
        },
        LastRunIterations$$: "System.Int32",
        get_LastRunIterations: function (){
            return this._LastRunIterations;
        },
        set_LastRunIterations: function (value){
            this._LastRunIterations = value;
        },
        NodePositions$$: "Microsoft.Msagl.Core.Geometry.Point[]",
        get_NodePositions: function (){
            return this.nodePositions;
        },
        NodeSizes$$: "Microsoft.Msagl.Core.DataStructures.Size[]",
        get_NodeSizes: function (){
            return this.nodeSizes;
        },
        StressSolver$$: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorization",
        get_StressSolver: function (){
            return this.stressSolver;
        },
        set_StressSolver: function (value){
            this.stressSolver = value;
            if (this.get_Settings() != null && this.stressSolver != null)
                this.stressSolver.set_Settings(this.get_Settings().get_StressSettings());
        },
        Graph$$: "Microsoft.Msagl.Core.Layout.GeometryGraph",
        get_Graph: function (){
            return this.graph;
        },
        set_Graph: function (value){
            this.graph = value;
            this.InitWithGraph();
        },
        InitializeSettings: function (){
            this.set_Settings(new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.OverlapRemovalSettings.ctor());
        },
        ctor: function (){
            this.trajectories = null;
            this.crossingsOverTime = new System.Collections.Generic.List$1.ctor(System.Int32.ctor);
            this.settings = null;
            this.lastCpuTime = new System.TimeSpan.ctor();
            this.nodeSizes = null;
            this.nodePositions = null;
            this.stressSolver = null;
            this.graph = null;
            this._LastRunIterations = 0;
            System.Object.ctor.call(this);
            this.InitializeSettings();
        },
        ctor$$GeometryGraph: function (graph){
            this.trajectories = null;
            this.crossingsOverTime = new System.Collections.Generic.List$1.ctor(System.Int32.ctor);
            this.settings = null;
            this.lastCpuTime = new System.TimeSpan.ctor();
            this.nodeSizes = null;
            this.nodePositions = null;
            this.stressSolver = null;
            this.graph = null;
            this._LastRunIterations = 0;
            System.Object.ctor.call(this);
            this.set_Graph(graph);
            this.InitializeSettings();
        },
        InitWithGraph: function (){
            if (this.get_StressSolver() != null){
            }
            if (this.get_Graph() == null || this.get_Graph().get_Nodes().get_Count() == 0)
                return;
            if (this.get_StressSolver() == null){
                this.set_StressSolver(new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorization.ctor());
                if (this.get_Settings() != null)
                    this.get_StressSolver().set_Settings(this.get_Settings().get_StressSettings());
            }
        },
        RemoveOverlap: function (){
            if (this.get_Graph() == null || this.get_Graph().get_Nodes().get_Count() == 0)
                return new System.TimeSpan.ctor();
            (function (){
                var $1 = {
                    Value: this.nodePositions
                };
                var $2 = {
                    Value: this.nodeSizes
                };
                var $res = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.InitNodePositionsAndBoxes(this.get_Settings(), this.get_Graph(), $1, $2);
                this.nodePositions = $1.Value;
                this.nodeSizes = $2.Value;
                return $res;
            }).call(this);
            if (!(this.get_Settings().get_InitialScaling() == Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.InitialScaling.None))
                this.DoInitialScaling();
            Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.InitStressWithGraph(this.get_StressSolver(), this.get_Graph(), this.nodePositions);
            this.trajectories = new System.Collections.Generic.List$1.ctor$$Int32(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, this.get_Graph().get_Nodes().get_Count());
            for (var i = 0; i < this.nodePositions.length; i++){
                var poly = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
                poly.AddPoint$$Point(this.nodePositions[i]);
                this.trajectories.Add(poly);
            }
            var scanlinePhase = false;
            var iter = 0;
            var finished = false;
            while (!finished && ((iter++) < this.get_Settings().get_IterationsMax() || !this.get_Settings().get_StopOnMaxIterat())){
                finished = (function (){
                    var $1 = {
                        Value: scanlinePhase
                    };
                    var $res = this.DoSingleIteration(iter, $1);
                    scanlinePhase = $1.Value;
                    return $res;
                }).call(this);
            }
            this.set_LastRunIterations(iter);
            this.SetPositionsToGraph();
            var nodeBoxArea = System.Linq.Enumerable.Sum$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.DataStructures.Size.ctor, this.nodeSizes, $CreateAnonymousDelegate(this, function (r){
                return r.get_Width() * r.get_Height();
            }));
            var boundingBox = this.GetCommonRectangle(this.nodeSizes, this.nodePositions);
            var boundingBoxArea = boundingBox.get_Width() * boundingBox.get_Height();
            System.Console.WriteLine$$String$$Object("Needed maxIterat: {0}", iter);
            System.Console.WriteLine$$String$$Object("BBox Area Ratio: {0}", boundingBoxArea / nodeBoxArea);
            return new System.TimeSpan.ctor$$Int64(0);
        },
        GetCommonRectangle: function (sizes, points){
            var rect = Microsoft.Msagl.Core.Geometry.Rectangle.CreateAnEmptyBox();
            System.Diagnostics.Debug.Assert$$Boolean(sizes.length == points.length);
            for (var i = 0; i < sizes.length; i++)
                rect.Add$$Size$$Point(sizes[i], points[i]);
            return rect;
        },
        DoSingleIteration: function (currentIteration, scanlinePhase){
            var sites = System.Linq.Enumerable.ToList$1(System.Tuple$2.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$3(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Tuple$2.ctor, this.nodePositions, $CreateAnonymousDelegate(this, function (p, index){
                return new System.Tuple$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Object.ctor, p, index);
            })));
            var triangulation = new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.ctor$$IEnumerable$1(sites);
            triangulation.Run();
            var proximityEdgesWithDistance;
            var numCrossings = (function (){
                var $1 = {
                    Value: proximityEdgesWithDistance
                };
                var $res = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.GetProximityEdgesWithDistance(this.get_Graph(), triangulation, this.nodeSizes, $1);
                proximityEdgesWithDistance = $1.Value;
                return $res;
            }).call(this);
            if (scanlinePhase.Value || numCrossings == 0){
                scanlinePhase.Value = true;
                numCrossings = (function (){
                    var $1 = {
                        Value: numCrossings
                    };
                    var $res = this.CompleteProximityGraphWithRTree($1, proximityEdgesWithDistance);
                    numCrossings = $1.Value;
                    return $res;
                }).call(this);
            }
            var realCrossings = this.CountCrossingsWithRTree(this.nodeSizes);
            this.crossingsOverTime.Add(realCrossings);
            if (currentIteration % 10 == 0)
                System.Console.WriteLine$$String$$Object$$Object("Scanline: {0}, Crossings: {1}", scanlinePhase.Value, numCrossings);
            if (numCrossings == 0)
                return true;
            Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.AddStressFromProximityEdges(this.get_StressSolver(), proximityEdgesWithDistance);
            var newPositions = this.get_StressSolver().IterateAll();
            Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.ShowCurrentMovementVectors(currentIteration, this.nodeSizes, this.nodePositions, newPositions, proximityEdgesWithDistance, null);
            this.UpdatePointsAndBoxes(newPositions);
            this.get_StressSolver().ClearVotings();
            for (var i = 0; i < this.nodePositions.length; i++){
                this.trajectories.get_Item$$Int32(i).AddPoint$$Point(newPositions.get_Item$$Int32(i));
            }
            return false;
        },
        UpdatePointsAndBoxes: function (newPositions){
            for (var i = 0; i < this.nodePositions.length; i++)
                this.nodePositions[i] = newPositions.get_Item$$Int32(i);
        },
        SetPositionsToGraph: function (){
            for (var i = 0; i < this.get_Graph().get_Nodes().get_Count(); i++){
                if (this.get_Settings().get_WorkInInches())
                    this.get_Graph().get_Nodes().get_Item$$Int32(i).set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(this.nodePositions[i], 72));
                else
                    this.get_Graph().get_Nodes().get_Item$$Int32(i).set_Center(this.nodePositions[i]);
            }
        },
        ShowTrajectoriesOfNodes: function (trajectories){
        },
        CompleteProximityGraphWithRTree: function (currentCrossings, proximityEdgesWithDistance){
            var newCrossings = this.CreateProximityEdgesWithRTree(proximityEdgesWithDistance);
            return currentCrossings.Value + newCrossings;
        },
        DoInitialScaling: function (){
            if (this.get_Graph().get_Edges().get_Count() == 0)
                return;
            var avgEdgeLength = this.AvgEdgeLength();
            var goalLength;
            if (this.get_Settings().get_InitialScaling() == Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.InitialScaling.Inch72Pixel)
                goalLength = 72;
            else if (this.get_Settings().get_InitialScaling() == Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.InitialScaling.AvgNodeSize)
                goalLength = System.Linq.Enumerable.Average$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.DataStructures.Size.ctor, this.nodeSizes, $CreateAnonymousDelegate(this, function (box){
                    return (box.get_Width() + box.get_Height()) / 2;
                }));
            else
                return;
            var scaling = goalLength / avgEdgeLength;
            System.Console.WriteLine$$String$$Object$$Object("AvgEdgeLength Scaling Method: {0}, ScaleFactor={1:F2}", this.get_Settings().get_InitialScaling(), scaling);
            for (var j = 0; j < this.nodePositions.length; j++){
                this.nodePositions[j] = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(this.nodePositions[j], scaling);
            }
            if (this.get_Settings().get_WorkInInches()){
                for (var i = 0; i < this.nodePositions.length; i++){
                    this.nodePositions[i] = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(this.nodePositions[i], 72);
                    this.nodeSizes[i] = Microsoft.Msagl.Core.DataStructures.Size.op_Division(this.nodeSizes[i], 72);
                }
            }
        },
        AvgEdgeLength: function (){
            var i = 0;
            var avgEdgeLength = 0;
            var $it44 = this.get_Graph().get_Edges().GetEnumerator();
            while ($it44.MoveNext()){
                var edge = $it44.get_Current();
                var sPoint = edge.get_Source().get_Center();
                var tPoint = edge.get_Target().get_Center();
                var euclid = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(sPoint, tPoint)).get_Length();
                avgEdgeLength += euclid;
                i++;
            }
            avgEdgeLength /= i;
            return avgEdgeLength;
        },
        CreateProximityEdgesWithRTree: function (proximityEdges){
            var edgeSet = new System.Collections.Generic.HashSet$1.ctor(System.Tuple$2.ctor);
            var $it45 = proximityEdges.GetEnumerator();
            while ($it45.MoveNext()){
                var proximityEdge = $it45.get_Current();
                edgeSet.Add(System.Tuple.Create$2$$T1$$T2(System.Int32.ctor, System.Int32.ctor, proximityEdge.get_Item1(), proximityEdge.get_Item2()));
            }
            var rootNode = Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnEnumeration(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$3(Microsoft.Msagl.Core.DataStructures.Size.ctor, Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, this.nodeSizes, $CreateAnonymousDelegate(this, function (size, index){
                return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(System.Int32.ctor, index, new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Size$$Point(size, this.nodePositions[index]));
            })));
            var numCrossings = 0;
            Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$2$$RectangleNode$1$$RectangleNode$1$$Action$2(System.Int32.ctor, System.Int32.ctor, rootNode, rootNode, $CreateAnonymousDelegate(this, function (a, b){
                if (a == b)
                    return;
                var t;
                var dist = (function (){
                    var $1 = {
                        Value: t
                    };
                    var $res = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.GetOverlapFactorBetweenNodes(a, b, this.nodePositions[a], this.nodePositions[b], this.nodeSizes, $1);
                    t = $1.Value;
                    return $res;
                }).call(this);
                var smallId = a;
                var bigId = b;
                if (smallId > bigId){
                    smallId = b;
                    bigId = a;
                }
                if (!(t > 1) || edgeSet.Contains(new System.Tuple$2.ctor(System.Int32.ctor, System.Int32.ctor, smallId, bigId)))
                    return;
                proximityEdges.Add(System.Tuple.Create$4$$T1$$T2$$T3$$T4(System.Int32.ctor, System.Int32.ctor, System.Double.ctor, System.Double.ctor, smallId, bigId, dist, t));
                edgeSet.Add(new System.Tuple$2.ctor(System.Int32.ctor, System.Int32.ctor, smallId, bigId));
                numCrossings++;
            }));
            return numCrossings;
        },
        CountCrossingsWithRTree: function (nodeSizes){
            var rootNode = Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnEnumeration(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$3(Microsoft.Msagl.Core.DataStructures.Size.ctor, Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, nodeSizes, $CreateAnonymousDelegate(this, function (r, index){
                return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(System.Int32.ctor, index, new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Size$$Point(r, this.nodePositions[index]));
            })));
            var numCrossings = 0;
            Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$2$$RectangleNode$1$$RectangleNode$1$$Action$2(System.Int32.ctor, System.Int32.ctor, rootNode, rootNode, $CreateAnonymousDelegate(this, function (a, b){
                if (a == b)
                    return;
                numCrossings++;
            }));
            return numCrossings;
        },
        RemoveOverlap$$GeometryGraph: function (graph){
            this.set_Graph(graph);
            this.RemoveOverlap();
        },
        GetLastRunIterations: function (){
            return this.get_LastRunIterations();
        },
        GetLastRunCpuTime: function (){
            return this.lastCpuTime;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$ProximityOverlapRemoval);
var Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$MST$MstOnDelaunayTriangulation = {
    fullname: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MST.MstOnDelaunayTriangulation",
    baseTypeName: "System.Object",
    staticDefinition: {
        GetMstOnTuple: function (proximityEdges, sizeId){
            if (proximityEdges.get_Count() == 0){
                return null;
            }
            var intPairs = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.Tuple$5.ctor, Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, proximityEdges, function (t){
                return new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(t.get_Item1(), t.get_Item2());
            }));
            var weighting = new System.Collections.Generic.Dictionary$2.ctor$$Int32(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, System.Tuple$5.ctor, System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, intPairs));
            for (var i = 0; i < proximityEdges.get_Count(); i++){
                weighting.set_Item$$TKey(intPairs[i], proximityEdges.get_Item$$Int32(i));
            }
            var graph = new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor$$IEnumerable$1$$Int32(Microsoft.Msagl.Core.GraphAlgorithms.IEdge.ctor, intPairs, sizeId);
            var mstOnBasicGraph = new Microsoft.Msagl.Core.GraphAlgorithms.MinimumSpanningTreeByPrim.ctor(graph, function (intPair){
                return weighting.get_Item$$TKey(Cast(intPair, Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor)).get_Item5();
            }, intPairs[0].get_First());
            var treeEdges = System.Linq.Enumerable.ToList$1(System.Tuple$5.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.GraphAlgorithms.IEdge.ctor, System.Tuple$5.ctor, mstOnBasicGraph.GetTreeEdges(), function (e){
                return weighting.get_Item$$TKey(Cast(e, Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor));
            }));
            return treeEdges;
        },
        GetMstOnCdt: function (cdt, weights){
            var siteArray = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Routing.CdtSite.ctor, cdt.PointsToSites.get_Values());
            var siteIndex = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.CdtSite.ctor, System.Int32.ctor);
            for (var i = 0; i < siteArray.length; i++)
                siteIndex.set_Item$$TKey(siteArray[i], i);
            var intPairsToCdtEdges = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MST.MstOnDelaunayTriangulation.GetEdges(siteArray, siteIndex);
            var graph = new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor$$IEnumerable$1$$Int32(Microsoft.Msagl.Core.GraphAlgorithms.IEdge.ctor, intPairsToCdtEdges.get_Keys(), siteArray.length);
            var mstOnBasicGraph = new Microsoft.Msagl.Core.GraphAlgorithms.MinimumSpanningTreeByPrim.ctor(graph, function (intPair){
                return weights(intPairsToCdtEdges.get_Item$$TKey(Cast(intPair, Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor)));
            }, 0);
            return new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Microsoft.Msagl.Routing.CdtEdge.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.GraphAlgorithms.IEdge.ctor, Microsoft.Msagl.Routing.CdtEdge.ctor, mstOnBasicGraph.GetTreeEdges(), function (e){
                return intPairsToCdtEdges.get_Item$$TKey(Cast(e, Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor));
            }));
        },
        GetEdges: function (siteArray, siteIndex){
            var d = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, Microsoft.Msagl.Routing.CdtEdge.ctor);
            for (var i = 0; i < siteArray.length; i++){
                var site = siteArray[i];
                var sourceIndex = siteIndex.get_Item$$TKey(site);
                var $it47 = site.Edges.GetEnumerator();
                while ($it47.MoveNext()){
                    var e = $it47.get_Current();
                    d.set_Item$$TKey(new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(sourceIndex, siteIndex.get_Item$$TKey(e.lowerSite)), e);
                }
            }
            return d;
        },
        Test: function (){
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$MST$MstOnDelaunayTriangulation);
var Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$StressEnergy$ExampleStressMajorization = {
    fullname: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.ExampleStressMajorization",
    baseTypeName: "System.Object",
    staticDefinition: {
        RunStressMajorizationExample: function (){
            var graph = new Microsoft.Msagl.Core.Layout.GeometryGraph.ctor();
            graph.get_Nodes().Add(new Microsoft.Msagl.Core.Layout.Node.ctor());
            graph.get_Nodes().Add(new Microsoft.Msagl.Core.Layout.Node.ctor());
            graph.get_Nodes().Add(new Microsoft.Msagl.Core.Layout.Node.ctor());
            graph.get_Nodes().Add(new Microsoft.Msagl.Core.Layout.Node.ctor());
            graph.get_Nodes().get_Item$$Int32(0).set_BoundaryCurve(Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateRectangle$$Double$$Double$$Point(20, 10, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(5, 5)));
            graph.get_Nodes().get_Item$$Int32(1).set_BoundaryCurve(Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateRectangle$$Double$$Double$$Point(20, 10, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(7, 10)));
            graph.get_Nodes().get_Item$$Int32(2).set_BoundaryCurve(Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateRectangle$$Double$$Double$$Point(20, 10, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(7, 2)));
            graph.get_Nodes().get_Item$$Int32(3).set_BoundaryCurve(Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateRectangle$$Double$$Double$$Point(20, 10, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(35, 1)));
            graph.get_Edges().Add(new Microsoft.Msagl.Core.Layout.Edge.ctor$$Node$$Node(graph.get_Nodes().get_Item$$Int32(0), graph.get_Nodes().get_Item$$Int32(1)));
            graph.get_Edges().Add(new Microsoft.Msagl.Core.Layout.Edge.ctor$$Node$$Node(graph.get_Nodes().get_Item$$Int32(0), graph.get_Nodes().get_Item$$Int32(2)));
            graph.get_Edges().Add(new Microsoft.Msagl.Core.Layout.Edge.ctor$$Node$$Node(graph.get_Nodes().get_Item$$Int32(0), graph.get_Nodes().get_Item$$Int32(3)));
            var idealEdgeLength = new Float64Array(graph.get_Edges().get_Count());
            for (var i = 0; i < graph.get_Edges().get_Count(); i++){
                idealEdgeLength[i] = 100;
            }
            var majorizer = new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorization.ctor();
            majorizer.set_Positions(new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, graph.get_Nodes(), function (v){
                return v.get_Center();
            })));
            majorizer.set_NodeVotings(new System.Collections.Generic.List$1.ctor$$Int32(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.NodeVoting.ctor, graph.get_Nodes().get_Count()));
            for (var i = 0; i < graph.get_Nodes().get_Count(); i++){
                var nodeVote = new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.NodeVoting.ctor$$Int32(i);
                majorizer.get_NodeVotings().Add(nodeVote);
            }
            var posDict = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, System.Int32.ctor);
            for (var i = 0; i < graph.get_Nodes().get_Count(); i++){
                posDict.set_Item$$TKey(graph.get_Nodes().get_Item$$Int32(i), i);
            }
            var edges = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Layout.Edge.ctor, graph.get_Edges());
            for (var i = 0; i < graph.get_Edges().get_Count(); i++){
                var edge = edges[i];
                var nodeId1 = posDict.get_Item$$TKey(edge.get_Source());
                var nodeId2 = posDict.get_Item$$TKey(edge.get_Target());
                var idealDistance = idealEdgeLength[i];
                var weight = 1 / (idealDistance * idealDistance);
                var voteFromNode1 = new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.Vote.ctor$$Int32$$Double$$Double(nodeId1, idealDistance, weight);
                var voteFromNode2 = new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.Vote.ctor$$Int32$$Double$$Double(nodeId2, idealDistance, weight);
                majorizer.get_NodeVotings().get_Item$$Int32(nodeId2).get_VotingBlocks().get_Item$$Int32(0).get_Votings().Add(voteFromNode1);
                majorizer.get_NodeVotings().get_Item$$Int32(nodeId1).get_VotingBlocks().get_Item$$Int32(0).get_Votings().Add(voteFromNode2);
            }
            majorizer.set_Settings(new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorizationSettings.ctor());
            majorizer.get_Settings().set_SolvingMethod(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.SolvingMethod.Localized);
            var result = majorizer.IterateAll();
            for (var i = 0; i < result.get_Count(); i++){
                graph.get_Nodes().get_Item$$Int32(i).set_Center(result.get_Item$$Int32(i));
            }
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$StressEnergy$ExampleStressMajorization);
var Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$StressEnergy$MaxIterationMethod = {
    fullname: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.MaxIterationMethod",
    staticDefinition: {
        FixedMax: 0,
        SqrtProblemSize: 1,
        LinearProblemSize: 2
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$StressEnergy$MaxIterationMethod);
var Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$StressEnergy$NodeVoting = {
    fullname: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.NodeVoting",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$Int32: function (votedNodeIndex){
            this.VotedNodeIndex = 0;
            this._VotingBlocks = null;
            System.Object.ctor.call(this);
            this.VotedNodeIndex = votedNodeIndex;
            this.set_VotingBlocks(new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.VoteBlock.ctor));
            var voteBlock = new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.VoteBlock.ctor(new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.Vote.ctor), 1);
            this.get_VotingBlocks().Add(voteBlock);
        },
        VotingBlocks$$: "System.Collections.Generic.List`1[[Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.VoteBlock]]",
        get_VotingBlocks: function (){
            return this._VotingBlocks;
        },
        set_VotingBlocks: function (value){
            this._VotingBlocks = value;
        },
        ctor$$Int32$$List$1$VoteBlock: function (votedNodeIndex, votingBlocks){
            this.VotedNodeIndex = 0;
            this._VotingBlocks = null;
            System.Object.ctor.call(this);
            this.VotedNodeIndex = votedNodeIndex;
            this.set_VotingBlocks(votingBlocks);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$StressEnergy$NodeVoting);
var Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$StressEnergy$StressMajorizationSettings = {
    fullname: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorizationSettings",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.maxStressIterations = 31;
            this.solvingMethod = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.SolvingMethod.PrecondConjugateGradient;
            this.updateMethod = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.UpdateMethod.Parallel;
            this.stressChangeTolerance = 0.01;
            this.cancelOnStressConvergence = true;
            this.cancelOnStressMaxIteration = true;
            this.maxSolverIterations = 100;
            this.solverMaxIteratMethod = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.MaxIterationMethod.SqrtProblemSize;
            this.residualTolerance = 0.01;
            this.cancelAfterFirstConjugate = true;
            this.parallelDegree = 4;
            this.parallelize = false;
            System.Object.ctor.call(this);
        },
        UpdateMethod$$: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.UpdateMethod",
        get_UpdateMethod: function (){
            return this.updateMethod;
        },
        set_UpdateMethod: function (value){
            this.updateMethod = value;
        },
        SolvingMethod$$: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.SolvingMethod",
        get_SolvingMethod: function (){
            return this.solvingMethod;
        },
        set_SolvingMethod: function (value){
            this.solvingMethod = value;
        },
        MaxStressIterations$$: "System.Int32",
        get_MaxStressIterations: function (){
            return this.maxStressIterations;
        },
        set_MaxStressIterations: function (value){
            this.maxStressIterations = value;
        },
        StressChangeTolerance$$: "System.Double",
        get_StressChangeTolerance: function (){
            return this.stressChangeTolerance;
        },
        set_StressChangeTolerance: function (value){
            this.stressChangeTolerance = value;
        },
        CancelOnStressConvergence$$: "System.Boolean",
        get_CancelOnStressConvergence: function (){
            return this.cancelOnStressConvergence;
        },
        set_CancelOnStressConvergence: function (value){
            this.cancelOnStressConvergence = value;
        },
        CancelOnStressMaxIteration$$: "System.Boolean",
        get_CancelOnStressMaxIteration: function (){
            return this.cancelOnStressMaxIteration;
        },
        set_CancelOnStressMaxIteration: function (value){
            this.cancelOnStressMaxIteration = value;
        },
        ResidualTolerance$$: "System.Double",
        get_ResidualTolerance: function (){
            return this.residualTolerance;
        },
        set_ResidualTolerance: function (value){
            this.residualTolerance = value;
        },
        CancelAfterFirstConjugate$$: "System.Boolean",
        get_CancelAfterFirstConjugate: function (){
            return this.cancelAfterFirstConjugate;
        },
        set_CancelAfterFirstConjugate: function (value){
            this.cancelAfterFirstConjugate = value;
        },
        SolverMaxIteratMethod$$: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.MaxIterationMethod",
        get_SolverMaxIteratMethod: function (){
            return this.solverMaxIteratMethod;
        },
        set_SolverMaxIteratMethod: function (value){
            this.solverMaxIteratMethod = value;
        },
        MaxSolverIterations$$: "System.Int32",
        get_MaxSolverIterations: function (){
            return this.maxSolverIterations;
        },
        set_MaxSolverIterations: function (value){
            this.maxSolverIterations = value;
        },
        Parallelize$$: "System.Boolean",
        get_Parallelize: function (){
            return this.parallelize;
        },
        set_Parallelize: function (value){
            this.parallelize = value;
        },
        ParallelDegree$$: "System.Int32",
        get_ParallelDegree: function (){
            return this.parallelDegree;
        },
        set_ParallelDegree: function (value){
            this.parallelDegree = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$StressEnergy$StressMajorizationSettings);
var Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$StressEnergy$SolvingMethod = {
    fullname: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.SolvingMethod",
    staticDefinition: {
        Localized: 0,
        PrecondConjugateGradient: 1,
        ConjugateGradient: 2
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$StressEnergy$SolvingMethod);
var Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$StressEnergy$StressMajorization = {
    fullname: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorization",
    baseTypeName: "System.Object",
    staticDefinition: {
        TestMajorizationSmall: function (){
            var positions = new System.Collections.Generic.List$1.ctor$$Int32(Microsoft.Msagl.Core.Geometry.Point.ctor, 4);
            positions.Add(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, 0));
            positions.Add(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-2, -1));
            positions.Add(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(1, 2));
            var nodeVotings = new System.Collections.Generic.List$1.ctor$$Int32(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.NodeVoting.ctor, 8);
            var votesNode1 = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.Vote.ctor);
            var votesNodeLeft = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.Vote.ctor);
            var votesNodeRight = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.Vote.ctor);
            votesNodeLeft.Add(new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.Vote.ctor$$Int32$$Double$$Double(0, 10, 1 / System.Math.Pow(10, 2)));
            votesNodeRight.Add(new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.Vote.ctor$$Int32$$Double$$Double(0, 10, 1 / System.Math.Pow(10, 2)));
            votesNode1.Add(new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.Vote.ctor$$Int32$$Double$$Double(1, 10, 1 / System.Math.Pow(10, 2)));
            votesNode1.Add(new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.Vote.ctor$$Int32$$Double$$Double(2, 10, 1 / System.Math.Pow(10, 2)));
            var blockNode1 = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.VoteBlock.ctor);
            blockNode1.Add(new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.VoteBlock.ctor(votesNode1, 1));
            var blockNodeLeft = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.VoteBlock.ctor);
            blockNodeLeft.Add(new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.VoteBlock.ctor(votesNodeLeft, 1));
            var blockNodeRight = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.VoteBlock.ctor);
            blockNodeRight.Add(new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.VoteBlock.ctor(votesNodeRight, 1));
            nodeVotings.Add(new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.NodeVoting.ctor$$Int32$$List$1$VoteBlock(0, blockNode1));
            nodeVotings.Add(new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.NodeVoting.ctor$$Int32$$List$1$VoteBlock(1, blockNodeLeft));
            nodeVotings.Add(new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.NodeVoting.ctor$$Int32$$List$1$VoteBlock(2, blockNodeRight));
            var majorization = new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorization.ctor();
            majorization.set_Positions(positions);
            majorization.set_NodeVotings(nodeVotings);
            for (var i = 0; i < 20; i++){
                var result = majorization.IterateSingleLocalizedMethod();
                var $it52 = result.GetEnumerator();
                while ($it52.MoveNext()){
                    var point = $it52.get_Current();
                    System.Console.WriteLine$$String$$Object("ResultPoint: {0}", point.toString());
                }
                System.Console.WriteLine$$String$$Object("Distance To Left: {0}", (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(result.get_Item$$Int32(0), result.get_Item$$Int32(1))).get_Length());
                System.Console.WriteLine$$String$$Object("Distance To Right: {0}", (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(result.get_Item$$Int32(0), result.get_Item$$Int32(2))).get_Length());
                System.Console.WriteLine$$String("----------------------------------------");
            }
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this._Settings = null;
            this._NodeVotings = null;
            this._Positions = null;
            System.Object.ctor.call(this);
        },
        Settings$$: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorizationSettings",
        get_Settings: function (){
            return this._Settings;
        },
        set_Settings: function (value){
            this._Settings = value;
        },
        NodeVotings$$: "System.Collections.Generic.List`1[[Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.NodeVoting]]",
        get_NodeVotings: function (){
            return this._NodeVotings;
        },
        set_NodeVotings: function (value){
            this._NodeVotings = value;
        },
        Positions$$: "System.Collections.Generic.List`1[[Microsoft.Msagl.Core.Geometry.Point]]",
        get_Positions: function (){
            return this._Positions;
        },
        set_Positions: function (value){
            this._Positions = value;
        },
        IterateSingleLocalizedMethod: function (){
            var newPositions;
            if (this.get_Settings().get_UpdateMethod() == Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.UpdateMethod.Serial)
                newPositions = this.get_Positions();
            else
                newPositions = new System.Collections.Generic.List$1.ctor$$Int32(Microsoft.Msagl.Core.Geometry.Point.ctor, this.get_Positions().get_Count());
            for (var i = 0; i < this.get_NodeVotings().get_Count(); i++){
                var nodeVoting = this.get_NodeVotings().get_Item$$Int32(i);
                var votedIndex = nodeVoting.VotedNodeIndex;
                var newPos = this.LocalizedOptimization(nodeVoting);
                if (this.get_Settings().get_UpdateMethod() == Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.UpdateMethod.Serial){
                    newPositions.set_Item$$Int32(votedIndex, newPos);
                }
                else
                    newPositions.Add(newPos);
            }
            if (this.get_Settings().get_UpdateMethod() == Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.UpdateMethod.Parallel){
                for (var i = 0; i < this.get_NodeVotings().get_Count(); i++){
                    var nodeVoting = this.get_NodeVotings().get_Item$$Int32(i);
                    var index = nodeVoting.VotedNodeIndex;
                    this.get_Positions().set_Item$$Int32(index, newPositions.get_Item$$Int32(i));
                }
            }
            return newPositions;
        },
        IterateAll: function (){
            this.initMaxIterationsSolver();
            var i = 0;
            var res = null;
            var stressOld = this.StressValue(this.get_Positions());
            while ((!this.get_Settings().get_CancelOnStressMaxIteration() || (i++) < this.get_Settings().get_MaxStressIterations())){
                if (this.get_Settings().get_SolvingMethod() == Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.SolvingMethod.Localized)
                    res = this.IterateSingleLocalizedMethod();
                else {
                    res = this.IterateSingleConjugateGradient();
                    if (this.get_Settings().get_CancelAfterFirstConjugate())
                        break;
                }
                var stressNew = this.StressValue(res);
                var stressChange = (stressOld > 0) ? (stressOld - stressNew) / stressOld : 0;
                stressChange = System.Math.Sqrt(stressChange) / this.get_Positions().get_Count();
                if (stressChange < this.get_Settings().get_StressChangeTolerance())
                    break;
            }
            return res;
        },
        initMaxIterationsSolver: function (){
            if (this.get_Positions() == null)
                return;
            var problemSize = this.get_Positions().get_Count();
            var maxIterat = this.get_Settings().get_MaxSolverIterations();
            switch (this.get_Settings().get_SolverMaxIteratMethod()){
                case Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.MaxIterationMethod.FixedMax:
                    return;
                case Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.MaxIterationMethod.SqrtProblemSize:
                    maxIterat = ((System.Math.Ceiling$$Double(System.Math.Sqrt(problemSize)))) | 0;
                    break;
                case Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.MaxIterationMethod.LinearProblemSize:
                    maxIterat = problemSize;
                    break;
                default:
                    return;
            }
            this.get_Settings().set_MaxSolverIterations(maxIterat);
        },
        IterateSingleConjugateGradient: function (){
            var Lw;
            var Lx;
            (function (){
                var $1 = {
                    Value: Lw
                };
                var $2 = {
                    Value: Lx
                };
                var $res = this.ConstructLinearSystemFromMajorization($1, $2);
                Lw = $1.Value;
                Lx = $2.Value;
                return $res;
            }).call(this);
            var zX = System.Linq.Enumerable.ToArray$1(System.Double.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Double.ctor, this.get_Positions(), $CreateAnonymousDelegate(this, function (p){
                return p.get_X();
            })));
            var zY = System.Linq.Enumerable.ToArray$1(System.Double.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Double.ctor, this.get_Positions(), $CreateAnonymousDelegate(this, function (p){
                return p.get_Y();
            })));
            var bX = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix.op_Multiply$$SparseMatrix$$Double$Array(Lx, zX);
            var bY = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix.op_Multiply$$SparseMatrix$$Double$Array(Lx, zY);
            var resX = null,resY = null;
            var invokers = (function (){
                var $v9 = new System.Collections.Generic.Dictionary$2.ctor(System.Boolean.ctor, System.Action$1.ctor);
                $v9.Add(true, System.Threading.Tasks.Parallel.Invoke$$Action$Array);
                $v9.Add(false, $CreateAnonymousDelegate(this, function (actions){
                    System.Array.ForEach(actions, $CreateAnonymousDelegate(this, function (a){
                        a();
                    }));
                }));
                return $v9;
            }).call(this);
            var solvers = (function (){
                var $v10 = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.SolvingMethod.ctor, System.Func$6.ctor);
                $v10.Add(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.SolvingMethod.ConjugateGradient, Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.LinearSystemSolver.SolveConjugateGradient$$SparseMatrix$$Double$Array$$Double$Array$$Int32$$Double);
                $v10.Add(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.SolvingMethod.PrecondConjugateGradient, Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.LinearSystemSolver.SolvePrecondConjugateGradient$$SparseMatrix$$Double$Array$$Double$Array$$Int32$$Double);
                return $v10;
            }).call(this);
            invokers.get_Item$$TKey(this.get_Settings().get_Parallelize())([$CreateAnonymousDelegate(this, function (){
                resX = solvers.get_Item$$TKey(this.get_Settings().get_SolvingMethod())(Lw, bX, zX, this.get_Settings().get_MaxSolverIterations(), this.get_Settings().get_ResidualTolerance());
            }), $CreateAnonymousDelegate(this, function (){
                resY = solvers.get_Item$$TKey(this.get_Settings().get_SolvingMethod())(Lw, bY, zY, this.get_Settings().get_MaxSolverIterations(), this.get_Settings().get_ResidualTolerance());
            })]);
            for (var i = 0; i < this.get_Positions().get_Count(); i++)
                this.get_Positions().set_Item$$Int32(i, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(resX[i], resY[i]));
            return this.get_Positions();
        },
        LocalizedOptimization: function (nodeVoting){
            var currentPosition = this.get_Positions().get_Item$$Int32(nodeVoting.VotedNodeIndex);
            var nextX = 0;
            var nextY = 0;
            var sumWeights = 0;
            if (nodeVoting.get_VotingBlocks() == null || nodeVoting.get_VotingBlocks().get_Count() == 0){
                return currentPosition;
            }
            var $it48 = nodeVoting.get_VotingBlocks().GetEnumerator();
            while ($it48.MoveNext()){
                var votingBlock = $it48.get_Current();
                var blockWeight = votingBlock.get_BlockWeight();
                var $it49 = votingBlock.get_Votings().GetEnumerator();
                while ($it49.MoveNext()){
                    var vote = $it49.get_Current();
                    var voterPos = this.get_Positions().get_Item$$Int32(vote.VoterIndex);
                    var votingDistance = vote.Distance;
                    var diffX = currentPosition.get_X() - voterPos.get_X();
                    var diffY = currentPosition.get_Y() - voterPos.get_Y();
                    var euclidDistance = System.Math.Sqrt(diffX * diffX + diffY * diffY);
                    var weight = blockWeight * vote.Weight;
                    var voteX = voterPos.get_X() + votingDistance * diffX / euclidDistance;
                    nextX += voteX * weight;
                    var voteY = voterPos.get_Y() + votingDistance * diffY / euclidDistance;
                    nextY += voteY * weight;
                    sumWeights += weight;
                }
            }
            if (sumWeights == 0){
                return currentPosition;
            }
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(nextX / sumWeights, nextY / sumWeights);
        },
        ClearVoting: function (nodeVoting){
            var $it50 = nodeVoting.get_VotingBlocks().GetEnumerator();
            while ($it50.MoveNext()){
                var block = $it50.get_Current();
                block.get_Votings().Clear();
            }
        },
        ClearVotings: function (){
            var $it51 = this.get_NodeVotings().GetEnumerator();
            while ($it51.MoveNext()){
                var nodeVoting = $it51.get_Current();
                this.ClearVoting(nodeVoting);
            }
        },
        ConstructLinearSystemFromMajorization: function (Lw, Lx){
            var numEdges = this.GetNumberOfEdges(this.get_NodeVotings());
            var edgesDistance = new Float64Array(numEdges);
            var edgesWeight = new Float64Array(numEdges);
            var adjLists = new Array(this.get_NodeVotings().get_Count());
            var row = 0;
            var edgeId = 0;
            var $it53 = this.get_NodeVotings().GetEnumerator();
            while ($it53.MoveNext()){
                var nodeVoting = $it53.get_Current();
                var targetId = nodeVoting.VotedNodeIndex;
                var numAdj = 0;
                nodeVoting.get_VotingBlocks().ForEach($CreateAnonymousDelegate(this, function (block){
                    numAdj += block.get_Votings().get_Count();
                }));
                var currentAdj = new System.Collections.Generic.List$1.ctor$$Int32(Int32Array, numAdj);
                if (row != targetId)
                    throw $CreateException(new System.ArgumentOutOfRangeException.ctor$$String("VotedNodeIndex must be consecutive starting from 0"), new Error());
                adjLists[row] = currentAdj;
                var $it54 = nodeVoting.get_VotingBlocks().GetEnumerator();
                while ($it54.MoveNext()){
                    var block = $it54.get_Current();
                    var $it55 = block.get_Votings().GetEnumerator();
                    while ($it55.MoveNext()){
                        var voting = $it55.get_Current();
                        var sourceId = voting.VoterIndex;
                        edgesDistance[edgeId] = voting.Distance;
                        edgesWeight[edgeId] = voting.Weight * block.get_BlockWeight();
                        currentAdj.Add(new Int32Array([sourceId, edgeId]));
                        edgeId++;
                    }
                }
                row++;
            }
            for (var rowC = 0; rowC < adjLists.length; rowC++){
                var adjList = adjLists[rowC];
                adjList.Add(new Int32Array([rowC, -1]));
                adjList.Sort$$Comparison$1($CreateAnonymousDelegate(this, function (a, b){
                    return a[0].CompareTo$$Int32(b[0]);
                }));
            }
            numEdges += adjLists.length;
            var diagonalPos = new Int32Array(adjLists.length);
            Lw.Value = new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix.ctor$$Int32$$Int32$$Int32(numEdges, adjLists.length, adjLists.length);
            Lx.Value = new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix.ctor$$Int32$$Int32$$Int32(numEdges, adjLists.length, adjLists.length);
            var valPos = 0;
            for (var rowId = 0; rowId < adjLists.length; rowId++){
                var adjList = adjLists[rowId];
                var sumLw = 0;
                var sumLx = 0;
                var $it56 = adjList.GetEnumerator();
                while ($it56.MoveNext()){
                    var node = $it56.get_Current();
                    var colId = node[0];
                    Lw.Value.ColInd()[valPos] = colId;
                    Lx.Value.ColInd()[valPos] = colId;
                    if (rowId == colId){
                        diagonalPos[rowId] = valPos;
                    }
                    else {
                        var distance = edgesDistance[node[1]];
                        var weight = edgesWeight[node[1]];
                        Lw.Value.Values()[valPos] = -weight;
                        sumLw += weight;
                        var euclid = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.get_Positions().get_Item$$Int32(rowId), this.get_Positions().get_Item$$Int32(colId))).get_Length();
                        var entry = -weight * distance / euclid;
                        Lx.Value.Values()[valPos] = entry;
                        sumLx += entry;
                    }
                    valPos++;
                }
                Lw.Value.Values()[diagonalPos[rowId]] = sumLw;
                Lx.Value.Values()[diagonalPos[rowId]] = -sumLx;
                Lw.Value.RowPtr()[rowId + 1] = valPos;
                Lx.Value.RowPtr()[rowId + 1] = valPos;
            }
        },
        GetNumberOfEdges: function (nodeVotings){
            var i = 0;
            var $it57 = nodeVotings.GetEnumerator();
            while ($it57.MoveNext()){
                var nodeVoting = $it57.get_Current();
                var targetId = nodeVoting.VotedNodeIndex;
                var $it58 = nodeVoting.get_VotingBlocks().GetEnumerator();
                while ($it58.MoveNext()){
                    var block = $it58.get_Current();
                    i += block.get_Votings().get_Count();
                }
            }
            return i;
        },
        StressValue: function (nodePositions){
            var stress = 0;
            var $it59 = this.get_NodeVotings().GetEnumerator();
            while ($it59.MoveNext()){
                var nodeVoting = $it59.get_Current();
                var targetId = nodeVoting.VotedNodeIndex;
                var $it60 = nodeVoting.get_VotingBlocks().GetEnumerator();
                while ($it60.MoveNext()){
                    var block = $it60.get_Current();
                    var $it61 = block.get_Votings().GetEnumerator();
                    while ($it61.MoveNext()){
                        var voting = $it61.get_Current();
                        var sourceId = voting.VoterIndex;
                        var euclid = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(nodePositions.get_Item$$Int32(targetId), nodePositions.get_Item$$Int32(sourceId))).get_Length();
                        var diff = euclid - voting.Distance;
                        stress += block.get_BlockWeight() * voting.Weight * (diff * diff);
                    }
                }
            }
            return stress;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$StressEnergy$StressMajorization);
var Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$StressEnergy$UpdateMethod = {
    fullname: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.UpdateMethod",
    staticDefinition: {
        Serial: 0,
        Parallel: 1
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$StressEnergy$UpdateMethod);
var Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$StressEnergy$Vote = {
    fullname: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.Vote",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$Int32$$Double$$Double: function (voterIndex, distance, weight){
            this.VoterIndex = 0;
            this.Distance = 0;
            this.Weight = 0;
            System.Object.ctor.call(this);
            this.VoterIndex = voterIndex;
            this.Distance = distance;
            this.Weight = weight;
        },
        ctor$$Int32$$Double: function (voterIndex, distance){
            this.VoterIndex = 0;
            this.Distance = 0;
            this.Weight = 0;
            System.Object.ctor.call(this);
            this.VoterIndex = voterIndex;
            this.Distance = distance;
            this.Weight = 1 / distance / distance;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$StressEnergy$Vote);
var Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$StressEnergy$VoteBlock = {
    fullname: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.VoteBlock",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (votings, blockWeight){
            this._Votings = null;
            this._BlockWeight = 0;
            System.Object.ctor.call(this);
            this.set_Votings(votings);
            this.set_BlockWeight(blockWeight);
        },
        Votings$$: "System.Collections.Generic.List`1[[Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.Vote]]",
        get_Votings: function (){
            return this._Votings;
        },
        set_Votings: function (value){
            this._Votings = value;
        },
        BlockWeight$$: "System.Double",
        get_BlockWeight: function (){
            return this._BlockWeight;
        },
        set_BlockWeight: function (value){
            this._BlockWeight = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$StressEnergy$VoteBlock);
var Microsoft$Msagl$Core$Layout$RectangleObstacle = {
    fullname: "Microsoft.Msagl.Core.Layout.RectangleObstacle",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Core.Layout.IObstacle"],
    Kind: "Class",
    definition: {
        ctor$$Rectangle: function (r){
            this._Rectangle = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
            this._Data = null;
            System.Object.ctor.call(this);
            this.set_Rectangle(r);
        },
        ctor$$Rectangle$$Object: function (r, data){
            this._Rectangle = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
            this._Data = null;
            System.Object.ctor.call(this);
            this.set_Rectangle(r);
            this.set_Data(data);
        },
        Rectangle$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_Rectangle: function (){
            return this._Rectangle;
        },
        set_Rectangle: function (value){
            this._Rectangle = value;
        },
        Data$$: "System.Object",
        get_Data: function (){
            return this._Data;
        },
        set_Data: function (value){
            this._Data = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$RectangleObstacle);
var Microsoft$Msagl$Core$Layout$SimpleIntEdge = {
    fullname: "Microsoft.Msagl.Core.Layout.SimpleIntEdge",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Core.GraphAlgorithms.IEdge"],
    Kind: "Class",
    definition: {
        ctor: function (){
            this._Source = 0;
            this._Target = 0;
            System.Object.ctor.call(this);
        },
        Source$$: "System.Int32",
        get_Source: function (){
            return this._Source;
        },
        set_Source: function (value){
            this._Source = value;
        },
        Target$$: "System.Int32",
        get_Target: function (){
            return this._Target;
        },
        set_Target: function (value){
            this._Target = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$SimpleIntEdge);
var Microsoft$Msagl$Core$ProjectionSolver$SolverAlgorithm = {
    fullname: "Microsoft.Msagl.Core.ProjectionSolver.SolverAlgorithm",
    staticDefinition: {
        ProjectOnly: 0,
        QpscWithScaling: 1,
        QpscWithoutScaling: 2
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Core$ProjectionSolver$SolverAlgorithm);
var Microsoft$Msagl$Core$Routing$BundlingSettings = {
    fullname: "Microsoft.Msagl.Core.Routing.BundlingSettings",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Core.Routing.BundlingSettings.DefaultCapacityOverflowCoefficientMultiplier = 1000;
            Microsoft.Msagl.Core.Routing.BundlingSettings.DefaultPathLenghtImportance = 500;
            Microsoft.Msagl.Core.Routing.BundlingSettings.DefaultInkImportance = 0.01;
            Microsoft.Msagl.Core.Routing.BundlingSettings.DefaultEdgeSeparation = 0.5;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.capacityOverflowCoefficient = Microsoft.Msagl.Core.Routing.BundlingSettings.DefaultCapacityOverflowCoefficientMultiplier;
            this.MaxHubRadius = 50;
            this.MinHubRadius = 0.1;
            this.pathLengthImportance = Microsoft.Msagl.Core.Routing.BundlingSettings.DefaultPathLenghtImportance;
            this.inkImportance = Microsoft.Msagl.Core.Routing.BundlingSettings.DefaultInkImportance;
            this.edgeSeparation = Microsoft.Msagl.Core.Routing.BundlingSettings.DefaultEdgeSeparation;
            this.useCubicBezierSegmentsInsideOfHubs = false;
            this.useGreedyMetrolineOrdering = true;
            this.angleThreshold = 0.785398163397448;
            this.hubRepulsionImportance = 100;
            this.bundleRepulsionImportance = 100;
            this.minimalRatioOfGoodCdtEdges = 0.9;
            this.highestQuality = true;
            this._CreateUnderlyingPolyline = false;
            this._KeepOriginalSpline = false;
            this._KeepOverlaps = false;
            this._StopAfterShortestPaths = false;
            System.Object.ctor.call(this);
        },
        CapacityOverflowCoefficient$$: "System.Double",
        get_CapacityOverflowCoefficient: function (){
            return this.capacityOverflowCoefficient;
        },
        set_CapacityOverflowCoefficient: function (value){
            this.capacityOverflowCoefficient = value;
        },
        CreateUnderlyingPolyline$$: "System.Boolean",
        get_CreateUnderlyingPolyline: function (){
            return this._CreateUnderlyingPolyline;
        },
        set_CreateUnderlyingPolyline: function (value){
            this._CreateUnderlyingPolyline = value;
        },
        PathLengthImportance$$: "System.Double",
        get_PathLengthImportance: function (){
            return this.pathLengthImportance;
        },
        set_PathLengthImportance: function (value){
            this.pathLengthImportance = value;
        },
        InkImportance$$: "System.Double",
        get_InkImportance: function (){
            return this.inkImportance;
        },
        set_InkImportance: function (value){
            this.inkImportance = value;
        },
        EdgeSeparation$$: "System.Double",
        get_EdgeSeparation: function (){
            return this.edgeSeparation;
        },
        set_EdgeSeparation: function (value){
            this.edgeSeparation = value;
        },
        UseCubicBezierSegmentsInsideOfHubs$$: "System.Boolean",
        get_UseCubicBezierSegmentsInsideOfHubs: function (){
            return this.useCubicBezierSegmentsInsideOfHubs;
        },
        set_UseCubicBezierSegmentsInsideOfHubs: function (value){
            this.useCubicBezierSegmentsInsideOfHubs = value;
        },
        UseGreedyMetrolineOrdering$$: "System.Boolean",
        get_UseGreedyMetrolineOrdering: function (){
            return this.useGreedyMetrolineOrdering;
        },
        set_UseGreedyMetrolineOrdering: function (value){
            this.useGreedyMetrolineOrdering = value;
        },
        AngleThreshold$$: "System.Double",
        get_AngleThreshold: function (){
            return this.angleThreshold;
        },
        set_AngleThreshold: function (value){
            this.angleThreshold = value;
        },
        HubRepulsionImportance$$: "System.Double",
        get_HubRepulsionImportance: function (){
            return this.hubRepulsionImportance;
        },
        set_HubRepulsionImportance: function (value){
            this.hubRepulsionImportance = value;
        },
        BundleRepulsionImportance$$: "System.Double",
        get_BundleRepulsionImportance: function (){
            return this.bundleRepulsionImportance;
        },
        set_BundleRepulsionImportance: function (value){
            this.bundleRepulsionImportance = value;
        },
        MinimalRatioOfGoodCdtEdges$$: "System.Double",
        get_MinimalRatioOfGoodCdtEdges: function (){
            return this.minimalRatioOfGoodCdtEdges;
        },
        set_MinimalRatioOfGoodCdtEdges: function (value){
            this.minimalRatioOfGoodCdtEdges = value;
        },
        HighestQuality$$: "System.Boolean",
        get_HighestQuality: function (){
            return this.highestQuality;
        },
        set_HighestQuality: function (value){
            this.highestQuality = value;
        },
        KeepOriginalSpline$$: "System.Boolean",
        get_KeepOriginalSpline: function (){
            return this._KeepOriginalSpline;
        },
        set_KeepOriginalSpline: function (value){
            this._KeepOriginalSpline = value;
        },
        KeepOverlaps$$: "System.Boolean",
        get_KeepOverlaps: function (){
            return this._KeepOverlaps;
        },
        set_KeepOverlaps: function (value){
            this._KeepOverlaps = value;
        },
        StopAfterShortestPaths$$: "System.Boolean",
        get_StopAfterShortestPaths: function (){
            return this._StopAfterShortestPaths;
        },
        set_StopAfterShortestPaths: function (value){
            this._StopAfterShortestPaths = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Routing$BundlingSettings);
var Microsoft$Msagl$DebugHelpers$Persistence$CharStreamElement = {
    fullname: "Microsoft.Msagl.DebugHelpers.Persistence.CharStreamElement",
    baseTypeName: "Microsoft.Msagl.DebugHelpers.CurveStreamElement",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (ch){
            Microsoft.Msagl.DebugHelpers.CurveStreamElement.ctor.call(this);
            this.Value = ch;
        },
        Char$$: "System.Char",
        get_Char: function (){
            return this.Value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$DebugHelpers$Persistence$CharStreamElement);
var Microsoft$Msagl$DebugHelpers$Persistence$GeometryGraphReader = {
    fullname: "Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.NodeDefaultPadding = 1;
        },
        CreateFromFile$$String: function (fileName){
            var settings;
            return (function (){
                var $1 = {
                    Value: settings
                };
                var $res = Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.CreateFromFile$$String$$LayoutAlgorithmSettings(fileName, $1);
                settings = $1.Value;
                return $res;
            })();
        },
        CreateFromFile$$String$$LayoutAlgorithmSettings: function (fileName, settings){
            var stream = System.IO.File.OpenRead(fileName);
            try{
                var graphReader = new Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.ctor$$Stream(stream);
                var graph = graphReader.Read();
                settings.Value = graphReader.get_Settings();
                return graph;
            }
            finally{
                stream.Dispose();
            }
        },
        ReadDoubleElement: function (r){
            return r.ReadElementContentAsDouble();
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.IDisposable"],
    Kind: "Class",
    definition: {
        ctor: function (){
            this.EdgeList = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor);
            this.idToEdges = new System.Collections.Generic.Dictionary$2.ctor(System.String.ctor, Microsoft.Msagl.Core.Layout.Edge.ctor);
            this.idToRails = new System.Collections.Generic.Dictionary$2.ctor(System.String.ctor, Microsoft.Msagl.Layout.LargeGraphLayout.Rail.ctor);
            this.railIdsToTopRankedEdgeInfo = new System.Collections.Generic.Dictionary$2.ctor(System.String.ctor, Microsoft.Msagl.Layout.LargeGraphLayout.LgEdgeInfo.ctor);
            this.graph = new Microsoft.Msagl.Core.Layout.GeometryGraph.ctor();
            this.stringToClusters = new System.Collections.Generic.Dictionary$2.ctor(System.String.ctor, Microsoft.Msagl.DebugHelpers.ClusterWithChildLists.ctor);
            this.nodeIdToNodes = new System.Collections.Generic.Dictionary$2.ctor(System.String.ctor, Microsoft.Msagl.Core.Layout.Node.ctor);
            this.xmlTextReader = null;
            this._Settings = null;
            this._XmlReader = null;
            System.Object.ctor.call(this);
        },
        Settings$$: "Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings",
        get_Settings: function (){
            return this._Settings;
        },
        set_Settings: function (value){
            this._Settings = value;
        },
        ctor$$Stream: function (streamP){
            this.EdgeList = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor);
            this.idToEdges = new System.Collections.Generic.Dictionary$2.ctor(System.String.ctor, Microsoft.Msagl.Core.Layout.Edge.ctor);
            this.idToRails = new System.Collections.Generic.Dictionary$2.ctor(System.String.ctor, Microsoft.Msagl.Layout.LargeGraphLayout.Rail.ctor);
            this.railIdsToTopRankedEdgeInfo = new System.Collections.Generic.Dictionary$2.ctor(System.String.ctor, Microsoft.Msagl.Layout.LargeGraphLayout.LgEdgeInfo.ctor);
            this.graph = new Microsoft.Msagl.Core.Layout.GeometryGraph.ctor();
            this.stringToClusters = new System.Collections.Generic.Dictionary$2.ctor(System.String.ctor, Microsoft.Msagl.DebugHelpers.ClusterWithChildLists.ctor);
            this.nodeIdToNodes = new System.Collections.Generic.Dictionary$2.ctor(System.String.ctor, Microsoft.Msagl.Core.Layout.Node.ctor);
            this.xmlTextReader = null;
            this._Settings = null;
            this._XmlReader = null;
            System.Object.ctor.call(this);
            var settings = (function (){
                var $v11 = new System.Xml.XmlReaderSettings.ctor();
                $v11.set_IgnoreComments(false);
                $v11.set_IgnoreWhitespace(true);
                return $v11;
            }).call(this);
            this.xmlTextReader = new System.Xml.XmlTextReader.ctor$$Stream(streamP);
            this.set_XmlReader(System.Xml.XmlReader.Create$$XmlReader$$XmlReaderSettings(this.xmlTextReader, settings));
        },
        FindClusterById: function (id){
            var cwl;
            if ((function (){
                var $1 = {
                    Value: cwl
                };
                var $res = this.stringToClusters.TryGetValue(id, $1);
                cwl = $1.Value;
                return $res;
            }).call(this))
                return cwl.Cluster;
            return null;
        },
        FindNodeById: function (id){
            var node;
            if ((function (){
                var $1 = {
                    Value: node
                };
                var $res = this.nodeIdToNodes.TryGetValue(id, $1);
                node = $1.Value;
                return $res;
            }).call(this))
                return node;
            return null;
        },
        Read: function (){
            var currentCulture = System.Threading.Thread.get_CurrentThread().get_CurrentCulture();
            System.Threading.Thread.get_CurrentThread().set_CurrentCulture(System.Globalization.CultureInfo.get_InvariantCulture());
            try{
                this.ReadGraph();
                return this.graph;
            }
            finally{
                System.Threading.Thread.get_CurrentThread().set_CurrentCulture(currentCulture);
            }
        },
        ReadLayoutAlgorithmSettings: function (reader){
            var layoutSettings = null;
            this.CheckToken(Microsoft.Msagl.DebugHelpers.GeometryToken.LayoutAlgorithmSettings);
            if (reader.get_IsEmptyElement()){
                reader.Read();
                return null;
            }
            var edgeRoutingMode = Cast(this.GetIntAttributeOrDefault(Microsoft.Msagl.DebugHelpers.GeometryToken.EdgeRoutingMode, 0), Microsoft.Msagl.Core.Routing.EdgeRoutingMode.ctor);
            var str = this.GetAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.LayoutAlgorithmType);
            if (this.get_XmlReader().get_NodeType() == 15){
                layoutSettings = new Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.ctor();
                var routingSettings = layoutSettings.get_EdgeRoutingSettings();
                routingSettings.set_EdgeRoutingMode(edgeRoutingMode);
            }
            else {
                if (str != null){
                    var token = Cast(System.Enum.Parse$$Type$$String$$Boolean(Typeof(Microsoft.Msagl.DebugHelpers.GeometryToken.ctor), str, false), Microsoft.Msagl.DebugHelpers.GeometryToken.ctor);
                    if (token == Microsoft.Msagl.DebugHelpers.GeometryToken.SugiyamaLayoutSettings){
                        layoutSettings = this.ReadSugiyamaLayoutSettings(edgeRoutingMode);
                    }
                    else if (token == Microsoft.Msagl.DebugHelpers.GeometryToken.MdsLayoutSettings){
                        var mds = new Microsoft.Msagl.Layout.MDS.MdsLayoutSettings.ctor();
                        var routingSettings = mds.get_EdgeRoutingSettings();
                        routingSettings.set_EdgeRoutingMode(edgeRoutingMode);
                        layoutSettings = mds;
                        if (this.get_XmlReader().IsStartElement$$String(Microsoft.Msagl.DebugHelpers.GeometryToken.Reporting.toString())){
                            this.ReadBooleanElement(Microsoft.Msagl.DebugHelpers.GeometryToken.Reporting);
                        }
                        mds.set_Exponent(Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.ReadDoubleElement(reader));
                        mds.set_IterationsWithMajorization(this.ReadIntElement(Microsoft.Msagl.DebugHelpers.GeometryToken.IterationsWithMajorization));
                        mds.set_PivotNumber(this.ReadIntElement(Microsoft.Msagl.DebugHelpers.GeometryToken.PivotNumber));
                        mds.set_RotationAngle(Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.ReadDoubleElement(reader));
                        mds.set_ScaleX(Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.ReadDoubleElement(reader));
                        mds.set_ScaleY(Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.ReadDoubleElement(reader));
                    }
                    else
                        throw $CreateException(new System.NotImplementedException.ctor(), new Error());
                }
            }
            reader.ReadEndElement();
            return layoutSettings;
        },
        ReadSugiyamaLayoutSettings: function (edgeRoutingMode){
            var sugiyama = new Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.ctor();
            var routingSettings = sugiyama.get_EdgeRoutingSettings();
            routingSettings.set_EdgeRoutingMode(edgeRoutingMode);
            var layoutSettings = sugiyama;
            sugiyama.set_MinNodeWidth(this.GetDoubleAttributeOrDefault(Microsoft.Msagl.DebugHelpers.GeometryToken.MinNodeWidth, sugiyama.get_MinNodeWidth()));
            sugiyama.set_MinNodeHeight(this.GetDoubleAttributeOrDefault(Microsoft.Msagl.DebugHelpers.GeometryToken.MinNodeHeight, sugiyama.get_MinimalHeight()));
            sugiyama.set_AspectRatio(this.GetDoubleAttributeOrDefault(Microsoft.Msagl.DebugHelpers.GeometryToken.AspectRatio, sugiyama.get_AspectRatio()));
            sugiyama.set_NodeSeparation(this.GetDoubleAttributeOrDefault(Microsoft.Msagl.DebugHelpers.GeometryToken.NodeSeparation, sugiyama.get_NodeSeparation()));
            sugiyama.set_ClusterMargin(sugiyama.get_NodeSeparation());
            sugiyama.set_RandomSeedForOrdering(this.GetIntAttributeOrDefault(Microsoft.Msagl.DebugHelpers.GeometryToken.RandomSeedForOrdering, sugiyama.get_RandomSeedForOrdering()));
            sugiyama.set_NoGainAdjacentSwapStepsBound(this.GetIntAttributeOrDefault(Microsoft.Msagl.DebugHelpers.GeometryToken.NoGainStepsBound, sugiyama.get_NoGainAdjacentSwapStepsBound()));
            sugiyama.set_MaxNumberOfPassesInOrdering(this.GetIntAttributeOrDefault(Microsoft.Msagl.DebugHelpers.GeometryToken.MaxNumberOfPassesInOrdering, sugiyama.get_MaxNumberOfPassesInOrdering()));
            sugiyama.set_RepetitionCoefficientForOrdering(this.GetIntAttributeOrDefault(Microsoft.Msagl.DebugHelpers.GeometryToken.RepetitionCoefficientForOrdering, sugiyama.get_RepetitionCoefficientForOrdering()));
            sugiyama.set_GroupSplit(this.GetIntAttributeOrDefault(Microsoft.Msagl.DebugHelpers.GeometryToken.GroupSplit, sugiyama.get_GroupSplit()));
            sugiyama.set_LabelCornersPreserveCoefficient(this.GetDoubleAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.LabelCornersPreserveCoefficient));
            sugiyama.set_BrandesThreshold(this.GetIntAttributeOrDefault(Microsoft.Msagl.DebugHelpers.GeometryToken.BrandesThreshold, sugiyama.get_BrandesThreshold()));
            sugiyama.set_LayerSeparation(this.GetDoubleAttributeOrDefault(Microsoft.Msagl.DebugHelpers.GeometryToken.LayerSeparation, sugiyama.get_LayerSeparation()));
            var transform = new Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.ctor();
            this.ReadTransform(transform);
            return layoutSettings;
        },
        ReadTransform: function (transform){
            this.XmlRead();
            if (this.TokenIs(Microsoft.Msagl.DebugHelpers.GeometryToken.Transform)){
                this.XmlRead();
                for (var i = 0; i < 2; i++)
                    for (var j = 0; j < 3; j++){
                        this.CheckToken(Microsoft.Msagl.DebugHelpers.GeometryToken.TransformElement);
                        this.MoveToContent();
                        transform.set_Item$$Int32$$Int32(i, j, this.ReadElementContentAsDouble());
                    }
                this.XmlRead();
            }
            else {
                transform.set_Item$$Int32$$Int32(0, 0, 1);
                transform.set_Item$$Int32$$Int32(0, 1, 0);
                transform.set_Item$$Int32$$Int32(0, 2, 0);
                transform.set_Item$$Int32$$Int32(1, 0, 0);
                transform.set_Item$$Int32$$Int32(1, 1, 1);
                transform.set_Item$$Int32$$Int32(1, 2, 0);
            }
        },
        ReadBooleanElement: function (tokens){
            this.CheckToken(tokens);
            return this.ReadElementContentAsBoolean();
        },
        ReadElementContentAsBoolean: function (){
            return this.get_XmlReader().ReadElementContentAsBoolean();
        },
        ReadIntElement: function (token){
            this.CheckToken(token);
            return this.ReadElementContentAsInt();
        },
        ReadGraph: function (){
            this.MoveToContent();
            if (this.get_XmlReader().get_Name().toLowerCase() != Microsoft.Msagl.DebugHelpers.GeometryToken.Graph.toString().toLowerCase())
                this.Error("expecting element \"graph\"");
            var done = false;
            do{
                switch (this.GetElementTag()){
                    case Microsoft.Msagl.DebugHelpers.GeometryToken.Nodes:
                        this.ReadNodes();
                        break;
                    case Microsoft.Msagl.DebugHelpers.GeometryToken.Edges:
                        this.ReadEdges();
                        break;
                    case Microsoft.Msagl.DebugHelpers.GeometryToken.Clusters:
                        this.ReadClusters();
                        break;
                    case Microsoft.Msagl.DebugHelpers.GeometryToken.LayoutAlgorithmSettings:
                        this.set_Settings(this.ReadLayoutAlgorithmSettings(this.get_XmlReader()));
                        break;
                    case Microsoft.Msagl.DebugHelpers.GeometryToken.LgLevels:
                        this.ReadLgLevels();
                        break;
                    case Microsoft.Msagl.DebugHelpers.GeometryToken.End:
                    case Microsoft.Msagl.DebugHelpers.GeometryToken.Graph:
                        if (this.get_XmlReader().get_NodeType() == 15){
                        done = true;
                        this.ReadEndElement();
                        break;
                    }
                        this.XmlRead();
                        break;
                    default:
                        this.get_XmlReader().Skip();
                        break;
                }
            }
            while (!done)
            this.graph.set_BoundingBox(this.graph.PumpTheBoxToTheGraphWithMargins());
        },
        ReadLgLevels: function (){
            var lgData = new Microsoft.Msagl.Layout.LargeGraphLayout.LgData.ctor(this.graph);
            this.graph.set_LgData(lgData);
            this.FillLgData(lgData);
            this.ReadEndElement();
        },
        FillLgData: function (lgData){
            this.XmlRead();
            if (this.TokenIs(Microsoft.Msagl.DebugHelpers.GeometryToken.LgEdgeInfos))
                this.ReadLgEdgeInfos(lgData);
            if (this.TokenIs(Microsoft.Msagl.DebugHelpers.GeometryToken.LgNodeInfos)){
                this.ReadLgNodeInfos(lgData);
            }
            this.ReadLevels(lgData);
        },
        ReadLgEdgeInfos: function (lgData){
            this.XmlRead();
            while (this.TokenIs(Microsoft.Msagl.DebugHelpers.GeometryToken.LgEdgeInfo))
                this.ReadLgEdgeInfo(lgData);
            this.ReadEndElement();
        },
        ReadLgEdgeInfo: function (lgData){
            var edgeId = this.GetAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.EdgeId);
            var edge = this.idToEdges.get_Item$$TKey(edgeId);
            lgData.GeometryEdgesToLgEdgeInfos.set_Item$$TKey(edge, (function (){
                var $v12 = new Microsoft.Msagl.Layout.LargeGraphLayout.LgEdgeInfo.ctor(edge);
                $v12.set_Rank(this.GetDoubleAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Rank));
                $v12.set_ZoomLevel(this.GetDoubleAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Zoomlevel));
                return $v12;
            }).call(this));
            this.XmlRead();
        },
        ReadLevels: function (lgData){
            var zoomLevel = 1;
            while (this.GetElementTag() == Microsoft.Msagl.DebugHelpers.GeometryToken.Level){
                this.ReadLevel(lgData, zoomLevel);
                zoomLevel *= 2;
            }
        },
        ReadLevel: function (lgData, zoomLevel){
            var levelNodeCount = this.GetIntAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.NodeCountOnLevel);
            if (lgData.get_LevelNodeCounts() == null){
                lgData.set_LevelNodeCounts(new System.Collections.Generic.List$1.ctor(System.Int32.ctor));
            }
            lgData.get_LevelNodeCounts().Add(levelNodeCount);
            var level = new Microsoft.Msagl.Layout.LargeGraphLayout.LgLevel.ctor(zoomLevel, this.graph);
            lgData.get_Levels().Add(level);
            this.XmlRead();
            var edgeIdToEdgeRailsSet = new System.Collections.Generic.Dictionary$2.ctor(System.String.ctor, Microsoft.Msagl.Core.DataStructures.Set$1.ctor);
            this.ReadRailIdsPerEdgeIds(lgData, edgeIdToEdgeRailsSet);
            this.ReadRails(level);
            this.ReadEndElement();
            this.ReadEndElement();
            level.CreateRailTree();
        },
        ReadRailIdsPerEdgeIds: function (lgData, edgeIdToEdgeRailsSet){
            this.XmlRead();
            while (this.TokenIs(Microsoft.Msagl.DebugHelpers.GeometryToken.EdgeRails))
                this.ReadEdgeRailIds(lgData, edgeIdToEdgeRailsSet);
            this.ReadEndElement();
        },
        ReadEdgeRailIds: function (lgData, edgeIdToEdgeRailsSet){
            var edgeId = this.GetAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.EdgeId);
            var railIdSet;
            edgeIdToEdgeRailsSet.set_Item$$TKey(edgeId, railIdSet = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(System.String.ctor));
            var edgeRailsString = this.GetAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.EdgeRails);
            var edgeInfo = lgData.GeometryEdgesToLgEdgeInfos.get_Item$$TKey(this.idToEdges.get_Item$$TKey(edgeId));
            for (var $i63 = 0,$t63 = edgeRailsString.Split$$Char$Array(" "),$l63 = $t63.length,railId = $t63[$i63]; $i63 < $l63; $i63++, railId = $t63[$i63]){
                this.UpdateToRankedEdgeInfoForRail(railId, edgeInfo);
                railIdSet.Insert(railId);
            }
            this.XmlRead();
        },
        UpdateToRankedEdgeInfoForRail: function (railId, edgeInfo){
            var topRankeEdgeInfo;
            if ((function (){
                var $1 = {
                    Value: topRankeEdgeInfo
                };
                var $res = this.railIdsToTopRankedEdgeInfo.TryGetValue(railId, $1);
                topRankeEdgeInfo = $1.Value;
                return $res;
            }).call(this)){
                if (topRankeEdgeInfo.get_Rank() < edgeInfo.get_Rank())
                    this.railIdsToTopRankedEdgeInfo.set_Item$$TKey(railId, edgeInfo);
            }
            else
                this.railIdsToTopRankedEdgeInfo.set_Item$$TKey(railId, edgeInfo);
        },
        ReadRails: function (level){
            this.CheckToken(Microsoft.Msagl.DebugHelpers.GeometryToken.Rails);
            this.XmlRead();
            while (this.TokenIs(Microsoft.Msagl.DebugHelpers.GeometryToken.Rail)){
                this.ReadRail(level);
            }
        },
        ReadRail: function (level){
            var railId = this.GetAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Id);
            var zoomLevel = (this.GetDoubleAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Zoomlevel)) | 0;
            var topRankedEdgoInfo = this.GetTopRankedEdgeInfoOfRail(railId);
            var rail = this.ContinueReadingRail(topRankedEdgoInfo, zoomLevel, level);
            this.idToRails.set_Item$$TKey(railId, rail);
        },
        ContinueReadingRail: function (topRankedEdgoInfo, zoomLevel, level){
            this.XmlRead();
            var pointString;
            if (this.TokenIs(Microsoft.Msagl.DebugHelpers.GeometryToken.Arrowhead)){
                var arrowheadPosition = this.TryGetPointAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.ArrowheadPosition);
                var attachmentPoint = this.TryGetPointAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.CurveAttachmentPoint);
                var ah = (function (){
                    var $v13 = new Microsoft.Msagl.Core.Layout.Arrowhead.ctor();
                    $v13.set_TipPosition(arrowheadPosition);
                    $v13.set_Length((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(attachmentPoint, arrowheadPosition)).get_Length());
                    return $v13;
                }).call(this);
                this.XmlRead();
                this.ReadEndElement();
                var rail = new Microsoft.Msagl.Layout.LargeGraphLayout.Rail.ctor$$Arrowhead$$Point$$LgEdgeInfo$$Int32(ah, attachmentPoint, topRankedEdgoInfo, zoomLevel);
                var tuple = new System.Tuple$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, arrowheadPosition, attachmentPoint);
                level._railDictionary.set_Item$$TKey(tuple, rail);
                return rail;
            }
            if (this.TokenIs(Microsoft.Msagl.DebugHelpers.GeometryToken.LineSegment)){
                pointString = this.GetAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Points);
                var linePoints = this.ParsePoints(pointString);
                System.Diagnostics.Debug.Assert$$Boolean(linePoints.length == 2);
                var ls = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(linePoints[0], linePoints[1]);
                this.XmlRead();
                this.ReadEndElement();
                var rail = new Microsoft.Msagl.Layout.LargeGraphLayout.Rail.ctor$$ICurve$$LgEdgeInfo$$Int32(ls, topRankedEdgoInfo, zoomLevel);
                var tuple = new System.Tuple$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, ls.get_Start(), ls.get_End());
                level._railDictionary.set_Item$$TKey(tuple, rail);
                return rail;
            }
            if (this.TokenIs(Microsoft.Msagl.DebugHelpers.GeometryToken.CubicBezierSegment)){
                pointString = this.GetAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Points);
                var controlPoints = this.ParsePoints(pointString);
                System.Diagnostics.Debug.Assert$$Boolean(controlPoints.length == 4);
                var bs = new Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ctor(controlPoints[0], controlPoints[1], controlPoints[2], controlPoints[3]);
                this.XmlRead();
                this.ReadEndElement();
                var rail = new Microsoft.Msagl.Layout.LargeGraphLayout.Rail.ctor$$ICurve$$LgEdgeInfo$$Int32(bs, topRankedEdgoInfo, zoomLevel);
                var tuple = new System.Tuple$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, bs.get_Start(), bs.get_End());
                level._railDictionary.set_Item$$TKey(tuple, rail);
                return rail;
            }
            throw $CreateException(new System.IO.InvalidDataException.ctor(), new Error());
        },
        GetTopRankedEdgeInfoOfRail: function (railId){
            return this.railIdsToTopRankedEdgeInfo.get_Item$$TKey(railId);
        },
        ReadLgNodeInfos: function (lgData){
            if (this.get_XmlReader().get_IsEmptyElement())
                return;
            lgData.GeometryNodesToLgNodeInfos = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Layout.LgNodeInfo.ctor);
            lgData.set_SortedLgNodeInfos(new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.LgNodeInfo.ctor));
            this.XmlRead();
            while (this.TokenIs(Microsoft.Msagl.DebugHelpers.GeometryToken.LgNodeInfo))
                this.ReadLgNodeInfo(lgData);
            this.ReadEndElement();
        },
        ReadLgNodeInfo: function (lgData){
            var nodeId = this.GetAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Id);
            var nodeInfo = (function (){
                var $v14 = new Microsoft.Msagl.Core.Layout.LgNodeInfo.ctor(this.nodeIdToNodes.get_Item$$TKey(nodeId));
                $v14.set_Rank(this.GetDoubleAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Rank));
                $v14.set_ZoomLevel(this.GetDoubleAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Zoomlevel));
                return $v14;
            }).call(this);
            lgData.get_SortedLgNodeInfos().Add(nodeInfo);
            lgData.GeometryNodesToLgNodeInfos.set_Item$$TKey(this.nodeIdToNodes.get_Item$$TKey(nodeId), nodeInfo);
            this.XmlRead();
        },
        GetElementTag: function (){
            if (this.get_XmlReader().get_NodeType() == 15 && this.get_XmlReader().get_Name() == "graph")
                return Microsoft.Msagl.DebugHelpers.GeometryToken.End;
            var token;
            if (this.get_XmlReader().get_ReadState() == 3)
                return Microsoft.Msagl.DebugHelpers.GeometryToken.Graph;
            if ((function (){
                var $1 = {
                    Value: token
                };
                var $res = System.Enum.TryParse$1$$String$$Boolean$$TEnum(Microsoft.Msagl.DebugHelpers.GeometryToken.ctor, this.get_XmlReader().get_Name(), true, $1);
                token = $1.Value;
                return $res;
            }).call(this))
                return token;
            throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
        },
        ReadClusters: function (){
            this.XmlRead();
            while (this.TokenIs(Microsoft.Msagl.DebugHelpers.GeometryToken.Cluster))
                this.ReadCluster();
            this.FleshOutClusters();
            var rootClusterSet = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Layout.Cluster.ctor);
            var $it63 = System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.DebugHelpers.ClusterWithChildLists.ctor, Microsoft.Msagl.Core.Layout.Cluster.ctor, this.stringToClusters.get_Values(), $CreateAnonymousDelegate(this, function (c){
                return c.Cluster;
            })).GetEnumerator();
            while ($it63.MoveNext()){
                var cluster = $it63.get_Current();
                if (cluster.get_ClusterParents() == null || !System.Linq.Enumerable.Any$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, cluster.get_ClusterParents()))
                    rootClusterSet.Insert(cluster);
            }
            if (rootClusterSet.get_Count() == 1)
                this.graph.set_RootCluster(System.Linq.Enumerable.First$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, rootClusterSet));
            else {
                this.graph.get_RootCluster().AddRangeOfCluster(rootClusterSet);
            }
            if (!this.get_XmlReader().IsStartElement())
                this.ReadEndElement();
        },
        FleshOutClusters: function (){
            var $it64 = this.stringToClusters.get_Values().GetEnumerator();
            while ($it64.MoveNext()){
                var clusterWithLists = $it64.get_Current();
                var cl = clusterWithLists.Cluster;
                var $it65 = clusterWithLists.ChildClusters.GetEnumerator();
                while ($it65.MoveNext()){
                    var i = $it65.get_Current();
                    cl.AddCluster(this.stringToClusters.get_Item$$TKey(i).Cluster);
                }
                var $it66 = clusterWithLists.ChildNodes.GetEnumerator();
                while ($it66.MoveNext()){
                    var i = $it66.get_Current();
                    cl.AddNode(this.nodeIdToNodes.get_Item$$TKey(i));
                }
            }
        },
        ReadCluster: function (){
            var cluster = (function (){
                var $v15 = new Microsoft.Msagl.Core.Layout.Cluster.ctor();
                $v15.set_RectangularBoundary(new Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.ctor());
                return $v15;
            }).call(this);
            var clusterWithChildLists = new Microsoft.Msagl.DebugHelpers.ClusterWithChildLists.ctor(cluster);
            cluster.Barycenter = this.TryGetPointAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Barycenter);
            var clusterId = this.GetAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Id);
            this.stringToClusters.set_Item$$TKey(clusterId, clusterWithChildLists);
            this.ReadChildClusters(clusterWithChildLists.ChildClusters);
            this.ReadChildNodes(clusterWithChildLists.ChildNodes);
            this.XmlRead();
            switch (this.NameToToken()){
                case Microsoft.Msagl.DebugHelpers.GeometryToken.ICurve:
                    cluster.set_BoundaryCurve(this.ReadICurve());
                    break;
                case Microsoft.Msagl.DebugHelpers.GeometryToken.Curve:
                    cluster.set_BoundaryCurve(this.ReadCurve());
                    this.XmlRead();
                    break;
                case Microsoft.Msagl.DebugHelpers.GeometryToken.Rect:
                    cluster.set_BoundaryCurve(this.ReadRect());
                    this.XmlRead();
                    break;
            }
            if (this.get_XmlReader().get_NodeType() != 15)
                cluster.set_RectangularBoundary(this.ReadClusterRectBoundary());
            this.ReadEndElement();
        },
        ReadClusterRectBoundary: function (){
            var recClBnd = (function (){
                var $v16 = new Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.ctor();
                $v16.set_LeftMargin(this.GetDoubleAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.LeftMargin));
                $v16.set_RightMargin(this.GetDoubleAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.RightMargin));
                $v16.set_TopMargin(this.GetDoubleAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.TopMargin));
                $v16.set_BottomMargin(this.GetDoubleAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.BottomMargin));
                return $v16;
            }).call(this);
            if (this.GetAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.DefaultLeftMargin) != null){
                var defaultLeftMargin = this.GetDoubleAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.DefaultLeftMargin);
                var defaultRightMargin = this.GetDoubleAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.DefaultRightMargin);
                var defaultTopMargin = this.GetDoubleAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.DefaultBottomMargin);
                var defaultBottomMargin = this.GetDoubleAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.DefaultBottomMargin);
                recClBnd.StoreDefaultMargin$$Double$$Double$$Double$$Double(defaultLeftMargin, defaultRightMargin, defaultBottomMargin, defaultTopMargin);
            }
            recClBnd.set_GenerateFixedConstraints(this.GetBoolAttributeOrDefault(Microsoft.Msagl.DebugHelpers.GeometryToken.GenerateFixedConstraints, false));
            recClBnd.set_GenerateFixedConstraintsDefault(this.GetBoolAttributeOrDefault(Microsoft.Msagl.DebugHelpers.GeometryToken.GenerateFixedConstraintsDefault, false));
            recClBnd.set_MinHeight(this.GetDoubleAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.MinNodeHeight));
            recClBnd.set_MinWidth(this.GetDoubleAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.MinNodeWidth));
            var ry;
            var left;
            var bottom;
            var w;
            var h;
            var rx;
            this.XmlRead();
            (function (){
                var $1 = {
                    Value: left
                };
                var $2 = {
                    Value: bottom
                };
                var $3 = {
                    Value: w
                };
                var $4 = {
                    Value: h
                };
                var $5 = {
                    Value: rx
                };
                var $6 = {
                    Value: ry
                };
                var $res = this.ReadRectParams($1, $2, $3, $4, $5, $6);
                left = $1.Value;
                bottom = $2.Value;
                w = $3.Value;
                h = $4.Value;
                rx = $5.Value;
                ry = $6.Value;
                return $res;
            }).call(this);
            recClBnd.set_Rect(new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Double$$Double$$Point(left, bottom, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(w, h)));
            recClBnd.set_RadiusX(rx);
            recClBnd.set_RadiusY(ry);
            recClBnd.set_RightBorderInfo(this.ReadBorderInfo(Microsoft.Msagl.DebugHelpers.GeometryToken.RightBorderInfo));
            recClBnd.set_LeftBorderInfo(this.ReadBorderInfo(Microsoft.Msagl.DebugHelpers.GeometryToken.LeftBorderInfo));
            recClBnd.set_TopBorderInfo(this.ReadBorderInfo(Microsoft.Msagl.DebugHelpers.GeometryToken.TopBorderInfo));
            recClBnd.set_BottomBorderInfo(this.ReadBorderInfo(Microsoft.Msagl.DebugHelpers.GeometryToken.BottomBorderInfo));
            this.XmlRead();
            this.ReadEndElement();
            return recClBnd;
        },
        ReadBorderInfo: function (token){
            this.XmlRead();
            this.CheckToken(token);
            var bi = (function (){
                var $v17 = new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor();
                $v17.set_InnerMargin(this.GetDoubleAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.InnerMargin));
                $v17.set_FixedPosition(this.GetDoubleAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.FixedPosition));
                $v17.set_Weight(this.GetDoubleAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Weight));
                return $v17;
            }).call(this);
            return bi;
        },
        ReadChildClusters: function (childClusters){
            var clusterIds = this.GetAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.ChildClusters);
            if (System.String.IsNullOrEmpty(clusterIds))
                return;
            childClusters.AddRange(clusterIds.Split$$Char$Array(" "));
        },
        ReadChildNodes: function (childNodes){
            var nodeIds = this.GetAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.ChildNodes);
            if (System.String.IsNullOrEmpty(nodeIds))
                return;
            childNodes.AddRange(nodeIds.Split$$Char$Array(" "));
        },
        ReadEdges: function (){
            this.CheckToken(Microsoft.Msagl.DebugHelpers.GeometryToken.Edges);
            this.XmlRead();
            while (this.TokenIs(Microsoft.Msagl.DebugHelpers.GeometryToken.Edge))
                this.ReadEdge();
            this.ReadEndElement();
        },
        ReadEdge: function (){
            this.CheckToken(Microsoft.Msagl.DebugHelpers.GeometryToken.Edge);
            var s = this.ReadSourceNode();
            var t = this.ReadTargetNode();
            var edge = (function (){
                var $v18 = new Microsoft.Msagl.Core.Layout.Edge.ctor$$Node$$Node(s, t);
                $v18.set_Separation((this.GetDoubleAttributeOrDefault(Microsoft.Msagl.DebugHelpers.GeometryToken.Separation, 1)) | 0);
                $v18.set_LineWidth(this.GetDoubleAttributeOrDefault(Microsoft.Msagl.DebugHelpers.GeometryToken.LineWidth, 1));
                $v18.set_Weight((this.GetDoubleAttributeOrDefault(Microsoft.Msagl.DebugHelpers.GeometryToken.Weight, 1)) | 0);
                return $v18;
            }).call(this);
            var id = this.GetAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Id);
            if (id != null){
                System.Diagnostics.Debug.Assert$$Boolean(this.idToEdges.ContainsKey(id) == false);
                this.idToEdges.set_Item$$TKey(id, edge);
            }
            else {
                System.Diagnostics.Debug.Assert$$Boolean(this.idToEdges.get_Count() == 0);
            }
            this.EdgeList.Add(edge);
            this.ReadArrowheadAtSource(edge);
            this.ReadArrowheadAtTarget(edge);
            this.ReadLabelFromAttribute(edge);
            var breakTheLoop = false;
            this.graph.get_Edges().Add(edge);
            if (this.get_XmlReader().get_IsEmptyElement()){
                this.get_XmlReader().Skip();
                return;
            }
            this.XmlRead();
            do{
                var token = this.GetElementTag();
                switch (token){
                    case Microsoft.Msagl.DebugHelpers.GeometryToken.Curve:
                        edge.set_Curve(this.ReadICurve());
                        break;
                    case Microsoft.Msagl.DebugHelpers.GeometryToken.LineSegment:
                        edge.set_Curve(this.ReadLineSeg());
                        break;
                    case Microsoft.Msagl.DebugHelpers.GeometryToken.Edge:
                        this.ReadEndElement();
                        breakTheLoop = true;
                        break;
                    case Microsoft.Msagl.DebugHelpers.GeometryToken.Polyline:
                        break;
                    default:
                        breakTheLoop = true;
                        break;
                }
                if (!breakTheLoop)
                    this.XmlRead();
            }
            while (!breakTheLoop)
        },
        ReadArrowheadAtSource: function (edge){
            var str = this.GetAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.As);
            var arrowhead = (function ($p7){
                edge.get_EdgeGeometry().set_SourceArrowhead($p7);
                return $p7;
            }).call(this, str != null ? (function (){
                var $v19 = new Microsoft.Msagl.Core.Layout.Arrowhead.ctor();
                $v19.set_TipPosition(this.ParsePoint(str));
                return $v19;
            }).call(this) : null);
            if (arrowhead != null)
                arrowhead.set_Length(this.GetDoubleAttributeOrDefault(Microsoft.Msagl.DebugHelpers.GeometryToken.Asl, 10));
            else {
                str = this.GetAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Asl);
                if (str != null)
                    edge.get_EdgeGeometry().set_SourceArrowhead((function (){
                        var $v20 = new Microsoft.Msagl.Core.Layout.Arrowhead.ctor();
                        $v20.set_Length(this.ParseDouble(str));
                        return $v20;
                    }).call(this));
            }
        },
        ParsePoint: function (str){
            var xy = System.Linq.Enumerable.ToArray$1(System.String.ctor, str.Split$$Char$Array(" "));
            System.Diagnostics.Debug.Assert$$Boolean(xy.length == 2);
            var x,y;
            if ((function (){
                var $1 = {
                    Value: x
                };
                var $res = System.Double.TryParse$$String$$Double(xy[0], $1);
                x = $1.Value;
                return $res;
            }).call(this) && (function (){
                var $1 = {
                    Value: y
                };
                var $res = System.Double.TryParse$$String$$Double(xy[1], $1);
                y = $1.Value;
                return $res;
            }).call(this))
                return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x, y);
            this.Error("invalid point format" + str);
            return new Microsoft.Msagl.Core.Geometry.Point.ctor();
        },
        ParsePoints: function (str){
            var tokens = str.Split$$Char$Array(" ");
            System.Diagnostics.Debug.Assert$$Boolean(tokens.length % 2 == 0);
            var ret = new Array((tokens.length / 2) | 0);
            for (var i = 0; i < tokens.length - 1; i += 2){
                var x,y;
                if ((function (){
                    var $1 = {
                        Value: x
                    };
                    var $res = System.Double.TryParse$$String$$Double(tokens[i], $1);
                    x = $1.Value;
                    return $res;
                }).call(this) && (function (){
                    var $1 = {
                        Value: y
                    };
                    var $res = System.Double.TryParse$$String$$Double(tokens[i + 1], $1);
                    y = $1.Value;
                    return $res;
                }).call(this))
                    ret[(i / 2) | 0] = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x, y);
                else
                    this.Error("invalid point format" + str);
            }
            return ret;
        },
        ReadArrowheadAtTarget: function (edge){
            var str = this.GetAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.At);
            var arrowhead = (function ($p8){
                edge.get_EdgeGeometry().set_TargetArrowhead($p8);
                return $p8;
            }).call(this, str != null ? (function (){
                var $v21 = new Microsoft.Msagl.Core.Layout.Arrowhead.ctor();
                $v21.set_TipPosition(this.ParsePoint(str));
                return $v21;
            }).call(this) : null);
            if (arrowhead != null)
                arrowhead.set_Length(this.GetDoubleAttributeOrDefault(Microsoft.Msagl.DebugHelpers.GeometryToken.Atl, 10));
            else {
                str = this.GetAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Atl);
                if (str != null)
                    edge.get_EdgeGeometry().set_TargetArrowhead((function (){
                        var $v22 = new Microsoft.Msagl.Core.Layout.Arrowhead.ctor();
                        $v22.set_Length(this.ParseDouble(str));
                        return $v22;
                    }).call(this));
            }
        },
        ReadLabelFromAttribute: function (geomObj){
            var str;
            if (!(function (){
                var $1 = {
                    Value: str
                };
                var $res = this.TryGetAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Label, $1);
                str = $1.Value;
                return $res;
            }).call(this))
                return;
            var label = new Microsoft.Msagl.Core.Layout.Label.ctor$$GeometryObject(geomObj);
            var center;
            var width,height;
            (function (){
                var $1 = {
                    Value: center
                };
                var $2 = {
                    Value: width
                };
                var $3 = {
                    Value: height
                };
                var $res = this.ParseLabel(str, $1, $2, $3);
                center = $1.Value;
                width = $2.Value;
                height = $3.Value;
                return $res;
            }).call(this);
            label.set_Center(center);
            label.set_Width(width);
            label.set_Height(height);
            var edge = As(geomObj, Microsoft.Msagl.Core.Layout.Edge.ctor);
            if (edge != null){
                edge.set_Label(label);
            }
        },
        ParseLabel: function (str, center, width, height){
            var ss = str.Split$$Char$Array(" ");
            System.Diagnostics.Debug.Assert$$Boolean(ss.length == 4);
            center.Value = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.ParseDouble(ss[0]), this.ParseDouble(ss[1]));
            width.Value = this.ParseDouble(ss[2]);
            height.Value = this.ParseDouble(ss[3]);
        },
        ParseDouble: function (s){
            var ret;
            if ((function (){
                var $1 = {
                    Value: ret
                };
                var $res = System.Double.TryParse$$String$$Double(s, $1);
                ret = $1.Value;
                return $res;
            }).call(this))
                return ret;
            this.Error(" cannot parse double " + s);
            return 0;
        },
        ReadTargetNode: function (){
            var targetId = this.GetMustAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.T);
            return this.GetNodeOrClusterById(targetId);
        },
        ReadSourceNode: function (){
            var id = this.GetMustAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.S);
            return this.GetNodeOrClusterById(id);
        },
        GetNodeOrClusterById: function (id){
            var ret;
            if ((function (){
                var $1 = {
                    Value: ret
                };
                var $res = this.nodeIdToNodes.TryGetValue(id, $1);
                ret = $1.Value;
                return $res;
            }).call(this))
                return ret;
            return this.stringToClusters.get_Item$$TKey(id).Cluster;
        },
        ReadNodes: function (){
            if (this.get_XmlReader().get_IsEmptyElement())
                return;
            this.XmlRead();
            while (this.TokenIs(Microsoft.Msagl.DebugHelpers.GeometryToken.Node))
                this.ReadNode();
            this.ReadEndElement();
        },
        ReadNode: function (){
            var nodeId = this.GetMustAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Id);
            var nodePadding = this.GetDoubleAttributeOrDefault(Microsoft.Msagl.DebugHelpers.GeometryToken.Padding, 1);
            this.XmlRead();
            var node = (function (){
                var $v23 = new Microsoft.Msagl.Core.Layout.Node.ctor$$ICurve(this.ReadICurve());
                $v23.set_Padding(nodePadding);
                $v23.set_UserData(nodeId);
                return $v23;
            }).call(this);
            if (node.get_BoundaryCurve() == null)
                throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            this.graph.get_Nodes().Add(node);
            this.get_XmlReader().Skip();
            this.ReadEndElement();
            this.nodeIdToNodes.set_Item$$TKey(nodeId, node);
        },
        GetAttribute: function (token){
            return this.get_XmlReader().GetAttribute$$String(Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.FirstCharToLower(token));
        },
        TryGetAttribute: function (token, val){
            return (val.Value = this.GetAttribute(token)) != null;
        },
        GetMustAttribute: function (token){
            var s = Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.FirstCharToLower(token);
            var ret = this.get_XmlReader().GetAttribute$$String(Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.FirstCharToLower(token));
            if (ret != null)
                return ret;
            this.Error("attribute " + s + " not found");
            return null;
        },
        GetIntAttribute: function (token){
            var val = this.GetAttribute(token);
            if (val == null)
                this.Error(System.String.Format$$String$$Object("attribute {0} not found", token));
            var ret;
            if ((function (){
                var $1 = {
                    Value: ret
                };
                var $res = System.Int32.TryParse$$String$$Int32(val, $1);
                ret = $1.Value;
                return $res;
            }).call(this))
                return ret;
            this.Error("cannot parse an int value " + val);
            return 0;
        },
        GetDoubleAttribute: function (token){
            var val = this.GetAttribute(token);
            if (val == null)
                this.Error(System.String.Format$$String$$Object("attribute {0} not found", token));
            var ret;
            if ((function (){
                var $1 = {
                    Value: ret
                };
                var $res = System.Double.TryParse$$String$$Double(val, $1);
                ret = $1.Value;
                return $res;
            }).call(this))
                return ret;
            this.Error("cannot parse an int value " + val);
            return 0;
        },
        GetDoubleAttributeOrDefault: function (token, defaultVal){
            var val = this.GetAttribute(token);
            if (val == null)
                return defaultVal;
            var ret;
            if ((function (){
                var $1 = {
                    Value: ret
                };
                var $res = System.Double.TryParse$$String$$Double(val, $1);
                ret = $1.Value;
                return $res;
            }).call(this))
                return ret;
            this.Error("cannot parse a double value " + val);
            return 0;
        },
        GetBoolAttributeOrDefault: function (token, defaultVal){
            var val = this.GetAttribute(token);
            if (val == null)
                return defaultVal;
            var ret;
            if ((function (){
                var $1 = {
                    Value: ret
                };
                var $res = System.Boolean.TryParse(val, $1);
                ret = $1.Value;
                return $res;
            }).call(this))
                return ret;
            this.Error("cannot parse a bool value " + val);
            return false;
        },
        GetIntAttributeOrDefault: function (token, defaultVal){
            var val = this.GetAttribute(token);
            if (val == null)
                return defaultVal;
            var ret;
            if ((function (){
                var $1 = {
                    Value: ret
                };
                var $res = System.Int32.TryParse$$String$$Int32(val, $1);
                ret = $1.Value;
                return $res;
            }).call(this))
                return ret;
            this.Error("cannot parse a bool value " + val);
            return 0;
        },
        TryGetPointAttribute: function (token){
            var val = this.GetAttribute(token);
            return val == null ? new Microsoft.Msagl.Core.Geometry.Point.ctor() : this.ParsePoint(val);
        },
        Error: function (msg){
            throw $CreateException(new System.InvalidOperationException.ctor$$String(msg + ";" + this.GetPositionInfo()), new Error());
        },
        ReadICurve: function (){
            switch (this.NameToToken()){
                case Microsoft.Msagl.DebugHelpers.GeometryToken.Curve:
                    return this.ReadCurve();
                case Microsoft.Msagl.DebugHelpers.GeometryToken.Ellipse:
                    return this.ReadEllipse();
                case Microsoft.Msagl.DebugHelpers.GeometryToken.Rect:
                    return this.ReadRect();
                case Microsoft.Msagl.DebugHelpers.GeometryToken.Polygon:
                    return this.ReadPolygon();
            }
            return null;
        },
        ReadPolygon: function (){
            var pointString = this.GetMustAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Points);
            var t = pointString.Split$$Char$Array(" ");
            if (t.length == 0 || t.length % 2 != 0)
                this.Error("invalid input for the polygon");
            var poly = (function (){
                var $v24 = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
                $v24.set_Closed(true);
                return $v24;
            }).call(this);
            for (var i = 0; i < t.length; i += 2)
                poly.AddPoint$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.ParseDouble(t[i]), this.ParseDouble(t[i + 1])));
            return poly;
        },
        ReadRect: function (){
            var y;
            var width;
            var height;
            var rx;
            var ry;
            var x;
            (function (){
                var $1 = {
                    Value: x
                };
                var $2 = {
                    Value: y
                };
                var $3 = {
                    Value: width
                };
                var $4 = {
                    Value: height
                };
                var $5 = {
                    Value: rx
                };
                var $6 = {
                    Value: ry
                };
                var $res = this.ReadRectParams($1, $2, $3, $4, $5, $6);
                x = $1.Value;
                y = $2.Value;
                width = $3.Value;
                height = $4.Value;
                rx = $5.Value;
                ry = $6.Value;
                return $res;
            }).call(this);
            var box = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Double$$Double$$Double$$Double(x, y, x + width, y + height);
            return new Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.ctor$$Rectangle$$Double$$Double(box, rx, ry);
        },
        ReadRectParams: function (x, y, width, height, rx, ry){
            x.Value = this.GetDoubleAttributeOrDefault(Microsoft.Msagl.DebugHelpers.GeometryToken.X, 0);
            y.Value = this.GetDoubleAttributeOrDefault(Microsoft.Msagl.DebugHelpers.GeometryToken.Y, 0);
            width.Value = this.ParseDouble(this.GetMustAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Width));
            height.Value = this.ParseDouble(this.GetMustAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Height));
            rx.Value = this.GetDoubleAttributeOrDefault(Microsoft.Msagl.DebugHelpers.GeometryToken.Rx, 0);
            ry.Value = this.GetDoubleAttributeOrDefault(Microsoft.Msagl.DebugHelpers.GeometryToken.Ry, 0);
        },
        ReadCurve: function (){
            if (this.get_XmlReader().MoveToFirstAttribute()){
                var token = this.NameToToken();
                switch (token){
                    case Microsoft.Msagl.DebugHelpers.GeometryToken.CurveData:
                        return this.ParseCurve(this.get_XmlReader().get_Value());
                }
                throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            }
            this.Error("No boundary curve is defined");
            return null;
        },
        NameToToken: function (){
            var token;
            if ((function (){
                var $1 = {
                    Value: token
                };
                var $res = System.Enum.TryParse$1$$String$$Boolean$$TEnum(Microsoft.Msagl.DebugHelpers.GeometryToken.ctor, this.get_XmlReader().get_Name(), true, $1);
                token = $1.Value;
                return $res;
            }).call(this))
                return token;
            this.Error("cannot parse " + this.get_XmlReader().get_Name());
            return Microsoft.Msagl.DebugHelpers.GeometryToken.Error;
        },
        ParseCurve: function (curveData){
            var curve = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor();
            var curveStream = new Microsoft.Msagl.DebugHelpers.CurveStream.ctor(curveData);
            var currentPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            do{
                var curveStreamElement = curveStream.GetNextCurveStreamElement();
                if (curveStreamElement == null)
                    return curve;
                var charStreamElement = As(curveStreamElement, Microsoft.Msagl.DebugHelpers.Persistence.CharStreamElement.ctor);
                if (charStreamElement == null){
                    this.Error("wrong formatted curve string " + curveStreamElement);
                    return null;
                }
                (function (){
                    var $1 = {
                        Value: currentPoint
                    };
                    var $res = this.AddCurveSegment(curveStream, charStreamElement.get_Char(), curve, $1);
                    currentPoint = $1.Value;
                    return $res;
                }).call(this);
            }
            while (true)
        },
        AddCurveSegment: function (curveStream, c, curve, currentPoint){
            switch (c){
                case "M":
                    currentPoint.Value = this.GetNextPointFromCurveData(curveStream);
                    break;
                case "m":
                    throw $CreateException(new System.NotImplementedException.ctor(), new Error());
                case "Z":
                case "z":
                    if (curve.get_Segments().get_Count() == 0)
                    this.Error("the curve is too short");
                    curve.AddSegment(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(currentPoint.Value, currentPoint.Value = curve.get_Start()));
                    break;
                case "L":
                    this.ProceedWithLines(curve, curveStream, currentPoint);
                    break;
                case "l":
                    throw $CreateException(new System.NotImplementedException.ctor(), new Error());
                case "H":
                    throw $CreateException(new System.NotImplementedException.ctor(), new Error());
                case "h":
                    throw $CreateException(new System.NotImplementedException.ctor(), new Error());
                case "V":
                    throw $CreateException(new System.NotImplementedException.ctor(), new Error());
                case "v":
                    throw $CreateException(new System.NotImplementedException.ctor(), new Error());
                case "C":
                    this.ProceedWithCubicBeziers(curve, curveStream, currentPoint);
                    break;
                case "c":
                    throw $CreateException(new System.NotImplementedException.ctor(), new Error());
                case "S":
                    throw $CreateException(new System.NotImplementedException.ctor(), new Error());
                case "s":
                    throw $CreateException(new System.NotImplementedException.ctor(), new Error());
                case "Q":
                    throw $CreateException(new System.NotImplementedException.ctor(), new Error());
                case "q":
                    throw $CreateException(new System.NotImplementedException.ctor(), new Error());
                case "T":
                    throw $CreateException(new System.NotImplementedException.ctor(), new Error());
                case "t":
                    throw $CreateException(new System.NotImplementedException.ctor(), new Error());
                case "A":
                    this.ReadEllepticalArc$$Curve$$CurveStream$$Point(curve, curveStream, currentPoint);
                    break;
                case "a":
                    throw $CreateException(new System.NotImplementedException.ctor(), new Error());
                default:
                    this.Error("unknown character " + c);
                    break;
            }
        },
        ProceedWithCubicBeziers: function (curve, curveStream, currentPoint){
            do{
                curve.AddSegment(new Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ctor(currentPoint.Value, this.GetNextPointFromCurveData(curveStream), this.GetNextPointFromCurveData(curveStream), currentPoint.Value = this.GetNextPointFromCurveData(curveStream)));
            }
            while (Is(curveStream.PickNextCurveStreamElement(), Microsoft.Msagl.DebugHelpers.DoubleStreamElement.ctor))
        },
        ReadEllepticalArc$$Curve$$CurveStream$$Point: function (curve, curveStream, currentPoint){
            curve.AddSegment(this.ReadEllepticalArc$$CurveStream$$Point(curveStream, currentPoint));
        },
        ReadEllepticalArc$$CurveStream$$Point: function (curveStream, currentPoint){
            var rx = this.GetNextDoubleFromCurveData(curveStream);
            var ry = this.GetNextDoubleFromCurveData(curveStream);
            var xAxisRotation = this.GetNextDoubleFromCurveData(curveStream) / 180 * 3.14159265358979;
            var largeArcFlag = (this.GetNextDoubleFromCurveData(curveStream)) | 0;
            var sweepFlag = (this.GetNextDoubleFromCurveData(curveStream)) | 0;
            var endPoint = this.GetNextPointFromCurveData(curveStream);
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(rx, 0) || Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(ry, 0))
                this.Error("ellipseArc radius is too small");
            var yScale = rx / ry;
            var rotationMatrix = Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.Rotation(-xAxisRotation);
            var scaleMatrix = new Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.ctor$$Double$$Double$$Double$$Double$$Double$$Double(1, 0, 0, 0, yScale, 0);
            var transform = Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$PlaneTransformation(scaleMatrix, rotationMatrix);
            var start = Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(transform, currentPoint.Value);
            currentPoint.Value = endPoint;
            var end = Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(transform, endPoint);
            var center;
            var startAngle;
            var endAngle;
            var axisY;
            (function (){
                var $1 = {
                    Value: center
                };
                var $2 = {
                    Value: startAngle
                };
                var $3 = {
                    Value: endAngle
                };
                var $4 = {
                    Value: axisY
                };
                var $res = this.GetArcCenterAndAngles(rx, largeArcFlag, sweepFlag, start, end, $1, $2, $3, $4);
                center = $1.Value;
                startAngle = $2.Value;
                endAngle = $3.Value;
                axisY = $4.Value;
                return $res;
            }).call(this);
            var inverted = transform.get_Inverse();
            center = Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(inverted, center);
            var rotation = Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.Rotation(xAxisRotation);
            var axisX = Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(rotation, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(rx, 0));
            axisY = Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(rotation, (Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(axisY, yScale)));
            var ret = new Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor$$Double$$Double$$Point$$Point$$Point(startAngle, endAngle, axisX, axisY, center);
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(ret.get_End(), endPoint));
            return ret;
        },
        GetArcCenterAndAngles: function (r, largeArcFlag, sweepFlag, start, end, center, startAngle, endAngle, axisY){
            var d = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(end, start);
            var dLenSquared = d.get_LengthSquared();
            var dLen = d.get_Length();
            var middle = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Addition(start, end)), 2);
            d = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(d, dLen);
            var perp = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(d.get_Y(), -d.get_X()), System.Math.Sqrt(r * r - dLenSquared / 4));
            center.Value = sweepFlag == 1 && largeArcFlag == 0 || sweepFlag == 0 && largeArcFlag == 1 ? Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(middle, perp) : Microsoft.Msagl.Core.Geometry.Point.op_Addition(middle, perp);
            var axisX = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(r, 0);
            axisY.Value = sweepFlag == 1 ? new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, r) : new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, -r);
            startAngle.Value = Microsoft.Msagl.Core.Geometry.Point.Angle$$Point$$Point(axisX, Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(start, center.Value));
            if (sweepFlag == 0)
                startAngle.Value = 6.28318530717959 - startAngle.Value;
            endAngle.Value = Microsoft.Msagl.Core.Geometry.Point.Angle$$Point$$Point(axisX, Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(end, center.Value));
            if (sweepFlag == 0)
                endAngle.Value = 6.28318530717959 - endAngle.Value;
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(endAngle.Value, startAngle.Value) && largeArcFlag == 1)
                endAngle.Value += 6.28318530717959;
            else if (endAngle.Value < startAngle.Value)
                endAngle.Value += 6.28318530717959;
        },
        ProceedWithLines: function (curve, curveStream, currentPoint){
            do{
                curve.AddSegment(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(currentPoint.Value, currentPoint.Value = this.GetNextPointFromCurveData(curveStream)));
            }
            while (Is(curveStream.PickNextCurveStreamElement(), Microsoft.Msagl.DebugHelpers.DoubleStreamElement.ctor))
        },
        GetNextPointFromCurveData: function (curveStream){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.GetNextDoubleFromCurveData(curveStream), this.GetNextDoubleFromCurveData(curveStream));
        },
        GetNextDoubleFromCurveData: function (curveStream){
            var a = curveStream.GetNextCurveStreamElement();
            if (a == null)
                this.Error("cannot parse curveData");
            var d = As(a, Microsoft.Msagl.DebugHelpers.DoubleStreamElement.ctor);
            if (d == null)
                this.Error("cannot parse curveData");
            return d.get_Double();
        },
        ReadLineSeg: function (){
            this.CheckToken(Microsoft.Msagl.DebugHelpers.GeometryToken.LineSegment);
            var str = this.GetAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Points);
            var ss = str.Split$$Char$Array(" ");
            if (ss.length != 4)
                this.Error("wrong number of points in LineSegment");
            var ds = System.Linq.Enumerable.ToArray$1(System.Double.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.String.ctor, System.Double.ctor, ss, $CreateDelegate(this, this.ParseDouble)));
            return new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(ds[0], ds[1]), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(ds[2], ds[3]));
        },
        ReadEllipse: function (){
            var cx = this.ParseDouble(this.GetMustAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Cx));
            var cy = this.ParseDouble(this.GetMustAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Cy));
            var rx = this.ParseDouble(this.GetMustAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Rx));
            var ry = this.ParseDouble(this.GetMustAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Ry));
            return new Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor$$Double$$Double$$Point(rx, ry, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(cx, cy));
        },
        TokenIs: function (t){
            return this.get_XmlReader().IsStartElement$$String(Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.FirstCharToLower(t)) || this.get_XmlReader().IsStartElement$$String(t.toString());
        },
        MoveToContent: function (){
            this.get_XmlReader().MoveToContent();
        },
        XmlReader$$: "System.Xml.XmlReader",
        get_XmlReader: function (){
            return this._XmlReader;
        },
        set_XmlReader: function (value){
            this._XmlReader = value;
        },
        SetXmlReader: function (reader){
            this.set_XmlReader(reader);
        },
        CheckToken: function (token){
            if (!this.get_XmlReader().IsStartElement$$String(Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.FirstCharToLower(token)) && !this.get_XmlReader().IsStartElement$$String(token.toString())){
                var positionInfo = this.GetPositionInfo();
                throw $CreateException(new System.IO.InvalidDataException.ctor$$String(System.String.Format$$IFormatProvider$$String$$Object$Array(System.Globalization.CultureInfo.get_InvariantCulture(), "expected {0}, {1}", [token, positionInfo])), new Error());
            }
        },
        GetPositionInfo: function (){
            if (this.xmlTextReader != null)
                return System.String.Format$$IFormatProvider$$String$$Object$Array(System.Globalization.CultureInfo.get_InvariantCulture(), "line {0} col {1}", [this.xmlTextReader.get_LineNumber(), this.xmlTextReader.get_LinePosition()]);
            return System.String.Empty;
        },
        ReadEndElement: function (){
            this.get_XmlReader().ReadEndElement();
        },
        ReadElementContentAsDouble: function (){
            return this.get_XmlReader().ReadElementContentAsDouble();
        },
        XmlRead: function (){
            this.get_XmlReader().Read();
        },
        ReadElementContentAsInt: function (){
            return this.get_XmlReader().ReadElementContentAsInt();
        },
        Dispose$$Boolean: function (disposing){
            if (disposing)
                this.xmlTextReader.Close();
        },
        Dispose: function (){
            this.Dispose$$Boolean(true);
            System.GC.SuppressFinalize(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$DebugHelpers$Persistence$GeometryGraphReader);
var Microsoft$Msagl$DebugHelpers$Persistence$GeometryGraphWriter = {
    fullname: "Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.FileExtension = ".msagl.geom";
        },
        Write$$GeometryGraph$$String: function (graph, fileName){
            Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.Write$$GeometryGraph$$LayoutAlgorithmSettings$$String(graph, null, fileName);
        },
        Write$$GeometryGraph$$LayoutAlgorithmSettings$$String: function (graph, settings, fileName){
            if (fileName == null)
                return;
            if (!fileName.EndsWith$$String$$StringComparison(".msagl.geom", 3))
                fileName += ".msagl.geom";
            var stream = System.IO.File.Open$$String$$FileMode(fileName, 2);
            try{
                var graphWriter = new Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.ctor$$Stream$$GeometryGraph$$LayoutAlgorithmSettings(stream, graph, settings);
                graphWriter.Write();
            }
            finally{
                stream.Dispose();
            }
        },
        FirstCharToLower: function (attrKind){
            var attrString = attrKind.toString();
            attrString = attrString.substr(0, 1).toLowerCase$$CultureInfo(System.Globalization.CultureInfo.get_InvariantCulture()) + attrString.substr(1, attrString.length - 1);
            return attrString;
        },
        WriteEllepticalArc: function (ellipse){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        AxesSwapped: function (axisA, axisB){
            return axisA.get_X() * axisB.get_Y() - axisB.get_X() * axisA.get_Y() < 0;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$Stream$$GeometryGraph$$LayoutAlgorithmSettings: function (streamPar, graphP, settings){
            this.nodeIds = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, System.String.ctor);
            this.edgeIds = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor, System.Int32.ctor);
            this.graph = null;
            this.needToCloseXmlWriter = true;
            this.stream = null;
            this.formatForDoubleString = "#.###########";
            this.precision = 11;
            this.edgeEnumeration = null;
            this._XmlWriter = null;
            this._Settings = null;
            System.Object.ctor.call(this);
            this.stream = streamPar;
            this.set_Graph(graphP);
            this.set_Settings(settings);
            var xmlWriterSettings = (function (){
                var $v25 = new System.Xml.XmlWriterSettings.ctor();
                $v25.set_Indent(true);
                return $v25;
            }).call(this);
            this.set_XmlWriter(System.Xml.XmlWriter.Create$$Stream$$XmlWriterSettings(this.stream, xmlWriterSettings));
            this.set_EdgeEnumeration(graphP.get_Edges());
        },
        ctor: function (){
            this.nodeIds = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, System.String.ctor);
            this.edgeIds = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor, System.Int32.ctor);
            this.graph = null;
            this.needToCloseXmlWriter = true;
            this.stream = null;
            this.formatForDoubleString = "#.###########";
            this.precision = 11;
            this.edgeEnumeration = null;
            this._XmlWriter = null;
            this._Settings = null;
            System.Object.ctor.call(this);
        },
        NeedToCloseXmlWriter$$: "System.Boolean",
        get_NeedToCloseXmlWriter: function (){
            return this.needToCloseXmlWriter;
        },
        set_NeedToCloseXmlWriter: function (value){
            this.needToCloseXmlWriter = value;
        },
        Stream$$: "System.IO.Stream",
        get_Stream: function (){
            return this.stream;
        },
        set_Stream: function (value){
            this.stream = value;
        },
        XmlWriter$$: "System.Xml.XmlWriter",
        get_XmlWriter: function (){
            return this._XmlWriter;
        },
        set_XmlWriter: function (value){
            this._XmlWriter = value;
        },
        Graph$$: "Microsoft.Msagl.Core.Layout.GeometryGraph",
        get_Graph: function (){
            return this.graph;
        },
        set_Graph: function (value){
            this.graph = value;
        },
        Settings$$: "Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings",
        get_Settings: function (){
            return this._Settings;
        },
        set_Settings: function (value){
            this._Settings = value;
        },
        Write: function (){
            var currentCulture = System.Threading.Thread.get_CurrentThread().get_CurrentCulture();
            System.Threading.Thread.get_CurrentThread().set_CurrentCulture(System.Globalization.CultureInfo.get_InvariantCulture());
            try{
                this.Open();
                this.WriteLayoutSettings();
                this.InitEdgeIds();
                this.WriteNodes();
                this.WriteClusters();
                this.WriteEdges();
                this.WriteLayers();
                this.Close();
            }
            finally{
                System.Threading.Thread.get_CurrentThread().set_CurrentCulture(currentCulture);
            }
        },
        WriteLayers: function (){
            if (this.graph.get_LgData() == null)
                return;
            this.WriteStartElement(Microsoft.Msagl.DebugHelpers.GeometryToken.LgLevels);
            this.WriteLgEdgeInfos();
            this.WriteSortedLgInfos();
            var railIds = this.CreateRailIds();
            for (var i = 0; i < this.graph.get_LgData().get_Levels().get_Count(); i++){
                this.WriteLevel(this.graph.get_LgData().get_Levels().get_Item$$Int32(i), railIds, this.graph.get_LgData().get_LevelNodeCounts().get_Item$$Int32(i));
            }
            this.WriteEndElement();
        },
        WriteLgEdgeInfos: function (){
            this.WriteStartElement(Microsoft.Msagl.DebugHelpers.GeometryToken.LgEdgeInfos);
            var $it67 = this.graph.get_LgData().GeometryEdgesToLgEdgeInfos.GetEnumerator();
            while ($it67.MoveNext()){
                var t = $it67.get_Current();
                var edge = t.get_Key();
                var ei = t.get_Value();
                this.WriteLgEdgeInfo(edge, ei);
            }
            this.WriteEndElement();
        },
        WriteLgEdgeInfo: function (edge, ei){
            this.WriteStartElement(Microsoft.Msagl.DebugHelpers.GeometryToken.LgEdgeInfo);
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.EdgeId, this.edgeIds.get_Item$$TKey(edge));
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Rank, ei.get_Rank());
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Zoomlevel, ei.get_ZoomLevel());
            this.WriteEndElement();
        },
        WriteLevel: function (level, railsToIds, nodeCountOnLevel){
            this.WriteStartElement(Microsoft.Msagl.DebugHelpers.GeometryToken.Level);
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.NodeCountOnLevel, nodeCountOnLevel);
            this.WriteLevelRails(level, railsToIds);
            this.WriteEndElement();
        },
        WriteLevelRails: function (level, railIds){
            this.WriteStartElement(Microsoft.Msagl.DebugHelpers.GeometryToken.RailsPerEdge);
            var $it68 = level._railsOfEdges.GetEnumerator();
            while ($it68.MoveNext()){
                var t = $it68.get_Current();
                this.WriteEdgeRails(t.get_Key(), t.get_Value(), railIds);
            }
            this.WriteEndElement();
            this.WriteRailsGeometry(level, railIds);
        },
        WriteRailsGeometry: function (level, railIds){
            this.WriteStartElement(Microsoft.Msagl.DebugHelpers.GeometryToken.Rails);
            var $it69 = level._railDictionary.get_Values().GetEnumerator();
            while ($it69.MoveNext()){
                var rail = $it69.get_Current();
                this.WriteRail(rail, railIds.get_Item$$TKey(rail));
            }
            this.WriteEndElement();
        },
        WriteRail: function (rail, railId){
            this.WriteStartElement(Microsoft.Msagl.DebugHelpers.GeometryToken.Rail);
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Id, railId);
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Zoomlevel, rail.ZoomLevel);
            var ah = As(rail.Geometry, Microsoft.Msagl.Core.Layout.Arrowhead.ctor);
            if (ah != null){
                this.WriteStartElement(Microsoft.Msagl.DebugHelpers.GeometryToken.Arrowhead);
                this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.ArrowheadPosition, ah.get_TipPosition());
                this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.CurveAttachmentPoint, rail.CurveAttachmentPoint);
                this.WriteEndElement();
            }
            else {
                var curve = As(rail.Geometry, Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor);
                if (curve != null)
                    this.WriteICurve(curve);
                else
                    throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            }
            this.WriteEndElement();
        },
        WriteEdgeRails: function (edge, rails, railIds){
            this.WriteStartElement(Microsoft.Msagl.DebugHelpers.GeometryToken.EdgeRails);
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.EdgeId, this.edgeIds.get_Item$$TKey(edge));
            var railIdStrings = new System.Collections.Generic.List$1.ctor(System.String.ctor);
            var $it70 = rails.GetEnumerator();
            while ($it70.MoveNext()){
                var rail = $it70.get_Current();
                railIdStrings.Add(railIds.get_Item$$TKey(rail).toString());
            }
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.EdgeRails, System.String.Join$$String$$IEnumerable$1$String(" ", railIdStrings));
            this.WriteEndElement();
        },
        CreateRailIds: function (){
            var ret = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Layout.LargeGraphLayout.Rail.ctor, System.Int32.ctor);
            var id = 0;
            var $it71 = this.graph.get_LgData().get_Levels().GetEnumerator();
            while ($it71.MoveNext()){
                var level = $it71.get_Current();
                var $it72 = level._railDictionary.get_Values().GetEnumerator();
                while ($it72.MoveNext()){
                    var rail = $it72.get_Current();
                    if (ret.ContainsKey(rail)){
                        continue;
                    }
                    ret.set_Item$$TKey(rail, id++);
                }
            }
            return ret;
        },
        WriteSortedLgInfos: function (){
            this.WriteStartElement(Microsoft.Msagl.DebugHelpers.GeometryToken.LgNodeInfos);
            var $it73 = this.graph.get_LgData().get_SortedLgNodeInfos().GetEnumerator();
            while ($it73.MoveNext()){
                var lgNodeInfo = $it73.get_Current();
                this.WriteLgNodeInfo(lgNodeInfo);
            }
            this.WriteEndElement();
        },
        WriteLgNodeInfo: function (lgNodeInfo){
            this.WriteStartElement(Microsoft.Msagl.DebugHelpers.GeometryToken.LgNodeInfo);
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Id, this.nodeIds.get_Item$$TKey(lgNodeInfo.get_GeometryNode()));
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Rank, lgNodeInfo.get_Rank());
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Zoomlevel, lgNodeInfo.get_ZoomLevel());
            this.WriteEndElement();
        },
        InitEdgeIds: function (){
            var id = 0;
            var $it74 = this.graph.get_Edges().GetEnumerator();
            while ($it74.MoveNext()){
                var e = $it74.get_Current();
                this.edgeIds.set_Item$$TKey(e, id++);
            }
        },
        WriteClusters: function (){
            if (this.graph.get_RootCluster() == null)
                return;
            this.WriteStartElement(Microsoft.Msagl.DebugHelpers.GeometryToken.Clusters);
            this.MapClustersToIds(this.graph.get_RootCluster());
            var $it75 = this.graph.get_RootCluster().AllClustersDepthFirstExcludingSelf().GetEnumerator();
            while ($it75.MoveNext()){
                var cluster = $it75.get_Current();
                this.WriteCluster(cluster, this.nodeIds.get_Item$$TKey(cluster));
            }
            this.WriteEndElement();
        },
        WriteCluster: function (cluster, clusterId){
            this.WriteStartElement(Microsoft.Msagl.DebugHelpers.GeometryToken.Cluster);
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Id, clusterId);
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Barycenter, cluster.Barycenter);
            this.WriteChildClusters(cluster);
            this.WriteChildNodes(cluster);
            if (cluster.get_BoundaryCurve() != null)
                this.WriteICurve(cluster.get_BoundaryCurve());
            this.WriteClusterRectBoundary(cluster.get_RectangularBoundary());
            this.WriteEndElement();
        },
        WriteClusterRectBoundary: function (recClBnd){
            if (recClBnd == null)
                return;
            this.WriteStartElement(Microsoft.Msagl.DebugHelpers.GeometryToken.RectangularClusterBoundary);
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.LeftMargin, recClBnd.get_LeftMargin());
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.RightMargin, recClBnd.get_RightMargin());
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.TopMargin, recClBnd.get_TopMargin());
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.BottomMargin, recClBnd.get_BottomMargin());
            if (recClBnd.get_DefaultMarginIsSet()){
                this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.DefaultLeftMargin, recClBnd.get_DefaultLeftMargin());
                this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.DefaultRightMargin, recClBnd.get_DefaultRightMargin());
                this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.DefaultTopMargin, recClBnd.get_DefaultTopMargin());
                this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.DefaultBottomMargin, recClBnd.get_DefaultBottomMargin());
            }
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.GenerateFixedConstraints, recClBnd.get_GenerateFixedConstraints());
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.GenerateFixedConstraintsDefault, recClBnd.get_GenerateFixedConstraintsDefault());
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.MinNodeHeight, recClBnd.get_MinHeight());
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.MinNodeWidth, recClBnd.get_MinWidth());
            this.WriteRect(recClBnd.get_Rect().get_Left(), recClBnd.get_Rect().get_Bottom(), recClBnd.get_Rect().get_Width(), recClBnd.get_Rect().get_Height(), recClBnd.get_RadiusX(), recClBnd.get_RadiusY());
            this.WriteBorderInfo(Microsoft.Msagl.DebugHelpers.GeometryToken.RightBorderInfo, recClBnd.get_RightBorderInfo());
            this.WriteBorderInfo(Microsoft.Msagl.DebugHelpers.GeometryToken.LeftBorderInfo, recClBnd.get_LeftBorderInfo());
            this.WriteBorderInfo(Microsoft.Msagl.DebugHelpers.GeometryToken.TopBorderInfo, recClBnd.get_TopBorderInfo());
            this.WriteBorderInfo(Microsoft.Msagl.DebugHelpers.GeometryToken.BottomBorderInfo, recClBnd.get_BottomBorderInfo());
            this.WriteEndElement();
        },
        WriteBorderInfo: function (token, borderInfo){
            this.WriteStartElement(token);
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.InnerMargin, borderInfo.get_InnerMargin());
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.FixedPosition, borderInfo.get_FixedPosition());
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Weight, borderInfo.get_Weight());
            this.WriteEndElement();
        },
        WriteChildNodes: function (cluster){
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.ChildNodes, System.String.Join$$String$$IEnumerable$1$String(" ", System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Node.ctor, System.String.ctor, cluster.nodes, $CreateAnonymousDelegate(this, function (child){
                return this.nodeIds.get_Item$$TKey(child).ToString$$IFormatProvider(System.Globalization.CultureInfo.get_InvariantCulture());
            }))));
        },
        WriteChildClusters: function (cluster){
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.ChildClusters, System.String.Join$$String$$IEnumerable$1$String(" ", System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Cluster.ctor, System.String.ctor, cluster.get_Clusters(), $CreateAnonymousDelegate(this, function (child){
                return this.get_NodeToIds().get_Item$$TKey(child);
            }))));
        },
        MapClustersToIds: function (cluster){
            var id;
            var setOfIds = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(System.String.ctor, this.nodeIds.get_Values());
            var $it76 = cluster.AllClustersDepthFirst().GetEnumerator();
            while ($it76.MoveNext()){
                var child = $it76.get_Current();
                if (!(function (){
                    var $1 = {
                        Value: id
                    };
                    var $res = this.nodeIds.TryGetValue(child, $1);
                    id = $1.Value;
                    return $res;
                }).call(this)){
                    id = this.FindNewId(setOfIds);
                    this.nodeIds.set_Item$$TKey(child, id);
                    setOfIds.Insert(id);
                }
            }
        },
        FindNewId: function (setOfIds){
            var i = this.nodeIds.get_Count();
            do{
                var s = i.toString();
                if (!setOfIds.Contains$$T(s))
                    return s;
                i++;
            }
            while (true)
        },
        Open: function (){
            this.get_XmlWriter().WriteStartElement$$String$$String(Microsoft.Msagl.DebugHelpers.GeometryToken.Graph.toString().toLowerCase(), "http://schemas.microsoft.com/msagl/2010");
        },
        Close: function (){
            this.get_XmlWriter().WriteEndElement();
            if (this.get_NeedToCloseXmlWriter()){
                this.get_XmlWriter().WriteEndDocument();
                this.get_XmlWriter().Flush();
                this.get_XmlWriter().Close();
            }
        },
        WriteEdges: function (){
            this.WriteStartElement(Microsoft.Msagl.DebugHelpers.GeometryToken.Edges);
            var $it77 = this.get_EdgeEnumeration().GetEnumerator();
            while ($it77.MoveNext()){
                var edge = $it77.get_Current();
                this.WriteEdge(edge);
            }
            this.WriteEndElement();
        },
        NodeOrClusterId: function (node){
            return this.nodeIds.get_Item$$TKey(node);
        },
        WriteEdge: function (edge){
            this.WriteStartElement(Microsoft.Msagl.DebugHelpers.GeometryToken.Edge);
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Id, this.edgeIds.get_Item$$TKey(edge));
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.S, this.NodeOrClusterId(edge.get_Source()).ToString$$IFormatProvider(System.Globalization.CultureInfo.get_InvariantCulture()));
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.T, this.NodeOrClusterId(edge.get_Target()).ToString$$IFormatProvider(System.Globalization.CultureInfo.get_InvariantCulture()));
            if (edge.get_LineWidth() != 1)
                this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.LineWidth, edge.get_LineWidth());
            if (edge.get_ArrowheadAtSource()){
                this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.As, edge.get_EdgeGeometry().get_SourceArrowhead().get_TipPosition());
                this.WriteDefaultDouble(Microsoft.Msagl.DebugHelpers.GeometryToken.Asl, edge.get_EdgeGeometry().get_SourceArrowhead().get_Length(), 10);
            }
            if (edge.get_ArrowheadAtTarget()){
                this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.At, edge.get_EdgeGeometry().get_TargetArrowhead().get_TipPosition());
                this.WriteDefaultDouble(Microsoft.Msagl.DebugHelpers.GeometryToken.Atl, edge.get_EdgeGeometry().get_TargetArrowhead().get_Length(), 10);
            }
            if (edge.get_Weight() != 1)
                this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Weight, edge.get_Weight());
            if (edge.get_Separation() != 1)
                this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Separation, edge.get_Separation());
            if (edge.get_Label() != null)
                this.WriteLabel(edge.get_Label());
            this.WriteICurve(edge.get_Curve());
            this.WriteEndElement();
        },
        WriteDefaultDouble: function (geometryToken, val, defaultValue){
            if (val != defaultValue)
                this.WriteAttribute(geometryToken, this.DoubleToString(val));
        },
        WriteAttribute: function (attrKind, val){
            var attrString = Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.FirstCharToLower(attrKind);
            if (Is(val, Microsoft.Msagl.Core.Geometry.Point.ctor))
                this.get_XmlWriter().WriteAttributeString$$String$$String(attrString, this.PointToString(Cast(val, Microsoft.Msagl.Core.Geometry.Point.ctor)));
            else if (true)
                this.get_XmlWriter().WriteAttributeString$$String$$String(attrString, this.DoubleToString(val));
            else
                this.get_XmlWriter().WriteAttributeString$$String$$String(attrString, val.toString());
        },
        PointToString: function (start){
            return this.DoubleToString(start.get_X()) + " " + this.DoubleToString(start.get_Y());
        },
        Precision$$: "System.Int32",
        get_Precision: function (){
            return this.precision;
        },
        set_Precision: function (value){
            this.precision = System.Math.Max$$Int32$$Int32(1, value);
            var s = new Array(this.precision + 2);
            s[0] = "#";
            s[1] = ".";
            for (var i = 0; i < this.precision; i++)
                s[2 + i] = "#";
            this.formatForDoubleString = new System.String.ctor$$Char$Array(s);
        },
        NodeToIds$$: "System.Collections.Generic.Dictionary`2[[Microsoft.Msagl.Core.Layout.Node],[System.String]]",
        get_NodeToIds: function (){
            return this.nodeIds;
        },
        set_NodeToIds: function (value){
            this.nodeIds = value;
        },
        EdgeEnumeration$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Layout.Edge]]",
        get_EdgeEnumeration: function (){
            return this.edgeEnumeration;
        },
        set_EdgeEnumeration: function (value){
            this.edgeEnumeration = value;
        },
        DoubleToString: function (d){
            return (System.Math.Abs$$Double(d) < 1E-11) ? "0" : d.ToString$$String$$IFormatProvider(this.formatForDoubleString, System.Globalization.CultureInfo.get_InvariantCulture());
        },
        WriteLabel: function (label){
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Label, this.LabelToString(label));
        },
        LabelToString: function (label){
            return System.String.Format$$String$$Object$$Object$$Object("{0} {1} {2}", this.PointToString(label.get_Center()), this.DoubleToString(label.get_Width()), this.DoubleToString(label.get_Height()));
        },
        WriteNodes: function (){
            this.WriteStartElement(Microsoft.Msagl.DebugHelpers.GeometryToken.Nodes);
            var $it78 = this.get_Graph().get_Nodes().GetEnumerator();
            while ($it78.MoveNext()){
                var node = $it78.get_Current();
                this.WriteNode(node);
            }
            this.WriteEndElement();
        },
        WriteNode: function (node){
            var id;
            if (!(function (){
                var $1 = {
                    Value: id
                };
                var $res = this.nodeIds.TryGetValue(node, $1);
                id = $1.Value;
                return $res;
            }).call(this))
                this.nodeIds.set_Item$$TKey(node, id = this.nodeIds.get_Count().toString());
            this.WriteStartElement(Microsoft.Msagl.DebugHelpers.GeometryToken.Node);
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Id, id);
            if (node.get_Padding() != 1)
                this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Padding, node.get_Padding());
            this.WriteICurve(node.get_BoundaryCurve());
            this.WriteEndElement();
        },
        WriteICurve: function (iCurve){
            if (iCurve == null)
                return;
            var rect = As(iCurve, Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.ctor);
            if (rect != null)
                this.WriteRect(rect.get_BoundingBox().get_Left(), rect.get_BoundingBox().get_Bottom(), rect.get_BoundingBox().get_Width(), rect.get_BoundingBox().get_Height(), rect.get_RadiusX(), rect.get_RadiusY());
            else {
                var c = As(iCurve, Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor);
                if (c != null)
                    this.WriteCurveInSvgStyle(c);
                else {
                    var ellipse = As(iCurve, Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor);
                    if (ellipse != null)
                        this.WriteEllipseInSvgStyle(ellipse);
                    else {
                        var poly = As(iCurve, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
                        if (poly != null)
                            this.WritePolylineInSvgStyle(poly);
                        else {
                            var ls = As(iCurve, Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor);
                            if (ls != null)
                                this.WriteLineSeg(ls);
                            else {
                                var bs = As(iCurve, Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ctor);
                                if (bs != null){
                                    this.WriteBezierSegment(bs);
                                }
                                else
                                    throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
                            }
                        }
                    }
                }
            }
        },
        WriteBezierSegment: function (bs){
            this.WriteStartElement(Microsoft.Msagl.DebugHelpers.GeometryToken.CubicBezierSegment);
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Points, this.PointsToString(bs.B(0), bs.B(1), bs.B(2), bs.B(3)));
            this.WriteEndElement();
        },
        WriteRect: function (x, y, width, height, rx, ry){
            this.WriteStartElement(Microsoft.Msagl.DebugHelpers.GeometryToken.Rect);
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.X, x);
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Y, y);
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Width, width);
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Height, height);
            if (rx > 0)
                this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Rx, rx);
            if (ry > 0)
                this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Ry, ry);
            this.WriteEndElement();
        },
        WritePolylineInSvgStyle: function (poly){
            this.WriteStartElement(poly.get_Closed() ? Microsoft.Msagl.DebugHelpers.GeometryToken.Polygon : Microsoft.Msagl.DebugHelpers.GeometryToken.Polyline);
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Points, this.PointsToString(System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Geometry.Point.ctor, poly)));
            this.WriteEndElement();
        },
        WriteEllipseInSvgStyle: function (ellipse){
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(ellipse.get_ParStart(), 0) && Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(ellipse.get_ParEnd(), 6.28318530717959)){
                this.WriteFullEllipse(ellipse);
            }
            else {
                Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.WriteEllepticalArc(ellipse);
            }
        },
        WriteFullEllipse: function (ellipse){
            this.WriteStartElement(Microsoft.Msagl.DebugHelpers.GeometryToken.Ellipse);
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Cx, ellipse.get_Center().get_X());
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Cy, ellipse.get_Center().get_Y());
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Rx, ellipse.get_AxisA().get_Length());
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Ry, ellipse.get_AxisB().get_Length());
            this.WriteEndElement();
        },
        WriteCurveInSvgStyle: function (curve){
            this.WriteStartElement(Microsoft.Msagl.DebugHelpers.GeometryToken.Curve);
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.CurveData, this.CurveString(curve));
            this.WriteEndElement();
        },
        CurveString: function (iCurve){
            return System.String.Join$$String$$IEnumerable$1$String(" ", this.CurveStringTokens(iCurve));
        },
        CurveStringTokens: function (iCurve){
            var $yield = [];
            $yield.push("M");
            $yield.push(this.PointToString(iCurve.get_Start()));
            var curve = As(iCurve, Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor);
            var previousInstruction = "w";
            if (curve != null)
                for (var i = 0; i < curve.get_Segments().get_Count(); i++){
                    var segment = curve.get_Segments().get_Item$$Int32(i);
                    if (i != curve.get_Segments().get_Count() - 1)
                        $yield.push((function (){
                            var $1 = {
                                Value: previousInstruction
                            };
                            var $res = this.SegmentString(segment, $1);
                            previousInstruction = $1.Value;
                            return $res;
                        }).call(this));
                    else {
                        if (Is(segment, Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor) && Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(segment.get_End(), iCurve.get_Start()))
                            $yield.push("Z");
                        else
                            $yield.push((function (){
                                var $1 = {
                                    Value: previousInstruction
                                };
                                var $res = this.SegmentString(segment, $1);
                                previousInstruction = $1.Value;
                                return $res;
                            }).call(this));
                    }
                }
            return $yield;
        },
        SegmentString: function (segment, previousInstruction){
            var ls = As(segment, Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor);
            if (ls != null){
                var str = this.LineSegmentString(ls, previousInstruction.Value);
                previousInstruction.Value = "L";
                return str;
            }
            var cubic = As(segment, Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ctor);
            if (cubic != null){
                var str = this.CubicBezierSegmentToString(cubic, previousInstruction.Value);
                previousInstruction.Value = "C";
                return str;
            }
            var ellipseArc = As(segment, Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor);
            if (ellipseArc != null){
                previousInstruction.Value = "A";
                return this.EllipticalArcToString(ellipseArc);
            }
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        EllipticalArcToString: function (ellipse){
            var rx = "A" + this.DoubleToString(ellipse.get_AxisA().get_Length());
            var ry = this.DoubleToString(ellipse.get_AxisB().get_Length());
            var xAxisRotation = this.DoubleToString(180 * Microsoft.Msagl.Core.Geometry.Point.Angle$$Point$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(1, 0), ellipse.get_AxisA()) / 3.14159265358979);
            var largeArcFlag = System.Math.Abs$$Double(ellipse.get_ParEnd() - ellipse.get_ParStart()) >= 3.14159265358979 ? "1" : "0";
            var sweepFlagInt = ellipse.get_ParEnd() > ellipse.get_ParStart() ? 1 : 0;
            if (Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.AxesSwapped(ellipse.get_AxisA(), ellipse.get_AxisB())){
                sweepFlagInt = sweepFlagInt == 1 ? 0 : 1;
            }
            var endPoint = this.PointToString(ellipse.get_End());
            return System.String.Join$$String$$String$Array(" ", rx, ry, xAxisRotation, largeArcFlag, sweepFlagInt.toString(), endPoint);
        },
        CubicBezierSegmentToString: function (cubic, previousInstruction){
            var str = this.PointsToString(cubic.B(1), cubic.B(2), cubic.B(3));
            return previousInstruction == "C" ? str : "C" + str;
        },
        PointsToString: function (points){
            return System.String.Join$$String$$IEnumerable$1$String(" ", System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Point.ctor, System.String.ctor, points, $CreateDelegate(this, this.PointToString)));
        },
        LineSegmentString: function (ls, previousInstruction){
            var str = this.PointToString(ls.get_End());
            return previousInstruction == "L" ? str : "L" + str;
        },
        WriteLineSeg: function (ls){
            this.WriteStartElement(Microsoft.Msagl.DebugHelpers.GeometryToken.LineSegment);
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Points, this.PointsToString(ls.get_Start(), ls.get_End()));
            this.WriteEndElement();
        },
        WriteTransformation: function (transformation){
            this.WriteStartElement(Microsoft.Msagl.DebugHelpers.GeometryToken.Transform);
            this.get_XmlWriter().WriteComment("the order of elements is [0,0],[0,1],[0,2],[1,0],[1,1],[1,2]");
            for (var i = 0; i < 2; i++)
                for (var j = 0; j < 3; j++)
                    this.WriteTransformationElement(transformation.get_Item$$Int32$$Int32(i, j));
            this.WriteEndElement();
        },
        WriteTransformationElement: function (t){
            this.WriteStringElement(Microsoft.Msagl.DebugHelpers.GeometryToken.TransformElement, t);
        },
        WriteStartElement: function (token){
            this.get_XmlWriter().WriteStartElement$$String(Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.FirstCharToLower(token));
        },
        WriteStringElement: function (tokens, element){
            this.get_XmlWriter().WriteElementString$$String$$String(tokens.toString(), System.Xml.XmlConvert.ToString$$Double(element));
        },
        WriteEndElement: function (){
            this.get_XmlWriter().WriteEndElement();
        },
        WriteLayoutSettings: function (){
            if (this.get_Settings() != null){
                var settings = this.get_Settings();
                var routingSettings = settings.get_EdgeRoutingSettings();
                this.WriteStartElement(Microsoft.Msagl.DebugHelpers.GeometryToken.LayoutAlgorithmSettings);
                this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.EdgeRoutingMode, routingSettings.get_EdgeRoutingMode());
                var sugiyama = As(settings, Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.ctor);
                if (sugiyama != null)
                    this.WriteSugiyamaSettings(sugiyama);
                else {
                    var mds = As(settings, Microsoft.Msagl.Layout.MDS.MdsLayoutSettings.ctor);
                    if (mds != null){
                        this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.LayoutAlgorithmType, Microsoft.Msagl.DebugHelpers.GeometryToken.MdsLayoutSettings);
                        this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.Exponent, mds.get_Exponent());
                        this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.IterationsWithMajorization, mds.get_IterationsWithMajorization());
                        this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.PivotNumber, mds.get_PivotNumber());
                        this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.RotationAngle, mds.get_RotationAngle());
                        this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.ScaleX, mds.get_ScaleX());
                        this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.ScaleY, mds.get_ScaleY());
                    }
                }
                this.get_XmlWriter().WriteEndElement();
            }
        },
        WriteSugiyamaSettings: function (sugiyama){
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.LayoutAlgorithmType, Microsoft.Msagl.DebugHelpers.GeometryToken.SugiyamaLayoutSettings);
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.MinNodeWidth, sugiyama.get_MinNodeWidth());
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.MinNodeHeight, sugiyama.get_MinNodeHeight());
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.AspectRatio, sugiyama.get_AspectRatio());
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.NodeSeparation, sugiyama.get_NodeSeparation());
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.RandomSeedForOrdering, sugiyama.get_RandomSeedForOrdering());
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.NoGainStepsBound, sugiyama.get_NoGainAdjacentSwapStepsBound());
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.MaxNumberOfPassesInOrdering, sugiyama.get_MaxNumberOfPassesInOrdering());
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.RepetitionCoefficientForOrdering, sugiyama.get_RepetitionCoefficientForOrdering());
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.GroupSplit, sugiyama.get_GroupSplit());
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.LabelCornersPreserveCoefficient, sugiyama.get_LabelCornersPreserveCoefficient());
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.BrandesThreshold, sugiyama.get_BrandesThreshold());
            this.WriteAttribute(Microsoft.Msagl.DebugHelpers.GeometryToken.LayerSeparation, sugiyama.get_LayerSeparation());
            this.WriteTransformation(sugiyama.get_Transformation());
        }
    }
};
JsTypes.push(Microsoft$Msagl$DebugHelpers$Persistence$GeometryGraphWriter);
var Microsoft$Msagl$DebugHelpers$CurveStream = {
    fullname: "Microsoft.Msagl.DebugHelpers.CurveStream",
    baseTypeName: "System.Object",
    staticDefinition: {
        RefineBlocks: function (blocks){
            var $yield = [];
            for (var $i80 = 0,$l80 = blocks.length,block = blocks[$i80]; $i80 < $l80; $i80++, block = blocks[$i80]){
                var ch = block.charAt(0);
                if (System.Char.IsLetter$$Char(ch)){
                    $yield.push(new Microsoft.Msagl.DebugHelpers.Persistence.CharStreamElement.ctor(ch));
                    if (block.length > 1){
                        var res;
                        if ((function (){
                            var $1 = {
                                Value: res
                            };
                            var $res = System.Double.TryParse$$String$$Double(block.substr(1), $1);
                            res = $1.Value;
                            return $res;
                        })())
                            $yield.push(new Microsoft.Msagl.DebugHelpers.DoubleStreamElement.ctor(res));
                        else
                            $yield.push(null);
                    }
                }
                else {
                    var res;
                    if ((function (){
                        var $1 = {
                            Value: res
                        };
                        var $res = System.Double.TryParse$$String$$Double(block, $1);
                        res = $1.Value;
                        return $res;
                    })())
                        $yield.push(new Microsoft.Msagl.DebugHelpers.DoubleStreamElement.ctor(res));
                    else
                        $yield.push(null);
                }
            }
            return $yield;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (curveData){
            this.data = null;
            this.curveStreamElements = null;
            this.offset = 0;
            System.Object.ctor.call(this);
            this.data = curveData;
            this.Init();
        },
        Init: function (){
            this.data = this.data.trim();
            var blocks = this.data.Split$$Char$Array$$StringSplitOptions([" "], 1);
            this.curveStreamElements = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.DebugHelpers.CurveStreamElement.ctor, Microsoft.Msagl.DebugHelpers.CurveStream.RefineBlocks(blocks));
        },
        GetNextCurveStreamElement: function (){
            if (this.offset >= this.curveStreamElements.length)
                return null;
            return this.curveStreamElements[this.offset++];
        },
        PickNextCurveStreamElement: function (){
            if (this.offset >= this.curveStreamElements.length)
                return null;
            return this.curveStreamElements[this.offset];
        }
    }
};
JsTypes.push(Microsoft$Msagl$DebugHelpers$CurveStream);
var Microsoft$Msagl$DebugHelpers$CurveStreamElement = {
    fullname: "Microsoft.Msagl.DebugHelpers.CurveStreamElement",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.Value = null;
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$DebugHelpers$CurveStreamElement);
var Microsoft$Msagl$DebugHelpers$DoubleStreamElement = {
    fullname: "Microsoft.Msagl.DebugHelpers.DoubleStreamElement",
    baseTypeName: "Microsoft.Msagl.DebugHelpers.CurveStreamElement",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (res){
            Microsoft.Msagl.DebugHelpers.CurveStreamElement.ctor.call(this);
            this.Value = res;
        },
        Double$$: "System.Double",
        get_Double: function (){
            return this.Value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$DebugHelpers$DoubleStreamElement);
var Microsoft$Msagl$Layout$Initial$Relayout = {
    fullname: "Microsoft.Msagl.Layout.Initial.Relayout",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        },
        GetShallowCopyGraphUnderCluster: function (cluster){
            var originalToCopyNodeMap = Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.ShallowNodeCopyDictionary(cluster);
            var newGraph = Microsoft.Msagl.Layout.Initial.Relayout.CreateGeometryGraphAndPopulateItWithNodes(originalToCopyNodeMap);
            var $it84 = originalToCopyNodeMap.get_Keys().GetEnumerator();
            while ($it84.MoveNext()){
                var target = $it84.get_Current();
                var $it85 = Microsoft.Msagl.Layout.Initial.Relayout.AllSuccessors(target).GetEnumerator();
                while ($it85.MoveNext()){
                    var underNode = $it85.get_Current();
                    var $it86 = underNode.get_InEdges().GetEnumerator();
                    while ($it86.MoveNext()){
                        var e = $it86.get_Current();
                        var sourceAncestorUnderRoot = Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.Ancestor(e.get_Source(), cluster);
                        if (Microsoft.Msagl.Layout.Initial.Relayout.IsBetweenClusters(sourceAncestorUnderRoot, target))
                            newGraph.get_Edges().Add(Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.CopyEdge$$Dictionary$2$Node$Node$$Edge$$Node$$Node(originalToCopyNodeMap, e, sourceAncestorUnderRoot, target));
                    }
                    var $it87 = target.get_SelfEdges().GetEnumerator();
                    while ($it87.MoveNext()){
                        var e = $it87.get_Current();
                        newGraph.get_Edges().Add(Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.CopyEdge$$Dictionary$2$Node$Node$$Edge(originalToCopyNodeMap, e));
                    }
                }
            }
            return newGraph;
        },
        CreateGeometryGraphAndPopulateItWithNodes: function (originalToCopyNodeMap){
            var newGraph = new Microsoft.Msagl.Core.Layout.GeometryGraph.ctor();
            var $it88 = originalToCopyNodeMap.get_Values().GetEnumerator();
            while ($it88.MoveNext()){
                var v = $it88.get_Current();
                newGraph.get_Nodes().Add(v);
            }
            return newGraph;
        },
        IsBetweenClusters: function (sourceAncestorUnderRoot, target){
            return sourceAncestorUnderRoot != target && sourceAncestorUnderRoot != null;
        },
        AllSuccessors: function (node){
            var ret = (function (){
                var $v27 = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor);
                $v27.Add(node);
                return $v27;
            })();
            var cl = As(node, Microsoft.Msagl.Core.Layout.Cluster.ctor);
            if (cl != null){
                var $it89 = cl.AllSuccessorsWidthFirst().GetEnumerator();
                while ($it89.MoveNext()){
                    var u = $it89.get_Current();
                    if (u != node)
                        ret.Add(u);
                }
            }
            return ret;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (graph, modifiedNodes, addedNodes, clusterSettings){
            this.graph = null;
            this.modifiedNodes = null;
            this.clusterSettings = null;
            this.ancestorsOfModifiedNodes = null;
            this.addedNodesByCluster = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Cluster.ctor, System.Collections.Generic.HashSet$1.ctor);
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(graph, "graph");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(clusterSettings, "clusterSettings");
            this.graph = graph;
            this.modifiedNodes = modifiedNodes;
            this.clusterSettings = clusterSettings;
            this.ancestorsOfModifiedNodes = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, System.Linq.Enumerable.SelectMany$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Layout.Cluster.ctor, modifiedNodes, $CreateAnonymousDelegate(this, function (v){
                return v.get_AllClusterAncestors();
            })));
            if (addedNodes == null)
                return;
            var $it80 = addedNodes.GetEnumerator();
            while ($it80.MoveNext()){
                var v = $it80.get_Current();
                this.CreateOrGetAddedChildrenOfParent(System.Linq.Enumerable.First$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, v.get_ClusterParents())).Add(v);
            }
            this.ancestorsOfModifiedNodes.InsertRange(System.Linq.Enumerable.SelectMany$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Layout.Cluster.ctor, addedNodes, $CreateAnonymousDelegate(this, function (v){
                return v.get_AllClusterAncestors();
            })));
        },
        CreateOrGetAddedChildrenOfParent: function (parent){
            var addedChildren;
            (function (){
                var $1 = {
                    Value: addedChildren
                };
                var $res = this.addedNodesByCluster.TryGetValue(parent, $1);
                addedChildren = $1.Value;
                return $res;
            }).call(this);
            if (addedChildren == null)
                this.addedNodesByCluster.set_Item$$TKey(parent, addedChildren = new System.Collections.Generic.HashSet$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor));
            return addedChildren;
        },
        RunInternal: function (){
            var openedClusters = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Cluster.ctor, System.Linq.Enumerable.OfType$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, this.modifiedNodes), $CreateAnonymousDelegate(this, function (cl){
                return !cl.get_IsCollapsed();
            })));
            if (openedClusters.length > 0)
                new Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.ctor$$GeometryGraph$$IEnumerable$1$Cluster$$Func$2$Cluster$LayoutAlgorithmSettings(this.graph, openedClusters, this.clusterSettings).Run();
            this.Visit(this.graph.get_RootCluster());
            Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.RouteParentEdges(this.graph, this.clusterSettings(this.graph.get_RootCluster()).get_EdgeRoutingSettings());
            Microsoft.Msagl.Miscellaneous.LayoutHelpers.RouteAndLabelEdges(this.graph, this.clusterSettings(this.graph.get_RootCluster()), System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, this.graph.get_Edges(), $CreateDelegate(this, this.BetweenClusterOnTheRightLevel)));
            this.graph.UpdateBoundingBox();
            this.ProgressComplete();
        },
        BetweenClusterOnTheRightLevel: function (edge){
            var sourceAncestors = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, edge.get_Source().get_AllClusterAncestors());
            var targetAncestors = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, edge.get_Target().get_AllClusterAncestors());
            return (Microsoft.Msagl.Core.DataStructures.Set$1.op_Multiply(sourceAncestors, targetAncestors)).IsContained(this.ancestorsOfModifiedNodes);
        },
        Visit: function (u){
            if (u.get_IsCollapsed() || !this.ancestorsOfModifiedNodes.Contains$$T(u))
                return;
            var $it81 = u.get_Clusters().GetEnumerator();
            while ($it81.MoveNext()){
                var c = $it81.get_Current();
                this.Visit(c);
            }
            this.LayoutCluster(u);
        },
        LayoutCluster: function (cluster){
            this.ProgressStep();
            cluster.UnsetInitialLayoutState();
            var settings = null;
            var s = this.clusterSettings(cluster);
            var layoutDirection = Microsoft.Msagl.Core.Geometry.Directions.None;
            if (Is(s, Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.ctor)){
                var ss = As(s, Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.ctor);
                settings = ss.get_FallbackLayoutSettings() != null ? new Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.ctor$$FastIncrementalLayoutSettings(Cast(ss.get_FallbackLayoutSettings(), Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.ctor)) : new Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.ctor();
                layoutDirection = Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.GetLayoutDirection(ss);
            }
            else {
                settings = new Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.ctor$$FastIncrementalLayoutSettings(Cast(s, Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.ctor));
            }
            settings.set_ApplyForces(true);
            settings.set_MinorIterations(10);
            settings.set_AvoidOverlaps(true);
            settings.set_InterComponentForces(false);
            settings.set_IdealEdgeLength((function (){
                var $v26 = new Microsoft.Msagl.Core.Layout.IdealEdgeLengthSettings.ctor();
                $v26.set_EdgeDirectionConstraints(layoutDirection);
                $v26.set_ConstrainedEdgeSeparation(30);
                return $v26;
            }).call(this));
            settings.get_EdgeRoutingSettings().set_EdgeRoutingMode(Microsoft.Msagl.Core.Routing.EdgeRoutingMode.Spline);
            var addedNodes;
            if ((function (){
                var $1 = {
                    Value: addedNodes
                };
                var $res = this.addedNodesByCluster.TryGetValue(cluster, $1);
                addedNodes = $1.Value;
                return $res;
            }).call(this)){
                settings.set_MinConstraintLevel(0);
                settings.set_MaxConstraintLevel(2);
            }
            else
                settings.set_MinConstraintLevel(2);
            var newGraph = Microsoft.Msagl.Layout.Initial.Relayout.GetShallowCopyGraphUnderCluster(cluster);
            Microsoft.Msagl.Core.Layout.LayoutAlgorithmHelpers.ComputeDesiredEdgeLengths(settings.get_IdealEdgeLength(), newGraph);
            this.LayoutComponent(newGraph, settings);
            Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.FixOriginalGraph(newGraph, true);
            cluster.UpdateBoundary(newGraph.get_BoundingBox());
        },
        GenerateOrthogonalOrderingConstraints: function (nodes, settings){
            var p = null;
            var $it82 = System.Linq.Enumerable.OrderBy$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Node.ctor, System.Double.ctor, this.graph.get_Nodes(), $CreateAnonymousDelegate(this, function (v){
                return v.get_Center().get_X();
            })).GetEnumerator();
            while ($it82.MoveNext()){
                var v = $it82.get_Current();
                if (p != null){
                    settings.AddStructuralConstraint(new Microsoft.Msagl.Layout.Incremental.HorizontalSeparationConstraint.ctor$$Node$$Node$$Double(p, v, 0.1));
                }
                p = v;
            }
            p = null;
            var $it83 = System.Linq.Enumerable.OrderBy$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Node.ctor, System.Double.ctor, this.graph.get_Nodes(), $CreateAnonymousDelegate(this, function (v){
                return v.get_Center().get_Y();
            })).GetEnumerator();
            while ($it83.MoveNext()){
                var v = $it83.get_Current();
                if (p != null){
                    settings.AddStructuralConstraint(new Microsoft.Msagl.Layout.Incremental.VerticalSeparationConstraint.ctor$$Node$$Node$$Double(p, v, 0.1));
                }
                p = v;
            }
        },
        LayoutComponent: function (component, settings){
            settings.set_MaxIterations(Microsoft.Msagl.Core.Layout.LayoutAlgorithmHelpers.NegativeLinearInterpolation$$Int32$$Int32$$Int32$$Int32$$Int32(component.get_Nodes().get_Count(), 50, 500, 3, 5));
            settings.set_MinorIterations(Microsoft.Msagl.Core.Layout.LayoutAlgorithmHelpers.NegativeLinearInterpolation$$Int32$$Int32$$Int32$$Int32$$Int32(component.get_Nodes().get_Count(), 50, 500, 2, 10));
            var fil = new Microsoft.Msagl.Layout.Incremental.FastIncrementalLayout.ctor(component, settings, settings.get_MinConstraintLevel(), $CreateAnonymousDelegate(this, function (anyCluster){
                return settings;
            }));
            System.Diagnostics.Debug.Assert$$Boolean(settings.get_Iterations() == 0);
            var $it90 = System.Linq.Enumerable.Range(settings.get_MinConstraintLevel(), settings.get_MaxConstraintLevel() + 1).GetEnumerator();
            while ($it90.MoveNext()){
                var level = $it90.get_Current();
                if (level != fil.get_CurrentConstraintLevel()){
                    fil.set_CurrentConstraintLevel(level);
                    if (level == 2){
                        settings.set_MinorIterations(1);
                        settings.set_ApplyForces(false);
                    }
                }
                do{
                    fil.Run();
                }
                while (!settings.get_IsDone())
            }
            component.set_Margins(settings.get_ClusterMargin());
            component.UpdateBoundingBox();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Initial$Relayout);
var Microsoft$Msagl$Layout$Initial$InitialLayoutByCluster = {
    fullname: "Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        },
        RouteParentEdges: function (graph, edgeRoutingSettings){
            var inParentEdges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor);
            var outParentEdges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor);
            Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.RouteSimplHooksAndFillTheLists(graph.get_RootCluster(), inParentEdges, outParentEdges, edgeRoutingSettings);
            if (inParentEdges.get_Count() > 0 || outParentEdges.get_Count() > 0)
                Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.LabelParentEdgesAndMaybeRerouteThemNicely(graph, inParentEdges, outParentEdges, edgeRoutingSettings);
        },
        LabelParentEdgesAndMaybeRerouteThemNicely: function (graph, inParentEdges, outParentEdges, edgeRoutingSettings){
            if (Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.AllowedToRoute(inParentEdges, outParentEdges, edgeRoutingSettings)){
                var shapeGroupRouter = new Microsoft.Msagl.Routing.SplineRouter.ctor$$GeometryGraph$$Double$$Double$$Double$$List$1$Edge$$List$1$Edge(graph, edgeRoutingSettings.get_Padding(), edgeRoutingSettings.get_PolylinePadding(), edgeRoutingSettings.get_RoutingToParentConeAngle(), inParentEdges, outParentEdges);
                shapeGroupRouter.Run();
            }
            var labeledEdges = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Layout.Edge.ctor, outParentEdges, inParentEdges), function (e){
                return System.Linq.Enumerable.Any$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Label.ctor, e.get_Labels());
            });
            if (System.Linq.Enumerable.Any$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Edge.ctor, labeledEdges)){
                var elb = new Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.ctor$$IEnumerable$1$Node$$IEnumerable$1$Edge(graph.get_Nodes(), labeledEdges);
                elb.Run();
            }
        },
        AllowedToRoute: function (inParentEdges, outParentEdges, edgeRoutingSettings){
            return Microsoft.Msagl.Routing.ShapeCreatorForRoutingToParents.NumberOfActiveNodesIsUnderThreshold(inParentEdges, outParentEdges, edgeRoutingSettings.get_SimpleSelfLoopsForParentEdgesThreshold());
        },
        RouteSimplHooksAndFillTheLists: function (rootCluster, inParentEdges, outParentEdges, edgeRoutingSettings){
            var padding = edgeRoutingSettings.get_Padding() + edgeRoutingSettings.get_PolylinePadding();
            var $it92 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Cluster.ctor, rootCluster.AllClustersWidthFirstExcludingSelfAvoidingChildrenOfCollapsed(), function (c){
                return !c.get_IsCollapsed();
            }).GetEnumerator();
            while ($it92.MoveNext()){
                var cluster = $it92.get_Current();
                Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.RouteClusterParentInEdges(inParentEdges, edgeRoutingSettings, cluster, padding);
                Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.RouteClusterParentOutEdges(outParentEdges, edgeRoutingSettings, cluster, padding);
            }
        },
        RouteClusterParentOutEdges: function (outParentEdges, edgeRoutingSettings, cluster, padding){
            var $it93 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, cluster.get_OutEdges(), function (e){
                return Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.IsDescendant(e.get_Target(), cluster);
            }).GetEnumerator();
            while ($it93.MoveNext()){
                var e = $it93.get_Current();
                var ePadding = System.Math.Max$$Double$$Double(padding, 1.5 * Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.ArrowlengthAtSource(e));
                var hookPort = As(e.get_SourcePort(), Microsoft.Msagl.Core.Layout.HookUpAnywhereFromInsidePort.ctor);
                if (hookPort == null)
                    e.set_SourcePort(hookPort = new Microsoft.Msagl.Core.Layout.HookUpAnywhereFromInsidePort.ctor$$Func$1$ICurve(function (){
                        return cluster.get_BoundaryCurve();
                    }));
                hookPort.set_HookSize(ePadding);
                e.set_Curve(Microsoft.Msagl.Routing.StraightLineEdges.CreateLoop$$Rectangle$$Rectangle$$Double$$Boolean(e.get_Target().get_BoundingBox(), cluster.get_BoundingBox(), ePadding, false));
                Microsoft.Msagl.Core.Layout.Arrowheads.TrimSplineAndCalculateArrowheads$$Edge$$ICurve$$Boolean$$Boolean(e, e.get_Curve(), false, edgeRoutingSettings.get_KeepOriginalSpline());
                outParentEdges.Add(e);
            }
        },
        RouteClusterParentInEdges: function (inParentEdges, edgeRoutingSettings, cluster, padding){
            var $it94 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, cluster.get_InEdges(), function (e){
                return Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.IsDescendant(e.get_Source(), cluster);
            }).GetEnumerator();
            while ($it94.MoveNext()){
                var e = $it94.get_Current();
                var ePadding = System.Math.Max$$Double$$Double(padding, 1.5 * Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.ArrowlengthAtTarget(e));
                var hookPort = As(e.get_TargetPort(), Microsoft.Msagl.Core.Layout.HookUpAnywhereFromInsidePort.ctor);
                if (hookPort == null)
                    e.set_TargetPort(hookPort = new Microsoft.Msagl.Core.Layout.HookUpAnywhereFromInsidePort.ctor$$Func$1$ICurve(function (){
                        return cluster.get_BoundaryCurve();
                    }));
                hookPort.set_HookSize(ePadding);
                e.set_Curve(Microsoft.Msagl.Routing.StraightLineEdges.CreateLoop$$Rectangle$$Rectangle$$Double$$Boolean(e.get_Source().get_BoundingBox(), cluster.get_BoundingBox(), ePadding, false));
                Microsoft.Msagl.Core.Layout.Arrowheads.TrimSplineAndCalculateArrowheads$$Edge$$ICurve$$Boolean$$Boolean(e, e.get_Curve(), false, edgeRoutingSettings.get_KeepOriginalSpline());
                inParentEdges.Add(e);
            }
        },
        ArrowlengthAtSource: function (edge){
            return edge.get_EdgeGeometry().get_SourceArrowhead() == null ? 0 : edge.get_EdgeGeometry().get_SourceArrowhead().get_Length();
        },
        ArrowlengthAtTarget: function (edge){
            return edge.get_EdgeGeometry().get_TargetArrowhead() == null ? 0 : edge.get_EdgeGeometry().get_TargetArrowhead().get_Length();
        },
        ValidateLayout: function (cluster){
            var $it95 = cluster.AllClustersDepthFirst().GetEnumerator();
            while ($it95.MoveNext()){
                var c = $it95.get_Current();
                var $it96 = System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Layout.Node.ctor, c.nodes, System.Linq.Enumerable.Cast$1(Microsoft.Msagl.Core.Layout.Node.ctor, c.get_Clusters())).GetEnumerator();
                while ($it96.MoveNext()){
                    var v = $it96.get_Current();
                    System.Diagnostics.Debug.Assert$$Boolean(c.get_BoundingBox().Contains$$Rectangle(v.get_BoundingBox()));
                }
            }
        },
        FixOriginalGraph: function (graph, translateEdges){
            var $it99 = graph.get_Nodes().GetEnumerator();
            while ($it99.MoveNext()){
                var v = $it99.get_Current();
                var originalNode = Cast(v.get_UserData(), Microsoft.Msagl.Core.Layout.Node.ctor);
                var delta = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v.get_BoundingBox().get_LeftBottom(), originalNode.get_BoundingBox().get_LeftBottom());
                var cluster = As(originalNode, Microsoft.Msagl.Core.Layout.Cluster.ctor);
                if (cluster != null){
                    cluster.DeepTranslation(delta, translateEdges);
                }
                else
                    originalNode.set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Addition(originalNode.get_Center(), delta));
            }
            if (translateEdges){
                var $it100 = graph.get_Edges().GetEnumerator();
                while ($it100.MoveNext()){
                    var e = $it100.get_Current();
                    var originalEdge = Cast(e.get_UserData(), Microsoft.Msagl.Core.Layout.Edge.ctor);
                    if (e.get_Curve() != null)
                        originalEdge.set_Curve(e.get_Curve().Clone());
                    originalEdge.set_Length(e.get_Length());
                    originalEdge.get_EdgeGeometry().set_SourcePort((function ($p9){
                        e.set_SourcePort($p9);
                        return $p9;
                    })(null));
                    originalEdge.get_EdgeGeometry().set_TargetPort((function ($p10){
                        e.set_TargetPort($p10);
                        return $p10;
                    })(null));
                    var $it101 = originalEdge.get_Labels().GetEnumerator();
                    while ($it101.MoveNext()){
                        var l = $it101.get_Current();
                        l.set_GeometryParent(originalEdge);
                    }
                }
            }
        },
        IsDescendant: function (node, root){
            return Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.Ancestor(node, root) != null;
        },
        GetComponents: function (cluster){
            var originalToCopyNodeMap = Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.ShallowNodeCopyDictionary(cluster);
            var copiedEdges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor);
            var $it102 = originalToCopyNodeMap.get_Keys().GetEnumerator();
            while ($it102.MoveNext()){
                var target = $it102.get_Current();
                var $it103 = target.get_InEdges().GetEnumerator();
                while ($it103.MoveNext()){
                    var e = $it103.get_Current();
                    var sourceAncestorUnderRoot = Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.Ancestor(e.get_Source(), cluster);
                    if (sourceAncestorUnderRoot == e.get_Source())
                        copiedEdges.Add(Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.CopyEdge$$Dictionary$2$Node$Node$$Edge$$Node$$Node(originalToCopyNodeMap, e, sourceAncestorUnderRoot, target));
                }
                copiedEdges.AddRange(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, Microsoft.Msagl.Core.Layout.Edge.ctor, target.get_SelfEdges(), function (e){
                    return Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.CopyEdge$$Dictionary$2$Node$Node$$Edge(originalToCopyNodeMap, e);
                }));
            }
            return Microsoft.Msagl.Core.Layout.GraphConnectedComponents.CreateComponents(System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Layout.Node.ctor, originalToCopyNodeMap.get_Values()), copiedEdges);
        },
        CopyEdge$$Dictionary$2$Node$Node$$Edge$$Node$$Node: function (originalToCopyNodeMap, originalEdge, originalSource, originalTarget){
            var e = (function (){
                var $v28 = new Microsoft.Msagl.Core.Layout.Edge.ctor$$Node$$Node(originalToCopyNodeMap.get_Item$$TKey(originalSource), originalToCopyNodeMap.get_Item$$TKey(originalTarget));
                $v28.set_EdgeGeometry(originalEdge.get_EdgeGeometry());
                $v28.set_SourcePort(null);
                $v28.set_TargetPort(null);
                $v28.set_Length(originalEdge.get_Length());
                $v28.set_UserData(originalEdge);
                return $v28;
            })();
            var $it104 = originalEdge.get_Labels().GetEnumerator();
            while ($it104.MoveNext()){
                var l = $it104.get_Current();
                e.get_Labels().Add(l);
                l.set_GeometryParent(e);
            }
            return e;
        },
        CopyEdge$$Dictionary$2$Node$Node$$Edge: function (originalToCopyNodeMap, originalEdge){
            return Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.CopyEdge$$Dictionary$2$Node$Node$$Edge$$Node$$Node(originalToCopyNodeMap, originalEdge, originalEdge.get_Source(), originalEdge.get_Target());
        },
        ShallowNodeCopyDictionary: function (cluster){
            var originalNodeToCopy = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Layout.Node.ctor);
            var $it105 = cluster.get_Nodes().GetEnumerator();
            while ($it105.MoveNext()){
                var v = $it105.get_Current();
                originalNodeToCopy.set_Item$$TKey(v, (function (){
                    var $v29 = new Microsoft.Msagl.Core.Layout.Node.ctor$$ICurve(v.get_BoundaryCurve().Clone());
                    $v29.set_UserData(v);
                    return $v29;
                })());
            }
            var $it106 = cluster.get_Clusters().GetEnumerator();
            while ($it106.MoveNext()){
                var cl = $it106.get_Current();
                if (cl.get_IsCollapsed())
                    originalNodeToCopy.set_Item$$TKey(cl, (function (){
                        var $v30 = new Microsoft.Msagl.Core.Layout.Node.ctor$$ICurve(cl.get_CollapsedBoundary().Clone());
                        $v30.set_UserData(cl);
                        return $v30;
                    })());
                else {
                    if (cl.get_BoundaryCurve() == null)
                        cl.set_BoundaryCurve(cl.get_RectangularBoundary().RectangularHull());
                    originalNodeToCopy.set_Item$$TKey(cl, (function (){
                        var $v31 = new Microsoft.Msagl.Core.Layout.Node.ctor$$ICurve(cl.get_BoundaryCurve().Clone());
                        $v31.set_UserData(cl);
                        return $v31;
                    })());
                }
            }
            return originalNodeToCopy;
        },
        Ancestor: function (node, root){
            if (System.Linq.Enumerable.Contains$1$$IEnumerable$1$$TSource(Microsoft.Msagl.Core.Layout.Cluster.ctor, node.get_ClusterParents(), root))
                return node;
            var parents = new System.Collections.Generic.Queue$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, node.get_ClusterParents());
            while (parents.get_Count() > 0){
                var parent = parents.Dequeue();
                if (System.Linq.Enumerable.Contains$1$$IEnumerable$1$$TSource(Microsoft.Msagl.Core.Layout.Cluster.ctor, root.get_Clusters(), parent))
                    return parent;
                var $it107 = parent.get_ClusterParents().GetEnumerator();
                while ($it107.MoveNext()){
                    var grandParent = $it107.get_Current();
                    parents.Enqueue(grandParent);
                }
            }
            return null;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$GeometryGraph$$LayoutAlgorithmSettings: function (graph, defaultSettings){
            this.graph = null;
            this.clusters = null;
            this.clusterSettings = null;
            this.parallelOptions = null;
            this.runInParallel = false;
            Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.ctor$$GeometryGraph$$Func$2$Cluster$LayoutAlgorithmSettings.call(this, graph, $CreateAnonymousDelegate(this, function (anyCluster){
                return defaultSettings;
            }));
        },
        ctor$$GeometryGraph$$Func$2$Cluster$LayoutAlgorithmSettings: function (graph, clusterSettings){
            this.graph = null;
            this.clusters = null;
            this.clusterSettings = null;
            this.parallelOptions = null;
            this.runInParallel = false;
            Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.ctor$$GeometryGraph$$IEnumerable$1$Cluster$$Func$2$Cluster$LayoutAlgorithmSettings.call(this, graph, [graph.get_RootCluster()], clusterSettings);
        },
        ctor$$GeometryGraph$$IEnumerable$1$Cluster$$Func$2$Cluster$LayoutAlgorithmSettings: function (graph, clusters, clusterSettings){
            this.graph = null;
            this.clusters = null;
            this.clusterSettings = null;
            this.parallelOptions = null;
            this.runInParallel = false;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(graph, "graph");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(clusters, "clusters");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(clusterSettings, "clusterSettings");
            this.graph = graph;
            this.clusters = System.Linq.Enumerable.ToList$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, clusters);
            this.clusterSettings = clusterSettings;
        },
        RunInParallel$$: "System.Boolean",
        get_RunInParallel: function (){
            return this.runInParallel;
        },
        set_RunInParallel: function (value){
            this.runInParallel = value;
        },
        RunInternal: function (){
            if (this.runInParallel){
                this.parallelOptions = new System.Threading.Tasks.ParallelOptions.ctor();
            }
            if (this.runInParallel && this.clusters.get_Count() > 1)
                System.Threading.Tasks.Parallel.ForEach$1$$IEnumerable$1$$ParallelOptions$$Action$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, this.clusters, this.parallelOptions, $CreateDelegate(this, this.ProcessCluster));
            else {
                var $it91 = this.clusters.GetEnumerator();
                while ($it91.MoveNext()){
                    var cluster = $it91.get_Current();
                    this.ProcessCluster(cluster);
                }
            }
            var isRootCluster = System.Linq.Enumerable.Any$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Cluster.ctor, this.clusters, $CreateAnonymousDelegate(this, function (c){
                return c == this.graph.get_RootCluster();
            }));
            if (isRootCluster){
                Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.RouteParentEdges(this.graph, this.clusterSettings(this.graph.get_RootCluster()).get_EdgeRoutingSettings());
            }
            this.graph.UpdateBoundingBox();
            if (isRootCluster){
                System.Diagnostics.Debug.Assert$$Boolean$$String(System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, this.clusters) == 1, "Layout by cluster with a root cluster should not contain any other cluster.");
                this.graph.Translate(Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(this.graph.get_BoundingBox().get_LeftBottom()));
            }
            this.ProgressComplete();
        },
        ProcessCluster: function (cluster){
            if (cluster.get_IsCollapsed())
                return;
            var oldBounds = cluster.get_BoundingBox();
            cluster.UnsetInitialLayoutStateIncludingAncestors();
            this.LayoutCluster(cluster);
            if (cluster != this.graph.get_RootCluster()){
                var newBounds = cluster.get_BoundingBox();
                cluster.DeepTranslation(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(oldBounds.get_Center(), newBounds.get_Center()), true);
            }
            Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.ValidateLayout(cluster);
        },
        LayoutCluster: function (cluster){
            if (cluster.get_IsCollapsed())
                return;
            var settings = this.clusterSettings(cluster);
            cluster.UnsetInitialLayoutState();
            if (this.runInParallel && System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, cluster.get_Clusters()) > 1)
                System.Threading.Tasks.Parallel.ForEach$1$$IEnumerable$1$$ParallelOptions$$Action$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, cluster.get_Clusters(), this.parallelOptions, $CreateDelegate(this, this.LayoutCluster));
            else {
                var $it97 = cluster.get_Clusters().GetEnumerator();
                while ($it97.MoveNext()){
                    var cl = $it97.get_Current();
                    this.LayoutCluster(cl);
                }
            }
            var components = Cast(Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.GetComponents(cluster), System.Collections.Generic.List$1.ctor);
            if (this.runInParallel)
                System.Threading.Tasks.Parallel.ForEach$1$$IEnumerable$1$$ParallelOptions$$Action$1(Microsoft.Msagl.Core.Layout.GeometryGraph.ctor, components, this.parallelOptions, $CreateAnonymousDelegate(this, function (comp){
                    this.LayoutComponent(settings, comp);
                }));
            else
                components.ForEach($CreateAnonymousDelegate(this, function (c){
                    this.LayoutComponent(settings, c);
                }));
            var bounds = Microsoft.Msagl.Layout.MDS.MdsGraphLayout.PackGraphs(components, settings);
            var $it98 = components.GetEnumerator();
            while ($it98.MoveNext()){
                var g = $it98.get_Current();
                Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.FixOriginalGraph(g, true);
            }
            cluster.UpdateBoundary(bounds);
            cluster.SetInitialLayoutState(settings.get_ClusterMargin());
            cluster.RaiseLayoutDoneEvent();
        },
        LayoutComponent: function (settings, component){
            var fdSettings = As(settings, Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.ctor);
            var mdsSettings = As(settings, Microsoft.Msagl.Layout.MDS.MdsLayoutSettings.ctor);
            var layeredSettings = As(settings, Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.ctor);
            if (fdSettings != null){
                this.ForceDirectedLayout(fdSettings, component);
            }
            else if (mdsSettings != null){
                this.MDSLayout(mdsSettings, component);
            }
            else if (layeredSettings != null){
                this.LayeredLayout(layeredSettings, component);
            }
            else {
                throw $CreateException(new System.NotImplementedException.ctor$$String("Unknown type of layout settings!"), new Error());
            }
        },
        ForceDirectedLayout: function (settings, component){
            Microsoft.Msagl.Core.Layout.LayoutAlgorithmHelpers.ComputeDesiredEdgeLengths(settings.get_IdealEdgeLength(), component);
            var layout = (function (){
                var $v32 = new Microsoft.Msagl.Layout.Initial.InitialLayout.ctor(component, settings);
                $v32.set_SingleComponent(true);
                return $v32;
            }).call(this);
            layout.Run$$CancelToken(this.get_CancelToken());
            Microsoft.Msagl.Layout.Initial.InitialLayoutHelpers.RouteEdges(component, settings, this.get_CancelToken());
            Microsoft.Msagl.Layout.Initial.InitialLayoutHelpers.PlaceLabels(component, this.get_CancelToken());
            Microsoft.Msagl.Layout.Initial.InitialLayoutHelpers.FixBoundingBox(component, settings);
        },
        MDSLayout: function (settings, component){
            Microsoft.Msagl.Core.Layout.LayoutAlgorithmHelpers.ComputeDesiredEdgeLengths(settings.get_IdealEdgeLength(), component);
            var layout = new Microsoft.Msagl.Layout.MDS.MdsGraphLayout.ctor(settings, component);
            layout.Run$$CancelToken(this.get_CancelToken());
            Microsoft.Msagl.Layout.Initial.InitialLayoutHelpers.RouteEdges(component, settings, this.get_CancelToken());
            Microsoft.Msagl.Layout.Initial.InitialLayoutHelpers.PlaceLabels(component, this.get_CancelToken());
            Microsoft.Msagl.Layout.Initial.InitialLayoutHelpers.FixBoundingBox(component, settings);
        },
        LayeredLayout: function (layeredSettings, component){
            var layeredLayout = new Microsoft.Msagl.Layout.Layered.LayeredLayout.ctor(component, layeredSettings);
            layeredLayout.SetCancelToken(this.get_CancelToken());
            var aspectRatio = layeredLayout.EstimateAspectRatio();
            var edgeDensity = component.get_Edges().get_Count() / component.get_Nodes().get_Count();
            var fallbackLayoutSettings = layeredSettings.get_FallbackLayoutSettings();
            if (fallbackLayoutSettings != null && (component.get_Nodes().get_Count() > 50 && edgeDensity > 2 || component.get_Nodes().get_Count() > 40 && edgeDensity > 3 || component.get_Nodes().get_Count() > 30 && edgeDensity > 4 || component.get_Nodes().get_Count() > 30 && aspectRatio > layeredSettings.get_MaxAspectRatioEccentricity() || component.get_Nodes().get_Count() > 30 && aspectRatio < 1 / layeredSettings.get_MaxAspectRatioEccentricity())){
                var prevEdgeRouting = fallbackLayoutSettings.get_EdgeRoutingSettings().get_EdgeRoutingMode();
                if (component.get_Nodes().get_Count() > 100 && edgeDensity > 2)
                    fallbackLayoutSettings.get_EdgeRoutingSettings().set_EdgeRoutingMode(Microsoft.Msagl.Core.Routing.EdgeRoutingMode.StraightLine);
                this.LayoutComponent(fallbackLayoutSettings, component);
                fallbackLayoutSettings.get_EdgeRoutingSettings().set_EdgeRoutingMode(prevEdgeRouting);
            }
            else {
                var prevEdgeRouting = layeredSettings.get_EdgeRoutingSettings().get_EdgeRoutingMode();
                if (component.get_Nodes().get_Count() > 100 && edgeDensity > 2){
                    layeredSettings.get_EdgeRoutingSettings().set_EdgeRoutingMode(Microsoft.Msagl.Core.Routing.EdgeRoutingMode.StraightLine);
                }
                layeredLayout.Run$$CancelToken(this.get_CancelToken());
                layeredSettings.get_EdgeRoutingSettings().set_EdgeRoutingMode(prevEdgeRouting);
                Microsoft.Msagl.Layout.Initial.InitialLayoutHelpers.FixBoundingBox(component, layeredSettings);
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Initial$InitialLayoutByCluster);
var Microsoft$Msagl$Layout$Initial$InitialLayoutHelpers = {
    fullname: "Microsoft.Msagl.Layout.Initial.InitialLayoutHelpers",
    baseTypeName: "System.Object",
    staticDefinition: {
        RouteEdges: function (component, settings, cancelToken){
            var mode = settings.get_EdgeRoutingSettings().get_EdgeRoutingMode();
            if (component.get_Nodes().get_Count() >= 2000){
                mode = Microsoft.Msagl.Core.Routing.EdgeRoutingMode.StraightLine;
            }
            switch (mode){
                case Microsoft.Msagl.Core.Routing.EdgeRoutingMode.Spline:
                    var splineRouter = new Microsoft.Msagl.Routing.SplineRouter.ctor$$GeometryGraph$$Double$$Double$$Double$$BundlingSettings(component, settings.get_EdgeRoutingSettings().get_Padding(), settings.get_NodeSeparation(), settings.get_EdgeRoutingSettings().get_ConeAngle(), null);
                    splineRouter.Run$$CancelToken(cancelToken);
                    break;
                case Microsoft.Msagl.Core.Routing.EdgeRoutingMode.SplineBundling:
                    splineRouter = new Microsoft.Msagl.Routing.SplineRouter.ctor$$GeometryGraph$$Double$$Double$$Double$$BundlingSettings(component, settings.get_EdgeRoutingSettings().get_Padding(), settings.get_NodeSeparation() / 20, settings.get_EdgeRoutingSettings().get_ConeAngle(), new Microsoft.Msagl.Core.Routing.BundlingSettings.ctor());
                    splineRouter.Run$$CancelToken(cancelToken);
                    break;
                case Microsoft.Msagl.Core.Routing.EdgeRoutingMode.Rectilinear:
                    var edgePadding = settings.get_EdgeRoutingSettings().get_Padding();
                    var cornerRadius = settings.get_EdgeRoutingSettings().get_CornerRadius();
                    var rectilinearEdgeRouter = new Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.ctor$$GeometryGraph$$Double$$Double$$Boolean(component, edgePadding, cornerRadius, true);
                    rectilinearEdgeRouter.Run$$CancelToken(cancelToken);
                    break;
                case Microsoft.Msagl.Core.Routing.EdgeRoutingMode.StraightLine:
                    var router = new Microsoft.Msagl.Routing.StraightLineEdges.ctor(component.get_Edges(), settings.get_EdgeRoutingSettings().get_Padding());
                    router.Run$$CancelToken(cancelToken);
                    break;
            }
        },
        PlaceLabels: function (component, cancelToken){
            var labelList = System.Linq.Enumerable.ToList$1(Microsoft.Msagl.Core.Layout.Label.ctor, System.Linq.Enumerable.SelectMany$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, Microsoft.Msagl.Core.Layout.Label.ctor, component.get_Edges(), function (e){
                return e.get_Labels();
            }));
            var labelPlacer = new Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.ctor$$GeometryGraph$$ICollection$1$Label(component, labelList);
            labelPlacer.Run$$CancelToken(cancelToken);
        },
        FixBoundingBox: function (component, settings){
            component.set_Margins(settings.get_ClusterMargin());
            component.UpdateBoundingBox();
            component.Translate(Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(component.get_BoundingBox().get_LeftBottom()));
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Initial$InitialLayoutHelpers);
var Microsoft$Msagl$Layout$LargeGraphLayout$DeviceIndependendZoomCalculatorForNodes = {
    fullname: "Microsoft.Msagl.Layout.LargeGraphLayout.DeviceIndependendZoomCalculatorForNodes",
    baseTypeName: "System.Object",
    staticDefinition: {
        PointToTuple: function (graphLeftBottom, point, gridSize){
            var dx = point.get_X() - graphLeftBottom.get_X();
            var dy = point.get_Y() - graphLeftBottom.get_Y();
            return new System.Tuple$2.ctor(System.Int32.ctor, System.Int32.ctor, ((dx / gridSize)) | 0, ((dy / gridSize)) | 0);
        },
        GetDistBetweenBoundingBoxes: function (source, target){
            var sb = source.get_BoundingBox();
            var tb = target.get_BoundingBox();
            if (sb.Intersects(tb))
                return 0;
            var spolygon = Microsoft.Msagl.Layout.LargeGraphLayout.DeviceIndependendZoomCalculatorForNodes.PolygonFromBox(sb);
            var tpolygon = Microsoft.Msagl.Layout.LargeGraphLayout.DeviceIndependendZoomCalculatorForNodes.PolygonFromBox(tb);
            return Microsoft.Msagl.Routing.Visibility.Polygon.Distance$$Polygon$$Polygon(spolygon, tpolygon);
        },
        PolygonFromBox: function (sb){
            var spolygon = new Microsoft.Msagl.Routing.Visibility.Polygon.ctor((function (){
                var $v33 = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor$$Point$Array([sb.get_LeftBottom(), sb.get_LeftTop(), sb.get_RightTop(), sb.get_RightBottom()]);
                $v33.set_Closed(true);
                return $v33;
            })());
            return spolygon;
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Layout.LargeGraphLayout.IZoomLevelCalculator"],
    Kind: "Class",
    definition: {
        ctor: function (nodeToLgNodeInfo, graph, settings, maxAmountPerTile){
            this.NodeToLgNodeInfo = null;
            this.maxAmountPerTile = 0;
            this._levelNodeCounts = new System.Collections.Generic.List$1.ctor(System.Int32.ctor);
            this.unassigned = 0;
            this.sortedLgNodeInfos = null;
            this.zoomLevel = 0;
            this._Graph = null;
            this._Settings = null;
            System.Object.ctor.call(this);
            this.NodeToLgNodeInfo = nodeToLgNodeInfo;
            this.maxAmountPerTile = maxAmountPerTile;
            this.set_Graph(graph);
            this.set_Settings(settings);
            this.unassigned = graph.get_Nodes().get_Count();
        },
        Graph$$: "Microsoft.Msagl.Core.Layout.GeometryGraph",
        get_Graph: function (){
            return this._Graph;
        },
        set_Graph: function (value){
            this._Graph = value;
        },
        Settings$$: "Microsoft.Msagl.Layout.LargeGraphLayout.LgLayoutSettings",
        get_Settings: function (){
            return this._Settings;
        },
        set_Settings: function (value){
            this._Settings = value;
        },
        SortedLgNodeInfos$$: "System.Collections.Generic.List`1[[Microsoft.Msagl.Core.Layout.LgNodeInfo]]",
        get_SortedLgNodeInfos: function (){
            return this.sortedLgNodeInfos;
        },
        LevelNodeCounts$$: "System.Collections.Generic.List`1[[System.Int32]]",
        get_LevelNodeCounts: function (){
            return this._levelNodeCounts;
        },
        Run: function (){
            this.sortedLgNodeInfos = this.GetSortedLgNodeInfos();
            this.get_Graph().UpdateBoundingBox();
            var gridSize = System.Math.Max$$Double$$Double(this.get_Graph().get_Width(), this.get_Graph().get_Height());
            this.zoomLevel = 1;
            while (this.SomeNodesAreNotAssigned()){
                System.Console.WriteLine$$String$$Object$$Object("zoom level {0} grisSize {1}", this.zoomLevel, gridSize);
                this.DrawNodesOnLevel(gridSize);
                this.zoomLevel *= 2;
                gridSize /= 2;
            }
        },
        DrawNodesOnLevel: function (gridSize){
            var tileTable = new System.Collections.Generic.Dictionary$2.ctor(System.Tuple$2.ctor, System.Int32.ctor);
            for (var i = 0; i < this.sortedLgNodeInfos.get_Count(); i++){
                var ni = this.sortedLgNodeInfos.get_Item$$Int32(i);
                var tuple = Microsoft.Msagl.Layout.LargeGraphLayout.DeviceIndependendZoomCalculatorForNodes.PointToTuple(this.get_Graph().get_LeftBottom(), ni.get_Center(), gridSize);
                if (!tileTable.ContainsKey(tuple))
                    tileTable.set_Item$$TKey(tuple, 0);
                var countForTile = tileTable.set_Item$$TKey(tuple, tileTable.get_Item$$TKey(tuple) + 1) + 1;
                if (countForTile > this.maxAmountPerTile){
                    if (this._levelNodeCounts.get_Count() == 0 || System.Linq.Enumerable.Last$1$$IEnumerable$1(System.Int32.ctor, this._levelNodeCounts) != i)
                        this._levelNodeCounts.Add(i);
                    break;
                }
                if (ni.get_ZoomLevelIsNotSet()){
                    ni.set_ZoomLevel(this.zoomLevel);
                    this.unassigned--;
                }
                if (this.unassigned == 0){
                    this._levelNodeCounts.Add(i + 1);
                    break;
                }
            }
        },
        SomeNodesAreNotAssigned: function (){
            return this.unassigned > 0;
        },
        GetSortedLgNodeInfos: function (){
            var ret = System.Linq.Enumerable.ToList$1(Microsoft.Msagl.Core.Layout.LgNodeInfo.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Layout.LgNodeInfo.ctor, this.get_Graph().get_Nodes(), $CreateAnonymousDelegate(this, function (n){
                return this.NodeToLgNodeInfo(n);
            })));
            ret.Sort$$Comparison$1($CreateAnonymousDelegate(this, function (a, b){
                return b.get_Rank().CompareTo$$Double(a.get_Rank());
            }));
            return ret;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$LargeGraphLayout$DeviceIndependendZoomCalculatorForNodes);
var Microsoft$Msagl$Layout$LargeGraphLayout$EdgePicker = {
    fullname: "Microsoft.Msagl.Layout.LargeGraphLayout.EdgePicker",
    baseTypeName: "System.Object",
    staticDefinition: {
        SetEdgeInfosZoomLevelsAndIcreaseRanks: function (lgData, nodeZoomLevelCalculator, nodeCountOnLevel){
            var edgePicker = new Microsoft.Msagl.Layout.LargeGraphLayout.EdgePicker.ctor(lgData, nodeZoomLevelCalculator, nodeCountOnLevel);
            edgePicker.Run();
        },
        TryToIncreaseRank: function (edgeInfo, edgeRank){
            if (edgeInfo.get_Rank() < edgeRank)
                edgeInfo.set_Rank(edgeRank);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (lgData, nodeZoomLevelCalculator, nodeCountOnLevel){
            this.lgData = null;
            this.nodeZoomLevelCalculator = null;
            this._nodeCountOnLevel = 0;
            this.PickShortestPaths = false;
            this.zoomLevel = 0;
            System.Object.ctor.call(this);
            this.lgData = lgData;
            this.nodeZoomLevelCalculator = nodeZoomLevelCalculator;
            this._nodeCountOnLevel = nodeCountOnLevel;
            this.zoomLevel = (nodeZoomLevelCalculator.get_SortedLgNodeInfos().get_Item$$Int32(nodeCountOnLevel - 1).get_ZoomLevel()) | 0;
        },
        Run: function (){
            if (this._nodeCountOnLevel == this.lgData.GeometryNodesToLgNodeInfos.get_Count()){
                var $it108 = this.lgData.GeometryEdgesToLgEdgeInfos.get_Keys().GetEnumerator();
                while ($it108.MoveNext()){
                    var e = $it108.get_Current();
                    this.UpdateEdgeInfoZoomLevel$$Edge(e);
                }
                return;
            }
            this.FillShortRoutes();
            if (this.PickShortestPaths)
                this.FillShortestPathsFromSomeSelectedNodes();
        },
        FillShortestPathsFromSomeSelectedNodes: function (){
            var bound = System.Math.Min$$Int32$$Int32(50, this._nodeCountOnLevel);
            for (var i = 0; i < bound; i++)
                this.IncludeEdgesOfShortestPathsFromNodeToOtherNodesOnLevel(this.nodeZoomLevelCalculator.get_SortedLgNodeInfos().get_Item$$Int32(i));
        },
        IncludeEdgesOfShortestPathsFromNodeToOtherNodesOnLevel: function (lgNodeInfo){
            this.RunShortestPathsToEveryOtherNode(lgNodeInfo);
            this.IncludeEdgeFromShortestPathTree(lgNodeInfo);
        },
        RunShortestPathsToEveryOtherNode: function (lgNodeInfo){
            var shortestPathToAllOthers = new Microsoft.Msagl.Layout.LargeGraphLayout.ShortestPathToAllOthers.ctor(lgNodeInfo, this.lgData.GeometryNodesToLgNodeInfos);
            shortestPathToAllOthers.Run();
        },
        IncludeEdgeFromShortestPathTree: function (lgNodeInfo){
            for (var i = 0; i < this._nodeCountOnLevel; i++){
                var otherNodeInfo = this.nodeZoomLevelCalculator.get_SortedLgNodeInfos().get_Item$$Int32(i);
                if (lgNodeInfo != otherNodeInfo){
                    var edgeRank = lgNodeInfo.get_Rank() + otherNodeInfo.get_Rank();
                    var $it109 = this.EdgesOfPath(lgNodeInfo, otherNodeInfo).GetEnumerator();
                    while ($it109.MoveNext()){
                        var e = $it109.get_Current();
                        this.UpdateEdgeInfoZoomLevel$$Edge$$Double(e, edgeRank);
                    }
                }
            }
        },
        EdgesOfPath: function (a, b){
            var $yield = [];
            if (b.Prev == null)
                return $yield;
            do{
                var e = b.Prev;
                $yield.push(e);
                b = e.get_Source() == b.get_GeometryNode() ? this.lgData.GeometryNodesToLgNodeInfos.get_Item$$TKey(e.get_Target()) : this.lgData.GeometryNodesToLgNodeInfos.get_Item$$TKey(e.get_Source());
            }
            while (b != a)
            return $yield;
        },
        FillShortRoutes: function (){
            for (var i = 0; i < this._nodeCountOnLevel; i++)
                this.FillShortRoutesOfNode(this.nodeZoomLevelCalculator.get_SortedLgNodeInfos().get_Item$$Int32(i).get_GeometryNode());
        },
        FillShortRoutesOfNode: function (node){
            var $it110 = node.get_OutEdges().GetEnumerator();
            while ($it110.MoveNext()){
                var e = $it110.get_Current();
                this.TryPickingEdge(e);
            }
        },
        TryPickingEdge: function (edge){
            if (this.lgData.GeometryNodesToLgNodeInfos.get_Item$$TKey(edge.get_Target()).get_ZoomLevel() <= this.zoomLevel)
                this.UpdateEdgeInfoZoomLevel$$Edge(edge);
        },
        UpdateEdgeInfoZoomLevel$$Edge: function (edge){
            var sourceNodeInfo = this.lgData.GeometryNodesToLgNodeInfos.get_Item$$TKey(edge.get_Source());
            var targetNodeInfo = this.lgData.GeometryNodesToLgNodeInfos.get_Item$$TKey(edge.get_Target());
            this.UpdateEdgeInfoZoomLevel$$Edge$$Double(edge, sourceNodeInfo.get_Rank() + targetNodeInfo.get_Rank());
        },
        UpdateEdgeInfoZoomLevel$$Edge$$Double: function (edge, edgeRank){
            var edgeInfo = this.lgData.GeometryEdgesToLgEdgeInfos.get_Item$$TKey(edge);
            this.TryToDecreaseZoomLevel(edgeInfo);
            Microsoft.Msagl.Layout.LargeGraphLayout.EdgePicker.TryToIncreaseRank(edgeInfo, edgeRank);
        },
        TryToDecreaseZoomLevel: function (edgeInfo){
            if (edgeInfo.get_ZoomLevel() > this.zoomLevel)
                edgeInfo.set_ZoomLevel(this.zoomLevel);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$LargeGraphLayout$EdgePicker);
var Microsoft$Msagl$Layout$LargeGraphLayout$IZoomLevelCalculator = {
    fullname: "Microsoft.Msagl.Layout.LargeGraphLayout.IZoomLevelCalculator",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Interface"
};
JsTypes.push(Microsoft$Msagl$Layout$LargeGraphLayout$IZoomLevelCalculator);
var Microsoft$Msagl$Layout$LargeGraphLayout$LgData = {
    fullname: "Microsoft.Msagl.Layout.LargeGraphLayout.LgData",
    baseTypeName: "System.Object",
    staticDefinition: {
        TransferHighlightedRails: function (level, edge, railsOfEdge){
            var $it113 = railsOfEdge.GetEnumerator();
            while ($it113.MoveNext()){
                var rail = $it113.get_Current();
                Microsoft.Msagl.Layout.LargeGraphLayout.LgData.AddRailToRailTreeOfLowerLevel(rail, level);
            }
            level._railsOfEdges.set_Item$$TKey(edge, railsOfEdge);
            level.HighlightedRails.InsertRange(railsOfEdge);
        },
        AddRailToRailTreeOfLowerLevel: function (rail, lowerLevel){
            var pt = rail.PointTuple();
            var box = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(pt.get_Item1(), pt.get_Item2());
            if (!lowerLevel._railTree.Contains(box, rail))
                lowerLevel._railTree.Add$$Rectangle$$TData(box, rail);
        },
        RailBelongsToLevel: function (level, rail){
            return level.ZoomLevel >= rail.ZoomLevel;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (mainGeomGraph){
            this.rTreeOfConnectedComps = new Microsoft.Msagl.Core.Geometry.RTree$1.ctor(Microsoft.Msagl.Core.Layout.GeometryGraph.ctor);
            this.GeometryNodesToLgNodeInfos = null;
            this.GeometryEdgesToLgEdgeInfos = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor, Microsoft.Msagl.Layout.LargeGraphLayout.LgEdgeInfo.ctor);
            this._higlightedEdges = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor);
            this.levels = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Layout.LargeGraphLayout.LgLevel.ctor);
            this.mainGeomGraph = null;
            this._SortedLgNodeInfos = null;
            this._LevelNodeCounts = null;
            System.Object.ctor.call(this);
            this.mainGeomGraph = mainGeomGraph;
        },
        Levels$$: "System.Collections.Generic.IList`1[[Microsoft.Msagl.Layout.LargeGraphLayout.LgLevel]]",
        get_Levels: function (){
            return this.levels;
        },
        AddConnectedGeomGraph: function (geomGraph){
            this.rTreeOfConnectedComps.Add$$Rectangle$$TData(geomGraph.get_BoundingBox(), geomGraph);
        },
        ConnectedGeometryGraphs$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Layout.GeometryGraph]]",
        get_ConnectedGeometryGraphs: function (){
            return this.rTreeOfConnectedComps.GetAllLeaves();
        },
        SortedLgNodeInfos$$: "System.Collections.Generic.List`1[[Microsoft.Msagl.Core.Layout.LgNodeInfo]]",
        get_SortedLgNodeInfos: function (){
            return this._SortedLgNodeInfos;
        },
        set_SortedLgNodeInfos: function (value){
            this._SortedLgNodeInfos = value;
        },
        LevelNodeCounts$$: "System.Collections.Generic.List`1[[System.Int32]]",
        get_LevelNodeCounts: function (){
            return this._LevelNodeCounts;
        },
        set_LevelNodeCounts: function (value){
            this._LevelNodeCounts = value;
        },
        GetSetOfVisibleRails: function (visibleRectangle, zoomLevel){
            var visibleLevelIndex = this.GetRelevantEdgeLevel(zoomLevel);
            return new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Layout.LargeGraphLayout.Rail.ctor, this.levels.get_Item$$Int32(visibleLevelIndex).GetRailsIntersectionVisRect(visibleRectangle));
        },
        AddLevel: function (levelZoom){
            var level = new Microsoft.Msagl.Layout.LargeGraphLayout.LgLevel.ctor(levelZoom, this.mainGeomGraph);
            this.levels.Add(level);
            return level;
        },
        GetRelevantEdgeLevel: function (zoomLevel){
            var logOfZoomLevel = System.Math.Log$$Double$$Double(zoomLevel, 2);
            if (logOfZoomLevel >= this.levels.get_Count()){
                return this.levels.get_Count() - 1;
            }
            var doubleIndexOfLevel = logOfZoomLevel - 1;
            var floor = (System.Math.Floor$$Double(doubleIndexOfLevel)) | 0;
            var ceiling = (System.Math.Ceiling$$Double(doubleIndexOfLevel)) | 0;
            System.Diagnostics.Debug.Assert$$Boolean(floor <= ceiling && floor <= doubleIndexOfLevel && doubleIndexOfLevel <= ceiling);
            if (ceiling <= 0)
                return 0;
            if (floor == ceiling)
                return floor;
            if (doubleIndexOfLevel < floor + 0.9)
                return floor;
            return ceiling;
        },
        HighlightEdgesPassingThroughRail: function (rail){
            var railLevel = this.levels.get_Item$$Int32((System.Math.Log$$Double$$Double(rail.ZoomLevel, 2)) | 0);
            var passingEdges = railLevel.GetEdgesPassingThroughRail(rail);
            this.HighlightEdges(passingEdges);
        },
        HighlightEdges: function (passingEdges){
            this._higlightedEdges.InsertRange(passingEdges);
            for (var i = this.levels.get_Count() - 1; i >= 0; i--)
                this.HighlightEdgesOnLevel(i, passingEdges);
        },
        HighlightEdgesOnLevel: function (i, edges){
            var level = this.levels.get_Item$$Int32(i);
            var railsToHighlight = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Layout.LargeGraphLayout.Rail.ctor);
            var $it111 = edges.GetEnumerator();
            while ($it111.MoveNext()){
                var edge = $it111.get_Current();
                var railsOfEdge;
                if (!(function (){
                    var $1 = {
                        Value: railsOfEdge
                    };
                    var $res = level._railsOfEdges.TryGetValue(edge, $1);
                    railsOfEdge = $1.Value;
                    return $res;
                }).call(this)){
                    var edgeInfo = this.GeometryEdgesToLgEdgeInfos.get_Item$$TKey(edge);
                    var edgeLevelIndex = (System.Math.Min$$Double$$Double(System.Math.Log$$Double$$Double(edgeInfo.get_ZoomLevel(), 2), this.levels.get_Count() - 1)) | 0;
                    railsOfEdge = this.levels.get_Item$$Int32(edgeLevelIndex)._railsOfEdges.get_Item$$TKey(edge);
                    Microsoft.Msagl.Layout.LargeGraphLayout.LgData.TransferHighlightedRails(level, edge, railsOfEdge);
                }
                else
                    railsToHighlight.InsertRange(railsOfEdge);
            }
            var $it112 = railsToHighlight.GetEnumerator();
            while ($it112.MoveNext()){
                var rail = $it112.get_Current();
                if (!level.HighlightedRails.Contains$$T(rail)){
                    rail.set_IsHighlighted(true);
                    level.HighlightedRails.Insert(rail);
                }
            }
        },
        GetMaximalZoomLevel: function (){
            if (this.levels == null || this.levels.get_Count() == 0)
                return 1;
            return System.Linq.Enumerable.Last$1$$IEnumerable$1(Microsoft.Msagl.Layout.LargeGraphLayout.LgLevel.ctor, this.levels).ZoomLevel;
        },
        PutOffEdgesPassingThroughTheRail: function (rail){
            var railLevel = this.levels.get_Item$$Int32((System.Math.Log$$Double$$Double(rail.ZoomLevel, 2)) | 0);
            var passingEdges = railLevel.GetEdgesPassingThroughRail(rail);
            this.PutOffEdges(passingEdges);
        },
        PutOffEdges: function (edgesToPutOff){
            var edgesToPutoffSet = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Edge.ctor, edgesToPutOff);
            for (var i = this.levels.get_Count() - 1; i >= 0; i--)
                this.PutOffEdgesOnLevel(i, edgesToPutoffSet);
            var $it114 = edgesToPutOff.GetEnumerator();
            while ($it114.MoveNext()){
                var e = $it114.get_Current();
                this._higlightedEdges.Remove(e);
            }
        },
        PutOffEdgesOnLevel: function (i, edgesToPutOff){
            var level = this.levels.get_Item$$Int32(i);
            var railsThatShouldBeHiglighted = this.GetRailsThatShouldBeHighlighted(level, edgesToPutOff);
            var $it115 = level.HighlightedRails.GetEnumerator();
            while ($it115.MoveNext()){
                var rail = $it115.get_Current();
                if (!railsThatShouldBeHiglighted.Contains$$T(rail)){
                    if (Microsoft.Msagl.Layout.LargeGraphLayout.LgData.RailBelongsToLevel(level, rail))
                        rail.set_IsHighlighted(false);
                    else {
                        var railTuple = rail.PointTuple();
                        var rect = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(railTuple.get_Item1(), railTuple.get_Item2());
                        level._railTree.Remove(rect, rail);
                    }
                }
            }
            var $it116 = edgesToPutOff.GetEnumerator();
            while ($it116.MoveNext()){
                var edge = $it116.get_Current();
                var lgEdgeInfo = this.GeometryEdgesToLgEdgeInfos.get_Item$$TKey(edge);
                if (lgEdgeInfo.get_ZoomLevel() > level.ZoomLevel)
                    level._railsOfEdges.Remove(edge);
            }
            level.HighlightedRails = railsThatShouldBeHiglighted;
        },
        GetRailsThatShouldBeHighlighted: function (level, edgesToPutOff){
            var ret = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Layout.LargeGraphLayout.Rail.ctor);
            var $it117 = this._higlightedEdges.GetEnumerator();
            while ($it117.MoveNext()){
                var edge = $it117.get_Current();
                if (edgesToPutOff.Contains$$T(edge))
                    continue;
                var railsOfEdge;
                if ((function (){
                    var $1 = {
                        Value: railsOfEdge
                    };
                    var $res = level._railsOfEdges.TryGetValue(edge, $1);
                    railsOfEdge = $1.Value;
                    return $res;
                }).call(this)){
                    ret.InsertRange(railsOfEdge);
                }
            }
            return ret;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$LargeGraphLayout$LgData);
var Microsoft$Msagl$Layout$LargeGraphLayout$LgData$CurveRailComparer = {
    fullname: "Microsoft.Msagl.Layout.LargeGraphLayout.LgData.CurveRailComparer",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IEqualityComparer$1"],
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        },
        Equals$$Tuple$2$Point$Point$$Tuple$2$Point$Point: function (x, y){
            return Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point$$Double(x.get_Item1(), y.get_Item1(), 1E-05) && Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point$$Double(x.get_Item2(), y.get_Item2(), 1E-05) || Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point$$Double(x.get_Item1(), y.get_Item2(), 1E-05) && Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point$$Double(x.get_Item2(), y.get_Item1(), 1E-05);
        },
        GetHashCode$$Tuple$2$Point$Point: function (tuple){
            return Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Point$$Int32(tuple.get_Item1(), 5).GetHashCode() | Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Point$$Int32(tuple.get_Item2(), 5).GetHashCode();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$LargeGraphLayout$LgData$CurveRailComparer);
var Microsoft$Msagl$Layout$LargeGraphLayout$LgData$ArrowheadRailComparer = {
    fullname: "Microsoft.Msagl.Layout.LargeGraphLayout.LgData.ArrowheadRailComparer",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IEqualityComparer$1"],
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        },
        Equals$$Arrowhead$$Arrowhead: function (x, y){
            return Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(x.get_TipPosition(), y.get_TipPosition());
        },
        GetHashCode$$Arrowhead: function (arrowhead){
            return Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Point$$Int32(arrowhead.get_TipPosition(), 5).GetHashCode();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$LargeGraphLayout$LgData$ArrowheadRailComparer);
var Microsoft$Msagl$Layout$LargeGraphLayout$LgEdgeInfo = {
    fullname: "Microsoft.Msagl.Layout.LargeGraphLayout.LgEdgeInfo",
    baseTypeName: "Microsoft.Msagl.Core.Layout.LgInfoBase",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (edge){
            this._Edge = null;
            Microsoft.Msagl.Core.Layout.LgInfoBase.ctor.call(this);
            this.set_Edge(edge);
            this.set_ZoomLevel(2147483647);
        },
        Edge$$: "Microsoft.Msagl.Core.Layout.Edge",
        get_Edge: function (){
            return this._Edge;
        },
        set_Edge: function (value){
            this._Edge = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$LargeGraphLayout$LgEdgeInfo);
var Microsoft$Msagl$Layout$LargeGraphLayout$LgInteractor = {
    fullname: "Microsoft.Msagl.Layout.LargeGraphLayout.LgInteractor",
    baseTypeName: "System.Object",
    staticDefinition: {
        PrepareGraphForLayout: function (connectedGraph){
            var $it133 = connectedGraph.get_RootCluster().AllClustersDepthFirst().GetEnumerator();
            while ($it133.MoveNext()){
                var cluster = $it133.get_Current();
                if (cluster.get_RectangularBoundary() == null)
                    cluster.set_RectangularBoundary(new Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.ctor());
            }
            var $it134 = connectedGraph.get_Edges().GetEnumerator();
            while ($it134.MoveNext()){
                var edge = $it134.get_Current();
                if (edge.get_SourcePort() == null){
                    var e = edge;
                    edge.set_SourcePort((function (ed){
                        return new Microsoft.Msagl.Core.Layout.RelativeFloatingPort.ctor$$Func$1$ICurve$$Func$1$Point(function (){
                            return ed.get_Source().get_BoundaryCurve();
                        }, function (){
                            return ed.get_Source().get_Center();
                        });
                    })(e));
                }
                if (edge.get_TargetPort() == null){
                    var e = edge;
                    edge.set_TargetPort((function (ed){
                        return new Microsoft.Msagl.Core.Layout.RelativeFloatingPort.ctor$$Func$1$ICurve$$Func$1$Point(function (){
                            return ed.get_Target().get_BoundaryCurve();
                        }, function (){
                            return ed.get_Target().get_Center();
                        });
                    })(e));
                }
            }
        },
        CreateClusteredSubgraphFromFlatGraph: function (subgraph, mainGeometryGraph){
            if (System.Linq.Enumerable.Any$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, mainGeometryGraph.get_RootCluster().get_Clusters()) == false)
                return subgraph;
            var ret = new Microsoft.Msagl.Core.Layout.GeometryGraph.ctor();
            var originalNodesToNewNodes = Microsoft.Msagl.Layout.LargeGraphLayout.LgInteractor.MapSubgraphNodesToNewNodesForRouting(subgraph);
            Microsoft.Msagl.Layout.LargeGraphLayout.LgInteractor.ReplicateClusterStructure(subgraph, originalNodesToNewNodes);
            Microsoft.Msagl.Layout.LargeGraphLayout.LgInteractor.AddNewNodeAndClustersToTheNewGraph(originalNodesToNewNodes, ret);
            var $it135 = subgraph.get_Edges().GetEnumerator();
            while ($it135.MoveNext()){
                var edge = $it135.get_Current();
                var ns = originalNodesToNewNodes.get_Item$$TKey(edge.get_Source());
                var nt = originalNodesToNewNodes.get_Item$$TKey(edge.get_Target());
                ret.get_Edges().Add((function (){
                    var $v41 = new Microsoft.Msagl.Core.Layout.Edge.ctor$$Node$$Node(ns, nt);
                    $v41.set_EdgeGeometry(edge.get_EdgeGeometry());
                    $v41.set_SourcePort(null);
                    $v41.set_TargetPort(null);
                    return $v41;
                })());
            }
            var $it136 = originalNodesToNewNodes.GetEnumerator();
            while ($it136.MoveNext()){
                var kv = $it136.get_Current();
                var newNode = kv.get_Value();
                var cluster = As(newNode, Microsoft.Msagl.Core.Layout.Cluster.ctor);
                if (cluster != null){
                    var oldNode = kv.get_Key();
                    if (oldNode.get_BoundaryCurve() != newNode.get_BoundaryCurve()){
                        oldNode.set_BoundaryCurve(newNode.get_BoundaryCurve());
                        oldNode.RaiseLayoutChangeEvent(null);
                    }
                }
            }
            return ret;
        },
        AddNewNodeAndClustersToTheNewGraph: function (onodesToNewNodes, ret){
            var $it137 = onodesToNewNodes.get_Values().GetEnumerator();
            while ($it137.MoveNext()){
                var newNode = $it137.get_Current();
                var cl = As(newNode, Microsoft.Msagl.Core.Layout.Cluster.ctor);
                if (cl == null)
                    ret.get_Nodes().Add(newNode);
                else {
                    if (!System.Linq.Enumerable.Any$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, cl.get_ClusterParents()))
                        ret.get_RootCluster().AddCluster(cl);
                }
            }
        },
        ReplicateClusterStructure: function (geometryGraph, onodesToNewNodes){
            var $it138 = geometryGraph.get_Nodes().GetEnumerator();
            while ($it138.MoveNext()){
                var onode = $it138.get_Current();
                var $it139 = onode.get_ClusterParents().GetEnumerator();
                while ($it139.MoveNext()){
                    var oclparent = $it139.get_Current();
                    var newParent;
                    if ((function (){
                        var $1 = {
                            Value: newParent
                        };
                        var $res = onodesToNewNodes.TryGetValue(oclparent, $1);
                        newParent = $1.Value;
                        return $res;
                    })())
                        (Cast(newParent, Microsoft.Msagl.Core.Layout.Cluster.ctor)).AddNode(onodesToNewNodes.get_Item$$TKey(onode));
                }
            }
        },
        MapSubgraphNodesToNewNodesForRouting: function (geometryGraph){
            var onodesToNewNodes = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Layout.Node.ctor);
            var $it140 = geometryGraph.get_Nodes().GetEnumerator();
            while ($it140.MoveNext()){
                var oNode = $it140.get_Current();
                var cluster = As(oNode, Microsoft.Msagl.Core.Layout.Cluster.ctor);
                onodesToNewNodes.set_Item$$TKey(oNode, cluster != null ? (function (){
                    var $v42 = new Microsoft.Msagl.Core.Layout.Cluster.ctor();
                    $v42.set_CollapsedBoundary(cluster.get_CollapsedBoundary());
                    $v42.set_BoundaryCurve(oNode.get_BoundaryCurve());
                    return $v42;
                })() : new Microsoft.Msagl.Core.Layout.Node.ctor$$ICurve(oNode.get_BoundaryCurve()));
            }
            return onodesToNewNodes;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (geometryGraph, lgLayoutSettings, cancelToken){
            this.mainGeometryGraph = null;
            this.lgLayoutSettings = null;
            this.railGraph = null;
            this.visibleRectangle = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
            this.visibleNodeSet = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Layout.LgNodeInfo.ctor);
            this.lgNodeHierarchy = null;
            this.lgData = null;
            this.cancelToken = null;
            this.RunInParallel = true;
            this._initFromPrecomputedLgData = false;
            this._CurrentZoomLevel = 0;
            this._MaximalEdgeZoomLevelInterval = null;
            System.Object.ctor.call(this);
            this.mainGeometryGraph = geometryGraph;
            this.lgLayoutSettings = lgLayoutSettings;
            this.cancelToken = cancelToken;
            if (geometryGraph.get_LgData() == null){
                this.lgData = (function (){
                    var $v34 = new Microsoft.Msagl.Layout.LargeGraphLayout.LgData.ctor(geometryGraph);
                    $v34.GeometryNodesToLgNodeInfos = lgLayoutSettings.get_GeometryNodesToLgNodeInfos();
                    return $v34;
                }).call(this);
                geometryGraph.set_LgData(this.lgData);
            }
            else {
                this._initFromPrecomputedLgData = true;
                this.lgData = geometryGraph.get_LgData();
                lgLayoutSettings.set_GeometryNodesToLgNodeInfos(this.lgData.GeometryNodesToLgNodeInfos);
            }
        },
        CurrentZoomLevel$$: "System.Double",
        get_CurrentZoomLevel: function (){
            return this._CurrentZoomLevel;
        },
        set_CurrentZoomLevel: function (value){
            this._CurrentZoomLevel = value;
        },
        Initialize: function (){
            if (this._initFromPrecomputedLgData){
                this.InitOnPrecomputedLgData();
                return;
            }
            this.CreateConnectedComponentsAndLayoutTheWholeGraph();
            Microsoft.Msagl.Layout.LargeGraphLayout.LevelCalculator.SetNodeZoomLevelsAndRouteEdgesOnLevels(this.lgData, this.mainGeometryGraph, this.lgLayoutSettings);
            this.TestZoomLevels();
            this.lgNodeHierarchy = Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnEnumeration(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.LgNodeInfo.ctor, Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.LgNodeInfo.ctor, this.lgData.GeometryNodesToLgNodeInfos.get_Values(), $CreateAnonymousDelegate(this, function (n){
                return !(Is(n.get_GeometryNode(), Microsoft.Msagl.Core.Layout.Cluster.ctor));
            })), $CreateAnonymousDelegate(this, function (lginfo){
                return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(Microsoft.Msagl.Core.Layout.LgNodeInfo.ctor, lginfo, lginfo.get_BoundingBox());
            })));
            this.railGraph = new Microsoft.Msagl.Layout.LargeGraphLayout.RailGraph.ctor();
        },
        InitOnPrecomputedLgData: function (){
            this.lgNodeHierarchy = Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnEnumeration(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.LgNodeInfo.ctor, Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.LgNodeInfo.ctor, this.lgData.GeometryNodesToLgNodeInfos.get_Values(), $CreateAnonymousDelegate(this, function (n){
                return !(Is(n.get_GeometryNode(), Microsoft.Msagl.Core.Layout.Cluster.ctor));
            })), $CreateAnonymousDelegate(this, function (lginfo){
                return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(Microsoft.Msagl.Core.Layout.LgNodeInfo.ctor, lginfo, lginfo.get_BoundingBox());
            })));
            this.railGraph = new Microsoft.Msagl.Layout.LargeGraphLayout.RailGraph.ctor();
        },
        TestZoomLevels: function (){
            var $it118 = this.mainGeometryGraph.get_RootCluster().AllClustersDepthFirstExcludingSelf().GetEnumerator();
            while ($it118.MoveNext()){
                var cluster = $it118.get_Current();
                var $it119 = System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Layout.Node.ctor, cluster.get_Clusters(), cluster.get_Nodes()).GetEnumerator();
                while ($it119.MoveNext()){
                    var n = $it119.get_Current();
                    System.Diagnostics.Debug.Assert$$Boolean(this.lgData.GeometryNodesToLgNodeInfos.get_Item$$TKey(cluster).get_Rank() >= this.lgData.GeometryNodesToLgNodeInfos.get_Item$$TKey(n).get_Rank());
                }
            }
        },
        MaximalEdgeZoomLevelInterval$$: "Microsoft.Msagl.Layout.LargeGraphLayout.Interval",
        get_MaximalEdgeZoomLevelInterval: function (){
            return this._MaximalEdgeZoomLevelInterval;
        },
        set_MaximalEdgeZoomLevelInterval: function (value){
            this._MaximalEdgeZoomLevelInterval = value;
        },
        FillGeometryNodeToLgInfosTables: function (){
            var $it120 = System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Layout.Node.ctor, this.mainGeometryGraph.get_Nodes(), this.mainGeometryGraph.get_RootCluster().AllClustersWideFirstExcludingSelf()).GetEnumerator();
            while ($it120.MoveNext()){
                var node = $it120.get_Current();
                this.lgData.GeometryNodesToLgNodeInfos.set_Item$$TKey(node, new Microsoft.Msagl.Core.Layout.LgNodeInfo.ctor(node));
            }
            var $it121 = this.mainGeometryGraph.get_Edges().GetEnumerator();
            while ($it121.MoveNext()){
                var edge = $it121.get_Current();
                this.lgData.GeometryEdgesToLgEdgeInfos.set_Item$$TKey(edge, new Microsoft.Msagl.Layout.LargeGraphLayout.LgEdgeInfo.ctor(edge));
            }
        },
        CreateConnectedComponentsAndLayoutTheWholeGraph: function (){
            this.CreateConnectedGraphs();
            if (this.lgLayoutSettings.get_NeedToLayout()){
                if (this.RunInParallel)
                    System.Threading.Tasks.Parallel.ForEach$1$$IEnumerable$1$$ParallelOptions$$Action$1(Microsoft.Msagl.Core.Layout.GeometryGraph.ctor, this.lgData.get_ConnectedGeometryGraphs(), new System.Threading.Tasks.ParallelOptions.ctor(), $CreateDelegate(this, this.LayoutAndPadOneComponent));
                else {
                    var $it122 = this.lgData.get_ConnectedGeometryGraphs().GetEnumerator();
                    while ($it122.MoveNext()){
                        var connectedGraph = $it122.get_Current();
                        this.LayoutAndPadOneComponent(connectedGraph);
                    }
                }
                var rect = Microsoft.Msagl.Layout.MDS.MdsGraphLayout.PackGraphs(this.lgData.get_ConnectedGeometryGraphs(), this.lgLayoutSettings);
                this.mainGeometryGraph.set_BoundingBox(rect);
            }
            else {
                var $it123 = this.lgData.get_ConnectedGeometryGraphs().GetEnumerator();
                while ($it123.MoveNext()){
                    var graph = $it123.get_Current();
                    graph.UpdateBoundingBox();
                }
            }
            this.FillGeometryNodeToLgInfosTables();
        },
        LayoutAndPadOneComponent: function (connectedGraph){
            this.LayoutOneComponent(connectedGraph);
            var box = connectedGraph.get_BoundingBox();
            box.Pad$$Double(this.lgLayoutSettings.get_NodeSeparation() / 2);
        },
        CreateConnectedGraphs: function (){
            var nodeToIndex;
            var listOfNodes = (function (){
                var $1 = {
                    Value: nodeToIndex
                };
                var $res = this.CreateNodeListForBasicGraph($1);
                nodeToIndex = $1.Value;
                return $res;
            }).call(this);
            var basicGraph = new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor$$IEnumerable$1$$Int32(Microsoft.Msagl.Core.Layout.SimpleIntEdge.ctor, this.GetSimpleIntEdges(nodeToIndex), listOfNodes.get_Count());
            var comps = Microsoft.Msagl.Core.GraphAlgorithms.ConnectedComponentCalculator$1.GetComponents(basicGraph);
            var $it124 = comps.GetEnumerator();
            while ($it124.MoveNext()){
                var comp = $it124.get_Current();
                this.lgData.AddConnectedGeomGraph(this.GetConnectedSubgraph(comp, listOfNodes));
            }
        },
        GetConnectedSubgraph: function (comp, nodeList){
            var edges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor);
            var nodes = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor);
            var geomGraph = new Microsoft.Msagl.Core.Layout.GeometryGraph.ctor();
            var $it125 = comp.GetEnumerator();
            while ($it125.MoveNext()){
                var i = $it125.get_Current();
                var node = nodeList.get_Item$$Int32(i);
                var cluster = As(node, Microsoft.Msagl.Core.Layout.Cluster.ctor);
                if (cluster != null){
                    if (System.Linq.Enumerable.First$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, cluster.get_ClusterParents()) == this.mainGeometryGraph.get_RootCluster()){
                        geomGraph.get_RootCluster().AddCluster(cluster);
                    }
                }
                else {
                    nodes.Add(node);
                }
                var $it126 = System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Layout.Edge.ctor, node.get_OutEdges(), node.get_SelfEdges()).GetEnumerator();
                while ($it126.MoveNext()){
                    var edge = $it126.get_Current();
                    System.Diagnostics.Debug.Assert$$Boolean(!edges.Contains(edge));
                    edges.Add(edge);
                }
            }
            geomGraph.set_Edges(new Microsoft.Msagl.Layout.LargeGraphLayout.SimpleEdgeCollection.ctor(edges));
            geomGraph.set_Nodes(new Microsoft.Msagl.Layout.LargeGraphLayout.SimpleNodeCollection.ctor(nodes));
            return geomGraph;
        },
        CreateNodeListForBasicGraph: function (nodeToIndex){
            var list = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor);
            nodeToIndex.Value = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, System.Int32.ctor);
            var $it127 = this.mainGeometryGraph.get_Nodes().GetEnumerator();
            while ($it127.MoveNext()){
                var node = $it127.get_Current();
                nodeToIndex.Value.set_Item$$TKey(node, list.get_Count());
                list.Add(node);
            }
            var $it128 = this.mainGeometryGraph.get_RootCluster().AllClustersDepthFirstExcludingSelf().GetEnumerator();
            while ($it128.MoveNext()){
                var node = $it128.get_Current();
                nodeToIndex.Value.set_Item$$TKey(node, list.get_Count());
                list.Add(node);
            }
            return list;
        },
        GetSimpleIntEdges: function (nodeToIndex){
            var list = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.SimpleIntEdge.ctor);
            var $it129 = this.mainGeometryGraph.get_Edges().GetEnumerator();
            while ($it129.MoveNext()){
                var edge = $it129.get_Current();
                list.Add((function (){
                    var $v35 = new Microsoft.Msagl.Core.Layout.SimpleIntEdge.ctor();
                    $v35.set_Source(nodeToIndex.get_Item$$TKey(edge.get_Source()));
                    $v35.set_Target(nodeToIndex.get_Item$$TKey(edge.get_Target()));
                    return $v35;
                }).call(this));
            }
            var $it130 = this.mainGeometryGraph.get_RootCluster().AllClustersDepthFirstExcludingSelf().GetEnumerator();
            while ($it130.MoveNext()){
                var cluster = $it130.get_Current();
                var $it131 = cluster.get_Clusters().GetEnumerator();
                while ($it131.MoveNext()){
                    var child = $it131.get_Current();
                    list.Add((function (){
                        var $v36 = new Microsoft.Msagl.Core.Layout.SimpleIntEdge.ctor();
                        $v36.set_Source(nodeToIndex.get_Item$$TKey(cluster));
                        $v36.set_Target(nodeToIndex.get_Item$$TKey(child));
                        return $v36;
                    }).call(this));
                }
                var $it132 = cluster.get_Nodes().GetEnumerator();
                while ($it132.MoveNext()){
                    var child = $it132.get_Current();
                    list.Add((function (){
                        var $v37 = new Microsoft.Msagl.Core.Layout.SimpleIntEdge.ctor();
                        $v37.set_Source(nodeToIndex.get_Item$$TKey(cluster));
                        $v37.set_Target(nodeToIndex.get_Item$$TKey(child));
                        return $v37;
                    }).call(this));
                }
            }
            return list;
        },
        LayoutOneComponent: function (component){
            Microsoft.Msagl.Layout.LargeGraphLayout.LgInteractor.PrepareGraphForLayout(component);
            if (System.Linq.Enumerable.Any$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, component.get_RootCluster().get_Clusters())){
                var layoutSettings = (function (){
                    var $v38 = new Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.ctor();
                    $v38.set_FallbackLayoutSettings((function (){
                        var $v39 = new Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.ctor();
                        $v39.set_AvoidOverlaps(true);
                        return $v39;
                    }).call(this));
                    $v38.set_NodeSeparation(this.lgLayoutSettings.get_NodeSeparation());
                    $v38.set_LayerSeparation(this.lgLayoutSettings.get_NodeSeparation());
                    $v38.set_EdgeRoutingSettings(this.lgLayoutSettings.get_EdgeRoutingSettings());
                    $v38.set_LayeringOnly(true);
                    return $v38;
                }).call(this);
                var initialBc = new Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.ctor$$GeometryGraph$$Func$2$Cluster$LayoutAlgorithmSettings(component, $CreateAnonymousDelegate(this, function (a){
                    return layoutSettings;
                }));
                initialBc.Run();
            }
            else
                Microsoft.Msagl.Miscellaneous.LayoutHelpers.CalculateLayout(component, this.GetMdsLayoutSettings(), this.cancelToken);
            var box = component.get_BoundingBox();
            box.Pad$$Double(this.lgLayoutSettings.get_NodeSeparation() / 2);
            component.set_BoundingBox(box);
        },
        GetMdsLayoutSettings: function (){
            var settings = (function (){
                var $v40 = new Microsoft.Msagl.Layout.MDS.MdsLayoutSettings.ctor();
                $v40.get_EdgeRoutingSettings().set_KeepOriginalSpline(true);
                $v40.get_EdgeRoutingSettings().set_EdgeRoutingMode(Microsoft.Msagl.Core.Routing.EdgeRoutingMode.None);
                return $v40;
            }).call(this);
            settings.set_ScaleX(settings.get_ScaleX() * 3);
            settings.set_ScaleY(settings.get_ScaleY() * 3);
            return settings;
        },
        FindVisibleRails: function (){
            this.railGraph.Rails.Clear();
            this.railGraph.Rails.InsertRange(this.lgData.GetSetOfVisibleRails(this.visibleRectangle, this.get_CurrentZoomLevel()));
            this.railGraph.VisibleEdges.Clear();
            this.railGraph.VisibleEdges.InsertRange(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Layout.LargeGraphLayout.Rail.ctor, Microsoft.Msagl.Core.Layout.Edge.ctor, this.railGraph.Rails, $CreateAnonymousDelegate(this, function (r){
                return r.TopRankedEdgeInfoOfTheRail.get_Edge();
            })));
        },
        RailGraph$$: "Microsoft.Msagl.Layout.LargeGraphLayout.RailGraph",
        get_RailGraph: function (){
            return this.railGraph;
        },
        GeometryEdgesToLgEdgeInfos$$: "System.Collections.Generic.IDictionary`2[[Microsoft.Msagl.Core.Layout.Edge],[Microsoft.Msagl.Layout.LargeGraphLayout.LgEdgeInfo]]",
        get_GeometryEdgesToLgEdgeInfos: function (){
            return this.lgData.GeometryEdgesToLgEdgeInfos;
        },
        AddFullyVisibleNodeToRailGraph: function (nodeInfo){
            nodeInfo.set_Kind(Microsoft.Msagl.Core.Layout.LgNodeInfoKind.FullyVisible);
            this.visibleNodeSet.Insert(nodeInfo);
            nodeInfo.set_Scale(1);
            this.AddAllParentsToOpenNodes(nodeInfo.get_GeometryNode());
        },
        FigureOutSatelliteScale: function (satellite){
            var lower = satellite.get_ZoomLevel() / this.lgLayoutSettings.SattelliteZoomFactor;
            var upper = satellite.get_ZoomLevel();
            return System.Math.Sqrt(0.8 * (this.get_CurrentZoomLevel() - lower) / (upper - lower) + 0.2);
        },
        RunOnViewChange: function (){
            this.visibleRectangle = Microsoft.Msagl.Core.Geometry.Rectangle.Intersect(this.lgLayoutSettings.get_ClientViewportMappedToGraph(), this.mainGeometryGraph.get_BoundingBox());
            if (this.visibleRectangle.get_IsEmpty())
                return;
            this.set_CurrentZoomLevel(this.GetZoomFactorToTheGraph());
            this.FillRailGraph();
            this.lgLayoutSettings.OnViewerChangeTransformAndInvalidateGraph(null);
        },
        GetZoomFactorToTheGraph: function (){
            return this.lgLayoutSettings.TransformFromGraphToScreen().get_Item$$Int32$$Int32(0, 0) / this.FitFactor();
        },
        FitFactor: function (){
            var vp = this.lgLayoutSettings.get_ClientViewportFunc()();
            return System.Math.Min$$Double$$Double(vp.get_Width() / this.mainGeometryGraph.get_Width(), vp.get_Height() / this.mainGeometryGraph.get_Height());
        },
        FillRailGraph: function (){
            this.ProcessOpenNodesAndSatelliteNodes();
            this.FindVisibleRails();
            this.RegisterPathNodes();
            this.railGraph.Nodes.Clear();
            var $it141 = this.visibleNodeSet.GetEnumerator();
            while ($it141.MoveNext()){
                var lgInfo = $it141.get_Current();
                this.railGraph.Nodes.Insert(lgInfo.get_GeometryNode());
            }
        },
        ProcessOpenNodesAndSatelliteNodes: function (){
            this.ClearOpenAndSatelliteSets();
            this.FillOpenNodeAdnSatelliteSets();
        },
        ClearOpenAndSatelliteSets: function (){
            var $it142 = this.visibleNodeSet.GetEnumerator();
            while ($it142.MoveNext()){
                var lgNodeInfo = $it142.get_Current();
                lgNodeInfo.set_Kind(Microsoft.Msagl.Core.Layout.LgNodeInfoKind.OutOfView);
            }
            this.visibleNodeSet.Clear();
        },
        FillOpenNodeAdnSatelliteSets: function (){
            this.lgLayoutSettings.set_BackgroundImageIsHidden(true);
            var $it143 = this.lgNodeHierarchy.GetNodeItemsIntersectingRectangle(this.visibleRectangle).GetEnumerator();
            while ($it143.MoveNext()){
                var nodeInfo = $it143.get_Current();
                this.AddVisibleNode(nodeInfo);
            }
        },
        AddVisibleNode: function (nodeInfo){
            if (nodeInfo.get_ZoomLevel() <= this.get_CurrentZoomLevel())
                this.AddFullyVisibleNodeToRailGraph(nodeInfo);
            else if (nodeInfo.get_ZoomLevel() <= this.get_CurrentZoomLevel() * this.lgLayoutSettings.SattelliteZoomFactor){
                this.visibleNodeSet.Insert(nodeInfo);
                nodeInfo.set_Kind(Microsoft.Msagl.Core.Layout.LgNodeInfoKind.Satellite);
                nodeInfo.set_Scale(this.FigureOutSatelliteScale(nodeInfo));
                this.AddAllParentsToOpenNodes(nodeInfo.get_GeometryNode());
            }
            else {
                this.lgLayoutSettings.set_BackgroundImageIsHidden(false);
            }
        },
        RegisterPathNodes: function (){
            var $it144 = this.railGraph.VisibleEdges.GetEnumerator();
            while ($it144.MoveNext()){
                var e = $it144.get_Current();
                this.RegisterSourceAndTargetOfPathEdgeAsPathNodes(e);
            }
        },
        RegisterSourceAndTargetOfPathEdgeAsPathNodes: function (edge){
            this.RegisterPathEdgeNode(edge.get_Source());
            this.RegisterPathEdgeNode(edge.get_Target());
        },
        RegisterPathEdgeNode: function (node){
            var nodeInfo = this.lgData.GeometryNodesToLgNodeInfos.get_Item$$TKey(node);
            if (nodeInfo.get_Kind() == Microsoft.Msagl.Core.Layout.LgNodeInfoKind.FullyVisible)
                return;
            if (Is(node, Microsoft.Msagl.Core.Layout.Cluster.ctor)){
                this.AddFullyVisibleNodeToRailGraph(this.lgData.GeometryNodesToLgNodeInfos.get_Item$$TKey(node));
                return;
            }
            nodeInfo.set_Kind(Microsoft.Msagl.Core.Layout.LgNodeInfoKind.PathNode);
            this.visibleNodeSet.Insert(nodeInfo);
            this.AddAllParentsToOpenNodes(node);
        },
        AddAllParentsToOpenNodes: function (node){
            var $it145 = node.get_AllClusterAncestors().GetEnumerator();
            while ($it145.MoveNext()){
                var cluster = $it145.get_Current();
                if (cluster == this.mainGeometryGraph.get_RootCluster())
                    continue;
                var clusterLgInfo = this.lgData.GeometryNodesToLgNodeInfos.get_Item$$TKey(cluster);
                clusterLgInfo.set_Kind(Microsoft.Msagl.Core.Layout.LgNodeInfoKind.FullyVisible);
                this.visibleNodeSet.Insert(clusterLgInfo);
            }
        },
        HighlightEdgesPassingThroughTheRail: function (rail){
            this.lgData.HighlightEdgesPassingThroughRail(rail);
        },
        HighlightEdges: function (edges){
            this.lgData.HighlightEdges(System.Linq.Enumerable.ToList$1(Microsoft.Msagl.Core.Layout.Edge.ctor, edges));
        },
        TheRailLevelIsTooHigh: function (rail){
            return this.lgData.GetRelevantEdgeLevel(rail.ZoomLevel) > this.lgData.GetRelevantEdgeLevel(this.GetZoomFactorToTheGraph());
        },
        GetMaximalZoomLevel: function (){
            if (this.lgData == null)
                return 1;
            return this.lgData.GetMaximalZoomLevel();
        },
        PutOffEdgesPassingThroughTheRail: function (rail){
            this.lgData.PutOffEdgesPassingThroughTheRail(rail);
        },
        PutOffEdges: function (edges){
            this.lgData.PutOffEdges(edges);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$LargeGraphLayout$LgInteractor);
var Microsoft$Msagl$Layout$LargeGraphLayout$LgInteractor$ZoomRequest = {
    fullname: "Microsoft.Msagl.Layout.LargeGraphLayout.LgInteractor.ZoomRequest",
    staticDefinition: {
        NoChange: 0,
        ZoomIn: 1,
        ZoomOut: 2
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Layout$LargeGraphLayout$LgInteractor$ZoomRequest);
var Microsoft$Msagl$Layout$LargeGraphLayout$LgLayoutSettings = {
    fullname: "Microsoft.Msagl.Layout.LargeGraphLayout.LgLayoutSettings",
    baseTypeName: "Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Layout.LargeGraphLayout.LgLayoutSettings.PathNodesScale = 0.1;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (clientViewportFunc, transformFromGraphToScreen, dpiX, dpiY, maximalArrowheadLength){
            this.TransformFromGraphToScreen = null;
            this.DpiX = 0;
            this.DpiY = 0;
            this.MaximalArrowheadLength = null;
            this.geometryNodesToLgNodeInfos = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Layout.LgNodeInfo.ctor);
            this.SattelliteZoomFactor = 10;
            this.clusterPadding = 5;
            this.reroutingDelayInSeconds = 1;
            this._scaleInterval = new Microsoft.Msagl.Layout.LargeGraphLayout.Interval.ctor$$Double$$Double(1E-05, 100000000);
            this.initialRouting = Microsoft.Msagl.Core.Routing.EdgeRoutingMode.StraightLine;
            this.needToLayout = true;
            this.maxNumberNodesPerTile = 20;
            this.usePrecalculatedEdges = true;
            this.EdgeTransparency = 100;
            this.ExitAfterInit = false;
            this.DrawBackgroundImage = false;
            this.ViewerChangeTransformAndInvalidateGraph = null;
            this._Algorithm = null;
            this._ClientViewportFunc = null;
            this._ScreenRectangle = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
            this._BackgroundImage = null;
            this._BackgroundImageIsHidden = false;
            Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings.ctor.call(this);
            this.set_ClientViewportFunc(clientViewportFunc);
            this.TransformFromGraphToScreen = transformFromGraphToScreen;
            this.DpiX = dpiX;
            this.DpiY = dpiY;
            this.MaximalArrowheadLength = maximalArrowheadLength;
            this.get_EdgeRoutingSettings().set_Padding(this.get_NodeSeparation() / 4);
            this.get_EdgeRoutingSettings().set_PolylinePadding(this.get_NodeSeparation() / 6);
        },
        add_ViewerChangeTransformAndInvalidateGraph: function (value){
            this.ViewerChangeTransformAndInvalidateGraph = $CombineDelegates(this.ViewerChangeTransformAndInvalidateGraph, value);
        },
        remove_ViewerChangeTransformAndInvalidateGraph: function (value){
            this.ViewerChangeTransformAndInvalidateGraph = $RemoveDelegate(this.ViewerChangeTransformAndInvalidateGraph, value);
        },
        OnViewerChangeTransformAndInvalidateGraph: function (transformation){
            if (this.ViewerChangeTransformAndInvalidateGraph != null)
                this.ViewerChangeTransformAndInvalidateGraph();
        },
        RailGraph$$: "Microsoft.Msagl.Layout.LargeGraphLayout.RailGraph",
        get_RailGraph: function (){
            return this.get_Algorithm() != null ? this.get_Algorithm().get_RailGraph() : null;
        },
        Clone: function (){
            return Cast(this.MemberwiseClone(), Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings.ctor);
        },
        Algorithm$$: "Microsoft.Msagl.Layout.LargeGraphLayout.LgInteractor",
        get_Algorithm: function (){
            return this._Algorithm;
        },
        set_Algorithm: function (value){
            this._Algorithm = value;
        },
        ClientViewportFunc$$: "System.Func`1[[Microsoft.Msagl.Core.Geometry.Rectangle]]",
        get_ClientViewportFunc: function (){
            return this._ClientViewportFunc;
        },
        set_ClientViewportFunc: function (value){
            this._ClientViewportFunc = value;
        },
        ClientViewportMappedToGraph$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_ClientViewportMappedToGraph: function (){
            var t = this.TransformFromGraphToScreen().get_Inverse();
            var p0 = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, 0);
            var vp = this.get_ClientViewportFunc()();
            var p1 = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(vp.get_Width(), vp.get_Height());
            return new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(t, p0), Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(t, p1));
        },
        GeometryNodesToLgNodeInfos$$: "System.Collections.Generic.Dictionary`2[[Microsoft.Msagl.Core.Layout.Node],[Microsoft.Msagl.Core.Layout.LgNodeInfo]]",
        get_GeometryNodesToLgNodeInfos: function (){
            return this.geometryNodesToLgNodeInfos;
        },
        set_GeometryNodesToLgNodeInfos: function (value){
            this.geometryNodesToLgNodeInfos = value;
        },
        GeometryEdgesToLgEdgeInfos$$: "System.Collections.Generic.IDictionary`2[[Microsoft.Msagl.Core.Layout.Edge],[Microsoft.Msagl.Layout.LargeGraphLayout.LgEdgeInfo]]",
        get_GeometryEdgesToLgEdgeInfos: function (){
            return this.get_Algorithm().get_GeometryEdgesToLgEdgeInfos();
        },
        ZoomFactor$$: "System.Double",
        get_ZoomFactor: function (){
            return this.get_Algorithm().GetZoomFactorToTheGraph();
        },
        ScreenRectangle$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_ScreenRectangle: function (){
            return this._ScreenRectangle;
        },
        set_ScreenRectangle: function (value){
            this._ScreenRectangle = value;
        },
        MaximalEdgeZoomLevelInterval$$: "Microsoft.Msagl.Layout.LargeGraphLayout.Interval",
        get_MaximalEdgeZoomLevelInterval: function (){
            return this.get_Algorithm().get_MaximalEdgeZoomLevelInterval();
        },
        ClusterPadding$$: "System.Double",
        get_ClusterPadding: function (){
            return this.clusterPadding;
        },
        set_ClusterPadding: function (value){
            this.clusterPadding = value;
        },
        ReroutingDelayInSeconds$$: "System.Double",
        get_ReroutingDelayInSeconds: function (){
            return this.reroutingDelayInSeconds;
        },
        set_ReroutingDelayInSeconds: function (value){
            this.reroutingDelayInSeconds = value;
        },
        ScaleInterval$$: "Microsoft.Msagl.Layout.LargeGraphLayout.Interval",
        get_ScaleInterval: function (){
            return this._scaleInterval;
        },
        set_ScaleInterval: function (value){
            this._scaleInterval = value;
        },
        InitialRouting$$: "Microsoft.Msagl.Core.Routing.EdgeRoutingMode",
        get_InitialRouting: function (){
            return this.initialRouting;
        },
        set_InitialRouting: function (value){
            this.initialRouting = value;
        },
        NeedToLayout$$: "System.Boolean",
        get_NeedToLayout: function (){
            return this.needToLayout;
        },
        set_NeedToLayout: function (value){
            this.needToLayout = value;
        },
        MaxNumberNodesPerTile$$: "System.Int32",
        get_MaxNumberNodesPerTile: function (){
            return this.maxNumberNodesPerTile;
        },
        set_MaxNumberNodesPerTile: function (value){
            this.maxNumberNodesPerTile = value;
        },
        UsePrecalculatedEdges$$: "System.Boolean",
        get_UsePrecalculatedEdges: function (){
            return this.usePrecalculatedEdges;
        },
        set_UsePrecalculatedEdges: function (value){
            this.usePrecalculatedEdges = value;
        },
        BackgroundImage$$: "System.String",
        get_BackgroundImage: function (){
            return this._BackgroundImage;
        },
        set_BackgroundImage: function (value){
            this._BackgroundImage = value;
        },
        HighlightEdgesPassingThroughTheRail: function (rail){
            this.get_Algorithm().HighlightEdgesPassingThroughTheRail(rail);
        },
        HighlightEdges: function (edges){
            this.get_Algorithm().HighlightEdges(edges);
        },
        TheRailLevelIsTooHigh: function (rail){
            return this.get_Algorithm().TheRailLevelIsTooHigh(rail);
        },
        GetMaximalZoomLevel: function (){
            return this.get_Algorithm().GetMaximalZoomLevel();
        },
        PutOffEdgesPassingThroughTheRail: function (rail){
            this.get_Algorithm().PutOffEdgesPassingThroughTheRail(rail);
        },
        PutOffEdges: function (edges){
            this.get_Algorithm().PutOffEdges(edges);
        },
        BackgroundImageIsHidden$$: "System.Boolean",
        get_BackgroundImageIsHidden: function (){
            return this._BackgroundImageIsHidden;
        },
        set_BackgroundImageIsHidden: function (value){
            this._BackgroundImageIsHidden = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$LargeGraphLayout$LgLayoutSettings);
var Microsoft$Msagl$Layout$LargeGraphLayout$LgLayoutSettings$LgLayoutEvent = {
    fullname: "Microsoft.Msagl.Layout.LargeGraphLayout.LgLayoutSettings.LgLayoutEvent",
    Kind: "Delegate",
    definition: {
        ctor: function (obj, func){
            System.MulticastDelegate.ctor.call(this, obj, func);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$LargeGraphLayout$LgLayoutSettings$LgLayoutEvent);
var Microsoft$Msagl$Layout$LargeGraphLayout$LevelCalculator = {
    fullname: "Microsoft.Msagl.Layout.LargeGraphLayout.LevelCalculator",
    baseTypeName: "System.Object",
    staticDefinition: {
        RouteEdgesOnLevels: function (lgData, nodeZoomLevelCalculator, lgLayoutSettings, mainGeomGraph){
            Microsoft.Msagl.Layout.LargeGraphLayout.LevelCalculator.AssignEdgesToLevels(lgData, nodeZoomLevelCalculator);
            var edgeInfos = Microsoft.Msagl.Layout.LargeGraphLayout.LevelCalculator.SortEdgeInfosByLevel(lgData);
            var $it146 = nodeZoomLevelCalculator.get_LevelNodeCounts().GetEnumerator();
            while ($it146.MoveNext()){
                var nodeCountOnLevel = $it146.get_Current();
                var finished = Microsoft.Msagl.Layout.LargeGraphLayout.LevelCalculator.RouteEdgesOnLevel(lgData, nodeZoomLevelCalculator, lgLayoutSettings, nodeCountOnLevel, edgeInfos, mainGeomGraph);
                if (finished)
                    break;
            }
            System.Console.WriteLine$$String("routing is done");
        },
        GetTileSize: function (graph, zoomLevel){
            return System.Math.Max$$Double$$Double(graph.get_Width(), graph.get_Height()) / zoomLevel;
        },
        RouteEdgesOnLevel: function (lgData, nodeZoomLevelCalculator, lgLayoutSettings, nodeCountOnLevel, edgeInfos, mainGeomGraph){
            var zoomLevel = (nodeZoomLevelCalculator.get_SortedLgNodeInfos().get_Item$$Int32(nodeCountOnLevel - 1).get_ZoomLevel()) | 0;
            var edgeInfosOfLevel = System.Linq.Enumerable.ToList$1(Microsoft.Msagl.Layout.LargeGraphLayout.LgEdgeInfo.ctor, System.Linq.Enumerable.TakeWhile$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Layout.LargeGraphLayout.LgEdgeInfo.ctor, edgeInfos, function (ei){
                return ei.get_ZoomLevel() <= zoomLevel;
            }));
            var tmpGraphForRouting = Microsoft.Msagl.Layout.LargeGraphLayout.LevelCalculator.CreateTmpGraphForRouting(lgData, edgeInfosOfLevel, zoomLevel);
            var level = lgData.AddLevel(zoomLevel);
            Microsoft.Msagl.Layout.LargeGraphLayout.LevelCalculator.RouteEdges(lgLayoutSettings, tmpGraphForRouting, lgData, level);
            return System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Layout.LargeGraphLayout.LgEdgeInfo.ctor, edgeInfosOfLevel) == lgData.GeometryEdgesToLgEdgeInfos.get_Count();
        },
        RouteEdges: function (lgLayoutSettings, tmpGraphForRouting, lgData, level){
            var routedEdges = 0;
            System.Console.WriteLine$$String$$Object("\nrouting for level {0}", level.ZoomLevel);
            var router = (function (){
                var $v43 = new Microsoft.Msagl.Routing.SplineRouter.ctor$$GeometryGraph$$Double$$Double$$Double$$BundlingSettings(tmpGraphForRouting, lgLayoutSettings.get_EdgeRoutingSettings().get_Padding(), lgLayoutSettings.get_EdgeRoutingSettings().get_PolylinePadding(), 0.523598775598299, null);
                $v43.set_RouteMultiEdgesAsBundles(false);
                $v43.UseEdgeLengthMultiplier = true;
                $v43.UsePolylineEndShortcutting = false;
                $v43.UseInnerPolylingShortcutting = false;
                $v43.AllowedShootingStraightLines = false;
                $v43.set_ContinueOnOverlaps(true);
                $v43.set_CacheCornersForSmoothing(true);
                $v43.ReplaceEdgeByRails = function (e){
                    routedEdges++;
                    if (routedEdges % 1000 == 0)
                        System.Console.Write$$String(".");
                    level.RegisterRailsOfEdge(lgData.GeometryEdgesToLgEdgeInfos.get_Item$$TKey(e));
                };
                $v43.set_Bidirectional(true);
                return $v43;
            })();
            router.Run();
            level.CreateRailTree();
            var $it147 = tmpGraphForRouting.get_Edges().GetEnumerator();
            while ($it147.MoveNext()){
                var edge = $it147.get_Current();
                level.FillRailDictionaryForEdge(edge);
                edge.set_Curve(null);
            }
        },
        GetLineSweeperPorts: function (tmpGraphForRouting, tileSize){
            var rtree = Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnEnumeration(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, tmpGraphForRouting.get_Nodes(), function (n){
                return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(Microsoft.Msagl.Core.Layout.Node.ctor, n, n.get_BoundingBox());
            }));
            var list = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            for (var left = tmpGraphForRouting.get_Left(); left < tmpGraphForRouting.get_Right(); left += tileSize)
                for (var bottom = tmpGraphForRouting.get_Bottom(); bottom < tmpGraphForRouting.get_Top(); bottom += tileSize){
                    Microsoft.Msagl.Layout.LargeGraphLayout.LevelCalculator.AddTilePoints(rtree, list, left, bottom, tileSize, tmpGraphForRouting.get_BoundingBox());
                }
            return list.ToArray();
        },
        AddTilePoints: function (rtree, list, left, bottom, tileSize, boundingBox){
            var n = 2;
            var del = tileSize / 3;
            for (var i = 0; i < n; i++)
                for (var j = 0; j < n; j++){
                    var p = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(i * del + left, j * del + bottom);
                    if (!boundingBox.Contains$$Point(p))
                        continue;
                    if (rtree.FirstHitNode$$Point(p) != null)
                        continue;
                    list.Add(p);
                }
        },
        CreateTmpGraphForRouting: function (lgData, edgeInfosOfLevel, levelZoom){
            var tmpGraphForRouting = (function (){
                var $v44 = new Microsoft.Msagl.Core.Layout.GeometryGraph.ctor();
                $v44.set_Nodes(Microsoft.Msagl.Layout.LargeGraphLayout.LevelCalculator.FindNodesOfLevelGraph(edgeInfosOfLevel, levelZoom, lgData));
                $v44.set_Edges(new Microsoft.Msagl.Layout.LargeGraphLayout.SimpleEdgeCollection.ctor(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Layout.LargeGraphLayout.LgEdgeInfo.ctor, Microsoft.Msagl.Core.Layout.Edge.ctor, edgeInfosOfLevel, function (ei){
                    return ei.get_Edge();
                })));
                return $v44;
            })();
            tmpGraphForRouting.UpdateBoundingBox();
            return tmpGraphForRouting;
        },
        SortEdgeInfosByLevel: function (lgData){
            var edgeInfos = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Layout.LargeGraphLayout.LgEdgeInfo.ctor, lgData.GeometryEdgesToLgEdgeInfos.get_Values());
            System.Array.Sort$1$$T$Array$$Comparison$1(Microsoft.Msagl.Layout.LargeGraphLayout.LgEdgeInfo.ctor, edgeInfos, function (a, b){
                return a.get_ZoomLevel().CompareTo$$Double(b.get_ZoomLevel());
            });
            return edgeInfos;
        },
        AssignEdgesToLevels: function (lgData, nodeZoomLevelCalculator){
            var $it148 = nodeZoomLevelCalculator.get_LevelNodeCounts().GetEnumerator();
            while ($it148.MoveNext()){
                var nodeCountOnLevel = $it148.get_Current();
                Microsoft.Msagl.Layout.LargeGraphLayout.EdgePicker.SetEdgeInfosZoomLevelsAndIcreaseRanks(lgData, nodeZoomLevelCalculator, nodeCountOnLevel);
            }
        },
        FindNodesOfLevelGraph: function (edgeInfos, levelZoom, lgData){
            var nodes = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor);
            var $it149 = edgeInfos.GetEnumerator();
            while ($it149.MoveNext()){
                var edgeInfo = $it149.get_Current();
                var edge = edgeInfo.get_Edge();
                Microsoft.Msagl.Layout.LargeGraphLayout.LevelCalculator.MaybeScaleDownTheNodeBoundaryAndAddToNodes(levelZoom, lgData, edge.get_Source(), nodes);
                Microsoft.Msagl.Layout.LargeGraphLayout.LevelCalculator.MaybeScaleDownTheNodeBoundaryAndAddToNodes(levelZoom, lgData, edge.get_Target(), nodes);
            }
            return new Microsoft.Msagl.Layout.LargeGraphLayout.SimpleNodeCollection.ctor(nodes);
        },
        MaybeScaleDownTheNodeBoundaryAndAddToNodes: function (levelZoom, lgData, node, nodes){
            nodes.Insert(node);
        },
        SetNodeZoomLevelsAndRouteEdgesOnLevels: function (lgData, mainGeometryGraph, lgLayoutSettings){
            var $it150 = lgData.get_ConnectedGeometryGraphs().GetEnumerator();
            while ($it150.MoveNext()){
                var connectedGraph = $it150.get_Current();
                Microsoft.Msagl.Layout.LargeGraphLayout.LevelCalculator.RankTheGraph(lgData, mainGeometryGraph, connectedGraph);
            }
            Microsoft.Msagl.Layout.LargeGraphLayout.LevelCalculator.UpdateRankClusters(lgData);
            var nodeZoomLevelCalculator = new Microsoft.Msagl.Layout.LargeGraphLayout.DeviceIndependendZoomCalculatorForNodes.ctor(function (node){
                return lgData.GeometryNodesToLgNodeInfos.get_Item$$TKey(node);
            }, mainGeometryGraph, lgLayoutSettings, lgLayoutSettings.get_MaxNumberNodesPerTile());
            nodeZoomLevelCalculator.Run();
            lgData.set_SortedLgNodeInfos(nodeZoomLevelCalculator.get_SortedLgNodeInfos());
            lgData.set_LevelNodeCounts(nodeZoomLevelCalculator.get_LevelNodeCounts());
            Microsoft.Msagl.Layout.LargeGraphLayout.LevelCalculator.RouteEdgesOnLevels(lgData, nodeZoomLevelCalculator, lgLayoutSettings, mainGeometryGraph);
        },
        UpdateRankClusters: function (lgData){
            var $it151 = lgData.GeometryNodesToLgNodeInfos.get_Values().GetEnumerator();
            while ($it151.MoveNext()){
                var lgInfo = $it151.get_Current();
                var $it152 = lgInfo.get_GeometryNode().get_ClusterParents().GetEnumerator();
                while ($it152.MoveNext()){
                    var cluster = $it152.get_Current();
                    var clusterLgInfo;
                    if ((function (){
                        var $1 = {
                            Value: clusterLgInfo
                        };
                        var $res = lgData.GeometryNodesToLgNodeInfos.TryGetValue(cluster, $1);
                        clusterLgInfo = $1.Value;
                        return $res;
                    })())if (clusterLgInfo.get_Rank() < lgInfo.get_Rank())
                        clusterLgInfo.set_Rank(lgInfo.get_Rank());
                }
            }
        },
        RankTheGraph: function (lgData, mainGeometryGraph, geomGraph){
            var nodeArray = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Layout.Node.ctor, geomGraph.get_Nodes());
            var flatGraph = (function (){
                var $v45 = new Microsoft.Msagl.Core.Layout.GeometryGraph.ctor();
                $v45.set_Nodes(new Microsoft.Msagl.Layout.LargeGraphLayout.SimpleNodeCollection.ctor(nodeArray));
                $v45.set_Edges(new Microsoft.Msagl.Layout.LargeGraphLayout.SimpleEdgeCollection.ctor(System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, geomGraph.get_Edges(), function (e){
                    return !(Is(e.get_Source(), Microsoft.Msagl.Core.Layout.Cluster.ctor)) && !(Is(e.get_Target(), Microsoft.Msagl.Core.Layout.Cluster.ctor));
                })));
                return $v45;
            })();
            var pageRank = Microsoft.Msagl.Prototype.Ranking.Centrality.PageRank(flatGraph, 0.85, false);
            var normalizer = geomGraph.get_Nodes().get_Count() / mainGeometryGraph.get_Nodes().get_Count();
            for (var i = 0; i < nodeArray.length; i++){
                var node = nodeArray[i];
                System.Diagnostics.Debug.Assert$$Boolean(node != mainGeometryGraph.get_RootCluster());
                lgData.GeometryNodesToLgNodeInfos.get_Item$$TKey(node).set_Rank(normalizer * pageRank[i]);
            }
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$LargeGraphLayout$LevelCalculator);
var Microsoft$Msagl$Layout$LargeGraphLayout$LgNodeCollection = {
    fullname: "Microsoft.Msagl.Layout.LargeGraphLayout.LgNodeCollection",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IList$1"],
    Kind: "Class",
    definition: {
        ctor: function (funcOfLgNodes){
            this.funcOfNodes = null;
            this._IsReadOnly = false;
            System.Object.ctor.call(this);
            this.funcOfNodes = $CreateAnonymousDelegate(this, function (){
                return System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.LgNodeInfo.ctor, Microsoft.Msagl.Core.Layout.Node.ctor, funcOfLgNodes(), $CreateAnonymousDelegate(this, function (n){
                    return n.get_GeometryNode();
                }));
            });
        },
        GetEnumerator: function (){
            return this.funcOfNodes().GetEnumerator();
        },
        Add: function (item){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        Clear: function (){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        Contains: function (item){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        CopyTo: function (array, arrayIndex){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        Remove: function (item){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Node.ctor, this.funcOfNodes());
        },
        IsReadOnly$$: "System.Boolean",
        get_IsReadOnly: function (){
            return this._IsReadOnly;
        },
        set_IsReadOnly: function (value){
            this._IsReadOnly = value;
        },
        IndexOf: function (item){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        Insert: function (index, item){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        RemoveAt: function (index){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        Item$$: "Microsoft.Msagl.Core.Layout.Node",
        get_Item$$Int32: function (index){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        set_Item$$Int32: function (index, value){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$LargeGraphLayout$LgNodeCollection);
var Microsoft$Msagl$Layout$LargeGraphLayout$Rail = {
    fullname: "Microsoft.Msagl.Layout.LargeGraphLayout.Rail",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Layout.LargeGraphLayout.Rail.railCount = 0;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.id = 0;
            this._isHighlighted = false;
            this.Geometry = null;
            this.CurveAttachmentPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.TopRankedEdgeInfoOfTheRail = null;
            this.ZoomLevel = 0;
            System.Object.ctor.call(this);
            Microsoft.Msagl.Layout.LargeGraphLayout.Rail.railCount++;
            this.id = Microsoft.Msagl.Layout.LargeGraphLayout.Rail.railCount;
        },
        GetId: function (){
            return this.id;
        },
        toString: function (){
            return this.id.toString();
        },
        ctor$$ICurve$$LgEdgeInfo$$Int32: function (curveSegment, topRankedEdgeInfoOfTheRail, zoomLevel){
            this.id = 0;
            this._isHighlighted = false;
            this.Geometry = null;
            this.CurveAttachmentPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.TopRankedEdgeInfoOfTheRail = null;
            this.ZoomLevel = 0;
            Microsoft.Msagl.Layout.LargeGraphLayout.Rail.ctor.call(this);
            this.TopRankedEdgeInfoOfTheRail = topRankedEdgeInfoOfTheRail;
            this.ZoomLevel = zoomLevel;
            this.Geometry = curveSegment;
        },
        ctor$$Arrowhead$$Point$$LgEdgeInfo$$Int32: function (arrowhead, curveAttachmentPoint, topRankedEdgeInfoOfTheRail, zoomLevel){
            this.id = 0;
            this._isHighlighted = false;
            this.Geometry = null;
            this.CurveAttachmentPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.TopRankedEdgeInfoOfTheRail = null;
            this.ZoomLevel = 0;
            Microsoft.Msagl.Layout.LargeGraphLayout.Rail.ctor.call(this);
            this.TopRankedEdgeInfoOfTheRail = topRankedEdgeInfoOfTheRail;
            this.Geometry = arrowhead.Clone();
            this.CurveAttachmentPoint = curveAttachmentPoint;
            this.ZoomLevel = zoomLevel;
        },
        BoundingBox$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_BoundingBox: function (){
            var icurve = As(this.Geometry, Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor);
            if (icurve != null)
                return icurve.get_BoundingBox();
            var arrowhead = Cast(this.Geometry, Microsoft.Msagl.Core.Layout.Arrowhead.ctor);
            var rec = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(arrowhead.get_TipPosition(), this.CurveAttachmentPoint);
            rec.Pad$$Double(arrowhead.get_Width());
            return rec;
        },
        IsHighlighted$$: "System.Boolean",
        get_IsHighlighted: function (){
            return this._isHighlighted;
        },
        set_IsHighlighted: function (value){
            this._isHighlighted = value;
        },
        PointTuple: function (){
            var icurve = As(this.Geometry, Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor);
            if (icurve != null)
                return new System.Tuple$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, icurve.get_Start(), icurve.get_End());
            var arrowhead = Cast(this.Geometry, Microsoft.Msagl.Core.Layout.Arrowhead.ctor);
            return new System.Tuple$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, arrowhead.get_TipPosition(), this.CurveAttachmentPoint);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$LargeGraphLayout$Rail);
var Microsoft$Msagl$Layout$LargeGraphLayout$RailGraph = {
    fullname: "Microsoft.Msagl.Layout.LargeGraphLayout.RailGraph",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.Nodes = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor);
            this.Rails = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Layout.LargeGraphLayout.Rail.ctor);
            this.VisibleEdges = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor);
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$LargeGraphLayout$RailGraph);
var Microsoft$Msagl$Layout$LargeGraphLayout$Interval = {
    fullname: "Microsoft.Msagl.Layout.LargeGraphLayout.Interval",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$Double$$Double: function (start, end){
            this._Start = 0;
            this._End = 0;
            System.Object.ctor.call(this);
            this.set_Start(start);
            this.set_End(end);
        },
        ctor$$Interval$$Interval: function (a, b){
            this._Start = 0;
            this._End = 0;
            System.Object.ctor.call(this);
            this.set_Start(a.get_Start());
            this.set_End(a.get_End());
            this.Add(b.get_Start());
            this.Add(b.get_End());
        },
        Add: function (v){
            if (this.get_Start() > v)
                this.set_Start(v);
            if (this.get_End() < v)
                this.set_End(v);
        },
        Start$$: "System.Double",
        get_Start: function (){
            return this._Start;
        },
        set_Start: function (value){
            this._Start = value;
        },
        End$$: "System.Double",
        get_End: function (){
            return this._End;
        },
        set_End: function (value){
            this._End = value;
        },
        Length$$: "System.Double",
        get_Length: function (){
            return this.get_End() - this.get_Start();
        },
        Contains: function (v){
            return this.get_Start() <= v && v <= this.get_End();
        },
        GetInRange: function (v){
            return v < this.get_Start() ? this.get_Start() : (v > this.get_End() ? this.get_End() : v);
        },
        Intersects: function (other){
            if (other.get_Start() > this.get_End() + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return false;
            return !(other.get_End() < this.get_Start() - Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$LargeGraphLayout$Interval);
var Microsoft$Msagl$Layout$LargeGraphLayout$ShortestPartRouterForLg = {
    fullname: "Microsoft.Msagl.Layout.LargeGraphLayout.ShortestPartRouterForLg",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (source, target, geomNodeToLgNode){
            this.source = null;
            this.target = null;
            this.queue = new Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueue$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor);
            this.prev = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, System.Tuple$2.ctor);
            this.pathDirection = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.alpha = 0.5;
            this.costToTarget = 0;
            this.bestEdgeIntoTarget = null;
            this.ignoreInteresingEdgesFunc = false;
            this.geomNodeToLgNode = null;
            this._EdgeIsInterestingFunc = null;
            this._ConsiderOnlyInterestingEdges = false;
            System.Object.ctor.call(this);
            this.source = source;
            this.target = target;
            this.geomNodeToLgNode = geomNodeToLgNode;
            this.queue.Enqueue(source, 0);
            this.pathDirection = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(target.get_Center(), source.get_Center());
            this.costToTarget = Infinity;
            this.set_EdgeIsInterestingFunc($CreateDelegate(this, this.MonotonicityFunc));
        },
        EdgeIsInterestingFunc$$: "System.Func`3[[Microsoft.Msagl.Core.Layout.Node],[Microsoft.Msagl.Core.Layout.Node],[System.Boolean]]",
        get_EdgeIsInterestingFunc: function (){
            return this._EdgeIsInterestingFunc;
        },
        set_EdgeIsInterestingFunc: function (value){
            this._EdgeIsInterestingFunc = value;
        },
        ConsiderOnlyInterestingEdges$$: "System.Boolean",
        get_ConsiderOnlyInterestingEdges: function (){
            return this._ConsiderOnlyInterestingEdges;
        },
        set_ConsiderOnlyInterestingEdges: function (value){
            this._ConsiderOnlyInterestingEdges = value;
        },
        MonotonicityFunc: function (a, b){
            var edgeVector = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a.get_Center(), b.get_Center());
            return Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(edgeVector, this.pathDirection) >= 0;
        },
        Run: function (){
            this.ignoreInteresingEdgesFunc = false;
            var ret = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Layout.Edge.ctor, this.SearchForPath());
            if (ret.length > 0)
                return ret;
            if (this.get_ConsiderOnlyInterestingEdges())
                return null;
            this.ignoreInteresingEdgesFunc = true;
            this.Cleanup();
            var p = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Layout.Edge.ctor, this.SearchForPath());
            return p;
        },
        Cleanup: function (){
            this.costToTarget = Infinity;
            this.bestEdgeIntoTarget = null;
            this.prev.Clear();
            this.queue = new Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueue$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor);
            this.queue.Enqueue(this.source, 0);
        },
        SearchForPath: function (){
            while (this.queue.get_Count() > 0){
                var costPlus;
                var node = (function (){
                    var $1 = {
                        Value: costPlus
                    };
                    var $res = this.queue.Dequeue$$Double($1);
                    costPlus = $1.Value;
                    return $res;
                }).call(this);
                if (costPlus >= this.costToTarget)
                    break;
                var cost = node == this.source ? 0 : this.prev.get_Item$$TKey(node).get_Item2();
                this.ProcessVertex(node, cost);
            }
            var ret = this.RecoverPath();
            return ret;
        },
        RecoverPath: function (){
            var $yield = [];
            if (this.bestEdgeIntoTarget != null){
                var currentNode = this.target;
                var currentEdge = this.bestEdgeIntoTarget;
                do{
                    $yield.push(currentEdge);
                    currentNode = this.GetOtherVertex(currentEdge, currentNode);
                    if (currentNode == this.source)
                        break;
                    currentEdge = this.prev.get_Item$$TKey(currentNode).get_Item1();
                }
                while (true)
            }
            return $yield;
        },
        GetOtherVertex: function (currentEdge, currentNode){
            return currentEdge.get_Source() == currentNode ? currentEdge.get_Target() : currentEdge.get_Source();
        },
        ProcessVertex: function (node, cost){
            var $it153 = node.get_OutEdges().GetEnumerator();
            while ($it153.MoveNext()){
                var outEdge = $it153.get_Current();
                this.ProcessOutEdge(outEdge, cost);
            }
            var $it154 = node.get_InEdges().GetEnumerator();
            while ($it154.MoveNext()){
                var outEdge = $it154.get_Current();
                this.ProcessInEdge(outEdge, cost);
            }
        },
        ProcessInEdge: function (inEdge, cost){
            var edgeVector = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(inEdge.get_Source().get_Center(), inEdge.get_Target().get_Center());
            if (!this.ignoreInteresingEdgesFunc && this.get_EdgeIsInterestingFunc() != null && !this.get_EdgeIsInterestingFunc()(inEdge.get_Target(), inEdge.get_Source()))
                return;
            var costPlus = this.CalculateCostPlus(inEdge, edgeVector);
            var totalCostToEdgeEnd = cost + costPlus;
            if (inEdge.get_Source() == this.target){
                if (totalCostToEdgeEnd < this.costToTarget){
                    this.costToTarget = totalCostToEdgeEnd;
                    this.bestEdgeIntoTarget = inEdge;
                }
            }
            else {
                var h = this.AStarH(inEdge.get_Source());
                if (totalCostToEdgeEnd + h >= this.costToTarget)
                    return;
                var storedPrev;
                if ((function (){
                    var $1 = {
                        Value: storedPrev
                    };
                    var $res = this.prev.TryGetValue(inEdge.get_Source(), $1);
                    storedPrev = $1.Value;
                    return $res;
                }).call(this)){
                    if (storedPrev.get_Item2() > totalCostToEdgeEnd){
                        this.prev.set_Item$$TKey(inEdge.get_Source(), new System.Tuple$2.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor, System.Double.ctor, inEdge, totalCostToEdgeEnd));
                        this.queue.Enqueue(inEdge.get_Source(), totalCostToEdgeEnd + h);
                    }
                }
                else {
                    this.prev.set_Item$$TKey(inEdge.get_Source(), new System.Tuple$2.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor, System.Double.ctor, inEdge, totalCostToEdgeEnd));
                    this.queue.Enqueue(inEdge.get_Source(), totalCostToEdgeEnd + h);
                }
            }
        },
        ProcessOutEdge: function (outEdge, cost){
            var edgeVector = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(outEdge.get_Target().get_Center(), outEdge.get_Source().get_Center());
            if (!this.ignoreInteresingEdgesFunc && this.get_EdgeIsInterestingFunc() != null && !this.get_EdgeIsInterestingFunc()(outEdge.get_Source(), outEdge.get_Target()))
                return;
            var costPlus = this.CalculateCostPlus(outEdge, edgeVector);
            var totalCostToEdgeEnd = cost + costPlus;
            if (outEdge.get_Target() == this.target){
                if (totalCostToEdgeEnd < this.costToTarget){
                    this.costToTarget = totalCostToEdgeEnd;
                    this.bestEdgeIntoTarget = outEdge;
                }
            }
            else {
                var h = this.AStarH(outEdge.get_Target());
                if (totalCostToEdgeEnd + h >= this.costToTarget)
                    return;
                var storedPrev;
                if ((function (){
                    var $1 = {
                        Value: storedPrev
                    };
                    var $res = this.prev.TryGetValue(outEdge.get_Target(), $1);
                    storedPrev = $1.Value;
                    return $res;
                }).call(this)){
                    if (storedPrev.get_Item2() > totalCostToEdgeEnd){
                        this.prev.set_Item$$TKey(outEdge.get_Target(), new System.Tuple$2.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor, System.Double.ctor, outEdge, totalCostToEdgeEnd));
                        this.queue.Enqueue(outEdge.get_Target(), totalCostToEdgeEnd + h);
                    }
                }
                else {
                    this.prev.set_Item$$TKey(outEdge.get_Target(), new System.Tuple$2.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor, System.Double.ctor, outEdge, totalCostToEdgeEnd));
                    this.queue.Enqueue(outEdge.get_Target(), totalCostToEdgeEnd + h);
                }
            }
        },
        AStarH: function (node){
            return (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(node.get_Center(), this.target.get_Center())).get_Length() * (1 - this.alpha);
        },
        CalculateCostPlus: function (edge, edgeVector){
            return edgeVector.get_Length() * (1 - this.alpha / this.ZoomLevel(edge));
        },
        ZoomLevel: function (edge){
            var src = this.geomNodeToLgNode(edge.get_Source());
            var trg = this.geomNodeToLgNode(edge.get_Target());
            return System.Math.Max$$Double$$Double(src.get_ZoomLevel(), trg.get_ZoomLevel());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$LargeGraphLayout$ShortestPartRouterForLg);
var Microsoft$Msagl$Layout$LargeGraphLayout$ShortestPathToAllOthers = {
    fullname: "Microsoft.Msagl.Layout.LargeGraphLayout.ShortestPathToAllOthers",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (source, geometryNodesToLgNodes){
            this.source = null;
            this.geometryNodesToLgNodes = null;
            this.q = new Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueue$1.ctor(Microsoft.Msagl.Core.Layout.LgNodeInfo.ctor);
            System.Object.ctor.call(this);
            this.source = source;
            this.geometryNodesToLgNodes = geometryNodesToLgNodes;
            var $it155 = geometryNodesToLgNodes.get_Values().GetEnumerator();
            while ($it155.MoveNext()){
                var lgNodeInfo = $it155.get_Current();
                lgNodeInfo.Cost = Infinity;
                lgNodeInfo.InQueue = false;
                lgNodeInfo.Processed = false;
                lgNodeInfo.Prev = null;
            }
        },
        Run: function (){
            this.source.Cost = 0;
            this.source.Processed = true;
            this.q.Enqueue(this.source, 0);
            while (this.q.get_Count() > 0){
                var cost;
                var n = (function (){
                    var $1 = {
                        Value: cost
                    };
                    var $res = this.q.Dequeue$$Double($1);
                    cost = $1.Value;
                    return $res;
                }).call(this);
                this.ProcessNode(n);
            }
        },
        ProcessNode: function (nodeInfo){
            nodeInfo.Processed = true;
            var $it156 = nodeInfo.get_GeometryNode().get_OutEdges().GetEnumerator();
            while ($it156.MoveNext()){
                var edge = $it156.get_Current();
                this.ProcessEdge(edge, this.geometryNodesToLgNodes.get_Item$$TKey(edge.get_Target()), nodeInfo.Cost);
            }
            var $it157 = nodeInfo.get_GeometryNode().get_InEdges().GetEnumerator();
            while ($it157.MoveNext()){
                var edge = $it157.get_Current();
                this.ProcessEdge(edge, this.geometryNodesToLgNodes.get_Item$$TKey(edge.get_Source()), nodeInfo.Cost);
            }
        },
        ProcessEdge: function (edge, otherVert, cost){
            if (otherVert.Processed)
                return;
            var len = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(edge.get_Source().get_Center(), edge.get_Target().get_Center())).get_Length();
            var newCost = len + cost;
            if (newCost >= otherVert.Cost)
                return;
            otherVert.Prev = edge;
            if (otherVert.Cost == Infinity){
                otherVert.Cost = newCost;
                this.q.Enqueue(otherVert, newCost);
            }
            else {
                otherVert.Cost = newCost;
                this.q.DecreasePriority(otherVert, newCost);
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$LargeGraphLayout$ShortestPathToAllOthers);
var Microsoft$Msagl$Layout$LargeGraphLayout$SimpleEdgeCollection = {
    fullname: "Microsoft.Msagl.Layout.LargeGraphLayout.SimpleEdgeCollection",
    baseTypeName: "Microsoft.Msagl.Core.Layout.EdgeCollection",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (collectionEdges){
            this.edges = null;
            Microsoft.Msagl.Core.Layout.EdgeCollection.ctor.call(this, null);
            this.edges = (As(collectionEdges, System.Collections.Generic.List$1.ctor) != null ? As(collectionEdges, System.Collections.Generic.List$1.ctor) : System.Linq.Enumerable.ToList$1(Microsoft.Msagl.Core.Layout.Edge.ctor, collectionEdges));
        },
        GetEnumerator: function (){
            return this.edges.GetEnumerator();
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this.edges.get_Count();
        },
        Add: function (item){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        Clear: function (){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        Remove: function (item){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$LargeGraphLayout$SimpleEdgeCollection);
var Microsoft$Msagl$Layout$LargeGraphLayout$SimpleNodeCollection = {
    fullname: "Microsoft.Msagl.Layout.LargeGraphLayout.SimpleNodeCollection",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IList$1"],
    Kind: "Class",
    definition: {
        ctor: function (nodes){
            this.nodes = null;
            this._IsReadOnly = false;
            System.Object.ctor.call(this);
            this.nodes = new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Node.ctor, nodes);
        },
        GetEnumerator: function (){
            return this.nodes.GetEnumerator();
        },
        Add: function (item){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        Clear: function (){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        Contains: function (item){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        CopyTo: function (array, arrayIndex){
            this.nodes.CopyTo$$T$Array$$Int32(array, arrayIndex);
        },
        Remove: function (item){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this.nodes.get_Count();
        },
        IsReadOnly$$: "System.Boolean",
        get_IsReadOnly: function (){
            return this._IsReadOnly;
        },
        set_IsReadOnly: function (value){
            this._IsReadOnly = value;
        },
        IndexOf: function (item){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        Insert: function (index, item){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        RemoveAt: function (index){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        Item$$: "Microsoft.Msagl.Core.Layout.Node",
        get_Item$$Int32: function (index){
            return this.nodes.get_Item$$Int32(index);
        },
        set_Item$$Int32: function (index, value){
            this.nodes.set_Item$$Int32(index, value);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$LargeGraphLayout$SimpleNodeCollection);
var Microsoft$Msagl$Layout$Layered$LayeredLayoutEngine = {
    fullname: "Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        },
        VirtualNodeWidth$$: "System.Double",
        get_VirtualNodeWidth: function (){
            return 1;
        },
        VirtualNodeHeight: function (settings){
            return settings.get_MinNodeHeight() * 1.5 / 8;
        },
        EdgeSpan: function (layers, e){
            return layers[e.get_Source()] - layers[e.get_Target()];
        },
        CreateUpDownConstrainedIntEdge: function (intPair){
            var intEdge = new Microsoft.Msagl.Layout.Layered.IntEdge.ctor$$Int32$$Int32(intPair.x, intPair.y);
            intEdge.set_Weight(0);
            intEdge.set_Separation(1);
            return intEdge;
        },
        TryToPutLabelOutsideOfAngle: function (a, predecessor, successor){
            if (a.get_LabelToTheRightOfAnchorCenter()){
                if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(predecessor.get_Origin(), a.get_Origin(), successor.get_Origin()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise)
                    return true;
                var la = a.get_LeftAnchor();
                var ra = a.get_RightAnchor();
                var x = a.get_X();
                Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.PutLabelToTheLeft(a);
                if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(predecessor.get_Origin(), a.get_Origin(), successor.get_Origin()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise)
                    return true;
                a.set_X(x);
                a.set_LeftAnchor(la);
                a.set_RightAnchor(ra);
                a.set_LabelToTheRightOfAnchorCenter(true);
                a.set_LabelToTheLeftOfAnchorCenter(false);
                return false;
            }
            return false;
        },
        PutLabelToTheLeft: function (a){
            var r = a.get_Right();
            var t = a.get_LeftAnchor();
            a.set_LeftAnchor(a.get_RightAnchor());
            a.set_RightAnchor(t);
            a.set_X(r - a.get_RightAnchor());
            a.set_LabelToTheLeftOfAnchorCenter(true);
            a.set_LabelToTheRightOfAnchorCenter(false);
        },
        CalculateAnchorSizes: function (database, anchors, properLayeredGraph, originalGraph, intGraph, settings){
            database.set_Anchors(anchors.Value = new Array(properLayeredGraph.get_NodeCount()));
            for (var i = 0; i < anchors.Value.length; i++)
                anchors.Value[i] = new Microsoft.Msagl.Layout.Layered.Anchor.ctor$$Double(settings.get_LabelCornersPreserveCoefficient());
            for (var i = 0; i < originalGraph.get_Nodes().get_Count(); i++)
                Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.CalcAnchorsForOriginalNode(i, intGraph, anchors.Value, database, settings);
            var $it190 = database.get_AllIntEdges().GetEnumerator();
            while ($it190.MoveNext()){
                var intEdge = $it190.get_Current();
                if (intEdge.get_LayerEdges() != null){
                    var $it191 = intEdge.get_LayerEdges().GetEnumerator();
                    while ($it191.MoveNext()){
                        var layerEdge = $it191.get_Current();
                        var v = layerEdge.get_Target();
                        if (v != intEdge.get_Target()){
                            var anchor = anchors.Value[v];
                            if (!database.get_MultipleMiddles().Contains$$T(v)){
                                anchor.set_LeftAnchor((function ($p11){
                                    anchor.set_RightAnchor($p11);
                                    return $p11;
                                })(Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.get_VirtualNodeWidth() / 2));
                                anchor.set_TopAnchor((function ($p12){
                                    anchor.set_BottomAnchor($p12);
                                    return $p12;
                                })(Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.VirtualNodeHeight(settings) / 2));
                            }
                            else {
                                anchor.set_LeftAnchor((function ($p13){
                                    anchor.set_RightAnchor($p13);
                                    return $p13;
                                })(Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.get_VirtualNodeWidth() * 4));
                                anchor.set_TopAnchor((function ($p14){
                                    anchor.set_BottomAnchor($p14);
                                    return $p14;
                                })(Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.VirtualNodeHeight(settings) / 2));
                            }
                        }
                    }
                    if (intEdge.get_HasLabel()){
                        var lj = intEdge.get_LayerEdges().get_Item$$Int32((intEdge.get_LayerEdges().get_Count() / 2) | 0).get_Source();
                        var a = anchors.Value[lj];
                        var w = intEdge.get_LabelWidth(),h = intEdge.get_LabelHeight();
                        a.set_RightAnchor(w);
                        a.set_LeftAnchor(Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.get_VirtualNodeWidth() * 8);
                        if (a.get_TopAnchor() < h / 2)
                            a.set_TopAnchor((function ($p15){
                                a.set_BottomAnchor($p15);
                                return $p15;
                            })(h / 2));
                        a.set_LabelToTheRightOfAnchorCenter(true);
                    }
                }
            }
        },
        CalcInitialYAnchorLocations: function (layerArrays, spaceBeforeMargins, originalGraph, database, intGraph, settings, layersAreDoubled){
            var anchors = database.get_Anchors();
            var ymax = originalGraph.get_Margins() + spaceBeforeMargins;
            var i = 0;
            for (var $i193 = 0,$t193 = layerArrays.get_Layers(),$l193 = $t193.length,yLayer = $t193[$i193]; $i193 < $l193; $i193++, yLayer = $t193[$i193]){
                var bottomAnchorMax = 0;
                var topAnchorMax = 0;
                for (var $i194 = 0,$l194 = yLayer.length,j = yLayer[$i194]; $i194 < $l194; $i194++, j = yLayer[$i194]){
                    var p = anchors[j];
                    if (p.get_BottomAnchor() > bottomAnchorMax)
                        bottomAnchorMax = p.get_BottomAnchor();
                    if (p.get_TopAnchor() > topAnchorMax)
                        topAnchorMax = p.get_TopAnchor();
                }
                Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.MakeVirtualNodesTall(yLayer, bottomAnchorMax, topAnchorMax, originalGraph.get_Nodes().get_Count(), database.get_Anchors());
                var flatEdgesHeight = Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.SetFlatEdgesForLayer(database, layerArrays, i, intGraph, settings, ymax);
                var layerCenter = ymax + bottomAnchorMax + flatEdgesHeight;
                var layerTop = layerCenter + topAnchorMax;
                if (Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.NeedToSnapTopsToGrid(settings)){
                    layerTop += Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.SnapDeltaUp(layerTop, settings.get_GridSizeByY());
                    for (var $i195 = 0,$l195 = yLayer.length,j = yLayer[$i195]; $i195 < $l195; $i195++, j = yLayer[$i195])
                        anchors[j].set_Top(layerTop);
                }
                else if (Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.NeedToSnapBottomsToGrid(settings)){
                    var layerBottom = layerCenter - bottomAnchorMax;
                    layerBottom += Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.SnapDeltaUp(layerBottom, layerBottom);
                    for (var $i196 = 0,$l196 = yLayer.length,j = yLayer[$i196]; $i196 < $l196; $i196++, j = yLayer[$i196]){
                        anchors[j].set_Bottom(layerBottom);
                        layerTop = System.Math.Max$$Double$$Double(anchors[j].get_Top(), layerTop);
                    }
                }
                else
                    for (var $i197 = 0,$l197 = yLayer.length,j = yLayer[$i197]; $i197 < $l197; $i197++, j = yLayer[$i197])
                        anchors[j].set_Y(layerCenter);
                var layerSep = settings.ActualLayerSeparation(layersAreDoubled);
                ymax = layerTop + layerSep;
                i++;
            }
            Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.SetFlatEdgesForLayer(database, layerArrays, i, intGraph, settings, ymax);
        },
        NeedToSnapTopsToGrid: function (settings){
            return settings.get_SnapToGridByY() == Microsoft.Msagl.Layout.Layered.SnapToGridByY.Top;
        },
        NeedToSnapBottomsToGrid: function (settings){
            return settings.get_SnapToGridByY() == Microsoft.Msagl.Layout.Layered.SnapToGridByY.Bottom;
        },
        SnapDeltaUp: function (y, gridSize){
            if (gridSize == 0)
                return 0;
            var k = ((y / gridSize)) | 0;
            var delta = y - k * gridSize;
            System.Diagnostics.Debug.Assert$$Boolean(delta >= 0 && delta < gridSize);
            if (System.Math.Abs$$Double(delta) < 0.0001){
                return 0;
            }
            return gridSize - delta;
        },
        SetFlatEdgesForLayer: function (database, layerArrays, i, intGraph, settings, ymax){
            var flatEdgesHeight = 0;
            if (i > 0){
                var flatPairs = Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.GetFlatPairs(layerArrays.get_Layers()[i - 1], layerArrays.Y, intGraph);
                if (System.Linq.Enumerable.Any$1$$IEnumerable$1(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, flatPairs)){
                    var dyOfFlatEdge = settings.get_LayerSeparation() / 3;
                    var ym = ymax;
                    flatEdgesHeight = System.Linq.Enumerable.Max$$IEnumerable$1$Double((System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, System.Double.ctor, flatPairs, function (pair){
                        return Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.SetFlatEdgesLabelsHeightAndPositionts(pair, ym, dyOfFlatEdge, database);
                    })));
                }
            }
            return flatEdgesHeight;
        },
        GetLayoutDirection: function (settings){
            var dir = Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(settings.get_Transformation(), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, 1));
            return dir.get_CompassDirection();
        },
        SetFlatEdgesLabelsHeightAndPositionts: function (pair, ymax, dy, database){
            var height = 0;
            var list = database.GetMultiedge$$IntPair(pair);
            var $it199 = list.GetEnumerator();
            while ($it199.MoveNext()){
                var edge = $it199.get_Current();
                height += dy;
                var label = edge.get_Edge().get_Label();
                if (label != null){
                    label.set_Center(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(label.get_Center().get_X(), ymax + height + label.get_Height() / 2));
                    height += label.get_Height();
                }
            }
            return height;
        },
        GetFlatPairs: function (layer, layering, intGraph){
            return new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(null, Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(null, System.Linq.Enumerable.SelectMany$3$$IEnumerable$1$$Func$2$$Func$3(System.Int32.ctor, Microsoft.Msagl.Layout.Layered.IntEdge.ctor, null, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(System.Int32.ctor, layer, function (v){
                return v < intGraph.get_NodeCount();
            }), function (v){
                return intGraph.OutEdges(v);
            }, function (v, edge){
                return $CreateAnonymousObject({
                    v: v,
                    edge: edge
                });
            }), function ($$x2){
                return layering[$$x2.get_edge().get_Source()] == layering[$$x2.get_edge().get_Target()];
            }), function ($$x3){
                return new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor($$x3.get_edge().get_Source(), $$x3.get_edge().get_Target());
            }));
        },
        MakeVirtualNodesTall: function (yLayer, bottomAnchorMax, topAnchorMax, originalNodeCount, anchors){
            if (Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.LayerIsOriginal(yLayer, originalNodeCount))
                for (var $i201 = 0,$l201 = yLayer.length,j = yLayer[$i201]; $i201 < $l201; $i201++, j = yLayer[$i201])
                    if (j >= originalNodeCount){
                        var p = anchors[j];
                        p.set_BottomAnchor(bottomAnchorMax);
                        p.set_TopAnchor(topAnchorMax);
                    }
        },
        LayerIsOriginal: function (yLayer, origNodeCount){
            for (var $i202 = 0,$l202 = yLayer.length,j = yLayer[$i202]; $i202 < $l202; $i202++, j = yLayer[$i202])
                if (j < origNodeCount)
                    return true;
            return false;
        },
        CalcAnchorsForOriginalNode: function (i, intGraph, anchors, database, settings){
            var leftAnchor = 0;
            var rightAnchor = leftAnchor;
            var topAnchor = 0;
            var bottomAnchor = topAnchor;
            if (intGraph.get_Nodes() != null){
                var node = intGraph.get_Nodes().get_Item$$Int32(i);
                (function (){
                    var $1 = {
                        Value: leftAnchor
                    };
                    var $2 = {
                        Value: rightAnchor
                    };
                    var $3 = {
                        Value: topAnchor
                    };
                    var $4 = {
                        Value: bottomAnchor
                    };
                    var $res = Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.ExtendStandardAnchors($1, $2, $3, $4, node, settings);
                    leftAnchor = $1.Value;
                    rightAnchor = $2.Value;
                    topAnchor = $3.Value;
                    bottomAnchor = $4.Value;
                    return $res;
                })();
            }
            (function (){
                var $1 = {
                    Value: rightAnchor
                };
                var $2 = {
                    Value: topAnchor
                };
                var $3 = {
                    Value: bottomAnchor
                };
                var $res = Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.RightAnchorMultiSelfEdges(i, $1, $2, $3, database, settings);
                rightAnchor = $1.Value;
                topAnchor = $2.Value;
                bottomAnchor = $3.Value;
                return $res;
            })();
            var hw = settings.get_MinNodeWidth() / 2;
            if (leftAnchor < hw)
                leftAnchor = hw;
            if (rightAnchor < hw)
                rightAnchor = hw;
            var hh = settings.get_MinNodeHeight() / 2;
            if (topAnchor < hh)
                topAnchor = hh;
            if (bottomAnchor < hh)
                bottomAnchor = hh;
            anchors[i] = (function (){
                var $v47 = new Microsoft.Msagl.Layout.Layered.Anchor.ctor$$Double$$Double$$Double$$Double$$Node$$Double(leftAnchor, rightAnchor, topAnchor, bottomAnchor, intGraph.get_Nodes().get_Item$$Int32(i), settings.get_LabelCornersPreserveCoefficient());
                $v47.set_Padding(intGraph.get_Nodes().get_Item$$Int32(i).get_Padding());
                return $v47;
            })();
        },
        RightAnchorMultiSelfEdges: function (i, rightAnchor, topAnchor, bottomAnchor, database, settings){
            var delta = Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.WidthOfSelfEdge(database, i, rightAnchor, topAnchor, bottomAnchor, settings);
            rightAnchor.Value += delta;
        },
        WidthOfSelfEdge: function (database, i, rightAnchor, topAnchor, bottomAnchor, settings){
            var delta = 0;
            var multiedges = database.GetMultiedge$$Int32$$Int32(i, i);
            if (multiedges.get_Count() > 0){
                var $it202 = multiedges.GetEnumerator();
                while ($it202.MoveNext()){
                    var e = $it202.get_Current();
                    if (e.get_Edge().get_Label() != null){
                        rightAnchor.Value += e.get_Edge().get_Label().get_Width();
                        if (topAnchor.Value < e.get_Edge().get_Label().get_Height() / 2)
                            topAnchor.Value = bottomAnchor.Value = e.get_Edge().get_Label().get_Height() / 2;
                    }
                }
                delta += (settings.get_NodeSeparation() + settings.get_MinNodeWidth()) * multiedges.get_Count();
            }
            return delta;
        },
        ExtendStandardAnchors: function (leftAnchor, rightAnchor, topAnchor, bottomAnchor, node, settings){
            var w = node.get_Width();
            var h = node.get_Height();
            w /= 2;
            h /= 2;
            rightAnchor.Value = leftAnchor.Value = w;
            topAnchor.Value = bottomAnchor.Value = h;
            if (settings.get_GridSizeByX() > 0){
                rightAnchor.Value += settings.get_GridSizeByX() / 2;
                leftAnchor.Value += settings.get_GridSizeByX() / 2;
            }
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$LayerArrays$$GeometryGraph$$ProperLayeredGraph$$SugiyamaLayoutSettings$$Database$$BasicGraph$2$Node$IntEdge$$Dictionary$2$Node$Int32$$BasicGraph$2$Node$IntEdge$$Boolean$$ConstrainedOrdering$$Boolean$$XLayoutGraph: function (engineLayerArrays, originalGraph, properLayeredGraph, sugiyamaSettings, database, intGraph, nodeIdToIndex, gluedDagSkeletonForLayering, layersAreDoubled, constrainedOrdering, brandes, xLayoutGraph){
            this.engineLayerArrays = null;
            this.originalGraph = null;
            this.properLayeredGraph = null;
            this.sugiyamaSettings = null;
            this.database = null;
            this.IntGraph = null;
            this.xLayoutGraph = null;
            this.nodeIdToIndex = null;
            this.anchors = null;
            this.constrainedOrdering = null;
            this._Brandes = false;
            this._GluedDagSkeletonForLayering = null;
            this._LayersAreDoubled = false;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.engineLayerArrays = engineLayerArrays;
            this.originalGraph = originalGraph;
            this.properLayeredGraph = properLayeredGraph;
            this.sugiyamaSettings = sugiyamaSettings;
            this.database = database;
            this.IntGraph = intGraph;
            this.nodeIdToIndex = nodeIdToIndex;
            this.set_GluedDagSkeletonForLayering(gluedDagSkeletonForLayering);
            this.set_LayersAreDoubled(layersAreDoubled);
            this.constrainedOrdering = constrainedOrdering;
            this.set_Brandes(brandes);
            this.anchors = database.anchors;
            this.xLayoutGraph = xLayoutGraph;
        },
        Brandes$$: "System.Boolean",
        get_Brandes: function (){
            return this._Brandes;
        },
        set_Brandes: function (value){
            this._Brandes = value;
        },
        Database$$: "Microsoft.Msagl.Layout.Layered.Database",
        get_Database: function (){
            return this.database;
        },
        set_Database: function (value){
            this.database = value;
        },
        GluedDagSkeletonForLayering$$: "Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph`2[[Microsoft.Msagl.Core.Layout.Node],[Microsoft.Msagl.Layout.Layered.IntEdge]]",
        get_GluedDagSkeletonForLayering: function (){
            return this._GluedDagSkeletonForLayering;
        },
        set_GluedDagSkeletonForLayering: function (value){
            this._GluedDagSkeletonForLayering = value;
        },
        ctor$$GeometryGraph$$BasicGraph$2$Node$IntEdge$$Dictionary$2$Node$Int32$$SugiyamaLayoutSettings: function (originalGraph, graph, nodeIdToIndex, settings){
            this.engineLayerArrays = null;
            this.originalGraph = null;
            this.properLayeredGraph = null;
            this.sugiyamaSettings = null;
            this.database = null;
            this.IntGraph = null;
            this.xLayoutGraph = null;
            this.nodeIdToIndex = null;
            this.anchors = null;
            this.constrainedOrdering = null;
            this._Brandes = false;
            this._GluedDagSkeletonForLayering = null;
            this._LayersAreDoubled = false;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            if (originalGraph != null){
                this.originalGraph = originalGraph;
                this.sugiyamaSettings = settings;
                this.IntGraph = graph;
                this.set_Database(new Microsoft.Msagl.Layout.Layered.Database.ctor());
                this.nodeIdToIndex = nodeIdToIndex;
                var $it158 = graph.get_Edges().GetEnumerator();
                while ($it158.MoveNext()){
                    var e = $it158.get_Current();
                    this.database.RegisterOriginalEdgeInMultiedges(e);
                }
                this.CycleRemoval();
            }
        },
        ctor$$GeometryGraph$$SugiyamaLayoutSettings: function (originalGraph, settings){
            this.engineLayerArrays = null;
            this.originalGraph = null;
            this.properLayeredGraph = null;
            this.sugiyamaSettings = null;
            this.database = null;
            this.IntGraph = null;
            this.xLayoutGraph = null;
            this.nodeIdToIndex = null;
            this.anchors = null;
            this.constrainedOrdering = null;
            this._Brandes = false;
            this._GluedDagSkeletonForLayering = null;
            this._LayersAreDoubled = false;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            if (originalGraph != null){
                this.nodeIdToIndex = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, System.Int32.ctor);
                var nodes = originalGraph.get_Nodes();
                var index = 0;
                var $it159 = nodes.GetEnumerator();
                while ($it159.MoveNext()){
                    var n = $it159.get_Current();
                    this.nodeIdToIndex.set_Item$$TKey(n, index);
                    index++;
                }
                var edges = originalGraph.get_Edges();
                var intEdges = new Array(edges.get_Count());
                var i = 0;
                var $it160 = edges.GetEnumerator();
                while ($it160.MoveNext()){
                    var edge = $it160.get_Current();
                    if (edge.get_Source() == null || edge.get_Target() == null)
                        throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
                    var intEdge = new Microsoft.Msagl.Layout.Layered.IntEdge.ctor$$Int32$$Int32$$Edge(this.nodeIdToIndex.get_Item$$TKey(edge.get_Source()), this.nodeIdToIndex.get_Item$$TKey(edge.get_Target()), edge);
                    intEdges[i] = intEdge;
                    i++;
                }
                this.IntGraph = (function (){
                    var $v46 = new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$2.ctor$$IEnumerable$1$$Int32(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Layout.Layered.IntEdge.ctor, intEdges, originalGraph.get_Nodes().get_Count());
                    $v46.set_Nodes(nodes);
                    return $v46;
                }).call(this);
                this.originalGraph = originalGraph;
                this.sugiyamaSettings = settings;
                this.set_Database(new Microsoft.Msagl.Layout.Layered.Database.ctor());
                var $it161 = this.IntGraph.get_Edges().GetEnumerator();
                while ($it161.MoveNext()){
                    var e = $it161.get_Current();
                    this.database.RegisterOriginalEdgeInMultiedges(e);
                }
                this.CycleRemoval();
            }
        },
        CreateGluedDagSkeletonForLayering: function (){
            this.set_GluedDagSkeletonForLayering(new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$2.ctor$$IEnumerable$1$$Int32(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Layout.Layered.IntEdge.ctor, this.GluedDagSkeletonEdges(), this.originalGraph.get_Nodes().get_Count()));
            this.SetGluedEdgesWeights();
        },
        SetGluedEdgesWeights: function (){
            var gluedPairsToGluedEdge = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, Microsoft.Msagl.Layout.Layered.IntEdge.ctor);
            var $it162 = this.get_GluedDagSkeletonForLayering().get_Edges().GetEnumerator();
            while ($it162.MoveNext()){
                var ie = $it162.get_Current();
                gluedPairsToGluedEdge.set_Item$$TKey(new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(ie.get_Source(), ie.get_Target()), ie);
            }
            var $it163 = this.database.get_Multiedges().GetEnumerator();
            while ($it163.MoveNext()){
                var t = $it163.get_Current();
                if (t.get_Key().x != t.get_Key().y){
                    var gluedPair = this.get_VerticalConstraints().GluedIntPair$$IntPair(t.get_Key());
                    if (gluedPair.x == gluedPair.y)
                        continue;
                    var gluedIntEdge = gluedPairsToGluedEdge.get_Item$$TKey(gluedPair);
                    var $it164 = t.get_Value().GetEnumerator();
                    while ($it164.MoveNext()){
                        var ie = $it164.get_Current();
                        gluedIntEdge.set_Weight(gluedIntEdge.get_Weight() + ie.get_Weight());
                    }
                }
            }
        },
        GluedDagSkeletonEdges: function (){
            var ret = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Layout.Layered.IntEdge.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(null, Microsoft.Msagl.Layout.Layered.IntEdge.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(null, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.Collections.Generic.KeyValuePair$2.ctor, null, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(System.Collections.Generic.KeyValuePair$2.ctor, this.database.get_Multiedges(), $CreateAnonymousDelegate(this, function (kv){
                return kv.get_Key().x != kv.get_Key().y;
            })), $CreateAnonymousDelegate(this, function (kv){
                return $CreateAnonymousObject({
                    kv: kv,
                    e: this.get_VerticalConstraints().GluedIntEdge(kv.get_Value().get_Item$$Int32(0))
                });
            })), $CreateAnonymousDelegate(this, function ($$x0){
                return $$x0.get_e().get_Source() != $$x0.get_e().get_Target();
            })), $CreateAnonymousDelegate(this, function ($$x1){
                return $$x1.get_e();
            })));
            var gluedUpDownConstraints = System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, Microsoft.Msagl.Layout.Layered.IntEdge.ctor, this.get_VerticalConstraints().get_GluedUpDownIntConstraints(), $CreateAnonymousDelegate(this, function (p){
                return Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.CreateUpDownConstrainedIntEdge(p);
            }));
            var $it165 = gluedUpDownConstraints.GetEnumerator();
            while ($it165.MoveNext()){
                var edge = $it165.get_Current();
                ret.Insert(edge);
            }
            return ret;
        },
        RunInternal: function (){
            if (this.originalGraph.get_Nodes().get_Count() > 0){
                this.engineLayerArrays = this.CalculateLayers();
                if (!this.sugiyamaSettings.get_LayeringOnly())
                    this.RunPostLayering();
            }
            else
                this.originalGraph.boundingBox.SetToEmpty();
        },
        RunPostLayering: function (){
            var routingSettings = this.sugiyamaSettings.get_EdgeRoutingSettings();
            var mode = routingSettings.get_EdgeRoutingMode();
            if (this.constrainedOrdering != null)
                mode = Microsoft.Msagl.Core.Routing.EdgeRoutingMode.Spline;
            switch (mode){
                case Microsoft.Msagl.Core.Routing.EdgeRoutingMode.SugiyamaSplines:
                    this.CalculateEdgeSplines();
                    break;
                case Microsoft.Msagl.Core.Routing.EdgeRoutingMode.StraightLine:
                    Microsoft.Msagl.Routing.StraightLineEdges.SetStraightLineEdgesWithUnderlyingPolylines(this.originalGraph);
                    this.SetLabels();
                    break;
                case Microsoft.Msagl.Core.Routing.EdgeRoutingMode.Spline:
                    var padding = this.sugiyamaSettings.get_NodeSeparation() / 4;
                    var loosePadding = Microsoft.Msagl.Routing.SplineRouter.ComputeLooseSplinePadding(this.sugiyamaSettings.get_NodeSeparation(), padding);
                    var router = new Microsoft.Msagl.Routing.SplineRouter.ctor$$GeometryGraph$$Double$$Double$$Double$$BundlingSettings(this.originalGraph, padding, loosePadding, (0.523598775598299), null);
                    router.Run();
                    this.SetLabels();
                    break;
                case Microsoft.Msagl.Core.Routing.EdgeRoutingMode.SplineBundling:
                    var coneAngle = routingSettings.get_ConeAngle();
                    padding = this.sugiyamaSettings.get_NodeSeparation() / 20;
                    loosePadding = Microsoft.Msagl.Routing.SplineRouter.ComputeLooseSplinePadding(this.sugiyamaSettings.get_NodeSeparation(), padding) * 2;
                    if (this.sugiyamaSettings.get_EdgeRoutingSettings().get_BundlingSettings() == null)
                    this.sugiyamaSettings.get_EdgeRoutingSettings().set_BundlingSettings(new Microsoft.Msagl.Core.Routing.BundlingSettings.ctor());
                    var br = new Microsoft.Msagl.Routing.SplineRouter.ctor$$GeometryGraph$$Double$$Double$$Double$$BundlingSettings(this.originalGraph, padding, loosePadding, coneAngle, this.sugiyamaSettings.get_EdgeRoutingSettings().get_BundlingSettings());
                    br.Run();
                    this.SetLabels();
                    break;
                case Microsoft.Msagl.Core.Routing.EdgeRoutingMode.Rectilinear:
                case Microsoft.Msagl.Core.Routing.EdgeRoutingMode.RectilinearToCenter:
                    var rer = new Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.ctor$$GeometryGraph$$Double$$Double$$Boolean$$Boolean(this.originalGraph, this.sugiyamaSettings.get_NodeSeparation() / 3, this.sugiyamaSettings.get_NodeSeparation() / 4, true, this.sugiyamaSettings.get_EdgeRoutingSettings().get_UseObstacleRectangles());
                    rer.set_RouteToCenterOfObstacles(routingSettings.get_EdgeRoutingMode() == Microsoft.Msagl.Core.Routing.EdgeRoutingMode.RectilinearToCenter);
                    rer.set_BendPenaltyAsAPercentageOfDistance(routingSettings.get_BendPenalty());
                    rer.Run();
                    this.SetLabels();
                    break;
            }
            this.originalGraph.set_BoundingBox(this.originalGraph.PumpTheBoxToTheGraphWithMargins());
        },
        SetLabels: function (){
            var edgeLabeller = new Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.ctor$$GeometryGraph(this.originalGraph);
            edgeLabeller.Run();
        },
        IncrementalRun: function (node){
            this.PushLayers(node);
            this.RunPostLayering();
        },
        PushLayers: function (node){
            var nodeIndex = System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Node.ctor, System.Linq.Enumerable.TakeWhile$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Node.ctor, this.IntGraph.get_Nodes(), $CreateAnonymousDelegate(this, function (n){
                return node != n;
            })));
            var nodeAnchor = this.anchors[nodeIndex];
            var delWidth = 0.5 * (node.get_BoundaryCurve().get_BoundingBox().get_Width() - nodeAnchor.get_Width());
            var delHight = 0.5 * (node.get_BoundaryCurve().get_BoundingBox().get_Height() - nodeAnchor.get_Height());
            nodeAnchor.set_RightAnchor(nodeAnchor.get_RightAnchor() + delWidth);
            nodeAnchor.set_LeftAnchor(nodeAnchor.get_LeftAnchor() + delWidth);
            nodeAnchor.set_TopAnchor(nodeAnchor.get_TopAnchor() + delHight);
            nodeAnchor.set_BottomAnchor(nodeAnchor.get_BottomAnchor() + delHight);
            nodeAnchor.set_Node(node);
            this.PushDownLowerLayers(delHight, nodeIndex);
            this.PushUpUpperLayers(delHight, nodeIndex);
            if (this.xLayoutGraph != null){
                this.FixEdgeSeparation(nodeIndex);
                this.CalculateXLayersByGansnerNorthOnProperLayeredGraph();
            }
            else
                this.CalculateXPositionsByBrandes(this.engineLayerArrays);
            for (var i = 0; i < this.IntGraph.get_NodeCount(); i++){
                var n = this.IntGraph.get_Nodes().get_Item$$Int32(i);
                var a = this.anchors[i];
                n.set_Center(a.get_Origin());
                a.set_Node(n);
            }
        },
        FixEdgeSeparation: function (nodeIndex){
            var nodeLayerIndex = this.engineLayerArrays.Y[nodeIndex];
            var layer = this.engineLayerArrays.get_Layers()[nodeLayerIndex];
            var nodePosition = this.engineLayerArrays.get_X()[nodeIndex];
            var a = this.anchors[nodeIndex];
            if (nodePosition > 0){
                var target = layer[nodePosition - 1];
                var $it166 = this.xLayoutGraph.OutEdges(nodeIndex).GetEnumerator();
                while ($it166.MoveNext()){
                    var ie = $it166.get_Current();
                    if (ie.get_Target() == target){
                        ie.set_Separation(((this.sugiyamaSettings.get_NodeSeparation() + a.get_LeftAnchor() + this.anchors[target].get_RightAnchor() + 1)) | 0);
                        break;
                    }
                }
            }
            if (nodePosition < layer.length - 1){
                var source = layer[nodePosition + 1];
                var $it167 = this.xLayoutGraph.InEdges(nodeIndex).GetEnumerator();
                while ($it167.MoveNext()){
                    var ie = $it167.get_Current();
                    if (ie.get_Source() == source){
                        ie.set_Separation(((this.sugiyamaSettings.get_NodeSeparation() + a.get_RightAnchor() + this.anchors[source].get_LeftAnchor() + 1)) | 0);
                        break;
                    }
                }
            }
        },
        MoveNode: function (del, i){
            if (i < this.IntGraph.get_Nodes().get_Count()){
                var node = this.IntGraph.get_Nodes().get_Item$$Int32(i);
                node.set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Addition(node.get_Center(), del));
                this.anchors[i].set_Node(node);
            }
        },
        PushUpUpperLayers: function (delHight, nodeIndex){
            var delta = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, delHight);
            var layerIndex = this.engineLayerArrays.Y[nodeIndex];
            for (var i = layerIndex + 1; i < this.engineLayerArrays.get_Layers().length; i++){
                var layer = this.engineLayerArrays.get_Layers()[i];
                for (var $i169 = 0,$l169 = layer.length,j = layer[$i169]; $i169 < $l169; $i169++, j = layer[$i169]){
                    this.MoveNode(delta, j);
                    this.anchors[j].Move(delta);
                }
            }
        },
        PushDownLowerLayers: function (delHight, nodeIndex){
            var delta = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, -delHight);
            var layerIndex = this.engineLayerArrays.Y[nodeIndex];
            for (var i = 0; i < layerIndex; i++){
                var layer = this.engineLayerArrays.get_Layers()[i];
                for (var $i170 = 0,$l170 = layer.length,j = layer[$i170]; $i170 < $l170; $i170++, j = layer[$i170]){
                    this.MoveNode(delta, j);
                    this.anchors[j].Move(delta);
                }
            }
        },
        CalculateLayers: function (){
            this.CreateGluedDagSkeletonForLayering();
            var layerArrays = this.CalculateLayerArrays();
            this.UpdateNodePositionData();
            return layerArrays;
        },
        UpdateNodePositionData: function (){
            this.TryToSatisfyMinWidhtAndMinHeight();
            for (var i = 0; i < this.IntGraph.get_Nodes().get_Count() && i < this.database.get_Anchors().length; i++)
                this.IntGraph.get_Nodes().get_Item$$Int32(i).set_Center(this.database.get_Anchors()[i].get_Origin());
            if (this.sugiyamaSettings.get_GridSizeByX() > 0){
                for (var i = 0; i < this.originalGraph.get_Nodes().get_Count(); i++){
                    this.SnapLeftSidesOfTheNodeToGrid(i, this.sugiyamaSettings.get_GridSizeByX());
                }
            }
        },
        SnapLeftSidesOfTheNodeToGrid: function (i, gridSize){
            var node = this.IntGraph.get_Nodes().get_Item$$Int32(i);
            var anchor = this.database.get_Anchors()[i];
            anchor.set_LeftAnchor(anchor.get_LeftAnchor() - gridSize / 2);
            anchor.set_RightAnchor(anchor.get_RightAnchor() - gridSize / 2);
            var left = node.get_BoundingBox().get_Left();
            var k = ((left / gridSize)) | 0;
            var delta = left - k * gridSize;
            if (System.Math.Abs$$Double(delta) < 0.001){
                return;
            }
            if (System.Math.Abs$$Double(delta) <= gridSize / 2){
                node.set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Addition(node.get_Center(), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-delta, 0)));
            }
            else {
                node.set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Addition(node.get_Center(), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(gridSize - delta, 0)));
            }
            anchor.set_X(node.get_Center().get_X());
        },
        TryToSatisfyMinWidhtAndMinHeight: function (){
            this.TryToSatisfyMinWidth();
            this.TryToSatisfyMinHeight();
        },
        TryToSatisfyMinWidth: function (){
            if (this.sugiyamaSettings.get_MinimalWidth() == 0)
                return;
            var w = this.GetCurrentWidth();
            if (w < this.sugiyamaSettings.get_MinimalWidth())
                this.StretchWidth();
        },
        StretchWidth: function (){
            var desiredSpan = new Microsoft.Msagl.Core.DataStructures.RealNumberSpan.ctor();
            var $it170 = this.originalGraph.get_Nodes().GetEnumerator();
            while ($it170.MoveNext()){
                var node = $it170.get_Current();
                desiredSpan.AddValue(node.get_BoundingBox().get_Width() / 2);
                desiredSpan.AddValue(this.sugiyamaSettings.get_MinimalWidth() - node.get_BoundingBox().get_Width() / 2);
            }
            var currentSpan = new Microsoft.Msagl.Core.DataStructures.RealNumberSpan.ctor();
            var $it171 = this.NodeAnchors().GetEnumerator();
            while ($it171.MoveNext()){
                var anchor = $it171.get_Current();
                currentSpan.AddValue(anchor.get_X());
            }
            if (currentSpan.get_Length() > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                var stretch = desiredSpan.get_Length() / currentSpan.get_Length();
                if (stretch > 1)
                    for (var $i173 = 0,$t173 = this.anchors,$l173 = $t173.length,a = $t173[$i173]; $i173 < $l173; $i173++, a = $t173[$i173])
                        a.set_X(a.get_X() * stretch);
            }
        },
        TryToSatisfyMinHeight: function (){
            if (this.sugiyamaSettings.get_MinimalHeight() == 0)
                return;
            var h = this.GetCurrentHeight();
            if (h < this.sugiyamaSettings.get_MinimalHeight())
                this.StretchHeight();
        },
        GetCurrentHeight: function (){
            var span = new Microsoft.Msagl.Core.DataStructures.RealNumberSpan.ctor();
            var $it173 = this.NodeAnchors().GetEnumerator();
            while ($it173.MoveNext()){
                var anchor = $it173.get_Current();
                span.AddValue(anchor.get_Top());
                span.AddValue(anchor.get_Bottom());
            }
            return span.get_Length();
        },
        StretchHeight: function (){
            var desiredSpan = new Microsoft.Msagl.Core.DataStructures.RealNumberSpan.ctor();
            var $it174 = this.originalGraph.get_Nodes().GetEnumerator();
            while ($it174.MoveNext()){
                var node = $it174.get_Current();
                desiredSpan.AddValue(node.get_BoundingBox().get_Height() / 2);
                desiredSpan.AddValue(this.sugiyamaSettings.get_MinimalHeight() - node.get_BoundingBox().get_Height() / 2);
            }
            var currentSpan = new Microsoft.Msagl.Core.DataStructures.RealNumberSpan.ctor();
            var $it175 = this.NodeAnchors().GetEnumerator();
            while ($it175.MoveNext()){
                var anchor = $it175.get_Current();
                currentSpan.AddValue(anchor.get_Y());
            }
            if (currentSpan.get_Length() > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                var stretch = desiredSpan.get_Length() / currentSpan.get_Length();
                if (stretch > 1)
                    for (var $i177 = 0,$t177 = this.anchors,$l177 = $t177.length,a = $t177[$i177]; $i177 < $l177; $i177++, a = $t177[$i177])
                        a.set_Y(a.get_Y() * stretch);
            }
        },
        NodeAnchors: function (){
            return System.Linq.Enumerable.Take$1(Microsoft.Msagl.Layout.Layered.Anchor.ctor, this.anchors, System.Math.Min$$Int32$$Int32(this.IntGraph.get_Nodes().get_Count(), this.anchors.length));
        },
        GetCurrentWidth: function (){
            var span = new Microsoft.Msagl.Core.DataStructures.RealNumberSpan.ctor();
            var $it177 = this.NodeAnchors().GetEnumerator();
            while ($it177.MoveNext()){
                var anchor = $it177.get_Current();
                span.AddValue(anchor.get_Left());
                span.AddValue(anchor.get_Right());
            }
            return span.get_Length();
        },
        StretchToDesiredAspectRatio: function (aspectRatio, desiredAR){
            if (aspectRatio > desiredAR)
                this.StretchInYDirection(aspectRatio / desiredAR);
            else if (aspectRatio < desiredAR)
                this.StretchInXDirection(desiredAR / aspectRatio);
        },
        StretchInYDirection: function (scaleFactor){
            var center = (this.originalGraph.get_BoundingBox().get_Top() + this.originalGraph.get_BoundingBox().get_Bottom()) / 2;
            for (var $i179 = 0,$t179 = this.get_Database().get_Anchors(),$l179 = $t179.length,a = $t179[$i179]; $i179 < $l179; $i179++, a = $t179[$i179]){
                a.set_BottomAnchor(a.get_BottomAnchor() * scaleFactor);
                a.set_TopAnchor(a.get_TopAnchor() * scaleFactor);
                a.set_Y(center + scaleFactor * (a.get_Y() - center));
            }
            var h = this.originalGraph.get_Height() * scaleFactor;
            this.originalGraph.set_BoundingBox(new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Double$$Double$$Double$$Double(this.originalGraph.get_BoundingBox().get_Left(), center + h / 2, this.originalGraph.get_BoundingBox().get_Right(), center - h / 2));
        },
        StretchInXDirection: function (scaleFactor){
            var center = (this.originalGraph.get_BoundingBox().get_Left() + this.originalGraph.get_BoundingBox().get_Right()) / 2;
            for (var $i180 = 0,$t180 = this.get_Database().get_Anchors(),$l180 = $t180.length,a = $t180[$i180]; $i180 < $l180; $i180++, a = $t180[$i180]){
                a.set_LeftAnchor(a.get_LeftAnchor() * scaleFactor);
                a.set_RightAnchor(a.get_RightAnchor() * scaleFactor);
                a.set_X(center + scaleFactor * (a.get_X() - center));
            }
            var w = this.originalGraph.get_Width() * scaleFactor;
            this.originalGraph.set_BoundingBox(new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Double$$Double$$Double$$Double(center - w / 2, this.originalGraph.get_BoundingBox().get_Top(), center + w / 2, this.originalGraph.get_BoundingBox().get_Bottom()));
        },
        CalculateLayerArrays: function (){
            var layerArrays = this.CalculateYLayers();
            if (this.constrainedOrdering == null){
                this.DecideIfUsingFastXCoordCalculation(layerArrays);
                this.CalculateAnchorsAndYPositions(layerArrays);
                if (this.get_Brandes())
                    this.CalculateXPositionsByBrandes(layerArrays);
                else
                    this.CalculateXLayersByGansnerNorth(layerArrays);
            }
            else
                this.anchors = this.database.get_Anchors();
            this.OptimizeEdgeLabelsLocations();
            this.engineLayerArrays = layerArrays;
            this.StraightensShortEdges();
            var aspectRatio;
            (function (){
                var $1 = {
                    Value: aspectRatio
                };
                var $res = this.CalculateOriginalGraphBox($1);
                aspectRatio = $1.Value;
                return $res;
            }).call(this);
            if (this.sugiyamaSettings.get_AspectRatio() != 0)
                this.StretchToDesiredAspectRatio(aspectRatio, this.sugiyamaSettings.get_AspectRatio());
            return layerArrays;
        },
        DecideIfUsingFastXCoordCalculation: function (layerArrays){
            if (layerArrays.get_X().length >= this.sugiyamaSettings.get_BrandesThreshold())
                this.set_Brandes(true);
        },
        StraightensShortEdges: function (){
            for (; this.StraightenEdgePaths();){
            }
        },
        StraightenEdgePaths: function (){
            var ret = false;
            var $it180 = this.database.get_AllIntEdges().GetEnumerator();
            while ($it180.MoveNext()){
                var e = $it180.get_Current();
                if (e.get_LayerSpan() == 2)
                    ret = this.ShiftVertexWithNeighbors(e.get_LayerEdges().get_Item$$Int32(0).get_Source(), e.get_LayerEdges().get_Item$$Int32(0).get_Target(), e.get_LayerEdges().get_Item$$Int32(1).get_Target()) || ret;
            }
            return ret;
        },
        ShiftVertexWithNeighbors: function (u, i, v){
            var upper = this.database.get_Anchors()[u];
            var lower = this.database.get_Anchors()[v];
            var iAnchor = this.database.get_Anchors()[i];
            var x = (iAnchor.get_Y() - upper.get_Y()) * (lower.get_X() - upper.get_X()) / (lower.get_Y() - upper.get_Y()) + upper.get_X();
            var eps = 0.0001;
            if (x > iAnchor.get_X() + eps)
                return this.TryShiftToTheRight(x, i);
            if (x < iAnchor.get_X() - eps)
                return this.TryShiftToTheLeft(x, i);
            return false;
        },
        TryShiftToTheLeft: function (x, v){
            var layer = this.engineLayerArrays.get_Layers()[this.engineLayerArrays.Y[v]];
            var vPosition = this.engineLayerArrays.get_X()[v];
            if (vPosition > 0){
                var uAnchor = this.database.get_Anchors()[layer[vPosition - 1]];
                var allowedX = System.Math.Max$$Double$$Double(uAnchor.get_Right() + this.sugiyamaSettings.get_NodeSeparation() + this.database.get_Anchors()[v].get_LeftAnchor(), x);
                if (allowedX < this.database.get_Anchors()[v].get_X() - 1){
                    this.database.get_Anchors()[v].set_X(allowedX);
                    return true;
                }
                return false;
            }
            this.database.get_Anchors()[v].set_X(x);
            return true;
        },
        TryShiftToTheRight: function (x, v){
            var layer = this.engineLayerArrays.get_Layers()[this.engineLayerArrays.Y[v]];
            var vPosition = this.engineLayerArrays.get_X()[v];
            if (vPosition < layer.length - 1){
                var uAnchor = this.database.get_Anchors()[layer[vPosition + 1]];
                var allowedX = System.Math.Min$$Double$$Double(uAnchor.get_Left() - this.sugiyamaSettings.get_NodeSeparation() - this.database.get_Anchors()[v].get_RightAnchor(), x);
                if (allowedX > this.database.get_Anchors()[v].get_X() + 1){
                    this.database.get_Anchors()[v].set_X(allowedX);
                    return true;
                }
                return false;
            }
            this.database.get_Anchors()[v].set_X(x);
            return true;
        },
        CalculateYLayers: function (){
            var layerArrays = this.YLayeringAndOrdering(new Microsoft.Msagl.Layout.Layered.NetworkSimplexForGeneralGraph.ctor(this.get_GluedDagSkeletonForLayering(), this.get_CancelToken()));
            if (this.constrainedOrdering != null)
                return layerArrays;
            return this.InsertLayersIfNeeded(layerArrays);
        },
        VerticalConstraints$$: "Microsoft.Msagl.Layout.Layered.VerticalConstraintsForSugiyama",
        get_VerticalConstraints: function (){
            return this.sugiyamaSettings.get_VerticalConstraints();
        },
        HorizontalConstraints$$: "Microsoft.Msagl.Layout.Layered.HorizontalConstraintsForSugiyama",
        get_HorizontalConstraints: function (){
            return this.sugiyamaSettings.get_HorizontalConstraints();
        },
        CalculateAnchorsAndYPositions: function (layerArrays){
            (function (){
                var $1 = {
                    Value: this.anchors
                };
                var $res = Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.CalculateAnchorSizes(this.database, $1, this.properLayeredGraph, this.originalGraph, this.IntGraph, this.sugiyamaSettings);
                this.anchors = $1.Value;
                return $res;
            }).call(this);
            Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.CalcInitialYAnchorLocations(layerArrays, 500, this.originalGraph, this.database, this.IntGraph, this.sugiyamaSettings, this.get_LayersAreDoubled());
        },
        OptimizeEdgeLabelsLocations: function (){
            for (var i = 0; i < this.anchors.length; i++){
                var a = this.anchors[i];
                if (a.get_LabelToTheRightOfAnchorCenter()){
                    var predecessor;
                    var successor;
                    (function (){
                        var $1 = {
                            Value: predecessor
                        };
                        var $2 = {
                            Value: successor
                        };
                        var $res = this.GetSuccessorAndPredecessor(i, $1, $2);
                        predecessor = $1.Value;
                        successor = $2.Value;
                        return $res;
                    }).call(this);
                    if (!Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.TryToPutLabelOutsideOfAngle(a, predecessor, successor)){
                        var sumNow = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(predecessor.get_Origin(), a.get_Origin())).get_Length() + (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(successor.get_Origin(), a.get_Origin())).get_Length();
                        var nx = a.get_Right() - a.get_LeftAnchor();
                        var xy = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(nx, a.get_Y());
                        var sumWouldBe = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(predecessor.get_Origin(), xy)).get_Length() + (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(successor.get_Origin(), xy)).get_Length();
                        if (sumWouldBe < sumNow)
                            Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.PutLabelToTheLeft(a);
                    }
                }
            }
        },
        GetSuccessorAndPredecessor: function (i, p, s){
            var predecessor = 10;
            var $it181 = this.properLayeredGraph.InEdges(i).GetEnumerator();
            while ($it181.MoveNext()){
                var ie = $it181.get_Current();
                predecessor = ie.get_Source();
            }
            var successor = 10;
            var $it182 = this.properLayeredGraph.OutEdges(i).GetEnumerator();
            while ($it182.MoveNext()){
                var ie = $it182.get_Current();
                successor = ie.get_Target();
            }
            p.Value = this.anchors[predecessor];
            s.Value = this.anchors[successor];
        },
        CycleRemoval: function (){
            var verticalConstraints = this.sugiyamaSettings.get_VerticalConstraints();
            var feedbackSet = verticalConstraints.get_IsEmpty() ? Microsoft.Msagl.Core.GraphAlgorithms.CycleRemoval$1.GetFeedbackSet(this.IntGraph) : verticalConstraints.GetFeedbackSet$$BasicGraph$2$Node$IntEdge$$Dictionary$2$Node$Int32(this.IntGraph, this.nodeIdToIndex);
            this.database.AddFeedbackSet(feedbackSet);
        },
        CalculateXLayersByGansnerNorth: function (layerArrays){
            this.xLayoutGraph = this.CreateXLayoutGraph(layerArrays);
            this.CalculateXLayersByGansnerNorthOnProperLayeredGraph();
        },
        CalculateXLayersByGansnerNorthOnProperLayeredGraph: function (){
            var xLayers = (new Microsoft.Msagl.Layout.Layered.NetworkSimplex.ctor(this.xLayoutGraph, null)).GetLayers();
            for (var i = 0; i < this.database.get_Anchors().length; i++)
                this.anchors[i].set_X(xLayers[i]);
        },
        CreaeteProperLayeredGraph: function (layering, layerArrays){
            var n = layering.length;
            var nOfVV = 0;
            var $it183 = this.database.SkeletonEdges().GetEnumerator();
            while ($it183.MoveNext()){
                var e = $it183.get_Current();
                var span = Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.EdgeSpan(layering, e);
                System.Diagnostics.Debug.Assert$$Boolean(span >= 0);
                if (span > 0)
                    e.set_LayerEdges(new Array(span));
                var pe = 0;
                if (span > 1){
                    var d0 = n + nOfVV++;
                    var layerEdge = new Microsoft.Msagl.Layout.Layered.LayerEdge.ctor$$Int32$$Int32$$Int32$$Int32(e.get_Source(), d0, e.get_CrossingWeight(), e.get_Weight());
                    e.get_LayerEdges().set_Item$$Int32(pe++, layerEdge);
                    for (var j = 0; j < span - 2; j++){
                        d0++;
                        nOfVV++;
                        layerEdge = new Microsoft.Msagl.Layout.Layered.LayerEdge.ctor$$Int32$$Int32$$Int32$$Int32(d0 - 1, d0, e.get_CrossingWeight(), e.get_Weight());
                        e.get_LayerEdges().set_Item$$Int32(pe++, layerEdge);
                    }
                    layerEdge = new Microsoft.Msagl.Layout.Layered.LayerEdge.ctor$$Int32$$Int32$$Int32$$Int32(d0, e.get_Target(), e.get_CrossingWeight(), e.get_Weight());
                    e.get_LayerEdges().set_Item$$Int32(pe, layerEdge);
                }
                else if (span == 1){
                    var layerEdge = new Microsoft.Msagl.Layout.Layered.LayerEdge.ctor$$Int32$$Int32$$Int32$$Int32(e.get_Source(), e.get_Target(), e.get_CrossingWeight(), e.get_Weight());
                    e.get_LayerEdges().set_Item$$Int32(pe, layerEdge);
                }
            }
            var extendedVertexLayering = new Int32Array(this.originalGraph.get_Nodes().get_Count() + nOfVV);
            var $it184 = this.database.SkeletonEdges().GetEnumerator();
            while ($it184.MoveNext()){
                var e = $it184.get_Current();
                if (e.get_LayerEdges() != null){
                    var l = layering[e.get_Source()];
                    extendedVertexLayering[e.get_Source()] = l--;
                    var $it185 = e.get_LayerEdges().GetEnumerator();
                    while ($it185.MoveNext()){
                        var le = $it185.get_Current();
                        extendedVertexLayering[le.get_Target()] = l--;
                    }
                }
                else {
                    extendedVertexLayering[e.get_Source()] = layering[e.get_Source()];
                    extendedVertexLayering[e.get_Target()] = layering[e.get_Target()];
                }
            }
            this.properLayeredGraph = new Microsoft.Msagl.Layout.Layered.ProperLayeredGraph.ctor(new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$2.ctor$$IEnumerable$1$$Int32(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Layout.Layered.IntEdge.ctor, this.database.SkeletonEdges(), layering.length));
            this.properLayeredGraph.BaseGraph.set_Nodes(this.IntGraph.get_Nodes());
            layerArrays.Value = new Microsoft.Msagl.Layout.Layered.LayerArrays.ctor(extendedVertexLayering);
        },
        YLayeringAndOrdering: function (layering){
            var yLayers = layering.GetLayers();
            Microsoft.Msagl.Layout.Layered.Balancing.Balance(this.get_GluedDagSkeletonForLayering(), yLayers, this.GetNodeCountsOfGluedDag(), null);
            yLayers = this.ExtendLayeringToUngluedSameLayerVertices(yLayers);
            var layerArrays = new Microsoft.Msagl.Layout.Layered.LayerArrays.ctor(yLayers);
            if (this.get_HorizontalConstraints() == null || this.get_HorizontalConstraints().get_IsEmpty()){
                layerArrays = this.YLayeringAndOrderingWithoutHorizontalConstraints(layerArrays);
                return layerArrays;
            }
            this.constrainedOrdering = new Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.ctor(this.originalGraph, this.IntGraph, layerArrays.Y, this.nodeIdToIndex, this.database, this.sugiyamaSettings);
            this.constrainedOrdering.Calculate();
            this.properLayeredGraph = this.constrainedOrdering.ProperLayeredGraph;
            return this.constrainedOrdering.LayerArrays;
        },
        YLayeringAndOrderingWithoutHorizontalConstraints: function (layerArrays){
            (function (){
                var $1 = {
                    Value: layerArrays
                };
                var $res = this.CreaeteProperLayeredGraph(layerArrays.Y, $1);
                layerArrays = $1.Value;
                return $res;
            }).call(this);
            Microsoft.Msagl.Layout.Layered.Ordering.OrderLayers(this.properLayeredGraph, layerArrays, this.originalGraph.get_Nodes().get_Count(), this.sugiyamaSettings.get_AspectRatio() != 0, this.sugiyamaSettings, this.get_CancelToken());
            Microsoft.Msagl.Layout.Layered.MetroMapOrdering.UpdateLayerArrays$$ProperLayeredGraph$$LayerArrays(this.properLayeredGraph, layerArrays);
            return layerArrays;
        },
        CalculateXPositionsByBrandes: function (layerArrays){
            Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.CalculateXCoordinates(layerArrays, this.properLayeredGraph, this.originalGraph.get_Nodes().get_Count(), this.database.get_Anchors(), this.sugiyamaSettings.get_NodeSeparation());
        },
        CalculateOriginalGraphBox: function (aspectRatio){
            aspectRatio.Value = 0;
            if (this.anchors.length > 0){
                var box = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Double$$Double$$Double$$Double(this.anchors[0].get_Left(), this.anchors[0].get_Top(), this.anchors[0].get_Right(), this.anchors[0].get_Bottom());
                for (var i = 1; i < this.anchors.length; i++){
                    var a = this.anchors[i];
                    box.Add$$Point(a.get_LeftTop());
                    box.Add$$Point(a.get_RightBottom());
                }
                aspectRatio.Value = box.get_Width() / box.get_Height();
                var delta = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(box.get_LeftTop(), box.get_RightBottom())).get_Length() / 2;
                var del = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-delta, delta);
                box.Add$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Addition(box.get_LeftTop(), del));
                box.Add$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(box.get_RightBottom(), del));
                this.originalGraph.set_BoundingBox(box);
            }
        },
        InsertLayersIfNeeded: function (layerArrays){
            var needToInsertLayers = false;
            var multipleEdges = false;
            this.InsertVirtualEdgesIfNeeded(layerArrays);
            (function (){
                var $1 = {
                    Value: needToInsertLayers
                };
                var $2 = {
                    Value: multipleEdges
                };
                var $res = this.AnalyzeNeedToInsertLayersAndHasMultiedges(layerArrays, $1, $2);
                needToInsertLayers = $1.Value;
                multipleEdges = $2.Value;
                return $res;
            }).call(this);
            if (needToInsertLayers){
                (function (){
                    var $1 = {
                        Value: this.properLayeredGraph
                    };
                    var $2 = {
                        Value: layerArrays
                    };
                    var $res = Microsoft.Msagl.Layout.Layered.LayerInserter.InsertLayers$$ProperLayeredGraph$$LayerArrays$$Database$$BasicGraph$2$Node$IntEdge($1, $2, this.database, this.IntGraph);
                    this.properLayeredGraph = $1.Value;
                    layerArrays = $2.Value;
                    return $res;
                }).call(this);
                this.set_LayersAreDoubled(true);
            }
            else if (multipleEdges)
                (function (){
                    var $1 = {
                        Value: this.properLayeredGraph
                    };
                    var $2 = {
                        Value: layerArrays
                    };
                    var $res = Microsoft.Msagl.Layout.Layered.EdgePathsInserter.InsertPaths$$ProperLayeredGraph$$LayerArrays$$Database$$BasicGraph$2$Node$IntEdge($1, $2, this.database, this.IntGraph);
                    this.properLayeredGraph = $1.Value;
                    layerArrays = $2.Value;
                    return $res;
                }).call(this);
            this.RecreateIntGraphFromDataBase();
            return layerArrays;
        },
        LayersAreDoubled$$: "System.Boolean",
        get_LayersAreDoubled: function (){
            return this._LayersAreDoubled;
        },
        set_LayersAreDoubled: function (value){
            this._LayersAreDoubled = value;
        },
        RecreateIntGraphFromDataBase: function (){
            var edges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Layout.Layered.IntEdge.ctor);
            var $it186 = this.database.get_Multiedges().get_Values().GetEnumerator();
            while ($it186.MoveNext()){
                var list = $it186.get_Current();
                edges.AddRange(list);
            }
            this.IntGraph.SetEdges(edges, this.IntGraph.get_NodeCount());
        },
        AnalyzeNeedToInsertLayersAndHasMultiedges: function (layerArrays, needToInsertLayers, multipleEdges){
            var $it187 = this.IntGraph.get_Edges().GetEnumerator();
            while ($it187.MoveNext()){
                var ie = $it187.get_Current();
                if (ie.get_HasLabel() && layerArrays.Y[ie.get_Source()] != layerArrays.Y[ie.get_Target()]){
                    needToInsertLayers.Value = true;
                    break;
                }
            }
            if (needToInsertLayers.Value == false && this.constrainedOrdering == null){
                var $it188 = this.database.get_Multiedges().GetEnumerator();
                while ($it188.MoveNext()){
                    var kv = $it188.get_Current();
                    if (kv.get_Value().get_Count() > 1){
                        multipleEdges.Value = true;
                        if (layerArrays.Y[kv.get_Key().x] - layerArrays.Y[kv.get_Key().y] == 1){
                            needToInsertLayers.Value = true;
                            break;
                        }
                    }
                }
            }
        },
        InsertVirtualEdgesIfNeeded: function (layerArrays){
            if (this.constrainedOrdering != null)
                return;
            var $it189 = this.database.get_Multiedges().GetEnumerator();
            while ($it189.MoveNext()){
                var kv = $it189.get_Current();
                if (kv.get_Value().get_Count() % 2 == 0 && layerArrays.Y[kv.get_Key().get_First()] - 1 == layerArrays.Y[kv.get_Key().get_Second()]){
                    var newVirtualEdge = new Microsoft.Msagl.Layout.Layered.IntEdge.ctor$$Int32$$Int32(kv.get_Key().get_First(), kv.get_Key().get_Second());
                    newVirtualEdge.set_Edge(new Microsoft.Msagl.Core.Layout.Edge.ctor());
                    newVirtualEdge.set_IsVirtualEdge(true);
                    kv.get_Value().Insert((kv.get_Value().get_Count() / 2) | 0, newVirtualEdge);
                    this.IntGraph.AddEdge(newVirtualEdge);
                }
            }
        },
        GetNodeCountsOfGluedDag: function (){
            if (this.get_VerticalConstraints().get_IsEmpty()){
                var ret = new Int32Array(this.IntGraph.get_NodeCount());
                for (var i = 0; i < ret.length; i++)
                    ret[i] = 1;
                return ret;
            }
            return this.get_VerticalConstraints().GetGluedNodeCounts();
        },
        ExtendLayeringToUngluedSameLayerVertices: function (p){
            var vc = this.get_VerticalConstraints();
            for (var i = 0; i < p.length; i++)
                p[i] = p[vc.NodeToRepr(i)];
            return p;
        },
        CalculateEdgeSplines: function (){
            var routing = new Microsoft.Msagl.Layout.Layered.Routing.ctor(this.sugiyamaSettings, this.originalGraph, this.database, this.engineLayerArrays, this.properLayeredGraph, this.IntGraph);
            routing.Run();
        },
        GetNodeWidth: function (i){
            var node = this.IntGraph.get_Nodes().get_Item$$Int32(i);
            var a = 0,b = 0,c = 0;
            return node.get_Width() + (function (){
                var $1 = {
                    Value: a
                };
                var $2 = {
                    Value: b
                };
                var $3 = {
                    Value: c
                };
                var $res = Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.WidthOfSelfEdge(this.database, i, $1, $2, $3, this.sugiyamaSettings);
                a = $1.Value;
                b = $2.Value;
                c = $3.Value;
                return $res;
            }).call(this);
        },
        CalculateApproximateDimensions: function (){
            this.CreateGluedDagSkeletonForLayering();
            var ns = new Microsoft.Msagl.Layout.Layered.NetworkSimplexForGeneralGraph.ctor(this.get_GluedDagSkeletonForLayering(), null);
            var layers = ns.GetLayers();
            var layerMap = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor);
            var width,height;
            var layoutDirection = Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.GetLayoutDirection(this.sugiyamaSettings);
            if (layoutDirection == Microsoft.Msagl.Core.Geometry.Directions.North || layoutDirection == Microsoft.Msagl.Core.Geometry.Directions.South){
                for (var i = 0; i < layers.length; ++i){
                    var v = this.originalGraph.get_Nodes().get_Item$$Int32(i);
                    var size = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, 0);
                    var l = layers[i];
                    (function (){
                        var $1 = {
                            Value: size
                        };
                        var $res = layerMap.TryGetValue(l, $1);
                        size = $1.Value;
                        return $res;
                    }).call(this);
                    layerMap.set_Item$$TKey(l, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(v.get_BoundingBox().get_Width() + size.get_X() + this.sugiyamaSettings.get_NodeSeparation(), System.Math.Max$$Double$$Double(v.get_BoundingBox().get_Height(), size.get_Y())));
                }
                width = 0;
                height = this.sugiyamaSettings.get_LayerSeparation() * (layerMap.get_Count() - 1);
                var $it197 = layerMap.get_Values().GetEnumerator();
                while ($it197.MoveNext()){
                    var size = $it197.get_Current();
                    width = System.Math.Max$$Double$$Double(size.get_X(), width);
                    height += size.get_Y();
                }
            }
            else {
                for (var i = 0; i < layers.length; ++i){
                    var v = this.originalGraph.get_Nodes().get_Item$$Int32(i);
                    var size;
                    var l = layers[i];
                    (function (){
                        var $1 = {
                            Value: size
                        };
                        var $res = layerMap.TryGetValue(l, $1);
                        size = $1.Value;
                        return $res;
                    }).call(this);
                    layerMap.set_Item$$TKey(l, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(System.Math.Max$$Double$$Double(v.get_BoundingBox().get_Width(), size.get_X()), v.get_BoundingBox().get_Height() + size.get_Y() + this.sugiyamaSettings.get_NodeSeparation()));
                }
                width = this.sugiyamaSettings.get_LayerSeparation() * (layerMap.get_Count() - 1);
                height = 0;
                var $it198 = layerMap.get_Values().GetEnumerator();
                while ($it198.MoveNext()){
                    var size = $it198.get_Current();
                    width += size.get_X();
                    height = System.Math.Max$$Double$$Double(size.get_Y(), height);
                }
            }
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(width, height);
        },
        CreateXLayoutGraph: function (layerArrays){
            var nOfVerts = this.properLayeredGraph.get_NodeCount();
            var edges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Layout.Layered.IntEdge.ctor);
            var $it203 = this.properLayeredGraph.get_Edges().GetEnumerator();
            while ($it203.MoveNext()){
                var e = $it203.get_Current();
                var n1 = new Microsoft.Msagl.Layout.Layered.IntEdge.ctor$$Int32$$Int32(nOfVerts, e.get_Source());
                var n2 = new Microsoft.Msagl.Layout.Layered.IntEdge.ctor$$Int32$$Int32(nOfVerts, e.get_Target());
                n1.set_Weight((function ($p16){
                    n2.set_Weight($p16);
                    return $p16;
                }).call(this, e.Weight));
                n1.set_Separation(0);
                n2.set_Separation(0);
                nOfVerts++;
                edges.Add(n1);
                edges.Add(n2);
            }
            for (var $i205 = 0,$t205 = layerArrays.get_Layers(),$l205 = $t205.length,layer = $t205[$i205]; $i205 < $l205; $i205++, layer = $t205[$i205])
                for (var i = layer.length - 1; i > 0; i--){
                    var source = layer[i];
                    var target = layer[i - 1];
                    var ie = new Microsoft.Msagl.Layout.Layered.IntEdge.ctor$$Int32$$Int32(source, target);
                    var sourceAnchor = this.database.get_Anchors()[source];
                    var targetAnchor = this.database.get_Anchors()[target];
                    var sep = sourceAnchor.get_LeftAnchor() + targetAnchor.get_RightAnchor() + this.sugiyamaSettings.get_NodeSeparation();
                    ie.set_Separation(((sep + 1)) | 0);
                    edges.Add(ie);
                }
            var ret = new Microsoft.Msagl.Layout.Layered.XLayoutGraph.ctor(this.IntGraph, this.properLayeredGraph, layerArrays, edges, nOfVerts);
            ret.SetEdgeWeights();
            return ret;
        },
        SugiyamaSettings$$: "Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings",
        get_SugiyamaSettings: function (){
            return this.sugiyamaSettings;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$LayeredLayoutEngine);
var Microsoft$Msagl$Layout$Layered$RecoveryLayerCalculator = {
    fullname: "Microsoft.Msagl.Layout.Layered.RecoveryLayerCalculator",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Layout.Layered.LayerCalculator"],
    Kind: "Class",
    definition: {
        ctor: function (recoveredLayerArrays){
            this.layers = null;
            System.Object.ctor.call(this);
            this.layers = recoveredLayerArrays;
        },
        GetLayers: function (){
            return this.layers.Y;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$RecoveryLayerCalculator);
var Microsoft$Msagl$Layout$Layered$RecoveryLayeredLayoutEngine = {
    fullname: "Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine",
    baseTypeName: "System.Object",
    staticDefinition: {
        VirtualNodeWidth$$: "System.Double",
        get_VirtualNodeWidth: function (){
            return 1;
        },
        VirtualNodeHeight: function (settings){
            return settings.get_MinNodeHeight() * 1.5 / 8;
        },
        EdgeSpan: function (layers, e){
            return layers[e.get_Source()] - layers[e.get_Target()];
        },
        CreateUpDownConstrainedIntEdge: function (intPair){
            var intEdge = new Microsoft.Msagl.Layout.Layered.IntEdge.ctor$$Int32$$Int32(intPair.x, intPair.y);
            intEdge.set_Weight(0);
            intEdge.set_Separation(1);
            return intEdge;
        },
        TryToPutLabelOutsideOfAngle: function (a, predecessor, successor){
            if (a.get_LabelToTheRightOfAnchorCenter()){
                if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(predecessor.get_Origin(), a.get_Origin(), successor.get_Origin()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise)
                    return true;
                var la = a.get_LeftAnchor();
                var ra = a.get_RightAnchor();
                var x = a.get_X();
                Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.PutLabelToTheLeft(a);
                if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(predecessor.get_Origin(), a.get_Origin(), successor.get_Origin()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise)
                    return true;
                a.set_X(x);
                a.set_LeftAnchor(la);
                a.set_RightAnchor(ra);
                a.set_LabelToTheRightOfAnchorCenter(true);
                a.set_LabelToTheLeftOfAnchorCenter(false);
                return false;
            }
            return false;
        },
        PutLabelToTheLeft: function (a){
            var r = a.get_Right();
            var t = a.get_LeftAnchor();
            a.set_LeftAnchor(a.get_RightAnchor());
            a.set_RightAnchor(t);
            a.set_X(r - a.get_RightAnchor());
            a.set_LabelToTheLeftOfAnchorCenter(true);
            a.set_LabelToTheRightOfAnchorCenter(false);
        },
        CalculateAnchorSizes: function (database, anchors, properLayeredGraph, originalGraph, intGraph, settings){
            database.set_Anchors(anchors.Value = new Array(properLayeredGraph.get_NodeCount()));
            for (var i = 0; i < anchors.Value.length; i++)
                anchors.Value[i] = new Microsoft.Msagl.Layout.Layered.Anchor.ctor$$Double(settings.get_LabelCornersPreserveCoefficient());
            for (var i = 0; i < originalGraph.get_Nodes().get_Count(); i++)
                Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.CalcAnchorsForOriginalNode(i, intGraph, anchors.Value, database, settings);
            var $it234 = database.get_AllIntEdges().GetEnumerator();
            while ($it234.MoveNext()){
                var intEdge = $it234.get_Current();
                if (intEdge.get_LayerEdges() != null){
                    var $it235 = intEdge.get_LayerEdges().GetEnumerator();
                    while ($it235.MoveNext()){
                        var layerEdge = $it235.get_Current();
                        var v = layerEdge.get_Target();
                        if (v != intEdge.get_Target()){
                            var anchor = anchors.Value[v];
                            if (!database.get_MultipleMiddles().Contains$$T(v)){
                                anchor.set_LeftAnchor((function ($p17){
                                    anchor.set_RightAnchor($p17);
                                    return $p17;
                                })(Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.get_VirtualNodeWidth() / 2));
                                anchor.set_TopAnchor((function ($p18){
                                    anchor.set_BottomAnchor($p18);
                                    return $p18;
                                })(Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.VirtualNodeHeight(settings) / 2));
                            }
                            else {
                                anchor.set_LeftAnchor((function ($p19){
                                    anchor.set_RightAnchor($p19);
                                    return $p19;
                                })(Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.get_VirtualNodeWidth() * 4));
                                anchor.set_TopAnchor((function ($p20){
                                    anchor.set_BottomAnchor($p20);
                                    return $p20;
                                })(Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.VirtualNodeHeight(settings) / 2));
                            }
                        }
                    }
                    if (intEdge.get_HasLabel()){
                        var lj = intEdge.get_LayerEdges().get_Item$$Int32((intEdge.get_LayerEdges().get_Count() / 2) | 0).get_Source();
                        var a = anchors.Value[lj];
                        var w = intEdge.get_LabelWidth(),h = intEdge.get_LabelHeight();
                        a.set_RightAnchor(w);
                        a.set_LeftAnchor(Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.get_VirtualNodeWidth() * 8);
                        if (a.get_TopAnchor() < h / 2)
                            a.set_TopAnchor((function ($p21){
                                a.set_BottomAnchor($p21);
                                return $p21;
                            })(h / 2));
                        a.set_LabelToTheRightOfAnchorCenter(true);
                    }
                }
            }
        },
        CalcInitialYAnchorLocations: function (layerArrays, spaceBeforeMargins, originalGraph, database, intGraph, settings, layersAreDoubled){
            var anchors = database.get_Anchors();
            var ymax = originalGraph.get_Margins() + spaceBeforeMargins;
            var i = 0;
            for (var $i237 = 0,$t237 = layerArrays.get_Layers(),$l237 = $t237.length,yLayer = $t237[$i237]; $i237 < $l237; $i237++, yLayer = $t237[$i237]){
                var bottomAnchorMax = 0;
                var topAnchorMax = 0;
                for (var $i238 = 0,$l238 = yLayer.length,j = yLayer[$i238]; $i238 < $l238; $i238++, j = yLayer[$i238]){
                    var p = anchors[j];
                    if (p.get_BottomAnchor() > bottomAnchorMax)
                        bottomAnchorMax = p.get_BottomAnchor();
                    if (p.get_TopAnchor() > topAnchorMax)
                        topAnchorMax = p.get_TopAnchor();
                }
                Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.MakeVirtualNodesHigh(yLayer, bottomAnchorMax, topAnchorMax, originalGraph.get_Nodes().get_Count(), database.get_Anchors());
                var flatEdgesHeight = Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.SetFlatEdgesForLayer(database, layerArrays, i, intGraph, settings, ymax);
                var y = ymax + bottomAnchorMax + flatEdgesHeight;
                for (var $i239 = 0,$l239 = yLayer.length,j = yLayer[$i239]; $i239 < $l239; $i239++, j = yLayer[$i239])
                    anchors[j].set_Y(y);
                var layerSep = settings.ActualLayerSeparation(layersAreDoubled);
                ymax = y + topAnchorMax + layerSep;
                i++;
            }
            Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.SetFlatEdgesForLayer(database, layerArrays, i, intGraph, settings, ymax);
        },
        SetFlatEdgesForLayer: function (database, layerArrays, i, intGraph, settings, ymax){
            var flatEdgesHeight = 0;
            if (i > 0){
                var flatPairs = Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.GetFlatPairs(layerArrays.get_Layers()[i - 1], layerArrays.Y, intGraph);
                if (System.Linq.Enumerable.Any$1$$IEnumerable$1(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, flatPairs)){
                    var dyOfFlatEdge = settings.get_LayerSeparation() / 3;
                    var ym = ymax;
                    flatEdgesHeight = System.Linq.Enumerable.Max$$IEnumerable$1$Double((System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, System.Double.ctor, flatPairs, function (pair){
                        return Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.SetFlatEdgesLabelsHeightAndPositionts(pair, ym, dyOfFlatEdge, database);
                    })));
                }
            }
            return flatEdgesHeight;
        },
        GetLayoutDirection: function (settings){
            var dir = Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(settings.get_Transformation(), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, 1));
            return dir.get_CompassDirection();
        },
        SetFlatEdgesLabelsHeightAndPositionts: function (pair, ymax, dy, database){
            var height = 0;
            var list = database.GetMultiedge$$IntPair(pair);
            var $it241 = list.GetEnumerator();
            while ($it241.MoveNext()){
                var edge = $it241.get_Current();
                height += dy;
                var label = edge.get_Edge().get_Label();
                if (label != null){
                    label.set_Center(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(label.get_Center().get_X(), ymax + height + label.get_Height() / 2));
                    height += label.get_Height();
                }
            }
            return height;
        },
        GetFlatPairs: function (layer, layering, intGraph){
            return new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(null, Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(null, System.Linq.Enumerable.SelectMany$3$$IEnumerable$1$$Func$2$$Func$3(System.Int32.ctor, Microsoft.Msagl.Layout.Layered.IntEdge.ctor, null, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(System.Int32.ctor, layer, function (v){
                return v < intGraph.get_NodeCount();
            }), function (v){
                return intGraph.OutEdges(v);
            }, function (v, edge){
                return $CreateAnonymousObject({
                    v: v,
                    edge: edge
                });
            }), function ($$x2){
                return layering[$$x2.get_edge().get_Source()] == layering[$$x2.get_edge().get_Target()];
            }), function ($$x3){
                return new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor($$x3.get_edge().get_Source(), $$x3.get_edge().get_Target());
            }));
        },
        MakeVirtualNodesHigh: function (yLayer, bottomAnchorMax, topAnchorMax, originalNodeCount, anchors){
            if (Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.LayerIsOriginal(yLayer, originalNodeCount))
                for (var $i243 = 0,$l243 = yLayer.length,j = yLayer[$i243]; $i243 < $l243; $i243++, j = yLayer[$i243])
                    if (j >= originalNodeCount){
                        var p = anchors[j];
                        p.set_BottomAnchor(bottomAnchorMax);
                        p.set_TopAnchor(topAnchorMax);
                    }
        },
        LayerIsOriginal: function (yLayer, origNodeCount){
            for (var $i244 = 0,$l244 = yLayer.length,j = yLayer[$i244]; $i244 < $l244; $i244++, j = yLayer[$i244])
                if (j < origNodeCount)
                    return true;
            return false;
        },
        CalcAnchorsForOriginalNode: function (i, intGraph, anchors, database, settings){
            var leftAnchor = 0;
            var rightAnchor = leftAnchor;
            var topAnchor = 0;
            var bottomAnchor = topAnchor;
            if (intGraph.get_Nodes() != null){
                var node = intGraph.get_Nodes().get_Item$$Int32(i);
                (function (){
                    var $1 = {
                        Value: leftAnchor
                    };
                    var $2 = {
                        Value: rightAnchor
                    };
                    var $3 = {
                        Value: topAnchor
                    };
                    var $4 = {
                        Value: bottomAnchor
                    };
                    var $res = Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.ExtendStandardAnchors($1, $2, $3, $4, node);
                    leftAnchor = $1.Value;
                    rightAnchor = $2.Value;
                    topAnchor = $3.Value;
                    bottomAnchor = $4.Value;
                    return $res;
                })();
            }
            (function (){
                var $1 = {
                    Value: rightAnchor
                };
                var $2 = {
                    Value: topAnchor
                };
                var $3 = {
                    Value: bottomAnchor
                };
                var $res = Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.RightAnchorMultiSelfEdges(i, $1, $2, $3, database, settings);
                rightAnchor = $1.Value;
                topAnchor = $2.Value;
                bottomAnchor = $3.Value;
                return $res;
            })();
            var hw = settings.get_MinNodeWidth() / 2;
            if (leftAnchor < hw)
                leftAnchor = hw;
            if (rightAnchor < hw)
                rightAnchor = hw;
            var hh = settings.get_MinNodeHeight() / 2;
            if (topAnchor < hh)
                topAnchor = hh;
            if (bottomAnchor < hh)
                bottomAnchor = hh;
            anchors[i] = (function (){
                var $v49 = new Microsoft.Msagl.Layout.Layered.Anchor.ctor$$Double$$Double$$Double$$Double$$Node$$Double(leftAnchor, rightAnchor, topAnchor, bottomAnchor, intGraph.get_Nodes().get_Item$$Int32(i), settings.get_LabelCornersPreserveCoefficient());
                $v49.set_Padding(intGraph.get_Nodes().get_Item$$Int32(i).get_Padding());
                return $v49;
            })();
        },
        RightAnchorMultiSelfEdges: function (i, rightAnchor, topAnchor, bottomAnchor, database, settings){
            var delta = Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.WidthOfSelfEdge(database, i, rightAnchor, topAnchor, bottomAnchor, settings);
            rightAnchor.Value += delta;
        },
        WidthOfSelfEdge: function (database, i, rightAnchor, topAnchor, bottomAnchor, settings){
            var delta = 0;
            var multiedges = database.GetMultiedge$$Int32$$Int32(i, i);
            if (multiedges.get_Count() > 0){
                var $it244 = multiedges.GetEnumerator();
                while ($it244.MoveNext()){
                    var e = $it244.get_Current();
                    if (e.get_Edge().get_Label() != null){
                        rightAnchor.Value += e.get_Edge().get_Label().get_Width();
                        if (topAnchor.Value < e.get_Edge().get_Label().get_Height() / 2)
                            topAnchor.Value = bottomAnchor.Value = e.get_Edge().get_Label().get_Height() / 2;
                    }
                }
                delta += (settings.get_NodeSeparation() + settings.get_MinNodeWidth()) * multiedges.get_Count();
            }
            return delta;
        },
        ExtendStandardAnchors: function (leftAnchor, rightAnchor, topAnchor, bottomAnchor, node){
            var w = node.get_Width();
            var h = node.get_Height();
            w /= 2;
            h /= 2;
            rightAnchor.Value = leftAnchor.Value = w;
            topAnchor.Value = bottomAnchor.Value = h;
        },
        RecoverOriginalLayersAndSettings: function (geometryGraph, sugiyamaLayoutSettings){
            sugiyamaLayoutSettings.Value = new Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.ctor();
            return (Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.RecoverOriginalHorizontalLayers(geometryGraph, sugiyamaLayoutSettings.Value) != null ? Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.RecoverOriginalHorizontalLayers(geometryGraph, sugiyamaLayoutSettings.Value) : Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.RecoverOriginalVerticalLayers(geometryGraph, sugiyamaLayoutSettings.Value));
        },
        RecoverOriginalHorizontalLayers: function (geometryGraph, sugiyamaLayoutSettings){
            var nodes = geometryGraph.get_Nodes();
            var list = new System.Collections.Generic.List$1.ctor(System.Int32.ctor);
            for (var i = 0; i < nodes.get_Count(); i++)
                list.Add(i);
            var layers = System.Linq.Enumerable.GroupBy$2$$IEnumerable$1$$Func$2(System.Int32.ctor, System.Double.ctor, list, function (i){
                return nodes.get_Item$$Int32(i).get_Center().get_Y();
            });
            var layerList = new System.Collections.Generic.List$1.ctor(Int32Array);
            var $it247 = layers.GetEnumerator();
            while ($it247.MoveNext()){
                var layer = $it247.get_Current();
                layerList.Add(System.Linq.Enumerable.ToArray$1(System.Int32.ctor, layer));
            }
            sugiyamaLayoutSettings.set_LayerSeparation(Infinity);
            layerList = new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Int32Array, System.Linq.Enumerable.OrderBy$2$$IEnumerable$1$$Func$2(Int32Array, System.Double.ctor, layerList, function (l){
                return nodes.get_Item$$Int32(l[0]).get_Center().get_Y();
            }));
            for (var i = 0; i < layerList.get_Count() - 1; i++){
                var topOfI = System.Linq.Enumerable.Max$1$$IEnumerable$1$$Func$2(System.Int32.ctor, layerList.get_Item$$Int32(i), function (j){
                    return nodes.get_Item$$Int32(j).get_BoundingBox().get_Top();
                });
                var bottomOfINext = System.Linq.Enumerable.Min$1$$IEnumerable$1$$Func$2(System.Int32.ctor, layerList.get_Item$$Int32(i + 1), function (j){
                    return nodes.get_Item$$Int32(j).get_BoundingBox().get_Bottom();
                });
                var layerSep = bottomOfINext - topOfI;
                if (layerSep <= 0){
                    sugiyamaLayoutSettings.set_Transformation(null);
                    return null;
                }
                sugiyamaLayoutSettings.set_LayerSeparation(System.Math.Min$$Double$$Double(sugiyamaLayoutSettings.get_LayerSeparation(), layerSep));
            }
            var nodesToLayers = new Int32Array(nodes.get_Count());
            for (var i = 0; i < layerList.get_Count(); i++){
                var layer = layerList.get_Item$$Int32(i);
                for (var j = 0; j < layer.length; j++)
                    nodesToLayers[layer[j]] = i;
            }
            sugiyamaLayoutSettings.set_Transformation(System.Linq.Enumerable.Any$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, geometryGraph.get_Edges(), function (e){
                return e.get_Source().get_Center().get_Y() > e.get_Target().get_Center().get_Y();
            }) ? new Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.ctor() : Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.Rotation(3.14159265358979));
            return new Microsoft.Msagl.Layout.Layered.LayerArrays.ctor(nodesToLayers);
        },
        RecoverOriginalVerticalLayers: function (geometryGraph, sugiyamaLayoutSettings){
            var nodes = geometryGraph.get_Nodes();
            var list = new System.Collections.Generic.List$1.ctor(System.Int32.ctor);
            for (var i = 0; i < geometryGraph.get_Nodes().get_Count(); i++)
                list.Add(i);
            var layers = System.Linq.Enumerable.GroupBy$2$$IEnumerable$1$$Func$2(System.Int32.ctor, System.Double.ctor, list, function (i){
                return nodes.get_Item$$Int32(i).get_Center().get_X();
            });
            var layerList = new System.Collections.Generic.List$1.ctor(Int32Array);
            var $it248 = layers.GetEnumerator();
            while ($it248.MoveNext()){
                var layer = $it248.get_Current();
                layerList.Add(System.Linq.Enumerable.ToArray$1(System.Int32.ctor, layer));
            }
            layerList = new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Int32Array, System.Linq.Enumerable.OrderBy$2$$IEnumerable$1$$Func$2(Int32Array, System.Double.ctor, layerList, function (l){
                return nodes.get_Item$$Int32(l[0]).get_Center().get_X();
            }));
            sugiyamaLayoutSettings.set_LayerSeparation(Infinity);
            for (var i = 0; i < layerList.get_Count() - 1; i++){
                var rightOfI = System.Linq.Enumerable.Max$1$$IEnumerable$1$$Func$2(System.Int32.ctor, layerList.get_Item$$Int32(i), function (j){
                    return nodes.get_Item$$Int32(j).get_BoundingBox().get_Right();
                });
                var leftOfNext = System.Linq.Enumerable.Min$1$$IEnumerable$1$$Func$2(System.Int32.ctor, layerList.get_Item$$Int32(i + 1), function (j){
                    return nodes.get_Item$$Int32(j).get_BoundingBox().get_Left();
                });
                var layerSep = leftOfNext - rightOfI;
                if (layerSep <= 0){
                    return null;
                }
                sugiyamaLayoutSettings.set_LayerSeparation(System.Math.Min$$Double$$Double(sugiyamaLayoutSettings.get_LayerSeparation(), layerSep));
            }
            var nodesToLayers = new Int32Array(nodes.get_Count());
            for (var i = 0; i < layerList.get_Count(); i++){
                var layer = layerList.get_Item$$Int32(i);
                for (var j = 0; j < layer.length; j++)
                    nodesToLayers[layer[j]] = i;
            }
            sugiyamaLayoutSettings.set_Transformation(System.Linq.Enumerable.Any$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, geometryGraph.get_Edges(), function (e){
                return e.get_Source().get_Center().get_X() > e.get_Target().get_Center().get_X();
            }) ? Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.Rotation(-1.5707963267949) : Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.Rotation(1.5707963267949));
            return new Microsoft.Msagl.Layout.Layered.LayerArrays.ctor(nodesToLayers);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (originalGraph){
            this.engineLayerArrays = null;
            this.originalGraph = null;
            this.properLayeredGraph = null;
            this.sugiyamaSettings = null;
            this.database = null;
            this.IntGraph = null;
            this.xLayoutGraph = null;
            this.nodeIdToIndex = null;
            this.anchors = null;
            this.recoveredLayerArrays = null;
            this.layerToRecoveredYCoordinates = null;
            this.skeletonVirtualVerticesToX = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, System.Double.ctor);
            this.constrainedOrdering = null;
            this._Brandes = false;
            this._GluedDagSkeletonForLayering = null;
            this._LayersAreDoubled = false;
            System.Object.ctor.call(this);
            if (originalGraph != null){
                this.Init(originalGraph);
                this.recoveredLayerArrays = (function (){
                    var $1 = {
                        Value: this.sugiyamaSettings
                    };
                    var $res = Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.RecoverOriginalLayersAndSettings(originalGraph, $1);
                    this.sugiyamaSettings = $1.Value;
                    return $res;
                }).call(this);
            }
        },
        Brandes$$: "System.Boolean",
        get_Brandes: function (){
            return this._Brandes;
        },
        set_Brandes: function (value){
            this._Brandes = value;
        },
        Database$$: "Microsoft.Msagl.Layout.Layered.Database",
        get_Database: function (){
            return this.database;
        },
        set_Database: function (value){
            this.database = value;
        },
        GluedDagSkeletonForLayering$$: "Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph`2[[Microsoft.Msagl.Core.Layout.Node],[Microsoft.Msagl.Layout.Layered.IntEdge]]",
        get_GluedDagSkeletonForLayering: function (){
            return this._GluedDagSkeletonForLayering;
        },
        set_GluedDagSkeletonForLayering: function (value){
            this._GluedDagSkeletonForLayering = value;
        },
        FillLayersToRecoveredYCoordinates: function (){
            this.layerToRecoveredYCoordinates = new Float64Array(this.recoveredLayerArrays.get_Layers().length);
            for (var i = 0; i < this.layerToRecoveredYCoordinates.length; i++)
                this.layerToRecoveredYCoordinates[i] = this.originalGraph.get_Nodes().get_Item$$Int32(this.recoveredLayerArrays.get_Layers()[i][0]).get_Center().get_Y();
        },
        Init: function (geometryGraph){
            this.nodeIdToIndex = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, System.Int32.ctor);
            var nodes = geometryGraph.get_Nodes();
            this.InitNodesToIndex(nodes);
            var intEdges = this.CreateIntEdges(geometryGraph);
            this.IntGraph = (function (){
                var $v48 = new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$2.ctor$$IEnumerable$1$$Int32(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Layout.Layered.IntEdge.ctor, intEdges, geometryGraph.get_Nodes().get_Count());
                $v48.set_Nodes(nodes);
                return $v48;
            }).call(this);
            this.originalGraph = geometryGraph;
            if (this.sugiyamaSettings == null)
                this.sugiyamaSettings = new Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.ctor();
            this.CreateDatabaseAndRegisterIntEdgesInMultiEdges();
        },
        CreateDatabaseAndRegisterIntEdgesInMultiEdges: function (){
            this.set_Database(new Microsoft.Msagl.Layout.Layered.Database.ctor());
            var $it205 = this.IntGraph.get_Edges().GetEnumerator();
            while ($it205.MoveNext()){
                var e = $it205.get_Current();
                this.database.RegisterOriginalEdgeInMultiedges(e);
            }
        },
        CreateIntEdges: function (geometryGraph){
            var edges = geometryGraph.get_Edges();
            var intEdges = new Array(edges.get_Count());
            var i = 0;
            var $it206 = edges.GetEnumerator();
            while ($it206.MoveNext()){
                var edge = $it206.get_Current();
                if (edge.get_Source() == null || edge.get_Target() == null)
                    throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
                var intEdge = new Microsoft.Msagl.Layout.Layered.IntEdge.ctor$$Int32$$Int32$$Edge(this.nodeIdToIndex.get_Item$$TKey(edge.get_Source()), this.nodeIdToIndex.get_Item$$TKey(edge.get_Target()), edge);
                intEdges[i] = intEdge;
                i++;
            }
            return intEdges;
        },
        InitNodesToIndex: function (nodes){
            var index = 0;
            var $it207 = nodes.GetEnumerator();
            while ($it207.MoveNext()){
                var n = $it207.get_Current();
                this.nodeIdToIndex.set_Item$$TKey(n, index);
                index++;
            }
        },
        CreateGluedDagSkeletonForLayering: function (){
            this.set_GluedDagSkeletonForLayering(new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$2.ctor$$IEnumerable$1$$Int32(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Layout.Layered.IntEdge.ctor, this.GluedDagSkeletonEdges(), this.originalGraph.get_Nodes().get_Count()));
            this.SetGluedEdgesWeights();
        },
        SetGluedEdgesWeights: function (){
            var gluedPairsToGluedEdge = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, Microsoft.Msagl.Layout.Layered.IntEdge.ctor);
            var $it208 = this.get_GluedDagSkeletonForLayering().get_Edges().GetEnumerator();
            while ($it208.MoveNext()){
                var ie = $it208.get_Current();
                gluedPairsToGluedEdge.set_Item$$TKey(new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(ie.get_Source(), ie.get_Target()), ie);
            }
            var $it209 = this.database.get_Multiedges().GetEnumerator();
            while ($it209.MoveNext()){
                var t = $it209.get_Current();
                if (t.get_Key().x != t.get_Key().y){
                    var gluedPair = this.get_VerticalConstraints().GluedIntPair$$IntPair(t.get_Key());
                    if (gluedPair.x == gluedPair.y)
                        continue;
                    var gluedIntEdge = gluedPairsToGluedEdge.get_Item$$TKey(gluedPair);
                    var $it210 = t.get_Value().GetEnumerator();
                    while ($it210.MoveNext()){
                        var ie = $it210.get_Current();
                        gluedIntEdge.set_Weight(gluedIntEdge.get_Weight() + ie.get_Weight());
                    }
                }
            }
        },
        GluedDagSkeletonEdges: function (){
            var ret = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Layout.Layered.IntEdge.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(null, Microsoft.Msagl.Layout.Layered.IntEdge.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(null, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.Collections.Generic.KeyValuePair$2.ctor, null, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(System.Collections.Generic.KeyValuePair$2.ctor, this.database.get_Multiedges(), $CreateAnonymousDelegate(this, function (kv){
                return kv.get_Key().x != kv.get_Key().y;
            })), $CreateAnonymousDelegate(this, function (kv){
                return $CreateAnonymousObject({
                    kv: kv,
                    e: this.get_VerticalConstraints().GluedIntEdge(kv.get_Value().get_Item$$Int32(0))
                });
            })), $CreateAnonymousDelegate(this, function ($$x0){
                return $$x0.get_e().get_Source() != $$x0.get_e().get_Target();
            })), $CreateAnonymousDelegate(this, function ($$x1){
                return $$x1.get_e();
            })));
            var gluedUpDownConstraints = System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, Microsoft.Msagl.Layout.Layered.IntEdge.ctor, this.get_VerticalConstraints().get_GluedUpDownIntConstraints(), $CreateAnonymousDelegate(this, function (p){
                return Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.CreateUpDownConstrainedIntEdge(p);
            }));
            var $it211 = gluedUpDownConstraints.GetEnumerator();
            while ($it211.MoveNext()){
                var edge = $it211.get_Current();
                ret.Insert(edge);
            }
            return ret;
        },
        Run: function (){
            if (this.originalGraph.get_Nodes().get_Count() > 0){
                this.engineLayerArrays = this.CalculateLayers();
            }
            else
                this.originalGraph.boundingBox.SetToEmpty();
        },
        CalculateLayers: function (){
            this.CreateGluedDagSkeletonForLayering();
            var layerArrays = this.CalculateLayersWithoutAspectRatio();
            this.UpdateNodePositionData();
            return layerArrays;
        },
        UpdateNodePositionData: function (){
            this.TryToSatisfyMinWidhtAndMinHeight();
            for (var i = 0; i < this.IntGraph.get_Nodes().get_Count() && i < this.database.get_Anchors().length; i++)
                this.IntGraph.get_Nodes().get_Item$$Int32(i).set_Center(this.database.get_Anchors()[i].get_Origin());
        },
        TryToSatisfyMinWidhtAndMinHeight: function (){
            this.TryToSatisfyMinWidth();
            this.TryToSatisfyMinHeight();
        },
        TryToSatisfyMinWidth: function (){
            if (this.sugiyamaSettings.get_MinimalWidth() == 0)
                return;
            var w = this.GetCurrentWidth();
            if (w < this.sugiyamaSettings.get_MinimalWidth())
                this.StretchWidth();
        },
        StretchWidth: function (){
            var desiredSpan = new Microsoft.Msagl.Core.DataStructures.RealNumberSpan.ctor();
            var $it212 = this.originalGraph.get_Nodes().GetEnumerator();
            while ($it212.MoveNext()){
                var node = $it212.get_Current();
                desiredSpan.AddValue(node.get_BoundingBox().get_Width() / 2);
                desiredSpan.AddValue(this.sugiyamaSettings.get_MinimalWidth() - node.get_BoundingBox().get_Width() / 2);
            }
            var currentSpan = new Microsoft.Msagl.Core.DataStructures.RealNumberSpan.ctor();
            var $it213 = this.NodeAnchors().GetEnumerator();
            while ($it213.MoveNext()){
                var anchor = $it213.get_Current();
                currentSpan.AddValue(anchor.get_X());
            }
            if (currentSpan.get_Length() > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                var stretch = desiredSpan.get_Length() / currentSpan.get_Length();
                if (stretch > 1)
                    for (var $i215 = 0,$t215 = this.anchors,$l215 = $t215.length,a = $t215[$i215]; $i215 < $l215; $i215++, a = $t215[$i215])
                        a.set_X(a.get_X() * stretch);
            }
        },
        TryToSatisfyMinHeight: function (){
            if (this.sugiyamaSettings.get_MinimalHeight() == 0)
                return;
            var h = this.GetCurrentHeight();
            if (h < this.sugiyamaSettings.get_MinimalHeight())
                this.StretchHeight();
        },
        GetCurrentHeight: function (){
            var span = new Microsoft.Msagl.Core.DataStructures.RealNumberSpan.ctor();
            var $it215 = this.NodeAnchors().GetEnumerator();
            while ($it215.MoveNext()){
                var anchor = $it215.get_Current();
                span.AddValue(anchor.get_Top());
                span.AddValue(anchor.get_Bottom());
            }
            return span.get_Length();
        },
        StretchHeight: function (){
            var desiredSpan = new Microsoft.Msagl.Core.DataStructures.RealNumberSpan.ctor();
            var $it216 = this.originalGraph.get_Nodes().GetEnumerator();
            while ($it216.MoveNext()){
                var node = $it216.get_Current();
                desiredSpan.AddValue(node.get_BoundingBox().get_Height() / 2);
                desiredSpan.AddValue(this.sugiyamaSettings.get_MinimalHeight() - node.get_BoundingBox().get_Height() / 2);
            }
            var currentSpan = new Microsoft.Msagl.Core.DataStructures.RealNumberSpan.ctor();
            var $it217 = this.NodeAnchors().GetEnumerator();
            while ($it217.MoveNext()){
                var anchor = $it217.get_Current();
                currentSpan.AddValue(anchor.get_Y());
            }
            if (currentSpan.get_Length() > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                var stretch = desiredSpan.get_Length() / currentSpan.get_Length();
                if (stretch > 1)
                    for (var $i219 = 0,$t219 = this.anchors,$l219 = $t219.length,a = $t219[$i219]; $i219 < $l219; $i219++, a = $t219[$i219])
                        a.set_Y(a.get_Y() * stretch);
            }
        },
        NodeAnchors: function (){
            return System.Linq.Enumerable.Take$1(Microsoft.Msagl.Layout.Layered.Anchor.ctor, this.anchors, System.Math.Min$$Int32$$Int32(this.IntGraph.get_Nodes().get_Count(), this.anchors.length));
        },
        GetCurrentWidth: function (){
            var span = new Microsoft.Msagl.Core.DataStructures.RealNumberSpan.ctor();
            var $it219 = this.NodeAnchors().GetEnumerator();
            while ($it219.MoveNext()){
                var anchor = $it219.get_Current();
                span.AddValue(anchor.get_Left());
                span.AddValue(anchor.get_Right());
            }
            return span.get_Length();
        },
        StretchToDesiredAspectRatio: function (aspectRatio, desiredAr){
            if (aspectRatio > desiredAr)
                this.StretchInYDirection(aspectRatio / desiredAr);
            else if (aspectRatio < desiredAr)
                this.StretchInXDirection(desiredAr / aspectRatio);
        },
        StretchInYDirection: function (scaleFactor){
            var center = (this.originalGraph.get_BoundingBox().get_Top() + this.originalGraph.get_BoundingBox().get_Bottom()) / 2;
            for (var $i221 = 0,$t221 = this.get_Database().get_Anchors(),$l221 = $t221.length,a = $t221[$i221]; $i221 < $l221; $i221++, a = $t221[$i221]){
                a.set_BottomAnchor(a.get_BottomAnchor() * scaleFactor);
                a.set_TopAnchor(a.get_TopAnchor() * scaleFactor);
                a.set_Y(center + scaleFactor * (a.get_Y() - center));
            }
            var h = this.originalGraph.get_Height() * scaleFactor;
            this.originalGraph.set_BoundingBox(new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Double$$Double$$Double$$Double(this.originalGraph.get_BoundingBox().get_Left(), center + h / 2, this.originalGraph.get_BoundingBox().get_Right(), center - h / 2));
        },
        StretchInXDirection: function (scaleFactor){
            var center = (this.originalGraph.get_BoundingBox().get_Left() + this.originalGraph.get_BoundingBox().get_Right()) / 2;
            for (var $i222 = 0,$t222 = this.get_Database().get_Anchors(),$l222 = $t222.length,a = $t222[$i222]; $i222 < $l222; $i222++, a = $t222[$i222]){
                a.set_LeftAnchor(a.get_LeftAnchor() * scaleFactor);
                a.set_RightAnchor(a.get_RightAnchor() * scaleFactor);
                a.set_X(center + scaleFactor * (a.get_X() - center));
            }
            var w = this.originalGraph.get_Width() * scaleFactor;
            this.originalGraph.set_BoundingBox(new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Double$$Double$$Double$$Double(center - w / 2, this.originalGraph.get_BoundingBox().get_Top(), center + w / 2, this.originalGraph.get_BoundingBox().get_Bottom()));
        },
        CalculateLayersWithoutAspectRatio: function (){
            var layerArrays = this.CalculateYLayers();
            if (this.constrainedOrdering == null){
                this.DecideIfUsingFastXCoordCalculation(layerArrays);
                this.CalculateAnchorsAndYPositions(layerArrays);
                if (this.get_Brandes())
                    this.CalculateXPositionsByBrandes(layerArrays);
                else
                    this.CalculateXLayersByGansnerNorth(layerArrays);
            }
            else
                this.anchors = this.database.get_Anchors();
            this.OptimizeEdgeLabelsLocations();
            this.engineLayerArrays = layerArrays;
            this.StraightensShortEdges();
            var aspectRatio;
            (function (){
                var $1 = {
                    Value: aspectRatio
                };
                var $res = this.CalculateOriginalGraphBox($1);
                aspectRatio = $1.Value;
                return $res;
            }).call(this);
            if (this.sugiyamaSettings.get_AspectRatio() != 0)
                this.StretchToDesiredAspectRatio(aspectRatio, this.sugiyamaSettings.get_AspectRatio());
            return layerArrays;
        },
        DecideIfUsingFastXCoordCalculation: function (layerArrays){
            if (layerArrays.get_X().length >= this.sugiyamaSettings.get_BrandesThreshold())
                this.set_Brandes(true);
            else {
                var s = System.Environment.GetEnvironmentVariable$$String("Brandes");
                if (!System.String.IsNullOrEmpty(s) && System.String.Compare$$String$$String$$Boolean$$CultureInfo(s, "on", true, System.Globalization.CultureInfo.get_CurrentCulture()) == 0)
                    this.set_Brandes(true);
            }
        },
        StraightensShortEdges: function (){
            for (; this.StraightenEdgePaths();){
            }
        },
        StraightenEdgePaths: function (){
            var ret = false;
            var $it222 = this.database.get_AllIntEdges().GetEnumerator();
            while ($it222.MoveNext()){
                var e = $it222.get_Current();
                if (e.get_LayerSpan() == 2)
                    ret = this.ShiftVertexWithNeighbors(e.get_LayerEdges().get_Item$$Int32(0).get_Source(), e.get_LayerEdges().get_Item$$Int32(0).get_Target(), e.get_LayerEdges().get_Item$$Int32(1).get_Target()) || ret;
            }
            return ret;
        },
        ShiftVertexWithNeighbors: function (u, i, v){
            var upper = this.database.get_Anchors()[u];
            var lower = this.database.get_Anchors()[v];
            var iAnchor = this.database.get_Anchors()[i];
            var x = (iAnchor.get_Y() - upper.get_Y()) * (lower.get_X() - upper.get_X()) / (lower.get_Y() - upper.get_Y()) + upper.get_X();
            var eps = 0.0001;
            if (x > iAnchor.get_X() + eps)
                return this.TryShiftToTheRight(x, i);
            if (x < iAnchor.get_X() - eps)
                return this.TryShiftToTheLeft(x, i);
            return false;
        },
        TryShiftToTheLeft: function (x, v){
            var layer = this.engineLayerArrays.get_Layers()[this.engineLayerArrays.Y[v]];
            var vPosition = this.engineLayerArrays.get_X()[v];
            if (vPosition > 0){
                var uAnchor = this.database.get_Anchors()[layer[vPosition - 1]];
                var allowedX = System.Math.Max$$Double$$Double(uAnchor.get_Right() + this.sugiyamaSettings.get_NodeSeparation() + this.database.get_Anchors()[v].get_LeftAnchor(), x);
                if (allowedX < this.database.get_Anchors()[v].get_X() - 1){
                    this.database.get_Anchors()[v].set_X(allowedX);
                    return true;
                }
                return false;
            }
            this.database.get_Anchors()[v].set_X(x);
            return true;
        },
        TryShiftToTheRight: function (x, v){
            var layer = this.engineLayerArrays.get_Layers()[this.engineLayerArrays.Y[v]];
            var vPosition = this.engineLayerArrays.get_X()[v];
            if (vPosition < layer.length - 1){
                var uAnchor = this.database.get_Anchors()[layer[vPosition + 1]];
                var allowedX = System.Math.Min$$Double$$Double(uAnchor.get_Left() - this.sugiyamaSettings.get_NodeSeparation() - this.database.get_Anchors()[v].get_RightAnchor(), x);
                if (allowedX > this.database.get_Anchors()[v].get_X() + 1){
                    this.database.get_Anchors()[v].set_X(allowedX);
                    return true;
                }
                return false;
            }
            this.database.get_Anchors()[v].set_X(x);
            return true;
        },
        CalculateYLayers: function (){
            var layerArrays = this.YLayeringAndOrdering(new Microsoft.Msagl.Layout.Layered.RecoveryLayerCalculator.ctor(this.recoveredLayerArrays));
            if (this.constrainedOrdering != null)
                return layerArrays;
            return this.InsertLayersIfNeeded(layerArrays);
        },
        VerticalConstraints$$: "Microsoft.Msagl.Layout.Layered.VerticalConstraintsForSugiyama",
        get_VerticalConstraints: function (){
            return this.sugiyamaSettings.get_VerticalConstraints();
        },
        HorizontalConstraints$$: "Microsoft.Msagl.Layout.Layered.HorizontalConstraintsForSugiyama",
        get_HorizontalConstraints: function (){
            return this.sugiyamaSettings.get_HorizontalConstraints();
        },
        CalculateAnchorsAndYPositions: function (layerArrays){
            (function (){
                var $1 = {
                    Value: this.anchors
                };
                var $res = Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.CalculateAnchorSizes(this.database, $1, this.properLayeredGraph, this.originalGraph, this.IntGraph, this.sugiyamaSettings);
                this.anchors = $1.Value;
                return $res;
            }).call(this);
            Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.CalcInitialYAnchorLocations(layerArrays, 500, this.originalGraph, this.database, this.IntGraph, this.sugiyamaSettings, this.get_LayersAreDoubled());
        },
        OptimizeEdgeLabelsLocations: function (){
            for (var i = 0; i < this.anchors.length; i++){
                var a = this.anchors[i];
                if (a.get_LabelToTheRightOfAnchorCenter()){
                    var predecessor;
                    var successor;
                    (function (){
                        var $1 = {
                            Value: predecessor
                        };
                        var $2 = {
                            Value: successor
                        };
                        var $res = this.GetSuccessorAndPredecessor(i, $1, $2);
                        predecessor = $1.Value;
                        successor = $2.Value;
                        return $res;
                    }).call(this);
                    if (!Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.TryToPutLabelOutsideOfAngle(a, predecessor, successor)){
                        var sumNow = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(predecessor.get_Origin(), a.get_Origin())).get_Length() + (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(successor.get_Origin(), a.get_Origin())).get_Length();
                        var nx = a.get_Right() - a.get_LeftAnchor();
                        var xy = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(nx, a.get_Y());
                        var sumWouldBe = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(predecessor.get_Origin(), xy)).get_Length() + (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(successor.get_Origin(), xy)).get_Length();
                        if (sumWouldBe < sumNow)
                            Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.PutLabelToTheLeft(a);
                    }
                }
            }
        },
        GetSuccessorAndPredecessor: function (i, p, s){
            var predecessor = 10;
            var $it223 = this.properLayeredGraph.InEdges(i).GetEnumerator();
            while ($it223.MoveNext()){
                var ie = $it223.get_Current();
                predecessor = ie.get_Source();
            }
            var successor = 10;
            var $it224 = this.properLayeredGraph.OutEdges(i).GetEnumerator();
            while ($it224.MoveNext()){
                var ie = $it224.get_Current();
                successor = ie.get_Target();
            }
            p.Value = this.anchors[predecessor];
            s.Value = this.anchors[successor];
        },
        CycleRemoval: function (){
            var feedbackSet = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Layout.Layered.IntEdge.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Layout.Layered.IntEdge.ctor, this.IntGraph.get_Edges(), $CreateAnonymousDelegate(this, function (e){
                return this.recoveredLayerArrays.Y[e.get_Source()] < this.recoveredLayerArrays.Y[e.get_Target()];
            })));
            this.database.AddFeedbackSet(feedbackSet);
        },
        CalculateXLayersByGansnerNorth: function (layerArrays){
            this.xLayoutGraph = this.CreateXLayoutGraph(layerArrays);
            this.CalculateXLayersByGansnerNorthOnProperLayeredGraph();
        },
        CalculateXLayersByGansnerNorthOnProperLayeredGraph: function (){
            var xLayers = (new Microsoft.Msagl.Layout.Layered.NetworkSimplex.ctor(this.xLayoutGraph, null)).GetLayers();
            for (var i = 0; i < this.database.get_Anchors().length; i++)
                this.anchors[i].set_X(xLayers[i]);
        },
        CreateProperLayeredGraph: function (layering, layerArrays){
            var n = layering.length;
            var nOfVv = 0;
            var $it225 = this.database.SkeletonEdges().GetEnumerator();
            while ($it225.MoveNext()){
                var e = $it225.get_Current();
                var span = Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.EdgeSpan(layering, e);
                System.Diagnostics.Debug.Assert$$Boolean(span >= 0);
                if (span > 0)
                    e.set_LayerEdges(new Array(span));
                var pe = 0;
                if (span > 1){
                    var d0 = n + nOfVv++;
                    var layerEdge = new Microsoft.Msagl.Layout.Layered.LayerEdge.ctor$$Int32$$Int32$$Int32(e.get_Source(), d0, e.get_CrossingWeight());
                    e.get_LayerEdges().set_Item$$Int32(pe++, layerEdge);
                    for (var j = 0; j < span - 2; j++){
                        d0++;
                        nOfVv++;
                        layerEdge = new Microsoft.Msagl.Layout.Layered.LayerEdge.ctor$$Int32$$Int32$$Int32(d0 - 1, d0, e.get_CrossingWeight());
                        e.get_LayerEdges().set_Item$$Int32(pe++, layerEdge);
                    }
                    layerEdge = new Microsoft.Msagl.Layout.Layered.LayerEdge.ctor$$Int32$$Int32$$Int32(d0, e.get_Target(), e.get_CrossingWeight());
                    e.get_LayerEdges().set_Item$$Int32(pe, layerEdge);
                }
                else if (span == 1){
                    var layerEdge = new Microsoft.Msagl.Layout.Layered.LayerEdge.ctor$$Int32$$Int32$$Int32(e.get_Source(), e.get_Target(), e.get_CrossingWeight());
                    e.get_LayerEdges().set_Item$$Int32(pe, layerEdge);
                }
            }
            var extendedVertexLayering = new Int32Array(this.originalGraph.get_Nodes().get_Count() + nOfVv);
            var $it226 = this.database.SkeletonEdges().GetEnumerator();
            while ($it226.MoveNext()){
                var e = $it226.get_Current();
                if (e.get_LayerEdges() != null){
                    var l = layering[e.get_Source()];
                    extendedVertexLayering[e.get_Source()] = l--;
                    var $it227 = e.get_LayerEdges().GetEnumerator();
                    while ($it227.MoveNext()){
                        var le = $it227.get_Current();
                        extendedVertexLayering[le.get_Target()] = l--;
                    }
                }
                else {
                    extendedVertexLayering[e.get_Source()] = layering[e.get_Source()];
                    extendedVertexLayering[e.get_Target()] = layering[e.get_Target()];
                }
            }
            this.properLayeredGraph = new Microsoft.Msagl.Layout.Layered.ProperLayeredGraph.ctor(new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$2.ctor$$IEnumerable$1$$Int32(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Layout.Layered.IntEdge.ctor, this.database.SkeletonEdges(), layering.length));
            this.properLayeredGraph.BaseGraph.set_Nodes(this.IntGraph.get_Nodes());
            layerArrays.Value = new Microsoft.Msagl.Layout.Layered.LayerArrays.ctor(extendedVertexLayering);
        },
        YLayeringAndOrdering: function (layering){
            var yLayers = layering.GetLayers();
            yLayers = this.ExtendLayeringToUngluedSameLayerVertices(yLayers);
            var layerArrays = new Microsoft.Msagl.Layout.Layered.LayerArrays.ctor(yLayers);
            if (this.get_HorizontalConstraints() == null || this.get_HorizontalConstraints().get_IsEmpty()){
                layerArrays = this.YLayeringAndOrderingWithoutHorizontalConstraints(layerArrays);
                return layerArrays;
            }
            this.constrainedOrdering = new Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.ctor(this.originalGraph, this.IntGraph, layerArrays.Y, this.nodeIdToIndex, this.database, this.sugiyamaSettings);
            this.constrainedOrdering.Calculate();
            this.properLayeredGraph = this.constrainedOrdering.ProperLayeredGraph;
            return this.constrainedOrdering.LayerArrays;
        },
        YLayeringAndOrderingWithoutHorizontalConstraints: function (layerArrays){
            (function (){
                var $1 = {
                    Value: layerArrays
                };
                var $res = this.CreateProperLayeredGraph(layerArrays.Y, $1);
                layerArrays = $1.Value;
                return $res;
            }).call(this);
            this.GetXCoordinatesOfVirtualNodesOfTheProperLayeredGraph(layerArrays);
            this.OrderLayers(layerArrays);
            Microsoft.Msagl.Layout.Layered.MetroMapOrdering.UpdateLayerArrays$$ProperLayeredGraph$$LayerArrays(this.properLayeredGraph, layerArrays);
            return layerArrays;
        },
        GetXCoordinatesOfVirtualNodesOfTheProperLayeredGraph: function (layerArrays){
            var $it228 = this.database.SkeletonEdges().GetEnumerator();
            while ($it228.MoveNext()){
                var skeletonEdge = $it228.get_Current();
                this.GetXCoordinatesOfVirtualNodesOfTheProperLayeredGraphForSkeletonEdge(skeletonEdge, layerArrays);
            }
        },
        GetXCoordinatesOfVirtualNodesOfTheProperLayeredGraphForSkeletonEdge: function (intEdge, layerArrays){
            if (intEdge.get_LayerEdges() == null || intEdge.get_LayerEdges().get_Count() < 2)
                return;
            var edgeCurve = intEdge.get_Edge().get_Curve();
            var layerIndex = layerArrays.Y[intEdge.get_Source()] - 1;
            for (var i = 1; i < intEdge.get_LayerEdges().get_Count(); i++){
                var v = intEdge.get_LayerEdges().get_Item$$Int32(i).get_Source();
                var layerY = this.layerToRecoveredYCoordinates[layerIndex--];
                var layerLine = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.originalGraph.get_Left(), layerY), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.originalGraph.get_Right(), layerY));
                var intersection = Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveIntersectionOne(edgeCurve, layerLine, false);
                this.skeletonVirtualVerticesToX.set_Item$$TKey(v, intersection.get_IntersectionPoint().get_X());
            }
        },
        OrderLayers: function (layerArrays){
            for (var $i230 = 0,$t230 = layerArrays.get_Layers(),$l230 = $t230.length,layer = $t230[$i230]; $i230 < $l230; $i230++, layer = $t230[$i230])
                this.OrderLayerBasedOnRecoveredXCoords(layer);
        },
        OrderLayerBasedOnRecoveredXCoords: function (layer){
            if (layer.length <= 1)
                return;
            var keys = new Float64Array(layer.length);
            for (var i = 0; i < layer.length; i++){
                var v = layer[i];
                keys[i] = this.properLayeredGraph.IsVirtualNode(v) ? this.skeletonVirtualVerticesToX.get_Item$$TKey(v) : this.originalGraph.get_Nodes().get_Item$$Int32(v).get_Center().get_X();
            }
            System.Array.Sort$2$$TKey$Array$$TValue$Array(System.Double.ctor, System.Int32.ctor, keys, layer);
        },
        CalculateXPositionsByBrandes: function (layerArrays){
            Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.CalculateXCoordinates(layerArrays, this.properLayeredGraph, this.originalGraph.get_Nodes().get_Count(), this.database.get_Anchors(), this.sugiyamaSettings.get_NodeSeparation());
        },
        CalculateOriginalGraphBox: function (aspectRatio){
            aspectRatio.Value = 0;
            if (this.anchors.length > 0){
                var box = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Double$$Double$$Double$$Double(this.anchors[0].get_Left(), this.anchors[0].get_Top(), this.anchors[0].get_Right(), this.anchors[0].get_Bottom());
                for (var i = 1; i < this.anchors.length; i++){
                    var a = this.anchors[i];
                    box.Add$$Point(a.get_LeftTop());
                    box.Add$$Point(a.get_RightBottom());
                }
                aspectRatio.Value = box.get_Width() / box.get_Height();
                var delta = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(box.get_LeftTop(), box.get_RightBottom())).get_Length() / 2;
                var del = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-delta, delta);
                box.Add$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Addition(box.get_LeftTop(), del));
                box.Add$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(box.get_RightBottom(), del));
                this.originalGraph.set_BoundingBox(box);
            }
        },
        InsertLayersIfNeeded: function (layerArrays){
            var needToInsertLayers = false;
            var multipleEdges = false;
            this.InsertVirtualEdgesIfNeeded(layerArrays);
            (function (){
                var $1 = {
                    Value: needToInsertLayers
                };
                var $2 = {
                    Value: multipleEdges
                };
                var $res = this.AnalyzeNeedToInsertLayersAndHasMultiedges(layerArrays, $1, $2);
                needToInsertLayers = $1.Value;
                multipleEdges = $2.Value;
                return $res;
            }).call(this);
            if (needToInsertLayers){
                (function (){
                    var $1 = {
                        Value: this.properLayeredGraph
                    };
                    var $2 = {
                        Value: layerArrays
                    };
                    var $res = Microsoft.Msagl.Layout.Layered.LayerInserter.InsertLayers$$ProperLayeredGraph$$LayerArrays$$Database$$BasicGraph$2$Node$IntEdge($1, $2, this.database, this.IntGraph);
                    this.properLayeredGraph = $1.Value;
                    layerArrays = $2.Value;
                    return $res;
                }).call(this);
                this.set_LayersAreDoubled(true);
            }
            else if (multipleEdges)
                (function (){
                    var $1 = {
                        Value: this.properLayeredGraph
                    };
                    var $2 = {
                        Value: layerArrays
                    };
                    var $res = Microsoft.Msagl.Layout.Layered.EdgePathsInserter.InsertPaths$$ProperLayeredGraph$$LayerArrays$$Database$$BasicGraph$2$Node$IntEdge($1, $2, this.database, this.IntGraph);
                    this.properLayeredGraph = $1.Value;
                    layerArrays = $2.Value;
                    return $res;
                }).call(this);
            this.RecreateIntGraphFromDataBase();
            return layerArrays;
        },
        LayersAreDoubled$$: "System.Boolean",
        get_LayersAreDoubled: function (){
            return this._LayersAreDoubled;
        },
        set_LayersAreDoubled: function (value){
            this._LayersAreDoubled = value;
        },
        RecreateIntGraphFromDataBase: function (){
            var edges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Layout.Layered.IntEdge.ctor);
            var $it230 = this.database.get_Multiedges().get_Values().GetEnumerator();
            while ($it230.MoveNext()){
                var list = $it230.get_Current();
                edges.AddRange(list);
            }
            this.IntGraph.SetEdges(edges, this.IntGraph.get_NodeCount());
        },
        AnalyzeNeedToInsertLayersAndHasMultiedges: function (layerArrays, needToInsertLayers, multipleEdges){
            var $it231 = this.IntGraph.get_Edges().GetEnumerator();
            while ($it231.MoveNext()){
                var ie = $it231.get_Current();
                if (ie.get_HasLabel() && layerArrays.Y[ie.get_Source()] != layerArrays.Y[ie.get_Target()]){
                    needToInsertLayers.Value = true;
                    break;
                }
            }
            if (needToInsertLayers.Value == false && this.constrainedOrdering == null){
                var $it232 = this.database.get_Multiedges().GetEnumerator();
                while ($it232.MoveNext()){
                    var kv = $it232.get_Current();
                    if (kv.get_Value().get_Count() > 1){
                        multipleEdges.Value = true;
                        if (layerArrays.Y[kv.get_Key().x] - layerArrays.Y[kv.get_Key().y] == 1){
                            needToInsertLayers.Value = true;
                            break;
                        }
                    }
                }
            }
        },
        InsertVirtualEdgesIfNeeded: function (layerArrays){
            if (this.constrainedOrdering != null)
                return;
            var $it233 = this.database.get_Multiedges().GetEnumerator();
            while ($it233.MoveNext()){
                var kv = $it233.get_Current();
                if (kv.get_Value().get_Count() % 2 == 0 && layerArrays.Y[kv.get_Key().get_First()] - 1 == layerArrays.Y[kv.get_Key().get_Second()]){
                    var newVirtualEdge = new Microsoft.Msagl.Layout.Layered.IntEdge.ctor$$Int32$$Int32(kv.get_Key().get_First(), kv.get_Key().get_Second());
                    newVirtualEdge.set_Edge(new Microsoft.Msagl.Core.Layout.Edge.ctor());
                    newVirtualEdge.set_IsVirtualEdge(true);
                    kv.get_Value().Insert((kv.get_Value().get_Count() / 2) | 0, newVirtualEdge);
                    this.IntGraph.AddEdge(newVirtualEdge);
                }
            }
        },
        ExtendLayeringToUngluedSameLayerVertices: function (p){
            var vc = this.get_VerticalConstraints();
            for (var i = 0; i < p.length; i++)
                p[i] = p[vc.NodeToRepr(i)];
            return p;
        },
        GetNodeWidth: function (i){
            var node = this.IntGraph.get_Nodes().get_Item$$Int32(i);
            var a = 0,b = 0,c = 0;
            return node.get_Width() + (function (){
                var $1 = {
                    Value: a
                };
                var $2 = {
                    Value: b
                };
                var $3 = {
                    Value: c
                };
                var $res = Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.WidthOfSelfEdge(this.database, i, $1, $2, $3, this.sugiyamaSettings);
                a = $1.Value;
                b = $2.Value;
                c = $3.Value;
                return $res;
            }).call(this);
        },
        CalculateApproximateDimensions: function (){
            this.CreateGluedDagSkeletonForLayering();
            var ns = new Microsoft.Msagl.Layout.Layered.NetworkSimplexForGeneralGraph.ctor(this.get_GluedDagSkeletonForLayering(), null);
            var layers = ns.GetLayers();
            var layerMap = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor);
            var width,height;
            var layoutDirection = Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.GetLayoutDirection(this.sugiyamaSettings);
            if (layoutDirection == Microsoft.Msagl.Core.Geometry.Directions.North || layoutDirection == Microsoft.Msagl.Core.Geometry.Directions.South){
                for (var i = 0; i < layers.length; ++i){
                    var v = this.originalGraph.get_Nodes().get_Item$$Int32(i);
                    var size;
                    var l = layers[i];
                    (function (){
                        var $1 = {
                            Value: size
                        };
                        var $res = layerMap.TryGetValue(l, $1);
                        size = $1.Value;
                        return $res;
                    }).call(this);
                    layerMap.set_Item$$TKey(l, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(v.get_BoundingBox().get_Width() + size.get_X() + this.sugiyamaSettings.get_NodeSeparation(), System.Math.Max$$Double$$Double(v.get_BoundingBox().get_Height(), size.get_Y())));
                }
                width = 0;
                height = this.sugiyamaSettings.get_LayerSeparation() * (layerMap.get_Count() - 1);
                var $it239 = layerMap.get_Values().GetEnumerator();
                while ($it239.MoveNext()){
                    var size = $it239.get_Current();
                    width = System.Math.Max$$Double$$Double(size.get_X(), width);
                    height += size.get_Y();
                }
            }
            else {
                for (var i = 0; i < layers.length; ++i){
                    var v = this.originalGraph.get_Nodes().get_Item$$Int32(i);
                    var size;
                    var l = layers[i];
                    (function (){
                        var $1 = {
                            Value: size
                        };
                        var $res = layerMap.TryGetValue(l, $1);
                        size = $1.Value;
                        return $res;
                    }).call(this);
                    layerMap.set_Item$$TKey(l, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(System.Math.Max$$Double$$Double(v.get_BoundingBox().get_Width(), size.get_X()), v.get_BoundingBox().get_Height() + size.get_Y() + this.sugiyamaSettings.get_NodeSeparation()));
                }
                width = this.sugiyamaSettings.get_LayerSeparation() * (layerMap.get_Count() - 1);
                height = 0;
                var $it240 = layerMap.get_Values().GetEnumerator();
                while ($it240.MoveNext()){
                    var size = $it240.get_Current();
                    width += size.get_X();
                    height = System.Math.Max$$Double$$Double(size.get_Y(), height);
                }
            }
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(width, height);
        },
        CreateXLayoutGraph: function (layerArrays){
            var nOfVerts = this.properLayeredGraph.get_NodeCount();
            var edges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Layout.Layered.IntEdge.ctor);
            var $it245 = this.properLayeredGraph.get_Edges().GetEnumerator();
            while ($it245.MoveNext()){
                var e = $it245.get_Current();
                var n1 = new Microsoft.Msagl.Layout.Layered.IntEdge.ctor$$Int32$$Int32(nOfVerts, e.get_Source());
                var n2 = new Microsoft.Msagl.Layout.Layered.IntEdge.ctor$$Int32$$Int32(nOfVerts, e.get_Target());
                n1.set_Weight((function ($p22){
                    n2.set_Weight($p22);
                    return $p22;
                }).call(this, 1));
                n1.set_Separation(0);
                n2.set_Separation(0);
                nOfVerts++;
                edges.Add(n1);
                edges.Add(n2);
            }
            for (var $i247 = 0,$t247 = layerArrays.get_Layers(),$l247 = $t247.length,layer = $t247[$i247]; $i247 < $l247; $i247++, layer = $t247[$i247])
                for (var i = layer.length - 1; i > 0; i--){
                    var source = layer[i];
                    var target = layer[i - 1];
                    var ie = new Microsoft.Msagl.Layout.Layered.IntEdge.ctor$$Int32$$Int32(source, target);
                    var sourceAnchor = this.database.get_Anchors()[source];
                    var targetAnchor = this.database.get_Anchors()[target];
                    var sep = sourceAnchor.get_LeftAnchor() + targetAnchor.get_RightAnchor() + this.sugiyamaSettings.get_NodeSeparation();
                    ie.set_Separation(((sep + 1)) | 0);
                    edges.Add(ie);
                }
            var ret = new Microsoft.Msagl.Layout.Layered.XLayoutGraph.ctor(this.IntGraph, this.properLayeredGraph, layerArrays, edges, nOfVerts);
            ret.SetEdgeWeights();
            return ret;
        },
        GetEngine: function (){
            if (this.recoveredLayerArrays == null)
                return null;
            if (!this.sugiyamaSettings.get_Transformation().get_IsIdentity()){
                this.originalGraph.Transform(this.sugiyamaSettings.get_Transformation().get_Inverse());
            }
            this.FillLayersToRecoveredYCoordinates();
            this.CycleRemoval();
            this.Run();
            var engine = this.CreateEngine();
            if (!this.sugiyamaSettings.get_Transformation().get_IsIdentity()){
                this.originalGraph.Transform(this.sugiyamaSettings.get_Transformation());
            }
            return engine;
        },
        CreateEngine: function (){
            return new Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.ctor$$LayerArrays$$GeometryGraph$$ProperLayeredGraph$$SugiyamaLayoutSettings$$Database$$BasicGraph$2$Node$IntEdge$$Dictionary$2$Node$Int32$$BasicGraph$2$Node$IntEdge$$Boolean$$ConstrainedOrdering$$Boolean$$XLayoutGraph(this.engineLayerArrays, this.originalGraph, this.properLayeredGraph, this.sugiyamaSettings, this.database, this.IntGraph, this.nodeIdToIndex, this.get_GluedDagSkeletonForLayering(), this.get_LayersAreDoubled(), this.constrainedOrdering, this.get_Brandes(), this.xLayoutGraph);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$RecoveryLayeredLayoutEngine);
var Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$MST$OverlapRemoval = {
    fullname: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MST.OverlapRemoval",
    baseTypeName: "System.Object",
    staticDefinition: {
        RemoveOverlaps: function (graph, nodeSeparation){
            var settings = (function (){
                var $v50 = new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.OverlapRemovalSettings.ctor();
                $v50.set_RandomizeAllPointsOnStart(true);
                $v50.set_NodeSeparation(nodeSeparation);
                return $v50;
            })();
            var mst = new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MST.OverlapRemoval.ctor(settings);
            mst.RemoveOverlap(graph);
        },
        PrintTimeSpan: function (stopWatch){
            var ts = stopWatch.get_Elapsed();
            var elapsedTime = System.String.Format$$String$$Object$Array("{0:00}:{1:00}:{2:00}.{3:00}", [ts.get_Hours(), ts.get_Minutes(), ts.get_Seconds(), (ts.get_Milliseconds() / 10) | 0]);
            System.Console.WriteLine$$String$$Object(elapsedTime, "RunTime");
        },
        AvgEdgeLength: function (graph){
            var i = 0;
            var avgEdgeLength = 0;
            var $it249 = graph.get_Edges().GetEnumerator();
            while ($it249.MoveNext()){
                var edge = $it249.get_Current();
                var sPoint = edge.get_Source().get_Center();
                var tPoint = edge.get_Target().get_Center();
                var euclid = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(sPoint, tPoint)).get_Length();
                avgEdgeLength += euclid;
                i++;
            }
            avgEdgeLength /= i;
            return avgEdgeLength;
        },
        GetIdealEdgeLength$$Int32$$Int32$$Point$$Point$$Size$Array: function (nodeId1, nodeId2, point1, point2, nodeSizes){
            var t;
            var idealDist = (function (){
                var $1 = {
                    Value: t
                };
                var $res = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MST.OverlapRemoval.GetIdealEdgeLength$$Int32$$Int32$$Point$$Point$$Size$Array$$Double(nodeId1, nodeId2, point1, point2, nodeSizes, $1);
                t = $1.Value;
                return $res;
            })();
            var length = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(point1, point2)).get_Length();
            var box1 = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Size$$Point(nodeSizes[nodeId1], point1);
            var box2 = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Size$$Point(nodeSizes[nodeId2], point2);
            var distBox = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MST.OverlapRemoval.GetDistanceRects(box1, box2);
            var weight;
            if (t > 1)
                weight = -(idealDist - length);
            else
                weight = distBox;
            var smallId = nodeId1;
            var bigId = nodeId2;
            if (nodeId1 > nodeId2){
                smallId = nodeId2;
                bigId = nodeId1;
            }
            return System.Tuple.Create$5$$T1$$T2$$T3$$T4$$T5(System.Int32.ctor, System.Int32.ctor, System.Double.ctor, System.Double.ctor, System.Double.ctor, smallId, bigId, t, idealDist, weight);
        },
        GetIdealEdgeLength$$Int32$$Int32$$Point$$Point$$Size$Array$$Double: function (nodeId1, nodeId2, point1, point2, nodeBoxes, tRes){
            if (nodeBoxes == null)
                throw $CreateException(new System.ArgumentNullException.ctor$$String("nodeBoxes"), new Error());
            var expandMax = 1.5;
            var expandMin = 1;
            var machineAcc = 1E-16;
            var dist = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(point1, point2)).get_Length();
            var dx = System.Math.Abs$$Double(point1.get_X() - point2.get_X());
            var dy = System.Math.Abs$$Double(point1.get_Y() - point2.get_Y());
            var wx = (nodeBoxes[nodeId1].get_Width() / 2 + nodeBoxes[nodeId2].get_Width() / 2);
            var wy = (nodeBoxes[nodeId1].get_Height() / 2 + nodeBoxes[nodeId2].get_Height() / 2);
            var t;
            if (dx < machineAcc * wx){
                t = wy / dy;
            }
            else if (dy < machineAcc * wy){
                t = wx / dx;
            }
            else {
                t = System.Math.Min$$Double$$Double(wx / dx, wy / dy);
            }
            if (t > 1)
                t = System.Math.Max$$Double$$Double(t, 1.001);
            t = System.Math.Min$$Double$$Double(expandMax, t);
            t = System.Math.Max$$Double$$Double(expandMin, t);
            tRes.Value = t;
            return t * dist;
        },
        GetDistanceRects: function (a, b){
            if (a.Intersects(b))
                return 0;
            var dx = 0,dy = 0;
            if (a.get_Right() < b.get_Left()){
                dx = a.get_Left() - b.get_Right();
            }
            else if (b.get_Right() < a.get_Left()){
                dx = a.get_Left() - b.get_Right();
            }
            if (a.get_Top() < b.get_Bottom()){
                dy = b.get_Bottom() - a.get_Top();
            }
            else if (b.get_Top() < a.get_Bottom()){
                dy = a.get_Bottom() - b.get_Top();
            }
            var euclid = System.Math.Sqrt(dx * dx + dy * dy);
            return euclid;
        },
        MoveNodePositions: function (treeEdges, nodePositions, rootNodeId){
            var posOld = nodePositions.Clone() instanceof Array || nodePositions.Clone() == null ? nodePositions.Clone() : (function (){
                throw new Error("InvalidCastException");
            }
            ());
            var visited = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(System.Int32.ctor);
            visited.Insert(rootNodeId);
            for (var i = 0; i < treeEdges.get_Count(); i++){
                var tupleEdge = treeEdges.get_Item$$Int32(i);
                if (visited.Contains$$T(tupleEdge.get_Item1()))
                    Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MST.OverlapRemoval.MoveUpperSite(tupleEdge, nodePositions, posOld, visited);
                else {
                    System.Diagnostics.Debug.Assert$$Boolean(visited.Contains$$T(tupleEdge.get_Item2()));
                    Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MST.OverlapRemoval.MoveLowerSite(tupleEdge, nodePositions, posOld, visited);
                }
            }
        },
        MoveUpperSite: function (edge, posNew, oldPos, visited){
            var idealLen = edge.get_Item4();
            var dir = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(oldPos[edge.get_Item2()], oldPos[edge.get_Item1()]);
            var len = dir.get_Length();
            dir = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(dir, (idealLen / len + 0.01));
            var standingNode = edge.get_Item1();
            var movedNode = edge.get_Item2();
            posNew[movedNode] = Microsoft.Msagl.Core.Geometry.Point.op_Addition(posNew[standingNode], dir);
            visited.Insert(movedNode);
        },
        MoveLowerSite: function (edge, posNew, oldPos, visited){
            var idealLen = edge.get_Item4();
            var dir = Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(oldPos[edge.get_Item2()]), oldPos[edge.get_Item1()]);
            var len = dir.get_Length();
            dir = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(dir, (idealLen / len + 0.01));
            var standingNode = edge.get_Item2();
            var movedNode = edge.get_Item1();
            posNew[movedNode] = Microsoft.Msagl.Core.Geometry.Point.op_Addition(posNew[standingNode], dir);
            visited.Insert(movedNode);
        },
        DoInitialScaling: function (graph, nodePositions, nodeSizes, scalingMethod){
            var avgEdgeLength = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MST.OverlapRemoval.AvgEdgeLength(graph);
            var goalLength;
            if (scalingMethod == Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.InitialScaling.Inch72Pixel)
                goalLength = 72;
            else if (scalingMethod == Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.InitialScaling.AvgNodeSize)
                goalLength = System.Linq.Enumerable.Average$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.DataStructures.Size.ctor, nodeSizes, function (box){
                    return (box.get_Width() + box.get_Height()) / 2;
                });
            else
                return;
            var scaling = goalLength / avgEdgeLength;
            System.Console.WriteLine$$String$$Object$$Object("AvgEdgeLength Scaling Method: {0}, ScaleFactor={1:F2}", scalingMethod, scaling);
            for (var j = 0; j < nodePositions.length; j++){
                nodePositions[j] = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(nodePositions[j], scaling);
            }
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.IOverlapRemoval"],
    Kind: "Class",
    definition: {
        ctor: function (settings){
            this.lastRunNumberIterations = 0;
            this._Settings = null;
            System.Object.ctor.call(this);
            this.set_Settings(settings);
        },
        Settings$$: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.OverlapRemovalSettings",
        get_Settings: function (){
            return this._Settings;
        },
        set_Settings: function (value){
            this._Settings = value;
        },
        RemoveOverlap: function (graph){
            if (graph.get_Nodes().get_Count() < 3){
                this.RemoveOverlapsOnTinyGraph(graph);
                return;
            }
            var nodePositions;
            var nodeSizes;
            (function (){
                var $1 = {
                    Value: nodePositions
                };
                var $2 = {
                    Value: nodeSizes
                };
                var $res = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.InitNodePositionsAndBoxes(this.get_Settings(), graph, $1, $2);
                nodePositions = $1.Value;
                nodeSizes = $2.Value;
                return $res;
            }).call(this);
            if (this.get_Settings().get_InitialScaling() != Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.InitialScaling.None)
                Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MST.OverlapRemoval.DoInitialScaling(graph, nodePositions, nodeSizes, Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.InitialScaling.Inch72Pixel);
            this.lastRunNumberIterations = 0;
            while (this.OneIteration(nodePositions, nodeSizes, false)){
                this.lastRunNumberIterations++;
            }
            while (this.OneIteration(nodePositions, nodeSizes, true)){
                this.lastRunNumberIterations++;
            }
            System.Console.WriteLine();
            for (var i = 0; i < graph.get_Nodes().get_Count(); i++){
                graph.get_Nodes().get_Item$$Int32(i).set_Center(nodePositions[i]);
            }
        },
        RemoveOverlapsOnTinyGraph: function (graph){
            if (graph.get_Nodes().get_Count() == 1)
                return;
            if (graph.get_Nodes().get_Count() == 2){
                var nodes = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Layout.Node.ctor, graph.get_Nodes());
                var a = nodes[0];
                var b = nodes[1];
                if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(a.get_Center(), b.get_Center()))
                    b.set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Addition(b.get_Center(), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0.001, 0)));
                var idealDist = this.GetIdealDistanceBetweenTwoNodes(a, b);
                var center = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Addition(a.get_Center(), b.get_Center())), 2);
                var dir = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a.get_Center(), b.get_Center()));
                var dist = dir.get_Length();
                dir = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(dir, 0.5 * idealDist / dist);
                a.set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Addition(center, dir));
                b.set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(center, dir));
            }
        },
        GetIdealDistanceBetweenTwoNodes: function (a, b){
            var abox = a.get_BoundingBox();
            var bbox = b.get_BoundingBox();
            abox.Pad$$Double(this.get_Settings().get_NodeSeparation() / 2);
            bbox.Pad$$Double(this.get_Settings().get_NodeSeparation() / 2);
            var ac = abox.get_Center();
            var bc = bbox.get_Center();
            var ab = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(ac, bc);
            var dx = System.Math.Abs$$Double(ab.get_X());
            var dy = System.Math.Abs$$Double(ab.get_Y());
            var wx = (abox.get_Width() / 2 + bbox.get_Width() / 2);
            var wy = (abox.get_Height() / 2 + bbox.get_Height() / 2);
            var machineAcc = 1E-16;
            var t;
            if (dx < machineAcc * wx)
                t = wy / dy;
            else if (dy < machineAcc * wy)
                t = wx / dx;
            else
                t = System.Math.Min$$Double$$Double(wx / dx, wy / dy);
            return t * ab.get_Length();
        },
        OneIteration: function (nodePositions, nodeSizes, scanlinePhase){
            var cdt = new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.ctor$$IEnumerable$1(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$3(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Tuple$2.ctor, nodePositions, $CreateAnonymousDelegate(this, function (p, index){
                return System.Tuple.Create$2$$T1$$T2(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Object.ctor, p, index);
            })));
            cdt.Run();
            var siteIndex = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.CdtSite.ctor, System.Int32.ctor);
            for (var i = 0; i < nodePositions.length; i++)
                siteIndex.set_Item$$TKey(cdt.PointsToSites.get_Item$$TKey(nodePositions[i]), i);
            var numCrossings = 0;
            var proximityEdges = new System.Collections.Generic.List$1.ctor(System.Tuple$5.ctor);
            var $it250 = cdt.PointsToSites.get_Values().GetEnumerator();
            while ($it250.MoveNext()){
                var site = $it250.get_Current();
                var $it251 = site.Edges.GetEnumerator();
                while ($it251.MoveNext()){
                    var edge = $it251.get_Current();
                    var point1 = edge.upperSite.Point;
                    var point2 = edge.lowerSite.Point;
                    var nodeId1 = siteIndex.get_Item$$TKey(edge.upperSite);
                    var nodeId2 = siteIndex.get_Item$$TKey(edge.lowerSite);
                    System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(point1, nodePositions[nodeId1]));
                    System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(point2, nodePositions[nodeId2]));
                    var tuple = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MST.OverlapRemoval.GetIdealEdgeLength$$Int32$$Int32$$Point$$Point$$Size$Array(nodeId1, nodeId2, point1, point2, nodeSizes);
                    proximityEdges.Add(tuple);
                    if (tuple.get_Item3() > 1)
                        numCrossings++;
                }
            }
            if (numCrossings == 0 || scanlinePhase){
                var additionalCrossings = this.FindProximityEdgesWithSweepLine(proximityEdges, nodeSizes, nodePositions);
                if (numCrossings == 0 && additionalCrossings == 0){
                    return false;
                }
                if (numCrossings == 0 && !scanlinePhase)
                    return false;
            }
            var treeEdges = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MST.MstOnDelaunayTriangulation.GetMstOnTuple(proximityEdges, nodePositions.length);
            var rootId = System.Linq.Enumerable.First$1$$IEnumerable$1(System.Tuple$5.ctor, treeEdges).get_Item1();
            Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MST.OverlapRemoval.MoveNodePositions(treeEdges, nodePositions, rootId);
            return true;
        },
        FindProximityEdgesWithSweepLine: function (proximityEdges, nodeSizes, nodePositions){
            var mstLineSweeper = new Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MST.MstLineSweeper.ctor(proximityEdges, nodeSizes, nodePositions);
            return mstLineSweeper.Run();
        },
        GetLastRunIterations: function (){
            return this.lastRunNumberIterations;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$MST$OverlapRemoval);
var Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$MST$OverlapRemovalMethod = {
    fullname: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MST.OverlapRemovalMethod",
    staticDefinition: {
        Prism: 0,
        Pmst: 1
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Core$Layout$ProximityOverlapRemoval$MST$OverlapRemovalMethod);
var Microsoft$Msagl$Prototype$Constraints$AlignmentConstraint = {
    fullname: "Microsoft.Msagl.Prototype.Constraints.AlignmentConstraint",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Layout.Incremental.IConstraint"],
    Kind: "Class",
    definition: {
        ctor: function (nodes){
            this.nodes = null;
            System.Object.ctor.call(this);
            this.nodes = System.Linq.Enumerable.ToList$1(Microsoft.Msagl.Core.Layout.Node.ctor, nodes);
        },
        leastSquaresLineFit: function (a, b){
            var mx = 0,my = 0,sx2 = 0,sy2 = 0,sxy = 0,n = this.nodes.get_Count();
            var $it252 = this.nodes.GetEnumerator();
            while ($it252.MoveNext()){
                var v = $it252.get_Current();
                var x = v.get_Center().get_X(),y = v.get_Center().get_Y();
                mx += x;
                my += y;
                sx2 += x * x;
                sy2 += y * y;
                sxy += x * y;
            }
            mx /= n;
            my /= n;
            var B = 0.5 * ((sy2 - n * my * my) - (sx2 - n * mx * mx)) / (n * mx * my - sxy);
            b.Value = System.Math.Sqrt(B * B + 1) - B;
            a.Value = my - b.Value * mx;
        },
        Project: function (){
            var a,b,d = 0;
            (function (){
                var $1 = {
                    Value: a
                };
                var $2 = {
                    Value: b
                };
                var $res = this.leastSquaresLineFit($1, $2);
                a = $1.Value;
                b = $2.Value;
                return $res;
            }).call(this);
            var $it253 = this.nodes.GetEnumerator();
            while ($it253.MoveNext()){
                var v = $it253.get_Current();
                var x0 = v.get_Center().get_X(),y0 = v.get_Center().get_Y();
                var x = (b * y0 + x0) / (b * b + 1);
                var y = a + b * x;
                var p = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x, y);
                d = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v.get_Center(), p)).get_Length();
                v.set_Center(p);
            }
            return d;
        },
        Level$$: "System.Int32",
        get_Level: function (){
            return 1;
        },
        Nodes$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Layout.Node]]",
        get_Nodes: function (){
            return this.nodes;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Prototype$Constraints$AlignmentConstraint);
var Microsoft$Msagl$Miscellaneous$LayoutEditing$BumperPusher = {
    fullname: "Microsoft.Msagl.Miscellaneous.LayoutEditing.BumperPusher",
    baseTypeName: "System.Object",
    staticDefinition: {
        PushByPoint: function (pushed, delPoint){
            pushed.get_UserData().set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Addition(pushed.get_UserData().get_Center(), delPoint));
            var cluster = As(pushed.get_UserData(), Microsoft.Msagl.Core.Layout.Cluster.ctor);
            if (cluster != null)
                cluster.DeepContentsTranslation$$Point$$Boolean(delPoint, true);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (pushedNodes, separation, pushingNodes){
            this.separation = 0;
            this.fixedNodes = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor);
            this.rtree = null;
            this.pushingNodes = null;
            System.Object.ctor.call(this);
            this.separation = separation;
            this.rtree = new Microsoft.Msagl.Core.Geometry.RTree$1.ctor$$RectangleNode$1(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnEnumeration(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, pushedNodes, $CreateAnonymousDelegate(this, function (n){
                return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(Microsoft.Msagl.Core.Layout.Node.ctor, n, this.GetPaddedBoxOfNode(n));
            }))));
            this.pushingNodes = pushingNodes;
        },
        FixedNodes$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Layout.Node]]",
        get_FixedNodes: function (){
            return this.fixedNodes;
        },
        GetPaddedBoxOfNode: function (n){
            var ret = n.get_BoundaryCurve().get_BoundingBox();
            ret.Pad$$Double(this.separation / 2);
            return ret;
        },
        PushNodes: function (){
            this.fixedNodes.Clear();
            this.fixedNodes.InsertRange(this.pushingNodes);
            var q = new System.Collections.Generic.Queue$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Node.ctor, this.pushingNodes);
            var ret = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor);
            while (q.get_Count() > 0){
                var n = q.Dequeue();
                var $it254 = this.PushByNodeAndReportPushedAsFixed(n).GetEnumerator();
                while ($it254.MoveNext()){
                    var node = $it254.get_Current();
                    q.Enqueue(node);
                    this.fixedNodes.Insert(node);
                    ret.Add(node);
                }
            }
            return ret;
        },
        PushByNodeAndReportPushedAsFixed: function (pushingNode){
            var ret = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor);
            var pushingNodeBox = this.GetPaddedBoxOfNode(pushingNode);
            var $it255 = this.rtree.GetAllLeavesIntersectingRectangle(pushingNodeBox).GetEnumerator();
            while ($it255.MoveNext()){
                var rectNode = $it255.get_Current();
                if (this.fixedNodes.Contains$$T(rectNode.get_UserData()))
                    continue;
                if (this.PushNodeAndUpdateRTree(pushingNode, rectNode))
                    ret.Add(rectNode.get_UserData());
            }
            return ret;
        },
        PushNodeAndUpdateRTree: function (pushingNode, pushed){
            var del = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(pushed.get_UserData().get_Center(), pushingNode.get_Center());
            var w = pushingNode.get_Width() / 2 + pushed.get_UserData().get_Width() / 2;
            var h = pushingNode.get_Height() / 2 + pushed.get_UserData().get_Height() / 2;
            var absDelXBetweenCenters = System.Math.Abs$$Double(del.get_X());
            var absDelYBetweenCenters = System.Math.Abs$$Double(del.get_Y());
            var xSep = absDelXBetweenCenters - w;
            var ySep = absDelYBetweenCenters - h;
            if (xSep >= this.separation || ySep >= this.separation)
                return false;
            if (absDelXBetweenCenters >= absDelYBetweenCenters){
                var d = del.get_X() > 0 ? this.separation - xSep : xSep - this.separation;
                this.PushByX(d, pushed);
            }
            else {
                var d = del.get_Y() > 0 ? this.separation - ySep : ySep - this.separation;
                this.PushByY(d, pushed);
            }
            this.UpdateBoundingBoxesOfPushedAndUpParents(pushed);
            return true;
        },
        PushByX: function (del, pushed){
            var delPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(del, 0);
            Microsoft.Msagl.Miscellaneous.LayoutEditing.BumperPusher.PushByPoint(pushed, delPoint);
        },
        PushByY: function (del, pushed){
            var delPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, del);
            Microsoft.Msagl.Miscellaneous.LayoutEditing.BumperPusher.PushByPoint(pushed, delPoint);
        },
        UpdateBoundingBoxesOfPushedAndUpParents: function (pushed){
            pushed.set_Rectangle(this.GetPaddedBoxOfNode(pushed.get_UserData()));
            var parent = pushed.get_Parent();
            while (parent != null){
                parent.set_Rectangle(new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Rectangle$$Rectangle(parent.get_Left().get_Rectangle(), parent.get_Right().get_Rectangle()));
                parent = parent.get_Parent();
            }
        },
        UpdateRTreeByChangedNodeBox: function (cluster, previousBox){
            var rectNode = this.FindClusterNode(cluster, previousBox);
            this.UpdateBoundingBoxesOfPushedAndUpParents(rectNode);
        },
        FindClusterNode: function (cluster, previousBox){
            var node = this.rtree.get_RootNode();
            return this.FindClusterNodeRecurse(node, cluster, previousBox);
        },
        FindClusterNodeRecurse: function (node, cluster, previousBox){
            if (node.get_UserData() != null)
                return node.get_UserData() == cluster ? node : null;
            var n0 = null;
            if (previousBox.Intersects(node.get_Left().get_Rectangle()))
                n0 = this.FindClusterNodeRecurse(node.get_Left(), cluster, previousBox);
            if (n0 != null)
                return n0;
            if (previousBox.Intersects(node.get_Right().get_Rectangle()))
                return this.FindClusterNodeRecurse(node.get_Right(), cluster, previousBox);
            return null;
        },
        FirstPushingNode: function (){
            return this.pushingNodes[0];
        }
    }
};
JsTypes.push(Microsoft$Msagl$Miscellaneous$LayoutEditing$BumperPusher);
var Microsoft$Msagl$Miscellaneous$LayoutEditing$IncrementalDragger = {
    fullname: "Microsoft.Msagl.Miscellaneous.LayoutEditing.IncrementalDragger",
    baseTypeName: "System.Object",
    staticDefinition: {
        DefaultClusterParent: function (n){
            return System.Linq.Enumerable.FirstOrDefault$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, n.get_ClusterParents());
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (pushingNodes, graph, layoutSettings){
            this.nodeSeparation = 0;
            this.layoutSettings = null;
            this.listOfPushers = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Miscellaneous.LayoutEditing.BumperPusher.ctor);
            this.pushingNodesArray = null;
            this.ChangedGraph = null;
            this.labelFixtures = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, Microsoft.Msagl.Miscellaneous.LayoutEditing.LabelFixture.ctor);
            this._graph = null;
            System.Object.ctor.call(this);
            this.set_graph(graph);
            this.nodeSeparation = layoutSettings.get_NodeSeparation();
            this.layoutSettings = layoutSettings;
            this.pushingNodesArray = (pushingNodes instanceof Array ? pushingNodes : null != null ? pushingNodes instanceof Array ? pushingNodes : null : System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Layout.Node.ctor, pushingNodes));
            System.Diagnostics.Debug.Assert$$Boolean$$String(System.Linq.Enumerable.All$1(Microsoft.Msagl.Core.Layout.Node.ctor, this.pushingNodesArray, $CreateAnonymousDelegate(this, function (n){
                return Microsoft.Msagl.Miscellaneous.LayoutEditing.IncrementalDragger.DefaultClusterParent(n) == null;
            })) || (new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Node.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Layout.Cluster.ctor, this.pushingNodesArray, $CreateAnonymousDelegate(this, function (n){
                return System.Linq.Enumerable.First$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, n.get_ClusterParents());
            })))).get_Count() == 1, "dragged nodes have to belong to the same cluster");
            this.InitBumperPushers();
        },
        graph$$: "Microsoft.Msagl.Core.Layout.GeometryGraph",
        get_graph: function (){
            return this._graph;
        },
        set_graph: function (value){
            this._graph = value;
        },
        InitBumperPushers: function (){
            if (this.pushingNodesArray.length == 0)
                return;
            var cluster = Microsoft.Msagl.Miscellaneous.LayoutEditing.IncrementalDragger.DefaultClusterParent(this.pushingNodesArray[0]);
            if (cluster == null)
                this.listOfPushers.Add(new Microsoft.Msagl.Miscellaneous.LayoutEditing.BumperPusher.ctor(this.get_graph().get_Nodes(), this.nodeSeparation, this.pushingNodesArray));
            else {
                this.listOfPushers.Add(new Microsoft.Msagl.Miscellaneous.LayoutEditing.BumperPusher.ctor(System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Layout.Node.ctor, cluster.get_Nodes(), cluster.get_Clusters()), this.nodeSeparation, this.pushingNodesArray));
                do{
                    var pushingCluster = cluster;
                    cluster = Microsoft.Msagl.Miscellaneous.LayoutEditing.IncrementalDragger.DefaultClusterParent(cluster);
                    if (cluster == null)
                        break;
                    this.listOfPushers.Add(new Microsoft.Msagl.Miscellaneous.LayoutEditing.BumperPusher.ctor(System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Layout.Node.ctor, cluster.get_Nodes(), cluster.get_Clusters()), this.nodeSeparation, [pushingCluster]));
                }
                while (true)
            }
        },
        RunPushers: function (){
            for (var i = 0; i < this.listOfPushers.get_Count(); i++){
                var bumperPusher = this.listOfPushers.get_Item$$Int32(i);
                bumperPusher.PushNodes();
                var cluster = Microsoft.Msagl.Miscellaneous.LayoutEditing.IncrementalDragger.DefaultClusterParent(bumperPusher.FirstPushingNode());
                if (cluster == null || cluster == this.get_graph().get_RootCluster())
                    break;
                var box = cluster.get_BoundaryCurve().get_BoundingBox();
                cluster.CalculateBoundsFromChildren(this.layoutSettings.get_ClusterMargin());
                System.Diagnostics.Debug.Assert$$Boolean(System.Linq.Enumerable.All$1(Microsoft.Msagl.Core.Layout.Node.ctor, cluster.get_Nodes(), $CreateAnonymousDelegate(this, function (n){
                    return cluster.get_BoundingBox().Contains$$Rectangle(n.get_BoundingBox());
                })));
                var newBox = cluster.get_BoundaryCurve().get_BoundingBox();
                if (Microsoft.Msagl.Core.Geometry.Rectangle.op_Equality(newBox, box)){
                    break;
                }
                this.listOfPushers.get_Item$$Int32(i + 1).UpdateRTreeByChangedNodeBox(cluster, box);
            }
        },
        Drag: function (delta){
            if (delta.get_Length() > 0)
                for (var $i257 = 0,$t257 = this.pushingNodesArray,$l257 = $t257.length,n = $t257[$i257]; $i257 < $l257; $i257++, n = $t257[$i257]){
                    n.set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Addition(n.get_Center(), delta));
                    var cl = As(n, Microsoft.Msagl.Core.Layout.Cluster.ctor);
                    if (cl != null)
                        cl.DeepContentsTranslation$$Point$$Boolean(delta, true);
                }
            this.RunPushers();
            this.RouteChangedEdges();
        },
        RouteChangedEdges: function (){
            this.ChangedGraph = this.GetChangedFlatGraph();
            var changedClusteredGraph = Microsoft.Msagl.Layout.LargeGraphLayout.LgInteractor.CreateClusteredSubgraphFromFlatGraph(this.ChangedGraph, this.get_graph());
            this.InitLabelFixtures(changedClusteredGraph);
            var router = (function (){
                var $v51 = new Microsoft.Msagl.Routing.SplineRouter.ctor$$GeometryGraph$$Double$$Double$$Double$$BundlingSettings(changedClusteredGraph, this.layoutSettings.get_EdgeRoutingSettings().get_Padding(), this.layoutSettings.get_EdgeRoutingSettings().get_PolylinePadding(), this.layoutSettings.get_EdgeRoutingSettings().get_ConeAngle(), this.layoutSettings.get_EdgeRoutingSettings().get_BundlingSettings());
                $v51.set_ContinueOnOverlaps(true);
                return $v51;
            }).call(this);
            router.Run();
            this.PositionLabels(changedClusteredGraph);
        },
        PositionLabels: function (changedClusteredGraph){
            var $it257 = changedClusteredGraph.get_Edges().GetEnumerator();
            while ($it257.MoveNext()){
                var edge = $it257.get_Current();
                this.PositionEdge(edge);
            }
        },
        PositionEdge: function (edge){
            var lf;
            if (!(function (){
                var $1 = {
                    Value: lf
                };
                var $res = this.labelFixtures.TryGetValue(edge.get_EdgeGeometry(), $1);
                lf = $1.Value;
                return $res;
            }).call(this))
                return;
            var curve = edge.get_Curve();
            var lenAtLabelAttachment = curve.get_Length() * lf.RelativeLengthOnCurve;
            var par = curve.GetParameterAtLength(lenAtLabelAttachment);
            var tang = curve.Derivative(par);
            var norm = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double((lf.RightSide ? tang.Rotate90Cw() : tang.Rotate90Ccw()).Normalize(), lf.NormalLength);
            edge.get_Label().set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Addition(curve.get_Item$$Double(par), norm));
        },
        InitLabelFixtures: function (changedClusteredGraph){
            var $it258 = changedClusteredGraph.get_Edges().GetEnumerator();
            while ($it258.MoveNext()){
                var edge = $it258.get_Current();
                this.InitLabelFixture(edge);
            }
        },
        InitLabelFixture: function (edge){
            if (edge.get_Label() == null)
                return;
            if (this.labelFixtures.ContainsKey(edge.get_EdgeGeometry()))
                return;
            var attachmentPar = edge.get_Curve().ClosestParameter(edge.get_Label().get_Center());
            var curve = edge.get_Curve();
            var tang = curve.Derivative(attachmentPar);
            var normal = tang.Rotate90Cw();
            var fromCurveToLabel = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(edge.get_Label().get_Center(), curve.get_Item$$Double(attachmentPar));
            var fixture = (function (){
                var $v52 = new Microsoft.Msagl.Miscellaneous.LayoutEditing.LabelFixture.ctor();
                $v52.RelativeLengthOnCurve = curve.LengthPartial(0, attachmentPar) / curve.get_Length();
                $v52.NormalLength = fromCurveToLabel.get_Length();
                $v52.RightSide = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(fromCurveToLabel, normal) > 0;
                return $v52;
            }).call(this);
            this.labelFixtures.set_Item$$TKey(edge.get_EdgeGeometry(), fixture);
        },
        GetChangedFlatGraph: function (){
            var changedNodes = this.GetChangedNodes();
            var changedEdges = this.GetChangedEdges(changedNodes);
            var $it259 = changedEdges.GetEnumerator();
            while ($it259.MoveNext()){
                var e = $it259.get_Current();
                changedNodes.Insert(e.get_Source());
                changedNodes.Insert(e.get_Target());
            }
            var changedGraph = (function (){
                var $v53 = new Microsoft.Msagl.Core.Layout.GeometryGraph.ctor();
                $v53.set_Nodes(new Microsoft.Msagl.Layout.LargeGraphLayout.SimpleNodeCollection.ctor(changedNodes));
                $v53.set_Edges(new Microsoft.Msagl.Layout.LargeGraphLayout.SimpleEdgeCollection.ctor(changedEdges));
                return $v53;
            }).call(this);
            return changedGraph;
        },
        GetChangedEdges: function (changedNodes){
            var list = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor);
            var box = Microsoft.Msagl.Core.Geometry.Rectangle.CreateAnEmptyBox();
            var $it260 = changedNodes.GetEnumerator();
            while ($it260.MoveNext()){
                var node = $it260.get_Current();
                box.Add$$Rectangle(node.get_BoundaryCurve().get_BoundingBox());
            }
            var boxPoly = box.Perimeter();
            var $it261 = this.get_graph().get_Edges().GetEnumerator();
            while ($it261.MoveNext()){
                var e = $it261.get_Current();
                if ((function (){
                    var $1 = {
                        Value: box
                    };
                    var $res = this.EdgeNeedsRouting($1, e, boxPoly, changedNodes);
                    box = $1.Value;
                    return $res;
                }).call(this))
                    list.Add(e);
            }
            return list;
        },
        EdgeNeedsRouting: function (box, edge, boxPolyline, changedNodes){
            if (edge.get_Curve() == null)
                return true;
            if (changedNodes.Contains$$T(edge.get_Source()) || changedNodes.Contains$$T(edge.get_Target()))
                return true;
            if (edge.get_Source().get_BoundaryCurve().get_BoundingBox().Intersects(box.Value) || edge.get_Target().get_BoundaryCurve().get_BoundingBox().Intersects(box.Value))
                return true;
            if (!edge.get_BoundingBox().Intersects(box.Value))
                return false;
            return Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveIntersectionOne(boxPolyline, edge.get_Curve(), false) != null;
        },
        GetChangedNodes: function (){
            return new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Node.ctor, System.Linq.Enumerable.SelectMany$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Miscellaneous.LayoutEditing.BumperPusher.ctor, Microsoft.Msagl.Core.Layout.Node.ctor, this.listOfPushers, $CreateAnonymousDelegate(this, function (p){
                return p.get_FixedNodes();
            })));
        }
    }
};
JsTypes.push(Microsoft$Msagl$Miscellaneous$LayoutEditing$IncrementalDragger);
var Microsoft$Msagl$Miscellaneous$LayoutEditing$LabelFixture = {
    fullname: "Microsoft.Msagl.Miscellaneous.LayoutEditing.LabelFixture",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.RelativeLengthOnCurve = 0;
            this.RightSide = false;
            this.NormalLength = 0;
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Miscellaneous$LayoutEditing$LabelFixture);
var Microsoft$Msagl$Miscellaneous$LayoutHelpers = {
    fullname: "Microsoft.Msagl.Miscellaneous.LayoutHelpers",
    baseTypeName: "System.Object",
    staticDefinition: {
        CalculateLayout: function (geometryGraph, settings, cancelToken){
            System.Console.WriteLine$$String("starting CalculateLayout");
            if (Is(settings, Microsoft.Msagl.Prototype.Ranking.RankingLayoutSettings.ctor)){
                var rankingLayoutSettings = As(settings, Microsoft.Msagl.Prototype.Ranking.RankingLayoutSettings.ctor);
                var rankingLayout = new Microsoft.Msagl.Prototype.Ranking.RankingLayout.ctor(rankingLayoutSettings, geometryGraph);
                rankingLayout.Run$$CancelToken(cancelToken);
                Microsoft.Msagl.Miscellaneous.LayoutHelpers.RouteAndLabelEdges(geometryGraph, settings, geometryGraph.get_Edges());
            }
            else if (Is(settings, Microsoft.Msagl.Layout.MDS.MdsLayoutSettings.ctor)){
                var mdsLayoutSettings = As(settings, Microsoft.Msagl.Layout.MDS.MdsLayoutSettings.ctor);
                var mdsLayout = new Microsoft.Msagl.Layout.MDS.MdsGraphLayout.ctor(mdsLayoutSettings, geometryGraph);
                mdsLayout.Run$$CancelToken(cancelToken);
                if (settings.get_EdgeRoutingSettings().get_EdgeRoutingMode() != Microsoft.Msagl.Core.Routing.EdgeRoutingMode.None)
                    Microsoft.Msagl.Miscellaneous.LayoutHelpers.RouteAndLabelEdges(geometryGraph, settings, geometryGraph.get_Edges());
            }
            else if (Is(settings, Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.ctor)){
                var incrementalSettings = As(settings, Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.ctor);
                incrementalSettings.set_AvoidOverlaps(true);
                var initialLayout = new Microsoft.Msagl.Layout.Initial.InitialLayout.ctor(geometryGraph, incrementalSettings);
                initialLayout.Run$$CancelToken(cancelToken);
                if (settings.get_EdgeRoutingSettings().get_EdgeRoutingMode() != Microsoft.Msagl.Core.Routing.EdgeRoutingMode.None)
                    Microsoft.Msagl.Miscellaneous.LayoutHelpers.RouteAndLabelEdges(geometryGraph, settings, geometryGraph.get_Edges());
            }
            else {
                var sugiyamaLayoutSettings = As(settings, Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.ctor);
                if (sugiyamaLayoutSettings != null)
                    Microsoft.Msagl.Miscellaneous.LayoutHelpers.ProcessSugiamaLayout(geometryGraph, sugiyamaLayoutSettings, cancelToken);
                else
                    Microsoft.Msagl.Miscellaneous.LayoutHelpers.InitLargeLayout(geometryGraph, settings, cancelToken);
            }
        },
        InitLargeLayout: function (geometryGraph, settings, cancelToken){
            var largeGraphLayoutSettings = Cast(settings, Microsoft.Msagl.Layout.LargeGraphLayout.LgLayoutSettings.ctor);
            var largeGraphLayout = new Microsoft.Msagl.Layout.LargeGraphLayout.LgInteractor.ctor(geometryGraph, largeGraphLayoutSettings, cancelToken);
            largeGraphLayoutSettings.set_Algorithm(largeGraphLayout);
            largeGraphLayout.Initialize();
        },
        ProcessSugiamaLayout: function (geometryGraph, sugiyamaLayoutSettings, cancelToken){
            var originalTransform;
            var transformIsNotIdentity = (function (){
                var $1 = {
                    Value: originalTransform
                };
                var $res = Microsoft.Msagl.Miscellaneous.LayoutHelpers.HandleTransformIsNotIdentity(geometryGraph, sugiyamaLayoutSettings, $1);
                originalTransform = $1.Value;
                return $res;
            })();
            if (System.Linq.Enumerable.Any$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, geometryGraph.get_RootCluster().get_Clusters())){
                Microsoft.Msagl.Miscellaneous.LayoutHelpers.PrepareGraphForInitialLayoutByCluster(geometryGraph, sugiyamaLayoutSettings);
                var initialBc = new Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.ctor$$GeometryGraph$$Func$2$Cluster$LayoutAlgorithmSettings(geometryGraph, function (a){
                    return sugiyamaLayoutSettings;
                });
                initialBc.Run$$CancelToken(cancelToken);
                Microsoft.Msagl.Miscellaneous.LayoutHelpers.RouteAndLabelEdges(geometryGraph, sugiyamaLayoutSettings, System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Layout.Edge.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, geometryGraph.get_Edges(), function (e){
                    return e.get_Curve() == null;
                })));
            }
            else
                geometryGraph.AlgorithmData = Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.CalculateLayout(geometryGraph, sugiyamaLayoutSettings, cancelToken);
            if (transformIsNotIdentity)
                sugiyamaLayoutSettings.set_Transformation(originalTransform);
            Microsoft.Msagl.Miscellaneous.LayoutHelpers.PostRunTransform(geometryGraph, sugiyamaLayoutSettings);
        },
        HandleTransformIsNotIdentity: function (geometryGraph, sugiyamaLayoutSettings, originalTransform){
            var transformIsNotIdentity = !sugiyamaLayoutSettings.get_Transformation().get_IsIdentity();
            originalTransform.Value = sugiyamaLayoutSettings.get_Transformation();
            if (transformIsNotIdentity){
                var m = sugiyamaLayoutSettings.get_Transformation().get_Inverse();
                var $it262 = geometryGraph.get_Nodes().GetEnumerator();
                while ($it262.MoveNext()){
                    var n = $it262.get_Current();
                    n.Transform(m);
                }
                var $it263 = geometryGraph.get_Edges().GetEnumerator();
                while ($it263.MoveNext()){
                    var e = $it263.get_Current();
                    if (e.get_Label() != null){
                        e.set_OriginalLabelWidth(e.get_Label().get_Width());
                        e.set_OriginalLabelHeight(e.get_Label().get_Height());
                        var r = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(m, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, 0)), Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(m, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(e.get_Label().get_Width(), e.get_Label().get_Height())));
                        e.get_Label().set_Width(r.get_Width());
                        e.get_Label().set_Height(r.get_Height());
                    }
                }
            }
            sugiyamaLayoutSettings.set_Transformation(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.get_UnitTransformation());
            return transformIsNotIdentity;
        },
        PrepareGraphForInitialLayoutByCluster: function (geometryGraph, sugiyamaLayoutSettings){
            var $it264 = geometryGraph.get_RootCluster().AllClustersDepthFirst().GetEnumerator();
            while ($it264.MoveNext()){
                var cluster = $it264.get_Current();
                if (cluster.get_RectangularBoundary() == null)
                    cluster.set_RectangularBoundary((function (){
                        var $v54 = new Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.ctor();
                        $v54.set_TopMargin(10);
                        return $v54;
                    })());
                if (cluster.get_BoundaryCurve() == null){
                    cluster.set_BoundaryCurve(new Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.ctor$$Rectangle$$Double$$Double(new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Double$$Double$$Double$$Double(0, 0, 10, 10), 3, 3));
                }
            }
            var $it265 = geometryGraph.get_Edges().GetEnumerator();
            while ($it265.MoveNext()){
                var edge = $it265.get_Current();
                edge.set_Curve(null);
                if (edge.get_SourcePort() == null){
                    var e = edge;
                    edge.set_SourcePort((function (ed){
                        return new Microsoft.Msagl.Core.Layout.RelativeFloatingPort.ctor$$Func$1$ICurve$$Func$1$Point(function (){
                            return ed.get_Source().get_BoundaryCurve();
                        }, function (){
                            return ed.get_Source().get_Center();
                        });
                    })(e));
                }
                if (edge.get_TargetPort() == null){
                    var e = edge;
                    edge.set_TargetPort((function (ed){
                        return new Microsoft.Msagl.Core.Layout.RelativeFloatingPort.ctor$$Func$1$ICurve$$Func$1$Point(function (){
                            return ed.get_Target().get_BoundaryCurve();
                        }, function (){
                            return ed.get_Target().get_Center();
                        });
                    })(e));
                }
            }
            if (sugiyamaLayoutSettings.get_FallbackLayoutSettings() == null)
                sugiyamaLayoutSettings.set_FallbackLayoutSettings((function (){
                    var $v55 = new Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.ctor();
                    $v55.set_AvoidOverlaps(true);
                    return $v55;
                })());
            Microsoft.Msagl.Miscellaneous.LayoutHelpers.AddOrphanNodesToRootCluster(geometryGraph);
        },
        AddOrphanNodesToRootCluster: function (geometryGraph){
            var clusterNodeSet = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor);
            var $it266 = geometryGraph.get_RootCluster().AllClustersDepthFirst().GetEnumerator();
            while ($it266.MoveNext()){
                var cl = $it266.get_Current();
                clusterNodeSet.InsertRange(cl.get_Nodes());
            }
            var $it267 = geometryGraph.get_Nodes().GetEnumerator();
            while ($it267.MoveNext()){
                var node = $it267.get_Current();
                if (clusterNodeSet.Contains$$T(node))
                    continue;
                geometryGraph.get_RootCluster().AddNode(node);
            }
        },
        RouteAndLabelEdges: function (geometryGraph, layoutSettings, edgesToRoute){
            var filteredEdgesToRoute = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Layout.Edge.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, edgesToRoute, function (e){
                return !e.UnderCollapsedCluster();
            }));
            var ers = layoutSettings.get_EdgeRoutingSettings();
            if (ers.get_EdgeRoutingMode() == Microsoft.Msagl.Core.Routing.EdgeRoutingMode.Rectilinear || ers.get_EdgeRoutingMode() == Microsoft.Msagl.Core.Routing.EdgeRoutingMode.RectilinearToCenter){
                Microsoft.Msagl.Routing.Rectilinear.RectilinearInteractiveEditor.CreatePortsAndRouteEdges$$Double$$Double$$IEnumerable$1$Node$$IEnumerable$1$Edge$$EdgeRoutingMode$$Boolean$$Boolean$$Double(layoutSettings.get_NodeSeparation() / 3, layoutSettings.get_NodeSeparation() / 3, geometryGraph.get_Nodes(), edgesToRoute, ers.get_EdgeRoutingMode(), true, ers.get_UseObstacleRectangles(), ers.get_BendPenalty());
            }
            else if (ers.get_EdgeRoutingMode() == Microsoft.Msagl.Core.Routing.EdgeRoutingMode.Spline || ers.get_EdgeRoutingMode() == Microsoft.Msagl.Core.Routing.EdgeRoutingMode.SugiyamaSplines){
                (function (){
                    var $v56 = new Microsoft.Msagl.Routing.SplineRouter.ctor$$GeometryGraph$$IEnumerable$1$Edge$$Double$$Double$$Double$$BundlingSettings(geometryGraph, filteredEdgesToRoute, ers.get_Padding(), ers.get_PolylinePadding(), ers.get_ConeAngle(), null);
                    $v56.set_ContinueOnOverlaps(true);
                    $v56.set_KeepOriginalSpline(ers.get_KeepOriginalSpline());
                    return $v56;
                })().Run();
            }
            else if (ers.get_EdgeRoutingMode() == Microsoft.Msagl.Core.Routing.EdgeRoutingMode.SplineBundling){
                var edgeBundlingSettings = (ers.get_BundlingSettings() != null ? ers.get_BundlingSettings() : new Microsoft.Msagl.Core.Routing.BundlingSettings.ctor());
                var bundleRouter = (function (){
                    var $v57 = new Microsoft.Msagl.Routing.SplineRouter.ctor$$GeometryGraph$$IEnumerable$1$Edge$$Double$$Double$$Double$$BundlingSettings(geometryGraph, filteredEdgesToRoute, ers.get_Padding(), ers.get_PolylinePadding(), ers.get_ConeAngle(), edgeBundlingSettings);
                    $v57.set_KeepOriginalSpline(ers.get_KeepOriginalSpline());
                    return $v57;
                })();
                bundleRouter.Run();
                if (bundleRouter.get_OverlapsDetected()){
                    (function (){
                        var $v58 = new Microsoft.Msagl.Routing.SplineRouter.ctor$$GeometryGraph$$IEnumerable$1$Edge$$Double$$Double$$Double$$BundlingSettings(geometryGraph, filteredEdgesToRoute, ers.get_Padding(), ers.get_PolylinePadding(), ers.get_ConeAngle(), null);
                        $v58.set_ContinueOnOverlaps(true);
                        $v58.set_KeepOriginalSpline(ers.get_KeepOriginalSpline());
                        return $v58;
                    })().Run();
                }
            }
            else if (ers.get_EdgeRoutingMode() == Microsoft.Msagl.Core.Routing.EdgeRoutingMode.StraightLine){
                var router = new Microsoft.Msagl.Routing.StraightLineEdges.ctor(filteredEdgesToRoute, ers.get_Padding());
                router.Run();
            }
            var elb = new Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.ctor$$IEnumerable$1$Node$$IEnumerable$1$Edge(geometryGraph.get_Nodes(), filteredEdgesToRoute);
            elb.Run();
            geometryGraph.UpdateBoundingBox();
        },
        IncrementalLayout: function (geometryGraph, node, settings){
            if (settings == null)
                return;
            var engine = As(geometryGraph.AlgorithmData, Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.ctor);
            if (engine != null){
                engine.IncrementalRun(node);
                Microsoft.Msagl.Miscellaneous.LayoutHelpers.PostRunTransform(geometryGraph, settings);
            }
        },
        PostRunTransform: function (geometryGraph, settings){
            var transform = !settings.get_Transformation().get_IsIdentity();
            if (transform){
                var $it268 = geometryGraph.get_Nodes().GetEnumerator();
                while ($it268.MoveNext()){
                    var n = $it268.get_Current();
                    n.Transform(settings.get_Transformation());
                }
                var $it269 = geometryGraph.get_RootCluster().get_Clusters().GetEnumerator();
                while ($it269.MoveNext()){
                    var n = $it269.get_Current();
                    n.Transform(settings.get_Transformation());
                    n.get_RectangularBoundary().set_Rect(n.get_BoundaryCurve().get_BoundingBox());
                }
                var $it270 = geometryGraph.get_Edges().GetEnumerator();
                while ($it270.MoveNext()){
                    var e = $it270.get_Current();
                    if (e.get_Label() != null){
                        e.get_Label().set_Width(e.get_OriginalLabelWidth());
                        e.get_Label().set_Height(e.get_OriginalLabelHeight());
                    }
                }
                Microsoft.Msagl.Miscellaneous.LayoutHelpers.TransformCurves(geometryGraph, settings);
            }
            geometryGraph.UpdateBoundingBox();
        },
        TransformCurves: function (geometryGraph, settings){
            var transformation = settings.get_Transformation();
            geometryGraph.set_BoundingBox(new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(transformation, geometryGraph.get_LeftBottom()), Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(transformation, geometryGraph.get_RightTop())));
            var $it271 = geometryGraph.get_Edges().GetEnumerator();
            while ($it271.MoveNext()){
                var e = $it271.get_Current();
                if (e.get_Label() != null)
                    e.get_Label().set_Center(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(transformation, e.get_Label().get_Center()));
                if (e.get_Curve() != null){
                    e.set_Curve(e.get_Curve().Transform(transformation));
                    var eg = e.get_EdgeGeometry();
                    if (eg.get_SourceArrowhead() != null)
                        eg.get_SourceArrowhead().set_TipPosition(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(transformation, eg.get_SourceArrowhead().get_TipPosition()));
                    if (eg.get_TargetArrowhead() != null)
                        eg.get_TargetArrowhead().set_TipPosition(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(transformation, eg.get_TargetArrowhead().get_TipPosition()));
                    Microsoft.Msagl.Miscellaneous.LayoutHelpers.TransformUnderlyingPolyline(e, settings);
                }
            }
        },
        TransformUnderlyingPolyline: function (e, settings){
            if (e.get_UnderlyingPolyline() != null){
                for (var s = e.get_UnderlyingPolyline().get_HeadSite(); s != null; s = s.get_Next()){
                    s.set_Point(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(settings.get_Transformation(), s.get_Point()));
                }
            }
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Miscellaneous$LayoutHelpers);
var Microsoft$Msagl$Prototype$LayoutEditing$EdgeRestoreData = {
    fullname: "Microsoft.Msagl.Prototype.LayoutEditing.EdgeRestoreData",
    baseTypeName: "Microsoft.Msagl.Prototype.LayoutEditing.RestoreData",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (edge){
            this.labelCenter = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._UnderlyingPolyline = null;
            this._Curve = null;
            this._ArrowheadAtSourcePosition = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._ArrowheadAtTargetPosition = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._LabelOffsetFromTheAttachmentPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._LabelAttachmentParameter = 0;
            Microsoft.Msagl.Prototype.LayoutEditing.RestoreData.ctor.call(this);
            if (edge.get_UnderlyingPolyline() == null){
                var asCurve = ((As(edge.get_Curve(), Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor)) != null ? (As(edge.get_Curve(), Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor)) : new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor$$List$1$ICurve((function (){
                    var $v59 = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor);
                    $v59.Add(edge.get_Curve());
                    return $v59;
                }).call(this)));
                edge.set_UnderlyingPolyline(Microsoft.Msagl.Core.Geometry.SmoothedPolyline.FromPoints(System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Geometry.Point.ctor, [edge.get_Source().get_Center()], Microsoft.Msagl.Core.Geometry.Curves.Polyline.PolylineFromCurve(asCurve)), [edge.get_Target().get_Center()])));
            }
            this.set_UnderlyingPolyline(edge.get_UnderlyingPolyline().Clone());
            this.set_Curve(edge.get_Curve().Clone());
            if (edge.get_EdgeGeometry().get_SourceArrowhead() != null)
                this.set_ArrowheadAtSourcePosition(edge.get_EdgeGeometry().get_SourceArrowhead().get_TipPosition());
            if (edge.get_EdgeGeometry().get_TargetArrowhead() != null)
                this.set_ArrowheadAtTargetPosition(edge.get_EdgeGeometry().get_TargetArrowhead().get_TipPosition());
            if (edge.get_Label() != null && edge.get_UnderlyingPolyline() != null){
                this.labelCenter = edge.get_Label().get_Center();
                var untrimmedCurve = edge.get_UnderlyingPolyline().CreateCurve();
                this.set_LabelAttachmentParameter(untrimmedCurve.ClosestParameter(this.labelCenter));
                this.set_LabelOffsetFromTheAttachmentPoint(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.labelCenter, untrimmedCurve.get_Item$$Double(this.get_LabelAttachmentParameter())));
            }
        },
        UnderlyingPolyline$$: "Microsoft.Msagl.Core.Geometry.SmoothedPolyline",
        get_UnderlyingPolyline: function (){
            return this._UnderlyingPolyline;
        },
        set_UnderlyingPolyline: function (value){
            this._UnderlyingPolyline = value;
        },
        LabelCenter$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_LabelCenter: function (){
            return this.labelCenter;
        },
        set_LabelCenter: function (value){
            this.labelCenter = value;
        },
        Curve$$: "Microsoft.Msagl.Core.Geometry.Curves.ICurve",
        get_Curve: function (){
            return this._Curve;
        },
        set_Curve: function (value){
            this._Curve = value;
        },
        ArrowheadAtSourcePosition$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_ArrowheadAtSourcePosition: function (){
            return this._ArrowheadAtSourcePosition;
        },
        set_ArrowheadAtSourcePosition: function (value){
            this._ArrowheadAtSourcePosition = value;
        },
        ArrowheadAtTargetPosition$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_ArrowheadAtTargetPosition: function (){
            return this._ArrowheadAtTargetPosition;
        },
        set_ArrowheadAtTargetPosition: function (value){
            this._ArrowheadAtTargetPosition = value;
        },
        LabelOffsetFromTheAttachmentPoint$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_LabelOffsetFromTheAttachmentPoint: function (){
            return this._LabelOffsetFromTheAttachmentPoint;
        },
        set_LabelOffsetFromTheAttachmentPoint: function (value){
            this._LabelOffsetFromTheAttachmentPoint = value;
        },
        LabelAttachmentParameter$$: "System.Double",
        get_LabelAttachmentParameter: function (){
            return this._LabelAttachmentParameter;
        },
        set_LabelAttachmentParameter: function (value){
            this._LabelAttachmentParameter = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Prototype$LayoutEditing$EdgeRestoreData);
var Microsoft$Msagl$Prototype$LayoutEditing$GraphRestoreData = {
    fullname: "Microsoft.Msagl.Prototype.LayoutEditing.GraphRestoreData",
    baseTypeName: "Microsoft.Msagl.Prototype.LayoutEditing.RestoreData",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            Microsoft.Msagl.Prototype.LayoutEditing.RestoreData.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Prototype$LayoutEditing$GraphRestoreData);
var Microsoft$Msagl$Prototype$LayoutEditing$LabelRestoreData = {
    fullname: "Microsoft.Msagl.Prototype.LayoutEditing.LabelRestoreData",
    baseTypeName: "Microsoft.Msagl.Prototype.LayoutEditing.RestoreData",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (centerP){
            this.center = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            Microsoft.Msagl.Prototype.LayoutEditing.RestoreData.ctor.call(this);
            this.center = centerP;
        },
        Center$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Center: function (){
            return this.center;
        },
        set_Center: function (value){
            this.center = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Prototype$LayoutEditing$LabelRestoreData);
var Microsoft$Msagl$Prototype$LayoutEditing$NodeRestoreData = {
    fullname: "Microsoft.Msagl.Prototype.LayoutEditing.NodeRestoreData",
    baseTypeName: "Microsoft.Msagl.Prototype.LayoutEditing.RestoreData",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (boundaryCurve){
            this.boundaryCurve = null;
            Microsoft.Msagl.Prototype.LayoutEditing.RestoreData.ctor.call(this);
            this.boundaryCurve = boundaryCurve;
        },
        BoundaryCurve$$: "Microsoft.Msagl.Core.Geometry.Curves.ICurve",
        get_BoundaryCurve: function (){
            return this.boundaryCurve;
        },
        set_BoundaryCurve: function (value){
            this.boundaryCurve = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Prototype$LayoutEditing$NodeRestoreData);
var Microsoft$Msagl$Prototype$LayoutEditing$ObstacleCalculator = {
    fullname: "Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator",
    baseTypeName: "System.Object",
    staticDefinition: {
        TraverseHierarchy: function (node, visitor){
            visitor(node);
            if (node.get_Left() != null)
                Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.TraverseHierarchy(node.get_Left(), visitor);
            if (node.get_Right() != null)
                Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.TraverseHierarchy(node.get_Right(), visitor);
        },
        ConnectedComponents: function (overlapGraph){
            var list = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.DataStructures.Set$1.ctor);
            var processedPolylines = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            var $it281 = overlapGraph.get_Nodes().GetEnumerator();
            while ($it281.MoveNext()){
                var poly = $it281.get_Current();
                if (!processedPolylines.Contains$$T(poly)){
                    var component = Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.GetComponent(poly, overlapGraph);
                    if (component.get_Count() > 1)
                        list.Add(component);
                    processedPolylines = Microsoft.Msagl.Core.DataStructures.Set$1.op_Addition(processedPolylines, component);
                }
            }
            return list;
        },
        GetComponent: function (poly, graph){
            var ret = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            ret.Insert(poly);
            var queue = new System.Collections.Generic.Queue$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            queue.Enqueue(poly);
            while (queue.get_Count() > 0){
                var $it282 = graph.Descendents(queue.Dequeue()).GetEnumerator();
                while ($it282.MoveNext()){
                    var p = $it282.get_Current();
                    if (!ret.Contains$$T(p)){
                        queue.Enqueue(p);
                        ret.Insert(p);
                    }
                }
            }
            return ret;
        },
        CreateRectNodeOfPolyline: function (polyline){
            return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, polyline, (As(polyline, Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor)).get_BoundingBox());
        },
        OneCurveLiesInsideOfOther: function (polyA, polyB){
            return (Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(polyA.get_Start(), polyB) != Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside || Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(polyB.get_Start(), polyA) != Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside);
        },
        GetPaddedPolyline: function (closedCurve, padding){
            return Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CreatePaddedPolyline(Microsoft.Msagl.Core.Geometry.Curves.Curve.PolylineAroundClosedCurve(closedCurve), padding);
        },
        TrimCurve: function (curve, u, v){
            System.Diagnostics.Debug.Assert$$Boolean(u >= curve.get_ParStart() && u <= curve.get_ParEnd());
            System.Diagnostics.Debug.Assert$$Boolean(v >= curve.get_ParStart() && v <= curve.get_ParEnd());
            if (u < v)
                return As(curve.Trim(u, v), Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor);
            var c = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor();
            c.AddSegment(As(curve.Trim(u, curve.get_ParEnd()), Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor));
            c.AddSegment(As(curve.Trim(curve.get_ParStart(), v), Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor));
            return c;
        },
        PaddedPolylineBoundaryOfNode: function (node, padding){
            return Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CreatePaddedPolyline(Microsoft.Msagl.Core.Geometry.Curves.Curve.PolylineAroundClosedCurve(node.get_BoundaryCurve()), padding);
        },
        LoosePolylineWithFewCorners: function (tightPolyline, p){
            if (p < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return tightPolyline;
            var loosePolyline = Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.CreateLoosePolylineOnBisectors(tightPolyline, p);
            return loosePolyline;
        },
        CreateLoosePolylineOnBisectors: function (tightPolyline, p){
            var ret = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
            ret.AddPoint$$Point(Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.GetStickingVertexOnBisector(tightPolyline.get_StartPoint(), p));
            var blockingPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            var candidate = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            var justAdded = true;
            for (var pp = tightPolyline.get_StartPoint().get_Next(); pp != null; pp = pp.get_Next()){
                var currentSticking = Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.GetStickingVertexOnBisector(pp, p);
                if (justAdded){
                    blockingPoint = pp.get_Point();
                    candidate = currentSticking;
                    justAdded = false;
                }
                else {
                    if (ret.get_Count() > 1){
                    }
                    if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(ret.get_EndPoint().get_Point(), blockingPoint, currentSticking) != Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise){
                        ret.AddPoint$$Point(candidate);
                        justAdded = true;
                        pp = pp.get_Prev();
                    }
                    else {
                        candidate = currentSticking;
                        if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(ret.get_EndPoint().get_Point(), blockingPoint, pp.get_Point()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise)
                            blockingPoint = pp.get_Point();
                    }
                }
            }
            if (!justAdded){
                if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(ret.get_EndPoint().get_Point(), blockingPoint, ret.get_StartPoint().get_Point()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise){
                    if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(ret.get_EndPoint().get_Point(), blockingPoint, ret.get_StartPoint().get_Next().get_Point()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise)
                        ret.RemoveStartPoint();
                }
                else {
                    ret.AddPoint$$Point(candidate);
                }
            }
            else {
                if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(ret.get_EndPoint().get_Point(), tightPolyline.get_StartPoint().get_Point(), ret.get_StartPoint().get_Next().get_Point()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise)
                    ret.RemoveStartPoint();
                else {
                }
            }
            ret.set_Closed(true);
            return ret;
        },
        GetStickingVertexOnBisector: function (pp, p){
            var u = pp.get_Polyline().Prev(pp).get_Point();
            var v = pp.get_Point();
            var w = pp.get_Polyline().Next(pp).get_Point();
            return Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(p, (Microsoft.Msagl.Core.Geometry.Point.op_Addition((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v, u)).Normalize(), (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v, w)).Normalize())).Normalize()), v);
        },
        CurvesIntersect: function (a, b){
            return Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(a, b, false).get_Count() > 0;
        },
        CurveIntersectsRectangleNode$$ICurve$$RectangleNode$1$Polyline: function (curve, rectNode){
            var boundingBox = curve.get_BoundingBox();
            return (function (){
                var $1 = {
                    Value: boundingBox
                };
                var $res = Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.CurveIntersectsRectangleNode$$ICurve$$Rectangle$$RectangleNode$1$Polyline(curve, $1, rectNode);
                boundingBox = $1.Value;
                return $res;
            })();
        },
        CurveIntersectsRectangleNode$$ICurve$$Rectangle$$RectangleNode$1$Polyline: function (curve, curveBox, rectNode){
            if (!rectNode.get_Rectangle().Intersects(curveBox.Value))
                return false;
            if (rectNode.get_UserData() != null)
                return Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveIntersectionOne(rectNode.get_UserData(), curve, false) != null || Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.Inside(rectNode.get_UserData(), curve);
            System.Diagnostics.Debug.Assert$$Boolean(rectNode.get_Left() != null && rectNode.get_Right() != null);
            return Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.CurveIntersectsRectangleNode$$ICurve$$Rectangle$$RectangleNode$1$Polyline(curve, curveBox, rectNode.get_Left()) || Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.CurveIntersectsRectangleNode$$ICurve$$Rectangle$$RectangleNode$1$Polyline(curve, curveBox, rectNode.get_Right());
        },
        Inside: function (curveUnderTest, curve){
            return Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(curve.get_Start(), curveUnderTest) == Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Inside;
        },
        CurveIntersectsRectangleNode$$Polyline$$RectangleNode$1$Polyline$$Polyline: function (quadrilateral, rectangleNode, polylineToIgnore){
            var boundingBox = quadrilateral.get_BoundingBox();
            return (function (){
                var $1 = {
                    Value: boundingBox
                };
                var $res = Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.CurveIntersectsRectangleNode$$ICurve$$Rectangle$$RectangleNode$1$Polyline$$Polyline(quadrilateral, $1, rectangleNode, polylineToIgnore);
                boundingBox = $1.Value;
                return $res;
            })();
        },
        CurveIntersectsRectangleNode$$ICurve$$Rectangle$$RectangleNode$1$Polyline$$Polyline: function (curve, curveBox, rectNode, polylineToIgnore){
            if (!rectNode.get_Rectangle().Intersects(curveBox.Value))
                return false;
            if (rectNode.get_UserData() != null)
                return rectNode.get_UserData() != polylineToIgnore && (Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveIntersectionOne(rectNode.get_UserData(), curve, false) != null || Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.Inside(rectNode.get_UserData(), curve));
            System.Diagnostics.Debug.Assert$$Boolean(rectNode.get_Left() != null && rectNode.get_Right() != null);
            return Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.CurveIntersectsRectangleNode$$ICurve$$Rectangle$$RectangleNode$1$Polyline$$Polyline(curve, curveBox, rectNode.get_Left(), polylineToIgnore) || Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.CurveIntersectsRectangleNode$$ICurve$$Rectangle$$RectangleNode$1$Polyline$$Polyline(curve, curveBox, rectNode.get_Right(), polylineToIgnore);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (router){
            this.looseObstacles = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            this.portObstacles = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor);
            this.rootOfLooseHierarchy = null;
            this.rootOfTightHierarachy = null;
            this.router = null;
            this.sourceFilterLine = null;
            this.targetFilterLine = null;
            this.tightObstacles = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            System.Object.ctor.call(this);
            this.router = router;
        },
        TightObstacles$$: "Microsoft.Msagl.Core.DataStructures.Set`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]",
        get_TightObstacles: function (){
            return this.tightObstacles;
        },
        LooseObstacles$$: "System.Collections.Generic.List`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]",
        get_LooseObstacles: function (){
            return this.looseObstacles;
        },
        RootOfTightHierararchy$$: "Microsoft.Msagl.Core.Geometry.RectangleNode`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]",
        get_RootOfTightHierararchy: function (){
            return this.rootOfTightHierarachy;
        },
        set_RootOfTightHierararchy: function (value){
            this.rootOfTightHierarachy = value;
        },
        RootOfLooseHierarchy$$: "Microsoft.Msagl.Core.Geometry.RectangleNode`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]",
        get_RootOfLooseHierarchy: function (){
            return this.rootOfLooseHierarchy;
        },
        set_RootOfLooseHierarchy: function (value){
            this.rootOfLooseHierarchy = value;
        },
        SourceFilterLine$$: "Microsoft.Msagl.Core.Geometry.Curves.LineSegment",
        get_SourceFilterLine: function (){
            return this.sourceFilterLine;
        },
        TargetFilterLine$$: "Microsoft.Msagl.Core.Geometry.Curves.LineSegment",
        get_TargetFilterLine: function (){
            return this.targetFilterLine;
        },
        EnteringAngle$$: "System.Double",
        get_EnteringAngle: function (){
            return this.router.get_EnteringAngleBound() * 3.14159265358979 / 180;
        },
        Calculate: function (){
            this.CreateTightObstacles();
            this.CreateLooseObstacles();
        },
        CreateLooseObstacles: function (){
            this.set_RootOfLooseHierarchy(this.get_RootOfTightHierararchy().Clone());
            Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.TraverseHierarchy(this.get_RootOfLooseHierarchy(), $CreateAnonymousDelegate(this, function (node){
                if (node.get_UserData() != null){
                    var tightPolyline = node.get_UserData();
                    var distance = this.FindMaxPaddingForTightPolyline(tightPolyline);
                    this.get_LooseObstacles().Add(node.set_UserData(Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.LoosePolylineWithFewCorners(tightPolyline, System.Math.Min$$Double$$Double(this.router.get_LoosePadding(), distance * 0.3))));
                    node.set_Rectangle(node.get_UserData().get_BoundingBox());
                    Microsoft.Msagl.Routing.InteractiveObstacleCalculator.UpdateRectsForParents(node);
                }
            }));
        },
        CreateTightObstacles: function (){
            this.CreateInitialTightObstacles();
            var overlappingPolylineSets;
            do{
                this.RemoveTightObstaclesOverlappingPortTightObstacles();
                this.CalculateTightHierarchy();
                overlappingPolylineSets = this.GetOverlappingSets();
                var $it272 = overlappingPolylineSets.GetEnumerator();
                while ($it272.MoveNext()){
                    var overlappingSet = $it272.get_Current();
                    this.InsertOverlappingSet(overlappingSet);
                }
            }
            while (overlappingPolylineSets.get_Count() > 0)
        },
        RemoveTightObstaclesOverlappingPortTightObstacles: function (){
            var toRemove = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            var $it273 = this.TightObstaclesMinusPortObstacles().GetEnumerator();
            while ($it273.MoveNext()){
                var poly = $it273.get_Current();
                var $it274 = this.portObstacles.GetEnumerator();
                while ($it274.MoveNext()){
                    var portObstacle = $it274.get_Current();
                    if (poly.get_BoundingBox().Intersects(portObstacle.get_BoundingBox()))if (Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(poly, portObstacle, false).get_Count() > 0 || Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.OneCurveLiesInsideOfOther(poly, portObstacle))
                        toRemove.Add(poly);
                }
            }
            var $it275 = toRemove.GetEnumerator();
            while ($it275.MoveNext()){
                var poly = $it275.get_Current();
                this.get_TightObstacles().Remove(poly);
            }
        },
        TightObstaclesMinusPortObstacles: function (){
            var $yield = [];
            var $it276 = this.get_TightObstacles().GetEnumerator();
            while ($it276.MoveNext()){
                var p = $it276.get_Current();
                if (this.portObstacles.Contains$$T(p) == false)
                    $yield.push(p);
            }
            return $yield;
        },
        InsertOverlappingSet: function (overlappingSet){
            var $it277 = overlappingSet.GetEnumerator();
            while ($it277.MoveNext()){
                var p = $it277.get_Current();
                this.tightObstacles.Remove(p);
            }
            var hull = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
            var $it278 = Microsoft.Msagl.Core.Geometry.ConvexHull.CalculateConvexHull(this.EnumerateOverSetOfPolylines(overlappingSet)).GetEnumerator();
            while ($it278.MoveNext()){
                var p = $it278.get_Current();
                hull.AddPoint$$Point(p);
            }
            hull.set_Closed(true);
            this.tightObstacles.Insert(hull);
        },
        EnumerateOverSetOfPolylines: function (pp){
            var $yield = [];
            var $it279 = pp.GetEnumerator();
            while ($it279.MoveNext()){
                var poly = $it279.get_Current();
                var $it280 = poly.GetEnumerator();
                while ($it280.MoveNext()){
                    var p = $it280.get_Current();
                    $yield.push(p);
                }
            }
            return $yield;
        },
        GetOverlappingSets: function (){
            var overlapGraph = this.CalculateOverlapGraph();
            return Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.ConnectedComponents(overlapGraph);
        },
        CalculateOverlapGraph: function (){
            var graph = new Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.PolylineGraph.ctor();
            this.CreateEdgesUnderTwoNodes(this.rootOfTightHierarachy, this.rootOfTightHierarachy, graph);
            return graph;
        },
        CalculateTightHierarchy: function (){
            var rectNodes = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor);
            var $it283 = this.get_TightObstacles().GetEnumerator();
            while ($it283.MoveNext()){
                var polyline = $it283.get_Current();
                rectNodes.Add(Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.CreateRectNodeOfPolyline(polyline));
            }
            this.set_RootOfTightHierararchy(Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnListOfNodes(rectNodes));
        },
        CreateEdgesUnderTwoNodes: function (a, b, overlapGraph){
            System.Diagnostics.Debug.Assert$$Boolean((a.get_UserData() == null && a.get_Left() != null && a.get_Right() != null) || (a.get_UserData() != null && a.get_Left() == null && a.get_Right() == null));
            System.Diagnostics.Debug.Assert$$Boolean((b.get_UserData() == null && b.get_Left() != null && b.get_Right() != null) || (b.get_UserData() != null && b.get_Left() == null && b.get_Right() == null));
            if (a.get_Rectangle().Intersects(b.get_Rectangle())){
                if (a.get_UserData() != null){
                    if (b.get_UserData() != null){
                        if (a.get_UserData() != b.get_UserData())if (Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(a.get_UserData(), b.get_UserData(), false).get_Count() > 0 || Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.OneCurveLiesInsideOfOther(a.get_UserData(), b.get_UserData())){
                            overlapGraph.AddEdge(a.get_UserData(), b.get_UserData());
                            overlapGraph.AddEdge(b.get_UserData(), a.get_UserData());
                        }
                    }
                    else {
                        this.CreateEdgesUnderTwoNodes(a, b.get_Left(), overlapGraph);
                        this.CreateEdgesUnderTwoNodes(a, b.get_Right(), overlapGraph);
                    }
                }
                else if (b.get_UserData() != null){
                    this.CreateEdgesUnderTwoNodes(b, a.get_Left(), overlapGraph);
                    this.CreateEdgesUnderTwoNodes(b, a.get_Right(), overlapGraph);
                }
                else {
                    this.CreateEdgesUnderTwoNodes(a.get_Left(), b.get_Left(), overlapGraph);
                    this.CreateEdgesUnderTwoNodes(a.get_Left(), b.get_Right(), overlapGraph);
                    this.CreateEdgesUnderTwoNodes(a.get_Right(), b.get_Left(), overlapGraph);
                    this.CreateEdgesUnderTwoNodes(a.get_Right(), b.get_Right(), overlapGraph);
                }
            }
        },
        CreateInitialTightObstacles: function (){
            this.tightObstacles = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            var $it284 = this.router.get_Graph().get_Nodes().GetEnumerator();
            while ($it284.MoveNext()){
                var node = $it284.get_Current();
                if (node == this.router.get_Source())
                    (function (){
                        var $1 = {
                            Value: this.sourceFilterLine
                        };
                        var $res = this.CreatePortObstacles(this.router.get_Source(), this.router.get_SourcePort(), $1);
                        this.sourceFilterLine = $1.Value;
                        return $res;
                    }).call(this);
                else if (node == this.router.get_Target())
                    (function (){
                        var $1 = {
                            Value: this.targetFilterLine
                        };
                        var $res = this.CreatePortObstacles(this.router.get_Target(), this.router.get_TargetPort(), $1);
                        this.targetFilterLine = $1.Value;
                        return $res;
                    }).call(this);
                else {
                    this.get_TightObstacles().Insert(Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.PaddedPolylineBoundaryOfNode(node, this.router.get_Padding()));
                }
            }
        },
        CreatePortObstacles: function (node, port, filterLine){
            var bp = As(port, Microsoft.Msagl.Core.Layout.CurvePort.ctor);
            if (bp != null){
                var padding = this.router.get_Padding();
                var closedCurve = node.get_BoundaryCurve();
                var paddingCurve = Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.GetPaddedPolyline(closedCurve, padding).ToCurve();
                var portPoint = node.get_BoundaryCurve().get_Item$$Double(bp.get_Parameter());
                var length = node.get_BoundaryCurve().get_BoundingBox().get_Width() + node.get_BoundaryCurve().get_BoundingBox().get_Height();
                var leftTipPar = this.GetLeftTipParam(bp.get_Parameter(), portPoint, paddingCurve, node, length);
                var rightTipPar = this.GetRightTipParam(bp.get_Parameter(), portPoint, paddingCurve, node, length);
                paddingCurve = Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.TrimCurve(paddingCurve, rightTipPar, leftTipPar);
                var n = (paddingCurve.get_Segments().get_Count() / 2) | 0;
                System.Diagnostics.Debug.Assert$$Boolean(n > 0);
                var rightChunk = Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.TrimCurve(paddingCurve, 0, n);
                var leftChunk = Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.TrimCurve(paddingCurve, n + 0.8, paddingCurve.get_ParEnd());
                filterLine.Value = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(0.5, (Microsoft.Msagl.Core.Geometry.Point.op_Addition(leftChunk.get_Start(), leftChunk.get_End()))), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(0.5, (Microsoft.Msagl.Core.Geometry.Point.op_Addition(rightChunk.get_Start(), rightChunk.get_End()))));
                var pol = Microsoft.Msagl.Core.Geometry.Curves.Polyline.PolylineFromCurve(leftChunk);
                pol.set_Closed(true);
                this.portObstacles.Insert(pol);
                this.get_TightObstacles().Insert(pol);
                pol = Microsoft.Msagl.Core.Geometry.Curves.Polyline.PolylineFromCurve(rightChunk);
                pol.set_Closed(true);
                this.portObstacles.Insert(pol);
                this.get_TightObstacles().Insert(pol);
            }
            else {
                filterLine.Value = null;
                this.portObstacles.Insert(node.get_BoundaryCurve());
            }
        },
        GetRightTipParam: function (portParam, portPoint, paddingCurve, node, length){
            var curveIsClockwise = Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CurveIsClockwise(node.get_BoundaryCurve(), node.get_Center());
            var tan = curveIsClockwise ? node.get_BoundaryCurve().RightDerivative(portParam) : Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(node.get_BoundaryCurve().LeftDerivative(portParam));
            tan = (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(tan.Normalize(), length)).Rotate(this.get_EnteringAngle());
            var xs = Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(paddingCurve, new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(portPoint, Microsoft.Msagl.Core.Geometry.Point.op_Addition(portPoint, tan)), true);
            System.Diagnostics.Debug.Assert$$Boolean(xs.get_Count() == 1);
            return xs.get_Item$$Int32(0).get_Par0();
        },
        GetLeftTipParam: function (portParam, portPoint, paddingCurve, node, length){
            var curveIsClockwise = Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CurveIsClockwise(node.get_BoundaryCurve(), node.get_Center());
            var tan = curveIsClockwise ? node.get_BoundaryCurve().LeftDerivative(portParam) : Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(node.get_BoundaryCurve().RightDerivative(portParam));
            tan = (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(tan.Normalize())), length)).Rotate(-this.get_EnteringAngle());
            var xs = Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(paddingCurve, new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(portPoint, Microsoft.Msagl.Core.Geometry.Point.op_Addition(portPoint, tan)), true);
            System.Diagnostics.Debug.Assert$$Boolean(xs.get_Count() == 1);
            return xs.get_Item$$Int32(0).get_Par0();
        },
        FindMaxPaddingForTightPolyline: function (polyline){
            var dist = 1.79769313486232E+308;
            var polygon = new Microsoft.Msagl.Routing.Visibility.Polygon.ctor(polyline);
            var $it285 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, this.get_RootOfLooseHierarchy().GetAllLeaves(), $CreateAnonymousDelegate(this, function (p){
                return p != polyline;
            })).GetEnumerator();
            while ($it285.MoveNext()){
                var poly = $it285.get_Current();
                dist = System.Math.Min$$Double$$Double(dist, Microsoft.Msagl.Routing.Visibility.Polygon.Distance$$Polygon$$Polygon(polygon, new Microsoft.Msagl.Routing.Visibility.Polygon.ctor(poly)));
            }
            dist = System.Math.Min$$Double$$Double(dist, Microsoft.Msagl.Prototype.LayoutEditing.RouterBetweenTwoNodes.DistanceFromPointToPolyline(this.router.get_SourcePoint(), polyline));
            dist = System.Math.Min$$Double$$Double(dist, Microsoft.Msagl.Prototype.LayoutEditing.RouterBetweenTwoNodes.DistanceFromPointToPolyline(this.router.get_TargetPoint(), polyline));
            return dist;
        },
        ObstaclesIntersectLine: function (a, b){
            return this.ObstaclesIntersectICurve(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(a, b));
        },
        ObstaclesIntersectICurve: function (curve){
            return Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.CurveIntersectsRectangleNode$$ICurve$$RectangleNode$1$Polyline(curve, this.get_RootOfTightHierararchy()) || (this.get_SourceFilterLine() != null && Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.CurvesIntersect(curve, this.get_SourceFilterLine())) || (this.get_TargetFilterLine() != null && Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.CurvesIntersect(curve, this.get_TargetFilterLine()));
        }
    }
};
JsTypes.push(Microsoft$Msagl$Prototype$LayoutEditing$ObstacleCalculator);
var Microsoft$Msagl$Prototype$LayoutEditing$ObstacleCalculator$Visitor = {
    fullname: "Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.Visitor",
    Kind: "Delegate",
    definition: {
        ctor: function (obj, func){
            System.MulticastDelegate.ctor.call(this, obj, func);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Prototype$LayoutEditing$ObstacleCalculator$Visitor);
var Microsoft$Msagl$Prototype$LayoutEditing$ObstacleCalculator$PolylineGraph = {
    fullname: "Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.PolylineGraph",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.sourceToTargets = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, System.Collections.Generic.List$1.ctor);
            System.Object.ctor.call(this);
        },
        Nodes$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]",
        get_Nodes: function (){
            return this.sourceToTargets.get_Keys();
        },
        AddEdge: function (source, target){
            var listOfEdges;
            if (!(function (){
                var $1 = {
                    Value: listOfEdges
                };
                var $res = this.sourceToTargets.TryGetValue(source, $1);
                listOfEdges = $1.Value;
                return $res;
            }).call(this)){
                this.sourceToTargets.set_Item$$TKey(source, listOfEdges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor));
            }
            listOfEdges.Add(target);
        },
        Descendents: function (Polyline){
            return this.sourceToTargets.get_Item$$TKey(Polyline);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Prototype$LayoutEditing$ObstacleCalculator$PolylineGraph);
var Microsoft$Msagl$Prototype$LayoutEditing$RestoreData = {
    fullname: "Microsoft.Msagl.Prototype.LayoutEditing.RestoreData",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.Action = null;
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Prototype$LayoutEditing$RestoreData);
var Microsoft$Msagl$Prototype$LayoutEditing$RestoreHelper = {
    fullname: "Microsoft.Msagl.Prototype.LayoutEditing.RestoreHelper",
    baseTypeName: "System.Object",
    staticDefinition: {
        GetRestoreData$$Node: function (node){
            return new Microsoft.Msagl.Prototype.LayoutEditing.NodeRestoreData.ctor(node.get_BoundaryCurve().Clone());
        },
        GetRestoreData$$Edge: function (edge){
            return new Microsoft.Msagl.Prototype.LayoutEditing.EdgeRestoreData.ctor(edge);
        },
        GetRestoreData$$GeometryGraph: function (graph){
            return new Microsoft.Msagl.Prototype.LayoutEditing.GraphRestoreData.ctor();
        },
        GetRestoreData$$Label: function (label){
            return new Microsoft.Msagl.Prototype.LayoutEditing.LabelRestoreData.ctor(label.get_Center());
        },
        GetRestoreData$$GeometryObject: function (geometryObject){
            var node = As(geometryObject, Microsoft.Msagl.Core.Layout.Node.ctor);
            if (node != null){
                return Microsoft.Msagl.Prototype.LayoutEditing.RestoreHelper.GetRestoreData$$Node(node);
            }
            var edge = As(geometryObject, Microsoft.Msagl.Core.Layout.Edge.ctor);
            if (edge != null){
                return Microsoft.Msagl.Prototype.LayoutEditing.RestoreHelper.GetRestoreData$$Edge(edge);
            }
            var label = As(geometryObject, Microsoft.Msagl.Core.Layout.Label.ctor);
            if (label != null){
                return Microsoft.Msagl.Prototype.LayoutEditing.RestoreHelper.GetRestoreData$$Label(label);
            }
            var graph = As(geometryObject, Microsoft.Msagl.Core.Layout.GeometryGraph.ctor);
            if (graph != null){
                return Microsoft.Msagl.Prototype.LayoutEditing.RestoreHelper.GetRestoreData$$GeometryGraph(graph);
            }
            return null;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Prototype$LayoutEditing$RestoreHelper);
var Microsoft$Msagl$Prototype$LayoutEditing$RouterBetweenTwoNodes = {
    fullname: "Microsoft.Msagl.Prototype.LayoutEditing.RouterBetweenTwoNodes",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Prototype.LayoutEditing.RouterBetweenTwoNodes.enteringAngleBound = 10;
        },
        DistanceFromPointToPolyline: function (p, poly){
            var d = Infinity;
            var u;
            for (var pp = poly.get_StartPoint(); pp.get_Next() != null; pp = pp.get_Next())
                d = System.Math.Min$$Double$$Double(d, (function (){
                    var $1 = {
                        Value: u
                    };
                    var $res = Microsoft.Msagl.Core.Geometry.Point.DistToLineSegment(p, pp.get_Point(), pp.get_Next().get_Point(), $1);
                    u = $1.Value;
                    return $res;
                })());
            return d;
        },
        CreateRelaxedPolylinePoints: function (polyline){
            var p = polyline.get_StartPoint();
            var ret = new Microsoft.Msagl.Routing.RelaxedPolylinePoint.ctor(p, p.get_Point());
            var currentRelaxed = ret;
            while (p.get_Next() != null){
                p = p.get_Next();
                var r = (function (){
                    var $v60 = new Microsoft.Msagl.Routing.RelaxedPolylinePoint.ctor(p, p.get_Point());
                    $v60.set_Prev(currentRelaxed);
                    return $v60;
                })();
                currentRelaxed.set_Next(r);
                currentRelaxed = r;
            }
            return ret;
        },
        PullCloserRelaxedPoint: function (relaxedPolylinePoint){
            relaxedPolylinePoint.get_PolylinePoint().set_Point(Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(0.2, relaxedPolylinePoint.get_OriginalPosition()), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(0.8, relaxedPolylinePoint.get_PolylinePoint().get_Point())));
        },
        LineIntersectsRectangleNode: function (ls, rectNode){
            if (!ls.get_BoundingBox().Intersects(rectNode.get_Rectangle()))
                return false;
            if (rectNode.get_UserData() != null){
                return Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(rectNode.get_UserData(), ls, false).get_Count() > 0;
            }
            return Microsoft.Msagl.Prototype.LayoutEditing.RouterBetweenTwoNodes.LineIntersectsRectangleNode(ls, rectNode.get_Left()) || Microsoft.Msagl.Prototype.LayoutEditing.RouterBetweenTwoNodes.LineIntersectsRectangleNode(ls, rectNode.get_Right());
        },
        SetRelaxedPointLocation: function (offset, relaxedPoint){
            var leftTurn = Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(relaxedPoint.get_Next().get_OriginalPosition(), relaxedPoint.get_OriginalPosition(), relaxedPoint.get_Prev().get_OriginalPosition()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise;
            var v = (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(relaxedPoint.get_Next().get_OriginalPosition(), relaxedPoint.get_Prev().get_OriginalPosition())).Normalize(), offset)).Rotate(1.5707963267949);
            if (!leftTurn)
                v = Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(v);
            relaxedPoint.get_PolylinePoint().set_Point(Microsoft.Msagl.Core.Geometry.Point.op_Addition(relaxedPoint.get_OriginalPosition(), v));
        },
        RemoveCollinearPoint: function (ret){
            for (var pp = ret.get_StartPoint().get_Next(); pp.get_Next() != null; pp = pp.get_Next())
                if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(pp.get_Prev().get_Point(), pp.get_Point(), pp.get_Next().get_Point()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Collinear){
                    pp.get_Prev().set_Next(pp.get_Next());
                    pp.get_Next().set_Prev(pp.get_Prev());
                }
            return ret;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (graph, minimalPadding, maximalPadding, offsetForRelaxing){
            this.pointsToObstacles = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            this._visGraph = null;
            this.obstacleCalculator = null;
            this.minimalPadding = 1;
            this.graph = null;
            this.sourceVisibilityVertex = null;
            this.targetVisibilityVertex = null;
            this._SourcePort = null;
            this._TargetPort = null;
            this._LoosePadding = 0;
            this._Target = null;
            this._Source = null;
            this._Polyline = null;
            this._OffsetForPolylineRelaxing = 0;
            System.Object.ctor.call(this);
            this.graph = graph;
            this.set_LoosePadding(maximalPadding);
            this.set_Padding(minimalPadding);
            this.set_OffsetForPolylineRelaxing(offsetForRelaxing);
        },
        SourcePort$$: "Microsoft.Msagl.Core.Layout.Port",
        get_SourcePort: function (){
            return this._SourcePort;
        },
        set_SourcePort: function (value){
            this._SourcePort = value;
        },
        TargetPort$$: "Microsoft.Msagl.Core.Layout.Port",
        get_TargetPort: function (){
            return this._TargetPort;
        },
        set_TargetPort: function (value){
            this._TargetPort = value;
        },
        EnteringAngleBound$$: "System.Double",
        get_EnteringAngleBound: function (){
            return 10;
        },
        Padding$$: "System.Double",
        get_Padding: function (){
            return this.minimalPadding;
        },
        set_Padding: function (value){
            this.minimalPadding = value;
        },
        LoosePadding$$: "System.Double",
        get_LoosePadding: function (){
            return this._LoosePadding;
        },
        set_LoosePadding: function (value){
            this._LoosePadding = value;
        },
        Target$$: "Microsoft.Msagl.Core.Layout.Node",
        get_Target: function (){
            return this._Target;
        },
        set_Target: function (value){
            this._Target = value;
        },
        TargetVisibilityVertex$$: "Microsoft.Msagl.Routing.Visibility.VisibilityVertex",
        get_TargetVisibilityVertex: function (){
            return this.targetVisibilityVertex;
        },
        Source$$: "Microsoft.Msagl.Core.Layout.Node",
        get_Source: function (){
            return this._Source;
        },
        set_Source: function (value){
            this._Source = value;
        },
        Graph$$: "Microsoft.Msagl.Core.Layout.GeometryGraph",
        get_Graph: function (){
            return this.graph;
        },
        Polyline$$: "Microsoft.Msagl.Core.Geometry.Curves.Polyline",
        get_Polyline: function (){
            return this._Polyline;
        },
        set_Polyline: function (value){
            this._Polyline = value;
        },
        OffsetForPolylineRelaxing$$: "System.Double",
        get_OffsetForPolylineRelaxing: function (){
            return this._OffsetForPolylineRelaxing;
        },
        set_OffsetForPolylineRelaxing: function (value){
            this._OffsetForPolylineRelaxing = value;
        },
        RouteEdge: function (edge, takeYourTime){
            this.set_Source(edge.get_Source());
            this.set_Target(edge.get_Target());
            this.set_SourcePort(edge.get_SourcePort());
            this.set_TargetPort(edge.get_TargetPort());
            this.CalculateObstacles();
            var lineSeg = this.TryRouteStraightLine();
            if (lineSeg != null){
                this.set_Polyline(new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor$$Point$$Point(lineSeg.get_Start(), lineSeg.get_End()));
                edge.set_UnderlyingPolyline(Microsoft.Msagl.Core.Geometry.SmoothedPolyline.FromPoints(this.get_Polyline()));
            }
            else {
                this.CalculateTangentVisibilityGraph();
                this.set_Polyline(this.GetShortestPolyline());
                this.RelaxPolyline();
                edge.set_UnderlyingPolyline(Microsoft.Msagl.Core.Geometry.SmoothedPolyline.FromPoints(this.get_Polyline()));
                if (takeYourTime){
                    this.TryToRemoveInflectionsAndCollinearSegs(edge.get_UnderlyingPolyline());
                    this.SmoothCorners(edge.get_UnderlyingPolyline());
                }
            }
            edge.set_Curve(edge.get_UnderlyingPolyline().CreateCurve());
        },
        RelaxPolyline: function (){
            var relaxedPolylinePoint = Microsoft.Msagl.Prototype.LayoutEditing.RouterBetweenTwoNodes.CreateRelaxedPolylinePoints(this.get_Polyline());
            for (relaxedPolylinePoint = relaxedPolylinePoint.get_Next(); relaxedPolylinePoint.get_Next() != null; relaxedPolylinePoint = relaxedPolylinePoint.get_Next())
                this.RelaxPolylinePoint(relaxedPolylinePoint);
        },
        RelaxPolylinePoint: function (relaxedPoint){
            for (var d = this.get_OffsetForPolylineRelaxing(); !this.RelaxWithGivenOffset(d, relaxedPoint); d /= 2){
            }
        },
        RelaxWithGivenOffset: function (offset, relaxedPoint){
            Microsoft.Msagl.Prototype.LayoutEditing.RouterBetweenTwoNodes.SetRelaxedPointLocation(offset, relaxedPoint);
            if (this.StickingSegmentDoesNotIntersectTightObstacles(relaxedPoint))
                return true;
            Microsoft.Msagl.Prototype.LayoutEditing.RouterBetweenTwoNodes.PullCloserRelaxedPoint(relaxedPoint.get_Prev());
            return false;
        },
        StickingSegmentDoesNotIntersectTightObstacles: function (relaxedPoint){
            return !this.LineIntersectsTightObstacles(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(relaxedPoint.get_PolylinePoint().get_Point(), relaxedPoint.get_Prev().get_PolylinePoint().get_Point())) && (relaxedPoint.get_Next() == null || !this.LineIntersectsTightObstacles(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(relaxedPoint.get_PolylinePoint().get_Point(), relaxedPoint.get_Next().get_PolylinePoint().get_Point())));
        },
        LineIntersectsTightObstacles: function (ls){
            return Microsoft.Msagl.Prototype.LayoutEditing.RouterBetweenTwoNodes.LineIntersectsRectangleNode(ls, this.obstacleCalculator.get_RootOfTightHierararchy());
        },
        SmoothCorners: function (edgePolyline){
            var a = edgePolyline.get_HeadSite();
            var b;
            var c;
            var mult = 1.5;
            while ((function (){
                var $1 = {
                    Value: b
                };
                var $2 = {
                    Value: c
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.FindCorner(a, $1, $2);
                b = $1.Value;
                c = $2.Value;
                return $res;
            }).call(this)){
                var k = 0.5;
                var seg;
                var u,v;
                if (a.get_Previous() == null){
                    u = 2;
                    v = 1;
                }
                else if (c.get_Next() == null){
                    u = 1;
                    v = 2;
                }
                else {
                    u = v = 1;
                }
                do{
                    seg = Microsoft.Msagl.Core.Geometry.Curves.Curve.CreateBezierSeg$$Double$$Double$$Site$$Site$$Site(k * u, k * v, a, b, c);
                    b.set_PreviousBezierSegmentFitCoefficient(k * u);
                    b.set_NextBezierSegmentFitCoefficient(k * v);
                    k /= mult;
                }
                while (this.obstacleCalculator.ObstaclesIntersectICurve(seg))
                k *= mult;
                if (k < 0.5){
                    k = 0.5 * (k + k * mult);
                    seg = Microsoft.Msagl.Core.Geometry.Curves.Curve.CreateBezierSeg$$Double$$Double$$Site$$Site$$Site(k * u, k * v, a, b, c);
                    if (!this.obstacleCalculator.ObstaclesIntersectICurve(seg)){
                        b.set_PreviousBezierSegmentFitCoefficient(k * u);
                        b.set_NextBezierSegmentFitCoefficient(k * v);
                    }
                }
                a = b;
            }
        },
        TryToRemoveInflectionsAndCollinearSegs: function (underlyingPolyline){
            var progress = true;
            while (progress){
                progress = false;
                for (var s = underlyingPolyline.get_HeadSite(); s != null && s.get_Next() != null; s = s.get_Next()){
                    if (s.get_Turn() * s.get_Next().get_Turn() < 0)
                        progress = (function (){
                            var $1 = {
                                Value: s
                            };
                            var $res = this.TryToRemoveInflectionEdge($1);
                            s = $1.Value;
                            return $res;
                        }).call(this) || progress;
                }
            }
        },
        TryToRemoveInflectionEdge: function (s){
            if (!this.obstacleCalculator.ObstaclesIntersectLine(s.Value.get_Previous().get_Point(), s.Value.get_Next().get_Point())){
                var a = s.Value.get_Previous();
                var b = s.Value.get_Next();
                a.set_Next(b);
                b.set_Previous(a);
                s.Value = a;
                return true;
            }
            if (!this.obstacleCalculator.ObstaclesIntersectLine(s.Value.get_Previous().get_Point(), s.Value.get_Next().get_Next().get_Point())){
                var a = s.Value.get_Previous();
                var b = s.Value.get_Next().get_Next();
                a.set_Next(b);
                b.set_Previous(a);
                s.Value = a;
                return true;
            }
            if (!this.obstacleCalculator.ObstaclesIntersectLine(s.Value.get_Point(), s.Value.get_Next().get_Next().get_Point())){
                var b = s.Value.get_Next().get_Next();
                s.Value.set_Next(b);
                b.set_Previous(s.Value);
                return true;
            }
            return false;
        },
        TryRouteStraightLine: function (){
            var ls = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(this.get_SourcePoint(), this.get_TargetPoint());
            if (this.obstacleCalculator.ObstaclesIntersectICurve(ls))
                return null;
            return ls;
        },
        TargetPoint$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_TargetPoint: function (){
            var tp = As(this.get_TargetPort(), Microsoft.Msagl.Core.Layout.CurvePort.ctor);
            if (tp != null)
                return this.get_Target().get_BoundaryCurve().get_Item$$Double(tp.get_Parameter());
            return this.get_TargetPort().get_Location();
        },
        SourcePoint$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_SourcePoint: function (){
            var sp = As(this.get_SourcePort(), Microsoft.Msagl.Core.Layout.CurvePort.ctor);
            if (sp != null)
                return this.get_Source().get_BoundaryCurve().get_Item$$Double(sp.get_Parameter());
            return this.get_SourcePort().get_Location();
        },
        GetShortestPolyline: function (){
            var pathCalc = new Microsoft.Msagl.Routing.SingleSourceSingleTargetShortestPathOnVisibilityGraph.ctor(this._visGraph, this.sourceVisibilityVertex, this.get_TargetVisibilityVertex());
            var path = pathCalc.GetPath(false);
            var ret = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
            var $it286 = path.GetEnumerator();
            while ($it286.MoveNext()){
                var v = $it286.get_Current();
                ret.AddPoint$$Point(v.Point);
            }
            return Microsoft.Msagl.Prototype.LayoutEditing.RouterBetweenTwoNodes.RemoveCollinearPoint(ret);
        },
        CalculateTangentVisibilityGraph: function (){
            this._visGraph = (function (){
                var $1 = {
                    Value: this.sourceVisibilityVertex
                };
                var $2 = {
                    Value: this.targetVisibilityVertex
                };
                var $res = Microsoft.Msagl.Routing.Visibility.VisibilityGraph.GetVisibilityGraphForShortestPath(this.get_SourcePoint(), this.get_TargetPoint(), this.obstacleCalculator.get_LooseObstacles(), $1, $2);
                this.sourceVisibilityVertex = $1.Value;
                this.targetVisibilityVertex = $2.Value;
                return $res;
            }).call(this);
        },
        CalculateObstacles: function (){
            this.obstacleCalculator = new Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.ctor(this);
            this.obstacleCalculator.Calculate();
            var $it287 = this.obstacleCalculator.get_TightObstacles().GetEnumerator();
            while ($it287.MoveNext()){
                var poly = $it287.get_Current();
                var $it288 = poly.GetEnumerator();
                while ($it288.MoveNext()){
                    var p = $it288.get_Current();
                    this.pointsToObstacles.set_Item$$TKey(p, poly);
                }
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Prototype$LayoutEditing$RouterBetweenTwoNodes);
var Microsoft$Msagl$Prototype$LayoutEditing$WeightedEdge = {
    fullname: "Microsoft.Msagl.Prototype.LayoutEditing.WeightedEdge",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Core.GraphAlgorithms.IEdge"],
    Kind: "Class",
    definition: {
        ctor: function (source, target, weight){
            this.source = 0;
            this.target = 0;
            this.weight = 0;
            System.Object.ctor.call(this);
            this.set_Source(source);
            this.set_Target(target);
            this.set_Weight(weight);
        },
        Source$$: "System.Int32",
        get_Source: function (){
            return this.source;
        },
        set_Source: function (value){
            this.source = value;
        },
        Target$$: "System.Int32",
        get_Target: function (){
            return this.target;
        },
        set_Target: function (value){
            this.target = value;
        },
        Weight$$: "System.Double",
        get_Weight: function (){
            return this.weight;
        },
        set_Weight: function (value){
            this.weight = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Prototype$LayoutEditing$WeightedEdge);
var Microsoft$Msagl$Prototype$MultiScale$MultiScaleLayout = {
    fullname: "Microsoft.Msagl.Prototype.MultiScale.MultiScaleLayout",
    baseTypeName: "System.Object",
    staticDefinition: {
        CenterNode: function (u){
            var c = u.get_Center();
            var count = 1;
            var $it290 = u.get_InEdges().GetEnumerator();
            while ($it290.MoveNext()){
                var e = $it290.get_Current();
                c = Microsoft.Msagl.Core.Geometry.Point.op_Addition(c, e.get_Source().get_Center());
                ++count;
            }
            var $it291 = u.get_OutEdges().GetEnumerator();
            while ($it291.MoveNext()){
                var e = $it291.get_Current();
                c = Microsoft.Msagl.Core.Geometry.Point.op_Addition(c, e.get_Target().get_Center());
                ++count;
            }
            var r = new System.Random.ctor();
            c = Microsoft.Msagl.Core.Geometry.Point.op_Addition(c, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(r.NextDouble(), r.NextDouble()));
            u.set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(c, count));
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        },
        CalculateLayout: function (graph, edgeLengthOffset, edgeLengthMultiplier){
            if (graph.get_Nodes().get_Count() <= 1){
                return;
            }
            var G = graph;
            var GraphStack = new System.Collections.Generic.Stack$1.ctor(Microsoft.Msagl.Core.Layout.GeometryGraph.ctor);
            while (G.get_Nodes().get_Count() > 3){
                GraphStack.Push(G);
                var n = G.get_Nodes().get_Count();
                G = this.CreateAbridgedGraph(G, edgeLengthOffset, edgeLengthMultiplier);
                if (G.get_Nodes().get_Count() == n){
                    G = GraphStack.Pop();
                    break;
                }
            }
            this.SimpleLayout(G, 1, edgeLengthMultiplier);
            var totalGraphCount = GraphStack.get_Count() + 1;
            while (GraphStack.get_Count() > 0){
                var toCenter = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor);
                var $it289 = G.get_Nodes().GetEnumerator();
                while ($it289.MoveNext()){
                    var u = $it289.get_Current();
                    var v = As(u.get_UserData(), Microsoft.Msagl.Core.Layout.Node.ctor);
                    if (v != null){
                        v.set_Center(u.get_Center());
                    }
                    else {
                        var e = As(u.get_UserData(), Microsoft.Msagl.Core.Layout.Edge.ctor);
                        e.get_Source().set_Center((function ($p23){
                            e.get_Target().set_Center($p23);
                            return $p23;
                        }).call(this, u.get_Center()));
                        toCenter.Add(e.get_Source());
                        toCenter.Add(e.get_Target());
                    }
                }
                toCenter.ForEach(Microsoft.Msagl.Prototype.MultiScale.MultiScaleLayout.CenterNode);
                G = GraphStack.Pop();
                this.SimpleLayout(G, GraphStack.get_Count() / totalGraphCount, edgeLengthMultiplier);
            }
        },
        SimpleLayout: function (graph, level, edgeLengthMultiplier){
            var settings = (function (){
                var $v61 = new Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.ctor();
                $v61.set_MaxIterations(10);
                $v61.set_MinorIterations(3);
                $v61.set_GravityConstant(1 - level);
                $v61.set_RepulsiveForceConstant(System.Math.Log$$Double(edgeLengthMultiplier * level * 500 + 2.71828182845905));
                $v61.set_InitialStepSize(0.6);
                return $v61;
            }).call(this);
            var $it292 = graph.get_Edges().GetEnumerator();
            while ($it292.MoveNext()){
                var e = $it292.get_Current();
                e.set_Length(e.get_Length() * System.Math.Log$$Double(level * 500 + 2.71828182845905));
            }
            settings.InitializeLayout$$GeometryGraph$$Int32(graph, settings.get_MinConstraintLevel());
            do{
                Microsoft.Msagl.Miscellaneous.LayoutHelpers.CalculateLayout(graph, settings, null);
            }
            while (settings.get_Iterations() < settings.get_MaxIterations())
        },
        CreateAbridgedGraph: function (graph, edgeLengthOffset, edgeLengthMultiplier){
            Microsoft.Msagl.Core.Layout.LayoutAlgorithmHelpers.SetEdgeLengthsProportionalToSymmetricDifference(graph, edgeLengthOffset, edgeLengthMultiplier);
            var g2 = new Microsoft.Msagl.Core.Layout.GeometryGraph.ctor();
            var nodes = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Node.ctor, graph.get_Nodes());
            var rand = new System.Random.ctor$$Int32(1);
            var edges = System.Linq.Enumerable.ToList$1(Microsoft.Msagl.Core.Layout.Edge.ctor, (System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(null, Microsoft.Msagl.Core.Layout.Edge.ctor, System.Linq.Enumerable.ThenBy$2$$IOrderedEnumerable$1$$Func$2(null, System.Int32.ctor, System.Linq.Enumerable.OrderBy$2$$IEnumerable$1$$Func$2(null, System.Double.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, null, graph.get_Edges(), $CreateAnonymousDelegate(this, function (e){
                return $CreateAnonymousObject({
                    e: e,
                    r: rand.Next()
                });
            })), $CreateAnonymousDelegate(this, function ($$x0){
                return $$x0.get_e().get_Length();
            })), $CreateAnonymousDelegate(this, function ($$x1){
                return $$x1.get_r();
            })), $CreateAnonymousDelegate(this, function ($$x2){
                return $$x2.get_e();
            }))));
            var nodeMap = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Layout.Node.ctor);
            var $it293 = edges.GetEnumerator();
            while ($it293.MoveNext()){
                var e = $it293.get_Current();
                if (nodes.Contains$$T(e.get_Source()) && nodes.Contains$$T(e.get_Target())){
                    var pairNode = (function (){
                        var $v62 = new Microsoft.Msagl.Core.Layout.Node.ctor();
                        $v62.set_UserData(e);
                        return $v62;
                    }).call(this);
                    nodeMap.set_Item$$TKey(e.get_Source(), pairNode);
                    nodeMap.set_Item$$TKey(e.get_Target(), pairNode);
                    g2.get_Nodes().Add(pairNode);
                    nodes.Remove(e.get_Source());
                    nodes.Remove(e.get_Target());
                }
            }
            var $it294 = nodes.GetEnumerator();
            while ($it294.MoveNext()){
                var u = $it294.get_Current();
                var v = (function (){
                    var $v63 = new Microsoft.Msagl.Core.Layout.Node.ctor();
                    $v63.set_UserData(u);
                    return $v63;
                }).call(this);
                g2.get_Nodes().Add(v);
                nodeMap.set_Item$$TKey(u, v);
            }
            var neighbours = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(System.Collections.Generic.KeyValuePair$2.ctor);
            var $it295 = edges.GetEnumerator();
            while ($it295.MoveNext()){
                var e = $it295.get_Current();
                var u = nodeMap.get_Item$$TKey(e.get_Source()),v = nodeMap.get_Item$$TKey(e.get_Target());
                var pair = new System.Collections.Generic.KeyValuePair$2.ctor$$TKey$$TValue(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Layout.Node.ctor, u, v);
                var raip = new System.Collections.Generic.KeyValuePair$2.ctor$$TKey$$TValue(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Layout.Node.ctor, v, u);
                if (pair.get_Key() != pair.get_Value() && !neighbours.Contains$$T(pair) && !neighbours.Contains$$T(raip)){
                    var e2 = (function (){
                        var $v64 = new Microsoft.Msagl.Core.Layout.Edge.ctor$$Node$$Node(u, v);
                        $v64.set_Length(e.get_Length());
                        return $v64;
                    }).call(this);
                    neighbours.Insert(pair);
                    g2.get_Edges().Add(e2);
                }
            }
            return g2;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Prototype$MultiScale$MultiScaleLayout);
var Microsoft$Msagl$Prototype$NonOverlappingBoundaries$CvxHull = {
    fullname: "Microsoft.Msagl.Prototype.NonOverlappingBoundaries.CvxHull",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Prototype.NonOverlappingBoundaries.IHull"],
    Kind: "Class",
    definition: {
        ctor: function (){
            this._Parent = null;
            System.Object.ctor.call(this);
        },
        Parent$$: "Microsoft.Msagl.Prototype.NonOverlappingBoundaries.ClusterConvexHull",
        get_Parent: function (){
            return this._Parent;
        },
        set_Parent: function (value){
            this._Parent = value;
        },
        Center$$: "Microsoft.Msagl.Core.Geometry.Point",
        RectangleNode$$: "Microsoft.Msagl.Core.Geometry.RectangleNode`1[[Microsoft.Msagl.Prototype.NonOverlappingBoundaries.IHull]]",
        Weight$$: "System.Double",
        Project: function (other){
            var v = As(other, Microsoft.Msagl.Prototype.NonOverlappingBoundaries.CvxHull.ctor);
            var vc = As(v, Microsoft.Msagl.Prototype.NonOverlappingBoundaries.ClusterConvexHull.ctor);
            var c = As(this, Microsoft.Msagl.Prototype.NonOverlappingBoundaries.ClusterConvexHull.ctor);
            if (c != null && c.Contains(v)){
                return 0;
            }
            if (vc != null && vc.Contains(this)){
                return 0;
            }
            System.Diagnostics.Debug.Assert$$Boolean(v != null);
            var pd = Microsoft.Msagl.Core.Geometry.Curves.PenetrationDepth.PenetrationDepthForPolylines(this.TranslatedBoundary(), v.TranslatedBoundary());
            if (pd.get_Length() > 0){
                var wpd = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(pd, (this.get_Weight() + v.get_Weight()));
                this.MoveCenter(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(v.get_Weight(), wpd));
                v.MoveCenter(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(-this.get_Weight(), wpd));
            }
            return pd.get_Length();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Prototype$NonOverlappingBoundaries$CvxHull);
var Microsoft$Msagl$Prototype$NonOverlappingBoundaries$RCHull = {
    fullname: "Microsoft.Msagl.Prototype.NonOverlappingBoundaries.RCHull",
    baseTypeName: "Microsoft.Msagl.Prototype.NonOverlappingBoundaries.CvxHull",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (parent, mNode, padding){
            this.mNode = null;
            this.boundary = null;
            this.translatedBoundary = null;
            this.w2 = 0;
            this.h2 = 0;
            Microsoft.Msagl.Prototype.NonOverlappingBoundaries.CvxHull.ctor.call(this);
            this.w2 = mNode.get_Width() / 2 + padding;
            this.h2 = mNode.get_Height() / 2 + padding;
            this.set_Parent(parent);
            this.boundary = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor$$Point$Array([new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-this.w2, -this.h2), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-this.w2, this.h2), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.w2, this.h2), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.w2, -this.h2)]);
            this.boundary.set_Closed(true);
            this.translatedBoundary = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor$$IEnumerable$1$Point(this.boundary);
            this.translatedBoundary.set_Closed(true);
            this.mNode = mNode;
        },
        Center$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Center: function (){
            return this.mNode.get_Center();
        },
        MoveCenter: function (delta){
            this.mNode.set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.mNode.get_Center(), delta));
        },
        RectangleNode$$: "Microsoft.Msagl.Core.Geometry.RectangleNode`1[[Microsoft.Msagl.Prototype.NonOverlappingBoundaries.IHull]]",
        get_RectangleNode: function (){
            var r = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Double$$Double$$Double$$Double(this.get_Center().get_X() - this.w2, this.get_Center().get_Y() - this.h2, this.get_Center().get_X() + this.w2, this.get_Center().get_Y() + this.h2);
            return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(Microsoft.Msagl.Prototype.NonOverlappingBoundaries.IHull.ctor, this, r);
        },
        Weight$$: "System.Double",
        get_Weight: function (){
            return (Cast(this.mNode.AlgorithmData, Microsoft.Msagl.Layout.Incremental.FiNode.ctor)).stayWeight;
        },
        TranslatedBoundary: function (){
            var qq = this.translatedBoundary.get_StartPoint();
            for (var pp = this.boundary.get_StartPoint(); pp != null; pp = pp.get_Next()){
                qq.set_Point(Microsoft.Msagl.Core.Geometry.Point.op_Addition(pp.get_Point(), this.get_Center()));
                qq = qq.get_Next();
            }
            return this.translatedBoundary;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Prototype$NonOverlappingBoundaries$RCHull);
var Microsoft$Msagl$Prototype$NonOverlappingBoundaries$ClusterConvexHull = {
    fullname: "Microsoft.Msagl.Prototype.NonOverlappingBoundaries.ClusterConvexHull",
    baseTypeName: "Microsoft.Msagl.Prototype.NonOverlappingBoundaries.CvxHull",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (cluster, parent){
            this.cluster = null;
            Microsoft.Msagl.Prototype.NonOverlappingBoundaries.CvxHull.ctor.call(this);
            this.cluster = cluster;
            this.set_Parent(parent);
        },
        Center$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Center: function (){
            return this.cluster.SetBarycenter();
        },
        MoveCenter: function (delta){
            this.cluster.ForEachNode($CreateAnonymousDelegate(this, function (v){
                v.set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Addition(v.get_Center(), delta));
            }));
        },
        Weight$$: "System.Double",
        get_Weight: function (){
            return this.cluster.get_Weight();
        },
        RectangleNode$$: "Microsoft.Msagl.Core.Geometry.RectangleNode`1[[Microsoft.Msagl.Prototype.NonOverlappingBoundaries.IHull]]",
        get_RectangleNode: function (){
            var r = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point(this.get_Center());
            var $it296 = this.cluster.get_Nodes().GetEnumerator();
            while ($it296.MoveNext()){
                var node = $it296.get_Current();
                r.Add$$Rectangle(node.get_BoundingBox());
            }
            return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(Microsoft.Msagl.Prototype.NonOverlappingBoundaries.IHull.ctor, this, r);
        },
        TranslatedBoundary: function (){
            return this.ComputeConvexHull();
        },
        ComputeConvexHull: function (){
            var points = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            var $it297 = this.cluster.get_Nodes().GetEnumerator();
            while ($it297.MoveNext()){
                var v = $it297.get_Current();
                var r = new Microsoft.Msagl.Prototype.NonOverlappingBoundaries.RCHull.ctor(null, v, 0);
                var $it298 = r.TranslatedBoundary().get_PolylinePoints().GetEnumerator();
                while ($it298.MoveNext()){
                    var p = $it298.get_Current();
                    points.Add(p.get_Point());
                }
            }
            var $it299 = this.cluster.get_Clusters().GetEnumerator();
            while ($it299.MoveNext()){
                var c = $it299.get_Current();
                points.AddRange(new Microsoft.Msagl.Prototype.NonOverlappingBoundaries.ClusterConvexHull.ctor(c, this).TranslatedBoundary());
            }
            return (function (){
                var $v65 = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor$$IEnumerable$1$Point(Microsoft.Msagl.Core.Geometry.ConvexHull.CalculateConvexHull(points));
                $v65.set_Closed(true);
                return $v65;
            }).call(this);
        },
        Contains: function (child){
            if (child.get_Parent() == null){
                return false;
            }
            if (child.get_Parent() == this){
                return true;
            }
            return this.Contains(child.get_Parent());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Prototype$NonOverlappingBoundaries$ClusterConvexHull);
var Microsoft$Msagl$Prototype$NonOverlappingBoundaries$AllPairsNonOverlappingBoundaries = {
    fullname: "Microsoft.Msagl.Prototype.NonOverlappingBoundaries.AllPairsNonOverlappingBoundaries",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Prototype.NonOverlappingBoundaries.AllPairsNonOverlappingBoundaries.AllPairsComputationLimit = 20;
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Layout.Incremental.IConstraint"],
    Kind: "Class",
    definition: {
        ctor: function (cluster, settings){
            this.hulls = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Prototype.NonOverlappingBoundaries.IHull.ctor);
            System.Object.ctor.call(this);
            var $it300 = cluster.nodes.GetEnumerator();
            while ($it300.MoveNext()){
                var v = $it300.get_Current();
                this.hulls.Add(new Microsoft.Msagl.Prototype.NonOverlappingBoundaries.RCHull.ctor(null, v, settings.get_NodeSeparation()));
            }
            var $it301 = cluster.clusters.GetEnumerator();
            while ($it301.MoveNext()){
                var c = $it301.get_Current();
                this.traverseClusters(null, c, settings.get_NodeSeparation());
            }
        },
        traverseClusters: function (parent, cluster, padding){
            var hull = new Microsoft.Msagl.Prototype.NonOverlappingBoundaries.ClusterConvexHull.ctor(cluster, parent);
            this.hulls.Add(hull);
            var $it302 = cluster.nodes.GetEnumerator();
            while ($it302.MoveNext()){
                var v = $it302.get_Current();
                this.hulls.Add(new Microsoft.Msagl.Prototype.NonOverlappingBoundaries.RCHull.ctor(hull, v, padding));
            }
            var $it303 = cluster.clusters.GetEnumerator();
            while ($it303.MoveNext()){
                var c = $it303.get_Current();
                this.traverseClusters(hull, c, padding);
            }
        },
        Project: function (){
            var displacement = 0;
            if (this.hulls.get_Count() < Microsoft.Msagl.Prototype.NonOverlappingBoundaries.AllPairsNonOverlappingBoundaries.AllPairsComputationLimit){
                for (var i = 0; i < this.hulls.get_Count() - 1; ++i){
                    var u = this.hulls.get_Item$$Int32(i);
                    for (var j = i + 1; j < this.hulls.get_Count(); ++j){
                        displacement += u.Project(this.hulls.get_Item$$Int32(j));
                    }
                }
            }
            else {
                var pq = new Microsoft.Msagl.Prototype.NonOverlappingBoundaries.ProximityQuery.ctor(this.hulls);
                var closePairs = pq.GetAllIntersections();
                var $it304 = closePairs.GetEnumerator();
                while ($it304.MoveNext()){
                    var k = $it304.get_Current();
                    displacement += k.get_Item1().Project(k.get_Item2());
                }
            }
            return displacement;
        },
        Level$$: "System.Int32",
        get_Level: function (){
            return 2;
        },
        Nodes$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Layout.Node]]",
        get_Nodes: function (){
            return new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Prototype$NonOverlappingBoundaries$AllPairsNonOverlappingBoundaries);
var Microsoft$Msagl$Prototype$NonOverlappingBoundaries$IHull = {
    fullname: "Microsoft.Msagl.Prototype.NonOverlappingBoundaries.IHull",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Interface"
};
JsTypes.push(Microsoft$Msagl$Prototype$NonOverlappingBoundaries$IHull);
var Microsoft$Msagl$Prototype$NonOverlappingBoundaries$ProximityQuery = {
    fullname: "Microsoft.Msagl.Prototype.NonOverlappingBoundaries.ProximityQuery",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (nodeHulls){
            this.hierarchy = null;
            System.Object.ctor.call(this);
            this.hierarchy = Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnEnumeration(this.GetNodeRects(nodeHulls));
        },
        GetAllIntersections: function (){
            var closePairs = new System.Collections.Generic.List$1.ctor(System.Tuple$2.ctor);
            this.GetClosePairs(this.hierarchy, this.hierarchy, closePairs);
            return closePairs;
        },
        GetIntersecting: function (leafNode, internalNode, intersecting){
            System.Diagnostics.Debug.Assert$$Boolean(leafNode.get_UserData() != null);
            if (!leafNode.get_Rectangle().Intersects(internalNode.get_Rectangle()))
                return;
            if (internalNode.get_UserData() != null){
                if (leafNode.get_UserData() != internalNode.get_UserData()){
                    intersecting.Add(internalNode.get_UserData());
                }
            }
            else {
                this.GetIntersecting(leafNode, internalNode.get_Left(), intersecting);
                this.GetIntersecting(leafNode, internalNode.get_Right(), intersecting);
            }
        },
        GetClosePairs: function (a, b, closePairs){
            if (!a.get_Rectangle().Intersects(b.get_Rectangle()))
                return;
            if (a.get_UserData() != null && b.get_UserData() != null){
                if (a.get_UserData() != b.get_UserData()){
                    var ap = a.get_UserData().get_Center();
                    var bp = b.get_UserData().get_Center();
                    if (ap.get_X() <= bp.get_X() || (ap.get_X() == bp.get_X() && ap.get_Y() <= bp.get_Y())){
                        closePairs.Add(new System.Tuple$2.ctor(Microsoft.Msagl.Prototype.NonOverlappingBoundaries.IHull.ctor, Microsoft.Msagl.Prototype.NonOverlappingBoundaries.IHull.ctor, a.get_UserData(), b.get_UserData()));
                    }
                }
            }
            else if (a.get_UserData() == null && b.get_UserData() == null){
                this.GetClosePairs(a.get_Left(), b.get_Left(), closePairs);
                this.GetClosePairs(a.get_Left(), b.get_Right(), closePairs);
                this.GetClosePairs(a.get_Right(), b.get_Left(), closePairs);
                this.GetClosePairs(a.get_Right(), b.get_Right(), closePairs);
            }
            else if (a.get_UserData() == null){
                this.GetClosePairs(a.get_Left(), b, closePairs);
                this.GetClosePairs(a.get_Right(), b, closePairs);
            }
            else {
                this.GetClosePairs(a, b.get_Left(), closePairs);
                this.GetClosePairs(a, b.get_Right(), closePairs);
            }
        },
        GetNodeRects: function (nodes){
            var $yield = [];
            var $it305 = nodes.GetEnumerator();
            while ($it305.MoveNext()){
                var v = $it305.get_Current();
                $yield.push(v.get_RectangleNode());
            }
            return $yield;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Prototype$NonOverlappingBoundaries$ProximityQuery);
var Microsoft$Msagl$Prototype$Phylo$PhyloEdge = {
    fullname: "Microsoft.Msagl.Prototype.Phylo.PhyloEdge",
    baseTypeName: "Microsoft.Msagl.Core.Layout.Edge",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (sourceP, targetP){
            Microsoft.Msagl.Core.Layout.Edge.ctor$$Node$$Node.call(this, sourceP, targetP);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Prototype$Phylo$PhyloEdge);
var Microsoft$Msagl$Prototype$Phylo$PhyloTree = {
    fullname: "Microsoft.Msagl.Prototype.Phylo.PhyloTree",
    baseTypeName: "Microsoft.Msagl.Core.Layout.GeometryGraph",
    staticDefinition: {
        NodeIsALeaf: function (node){
            return !node.get_OutEdges().GetEnumerator().MoveNext();
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.root = null;
            Microsoft.Msagl.Core.Layout.GeometryGraph.ctor.call(this);
        },
        Root$$: "Microsoft.Msagl.Core.Layout.Node",
        get_Root: function (){
            return this.root != null ? this.root : this.root = this.GetRoot();
        },
        GetRoot: function (){
            var ret = null;
            var $it306 = this.get_Nodes().GetEnumerator();
            while ($it306.MoveNext()){
                var n = $it306.get_Current();
                ret = n;
                break;
            }
            var oldVal;
            do{
                oldVal = ret;
                var $it307 = ret.get_InEdges().GetEnumerator();
                while ($it307.MoveNext()){
                    var e = $it307.get_Current();
                    ret = e.get_Source();
                }
            }
            while (oldVal != ret)
            return ret;
        },
        Leaves$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Layout.Node]]",
        get_Leaves: function (){
            var $yield = [];
            var $it308 = this.get_Nodes().GetEnumerator();
            while ($it308.MoveNext()){
                var node = $it308.get_Current();
                if (Microsoft.Msagl.Prototype.Phylo.PhyloTree.NodeIsALeaf(node))
                    $yield.push(node);
            }
            return $yield;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Prototype$Phylo$PhyloTree);
var Microsoft$Msagl$Prototype$Phylo$PhyloTreeLayoutCalclulation = {
    fullname: "Microsoft.Msagl.Prototype.Phylo.PhyloTreeLayoutCalclulation",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        },
        VirtualNodeWidth$$: "System.Double",
        get_VirtualNodeWidth: function (){
            return 1;
        },
        ExtendStandardAnchors: function (leftAnchor, rightAnchor, topAnchor, bottomAnchor, node){
            var w = node.get_Width();
            var h = node.get_Height();
            w /= 2;
            h /= 2;
            rightAnchor.Value = leftAnchor.Value = w;
            topAnchor.Value = bottomAnchor.Value = h;
        },
        GetTarget: function (i, span, edge, virtualNode){
            if (i < span - 1)
                return virtualNode;
            return edge.get_Target();
        },
        GetSource: function (i, edge, virtualNode){
            if (i > 0)
                return virtualNode.Value++;
            return edge.get_Source();
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (phyloTreeP, settings, intGraphP, dataBase){
            this.anchors = null;
            this.properLayeredGraph = null;
            this.dataBase = null;
            this.tree = null;
            this.intGraph = null;
            this.layerArrays = null;
            this.gridLayerOffsets = new System.Collections.Generic.SortedDictionary$2.ctor(System.Int32.ctor, System.Double.ctor);
            this.layerOffsets = null;
            this.cellSize = 0;
            this.nodeOffsets = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, System.Double.ctor);
            this.nodesToIndices = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, System.Int32.ctor);
            this.originalNodeToGridLayerIndices = null;
            this.gridLayerToLayer = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, System.Int32.ctor);
            this._LayoutSettings = null;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.dataBase = dataBase;
            this.tree = phyloTreeP;
            this.set_LayoutSettings(settings);
            this.intGraph = intGraphP;
            this.originalNodeToGridLayerIndices = new Int32Array(this.intGraph.get_Nodes().get_Count());
        },
        LayoutSettings$$: "Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings",
        get_LayoutSettings: function (){
            return this._LayoutSettings;
        },
        set_LayoutSettings: function (value){
            this._LayoutSettings = value;
        },
        RunInternal: function (){
            this.DefineCellSize();
            this.CalculateOriginalNodeToGridLayerIndices();
            this.CreateLayerArraysAndProperLayeredGraph();
            this.FillDataBase();
            this.RunXCoordinateAssignmentsByBrandes();
            this.CalcTheBoxFromAnchors();
            this.StretchIfNeeded();
            this.ProcessPositionedAnchors();
            this.RouteSplines();
        },
        StretchIfNeeded: function (){
            if (this.get_LayoutSettings().get_AspectRatio() != 0){
                var aspectRatio = this.tree.get_Width() / this.tree.get_Height();
                this.StretchToDesiredAspectRatio(aspectRatio, this.get_LayoutSettings().get_AspectRatio());
            }
        },
        StretchToDesiredAspectRatio: function (aspectRatio, desiredAR){
            if (aspectRatio > desiredAR)
                this.StretchInYDirection(aspectRatio / desiredAR);
            else if (aspectRatio < desiredAR)
                this.StretchInXDirection(desiredAR / aspectRatio);
        },
        StretchInYDirection: function (scaleFactor){
            var center = (this.tree.get_BoundingBox().get_Top() + this.tree.get_BoundingBox().get_Bottom()) / 2;
            for (var $i310 = 0,$t310 = this.dataBase.get_Anchors(),$l310 = $t310.length,a = $t310[$i310]; $i310 < $l310; $i310++, a = $t310[$i310]){
                a.set_BottomAnchor(a.get_BottomAnchor() * scaleFactor);
                a.set_TopAnchor(a.get_TopAnchor() * scaleFactor);
                a.set_Y(center + scaleFactor * (a.get_Y() - center));
            }
            var h = this.tree.get_Height() * scaleFactor;
            this.tree.set_BoundingBox(new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Double$$Double$$Double$$Double(this.tree.get_BoundingBox().get_Left(), center + h / 2, this.tree.get_BoundingBox().get_Right(), center - h / 2));
        },
        StretchInXDirection: function (scaleFactor){
            var center = (this.tree.get_BoundingBox().get_Left() + this.tree.get_BoundingBox().get_Right()) / 2;
            for (var $i311 = 0,$t311 = this.dataBase.get_Anchors(),$l311 = $t311.length,a = $t311[$i311]; $i311 < $l311; $i311++, a = $t311[$i311]){
                a.set_LeftAnchor(a.get_LeftAnchor() * scaleFactor);
                a.set_RightAnchor(a.get_RightAnchor() * scaleFactor);
                a.set_X(center + scaleFactor * (a.get_X() - center));
            }
            var w = this.tree.get_Width() * scaleFactor;
            this.tree.set_BoundingBox(new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Double$$Double$$Double$$Double(center - w / 2, this.tree.get_BoundingBox().get_Top(), center + w / 2, this.tree.get_BoundingBox().get_Bottom()));
        },
        DefineCellSize: function (){
            var min = 1.79769313486232E+308;
            var $it311 = this.tree.get_Edges().GetEnumerator();
            while ($it311.MoveNext()){
                var e = $it311.get_Current();
                min = System.Math.Min$$Double$$Double(min, e.get_Length());
            }
            this.cellSize = 0.3 * min;
        },
        CalculateOriginalNodeToGridLayerIndices: function (){
            this.InitNodesToIndices();
            this.FillNodeOffsets();
            var $it312 = this.nodeOffsets.GetEnumerator();
            while ($it312.MoveNext()){
                var kv = $it312.get_Current();
                var nodeIndex = this.nodesToIndices.get_Item$$TKey(kv.get_Key());
                var gridLayerIndex = this.originalNodeToGridLayerIndices[nodeIndex] = this.GetGridLayerIndex(kv.get_Value());
                if (!this.gridLayerOffsets.ContainsKey(gridLayerIndex))
                    this.gridLayerOffsets.set_Item$$TKey(gridLayerIndex, kv.get_Value());
            }
        },
        GetGridLayerIndex: function (len){
            return ((len / this.cellSize + 0.5)) | 0;
        },
        InitNodesToIndices: function (){
            for (var i = 0; i < this.intGraph.get_Nodes().get_Count(); i++)
                this.nodesToIndices.set_Item$$TKey(this.intGraph.get_Nodes().get_Item$$Int32(i), i);
        },
        FillNodeOffsets: function (){
            this.FillNodeOffsets$$Double$$Node(0, this.tree.get_Root());
        },
        FillNodeOffsets$$Double$$Node: function (p, node){
            this.nodeOffsets.set_Item$$TKey(node, p);
            var $it313 = node.get_OutEdges().GetEnumerator();
            while ($it313.MoveNext()){
                var e = $it313.get_Current();
                this.FillNodeOffsets$$Double$$Node(p + e.get_Length(), e.get_Target());
            }
        },
        FillDataBase: function (){
            var $it314 = this.intGraph.get_Edges().GetEnumerator();
            while ($it314.MoveNext()){
                var e = $it314.get_Current();
                this.dataBase.RegisterOriginalEdgeInMultiedges(e);
            }
            this.SizeAnchors();
            this.FigureYCoordinates();
        },
        FigureYCoordinates: function (){
            var m = this.GetMultiplier();
            var root = this.nodesToIndices.get_Item$$TKey(this.tree.get_Root());
            this.CalculateAnchorsY(root, m, 0);
            for (var i = this.intGraph.get_NodeCount(); i < this.dataBase.get_Anchors().length; i++)
                this.dataBase.get_Anchors()[i].set_Y(-m * this.layerOffsets[this.layerArrays.Y[i]]);
            for (var i = 0; i < this.layerOffsets.length; i++)
                this.layerOffsets[i] *= m;
        },
        GetMultiplier: function (){
            var m = 1;
            for (var i = this.layerArrays.get_Layers().length - 1; i > 0; i--){
                var nm = this.GetMultiplierBetweenLayers(i);
                if (nm > m)
                    m = nm;
            }
            return m;
        },
        GetMultiplierBetweenLayers: function (i){
            var a = this.FindLowestBottomOnLayer(i);
            var b = this.FindHighestTopOnLayer(i - 1);
            var ay = this.NodeY(i, a);
            var by = this.NodeY(i - 1, b);
            var diff = ay - by;
            if (diff < 0)
                throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            var nm = (this.dataBase.get_Anchors()[a].get_BottomAnchor() + this.dataBase.get_Anchors()[b].get_TopAnchor() + this.get_LayoutSettings().get_LayerSeparation()) / diff;
            if (nm > 1)
                return nm;
            return 1;
        },
        FindHighestTopOnLayer: function (layerIndex){
            var layer = this.layerArrays.get_Layers()[layerIndex];
            var ret = layer[0];
            var top = this.NodeY(layerIndex, ret) + this.dataBase.get_Anchors()[ret].get_TopAnchor();
            for (var i = 1; i < layer.length; i++){
                var node = layer[i];
                var nt = this.NodeY(layerIndex, node) + this.dataBase.get_Anchors()[node].get_TopAnchor();
                if (nt > top){
                    top = nt;
                    ret = node;
                }
            }
            return ret;
        },
        FindLowestBottomOnLayer: function (layerIndex){
            var layer = this.layerArrays.get_Layers()[layerIndex];
            var ret = layer[0];
            var bottom = this.NodeY(layerIndex, ret) - this.dataBase.get_Anchors()[ret].get_BottomAnchor();
            for (var i = 1; i < layer.length; i++){
                var node = layer[i];
                var nb = this.NodeY(layerIndex, node) - this.dataBase.get_Anchors()[node].get_BottomAnchor();
                if (nb < bottom){
                    bottom = nb;
                    ret = node;
                }
            }
            return ret;
        },
        NodeY: function (layer, node){
            return -(this.IsOriginal(node) ? this.nodeOffsets.get_Item$$TKey(this.intGraph.get_Nodes().get_Item$$Int32(node)) : this.layerOffsets[layer]);
        },
        IsOriginal: function (node){
            return node < this.intGraph.get_NodeCount();
        },
        CalculateAnchorsY: function (node, m, y){
            this.dataBase.get_Anchors()[node].set_Y(-y);
            var $it315 = this.intGraph.OutEdges(node).GetEnumerator();
            while ($it315.MoveNext()){
                var e = $it315.get_Current();
                this.CalculateAnchorsY(e.get_Target(), m, y + e.get_Edge().get_Length() * m);
            }
        },
        SizeAnchors: function (){
            this.dataBase.set_Anchors(this.anchors = new Array(this.properLayeredGraph.get_NodeCount()));
            for (var i = 0; i < this.anchors.length; i++)
                this.anchors[i] = new Microsoft.Msagl.Layout.Layered.Anchor.ctor$$Double(this.get_LayoutSettings().get_LabelCornersPreserveCoefficient());
            for (var i = 0; i < this.intGraph.get_NodeCount(); i++)
                this.CalcAnchorsForOriginalNode(i);
            var $it316 = this.dataBase.get_AllIntEdges().GetEnumerator();
            while ($it316.MoveNext()){
                var intEdge = $it316.get_Current();
                if (intEdge.get_LayerEdges() != null){
                    var $it317 = intEdge.get_LayerEdges().GetEnumerator();
                    while ($it317.MoveNext()){
                        var layerEdge = $it317.get_Current();
                        var v = layerEdge.get_Target();
                        if (v != intEdge.get_Target()){
                            var anchor = this.anchors[v];
                            if (!this.dataBase.get_MultipleMiddles().Contains$$T(v)){
                                anchor.set_LeftAnchor((function ($p24){
                                    anchor.set_RightAnchor($p24);
                                    return $p24;
                                }).call(this, Microsoft.Msagl.Prototype.Phylo.PhyloTreeLayoutCalclulation.get_VirtualNodeWidth() / 2));
                                anchor.set_TopAnchor((function ($p25){
                                    anchor.set_BottomAnchor($p25);
                                    return $p25;
                                }).call(this, this.get_VirtualNodeHeight() / 2));
                            }
                            else {
                                anchor.set_LeftAnchor((function ($p26){
                                    anchor.set_RightAnchor($p26);
                                    return $p26;
                                }).call(this, Microsoft.Msagl.Prototype.Phylo.PhyloTreeLayoutCalclulation.get_VirtualNodeWidth() * 4));
                                anchor.set_TopAnchor((function ($p27){
                                    anchor.set_BottomAnchor($p27);
                                    return $p27;
                                }).call(this, this.get_VirtualNodeHeight() / 2));
                            }
                        }
                    }
                    if (intEdge.get_Edge().get_Label() != null){
                        var lj = intEdge.get_LayerEdges().get_Item$$Int32((intEdge.get_LayerEdges().get_Count() / 2) | 0).get_Source();
                        var a = this.anchors[lj];
                        var w = intEdge.get_LabelWidth(),h = intEdge.get_LabelHeight();
                        a.set_RightAnchor(w);
                        a.set_LeftAnchor(this.get_LayoutSettings().get_NodeSeparation());
                        if (a.get_TopAnchor() < h / 2)
                            a.set_TopAnchor((function ($p28){
                                a.set_BottomAnchor($p28);
                                return $p28;
                            }).call(this, h / 2));
                        a.set_LabelToTheRightOfAnchorCenter(true);
                    }
                }
            }
        },
        VirtualNodeHeight$$: "System.Double",
        get_VirtualNodeHeight: function (){
            return this.get_LayoutSettings().get_MinNodeHeight() * 1.5 / 8;
        },
        CalcAnchorsForOriginalNode: function (i){
            var leftAnchor = 0;
            var rightAnchor = leftAnchor;
            var topAnchor = 0;
            var bottomAnchor = topAnchor;
            if (this.intGraph.get_Nodes() != null){
                var node = this.intGraph.get_Nodes().get_Item$$Int32(i);
                (function (){
                    var $1 = {
                        Value: leftAnchor
                    };
                    var $2 = {
                        Value: rightAnchor
                    };
                    var $3 = {
                        Value: topAnchor
                    };
                    var $4 = {
                        Value: bottomAnchor
                    };
                    var $res = Microsoft.Msagl.Prototype.Phylo.PhyloTreeLayoutCalclulation.ExtendStandardAnchors($1, $2, $3, $4, node);
                    leftAnchor = $1.Value;
                    rightAnchor = $2.Value;
                    topAnchor = $3.Value;
                    bottomAnchor = $4.Value;
                    return $res;
                }).call(this);
            }
            (function (){
                var $1 = {
                    Value: rightAnchor
                };
                var $2 = {
                    Value: topAnchor
                };
                var $3 = {
                    Value: bottomAnchor
                };
                var $res = this.RightAnchorMultiSelfEdges(i, $1, $2, $3);
                rightAnchor = $1.Value;
                topAnchor = $2.Value;
                bottomAnchor = $3.Value;
                return $res;
            }).call(this);
            var hw = this.get_LayoutSettings().get_MinNodeWidth() / 2;
            if (leftAnchor < hw)
                leftAnchor = hw;
            if (rightAnchor < hw)
                rightAnchor = hw;
            var hh = this.get_LayoutSettings().get_MinNodeHeight() / 2;
            if (topAnchor < hh)
                topAnchor = hh;
            if (bottomAnchor < hh)
                bottomAnchor = hh;
            this.anchors[i] = (function (){
                var $v66 = new Microsoft.Msagl.Layout.Layered.Anchor.ctor$$Double$$Double$$Double$$Double$$Node$$Double(leftAnchor, rightAnchor, topAnchor, bottomAnchor, this.intGraph.get_Nodes().get_Item$$Int32(i), this.get_LayoutSettings().get_LabelCornersPreserveCoefficient());
                $v66.set_Padding(this.intGraph.get_Nodes().get_Item$$Int32(i).get_Padding());
                return $v66;
            }).call(this);
        },
        RightAnchorMultiSelfEdges: function (i, rightAnchor, topAnchor, bottomAnchor){
            var delta = this.WidthOfSelfeEdge(i, rightAnchor, topAnchor, bottomAnchor);
            rightAnchor.Value += delta;
        },
        WidthOfSelfeEdge: function (i, rightAnchor, topAnchor, bottomAnchor){
            var delta = 0;
            var multiedges = this.dataBase.GetMultiedge$$Int32$$Int32(i, i);
            if (multiedges.get_Count() > 0){
                var $it318 = multiedges.GetEnumerator();
                while ($it318.MoveNext()){
                    var e = $it318.get_Current();
                    if (e.get_Edge().get_Label() != null){
                        rightAnchor.Value += e.get_Edge().get_Label().get_Width();
                        if (topAnchor.Value < e.get_Edge().get_Label().get_Height() / 2)
                            topAnchor.Value = bottomAnchor.Value = e.get_Edge().get_Label().get_Height() / 2;
                    }
                }
                delta += (this.get_LayoutSettings().get_NodeSeparation() + this.get_LayoutSettings().get_MinNodeWidth()) * multiedges.get_Count();
            }
            return delta;
        },
        RouteSplines: function (){
            var routing = new Microsoft.Msagl.Layout.Layered.Routing.ctor(this.get_LayoutSettings(), this.tree, this.dataBase, this.layerArrays, this.properLayeredGraph, null);
            routing.Run();
        },
        RunXCoordinateAssignmentsByBrandes: function (){
            Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.CalculateXCoordinates(this.layerArrays, this.properLayeredGraph, this.tree.get_Nodes().get_Count(), this.dataBase.get_Anchors(), this.get_LayoutSettings().get_NodeSeparation());
        },
        CreateLayerArraysAndProperLayeredGraph: function (){
            var numberOfLayers = this.gridLayerOffsets.get_Count();
            this.layerOffsets = new Float64Array(numberOfLayers);
            var i = numberOfLayers - 1;
            var $it319 = this.gridLayerOffsets.GetEnumerator();
            while ($it319.MoveNext()){
                var kv = $it319.get_Current();
                this.layerOffsets[i] = kv.get_Value();
                this.gridLayerToLayer.set_Item$$TKey(kv.get_Key(), i--);
            }
            var nOfNodes = this.CountTotalNodesIncludingVirtual(this.nodesToIndices.get_Item$$TKey(this.tree.get_Root()));
            var layering = new Int32Array(nOfNodes);
            var layers = new Array(numberOfLayers);
            for (i = 0; i < numberOfLayers; i++)
                layers[i] = new System.Collections.Generic.List$1.ctor(System.Int32.ctor);
            this.WalkTreeAndInsertLayerEdges$$Int32$Array$$List$1$Int32$Array(layering, layers);
            this.layerArrays = new Microsoft.Msagl.Layout.Layered.LayerArrays.ctor(layering);
            var ll = (function ($p29){
                this.layerArrays.set_Layers($p29);
                return $p29;
            }).call(this, new Array(numberOfLayers));
            i = 0;
            for (var $i321 = 0,$l321 = layers.length,layer = layers[$i321]; $i321 < $l321; $i321++, layer = layers[$i321]){
                ll[i++] = layer.ToArray();
            }
            this.properLayeredGraph = new Microsoft.Msagl.Layout.Layered.ProperLayeredGraph.ctor(this.intGraph);
        },
        CountTotalNodesIncludingVirtual: function (node){
            var ret = 1;
            var $it321 = this.intGraph.OutEdges(node).GetEnumerator();
            while ($it321.MoveNext()){
                var edge = $it321.get_Current();
                ret += this.NumberOfVirtualNodesOnEdge(edge) + this.CountTotalNodesIncludingVirtual(edge.get_Target());
            }
            return ret;
        },
        NumberOfVirtualNodesOnEdge: function (edge){
            return this.OriginalNodeLayer(edge.get_Source()) - this.OriginalNodeLayer(edge.get_Target()) - 1;
        },
        OriginalNodeLayer: function (node){
            return this.gridLayerToLayer.get_Item$$TKey(this.originalNodeToGridLayerIndices[node]);
        },
        WalkTreeAndInsertLayerEdges$$Int32$Array$$List$1$Int32$Array: function (layering, layers){
            var virtualNode = this.intGraph.get_NodeCount();
            var root = this.nodesToIndices.get_Item$$TKey(this.tree.get_Root());
            var l;
            layering[root] = l = this.OriginalNodeLayer(root);
            layers[l].Add(root);
            (function (){
                var $1 = {
                    Value: virtualNode
                };
                var $res = this.WalkTreeAndInsertLayerEdges$$Int32$Array$$List$1$Int32$Array$$Int32$$Int32(layering, layers, root, $1);
                virtualNode = $1.Value;
                return $res;
            }).call(this);
        },
        WalkTreeAndInsertLayerEdges$$Int32$Array$$List$1$Int32$Array$$Int32$$Int32: function (layering, layers, node, virtualNode){
            var $it322 = this.intGraph.OutEdges(node).GetEnumerator();
            while ($it322.MoveNext()){
                var edge = $it322.get_Current();
                this.InsertLayerEdgesForEdge(edge, layering, virtualNode, layers);
            }
        },
        InsertLayerEdgesForEdge: function (edge, layering, virtualNode, layers){
            var span = this.OriginalNodeLayer(edge.get_Source()) - this.OriginalNodeLayer(edge.get_Target());
            edge.set_LayerEdges(new Array(span));
            for (var i = 0; i < span; i++)
                edge.get_LayerEdges().set_Item$$Int32(i, new Microsoft.Msagl.Layout.Layered.LayerEdge.ctor$$Int32$$Int32$$Int32(Microsoft.Msagl.Prototype.Phylo.PhyloTreeLayoutCalclulation.GetSource(i, edge, virtualNode), Microsoft.Msagl.Prototype.Phylo.PhyloTreeLayoutCalclulation.GetTarget(i, span, edge, virtualNode.Value), edge.get_CrossingWeight()));
            var l = this.OriginalNodeLayer(edge.get_Source()) - 1;
            for (var i = 0; i < span; i++){
                var node = edge.get_LayerEdges().get_Item$$Int32(i).get_Target();
                layering[node] = l;
                layers[l--].Add(node);
            }
            this.WalkTreeAndInsertLayerEdges$$Int32$Array$$List$1$Int32$Array$$Int32$$Int32(layering, layers, edge.get_Target(), virtualNode);
        },
        ProcessPositionedAnchors: function (){
            for (var i = 0; i < this.tree.get_Nodes().get_Count(); i++)
                this.intGraph.get_Nodes().get_Item$$Int32(i).set_Center(this.anchors[i].get_Origin());
        },
        CalcTheBoxFromAnchors: function (){
            if (this.anchors.length > 0){
                var box = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Double$$Double$$Double$$Double(this.anchors[0].get_Left(), this.anchors[0].get_Top(), this.anchors[0].get_Right(), this.anchors[0].get_Bottom());
                for (var i = 1; i < this.anchors.length; i++){
                    var a = this.anchors[i];
                    box.Add$$Point(a.get_LeftTop());
                    box.Add$$Point(a.get_RightBottom());
                }
                var m = System.Math.Max$$Double$$Double(box.get_Width(), box.get_Height());
                var delta = this.tree.get_Margins() / 100 * m;
                var del = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-delta, delta);
                box.Add$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Addition(box.get_LeftTop(), del));
                box.Add$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(box.get_RightBottom(), del));
                this.tree.set_BoundingBox(box);
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Prototype$Phylo$PhyloTreeLayoutCalclulation);
var Microsoft$Msagl$Prototype$Ranking$Centrality = {
    fullname: "Microsoft.Msagl.Prototype.Ranking.Centrality",
    baseTypeName: "System.Object",
    staticDefinition: {
        PageRank: function (graph, omega, inverse){
            var p = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, System.Double.ctor);
            var n = graph.get_Nodes().get_Count();
            var $it323 = graph.get_Nodes().GetEnumerator();
            while ($it323.MoveNext()){
                var v = $it323.get_Current();
                p.set_Item$$TKey(v, 1 / (graph.get_Nodes().get_Count()));
            }
            for (var c = 0; c < 50; c++){
                var q = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, System.Double.ctor);
                var $it324 = graph.get_Nodes().GetEnumerator();
                while ($it324.MoveNext()){
                    var v = $it324.get_Current();
                    q.set_Item$$TKey(v, (1 - omega) / (graph.get_Nodes().get_Count()));
                }
                if (inverse){
                    var $it325 = graph.get_Nodes().GetEnumerator();
                    while ($it325.MoveNext()){
                        var v = $it325.get_Current();
                        var $it326 = v.get_OutEdges().GetEnumerator();
                        while ($it326.MoveNext()){
                            var edge = $it326.get_Current();
                            var u = edge.get_Target();
                            q.set_Item$$TKey(v, q.get_Item$$TKey(v) + omega * p.get_Item$$TKey(u) / System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Edge.ctor, u.get_InEdges()));
                        }
                    }
                }
                else {
                    var $it327 = graph.get_Nodes().GetEnumerator();
                    while ($it327.MoveNext()){
                        var v = $it327.get_Current();
                        var $it328 = v.get_InEdges().GetEnumerator();
                        while ($it328.MoveNext()){
                            var edge = $it328.get_Current();
                            var u = edge.get_Source();
                            q.set_Item$$TKey(v, q.get_Item$$TKey(v) + omega * p.get_Item$$TKey(u) / System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Edge.ctor, u.get_OutEdges()));
                        }
                    }
                }
                p = q;
            }
            var result = new Float64Array(n);
            var counter = 0;
            var $it329 = graph.get_Nodes().GetEnumerator();
            while ($it329.MoveNext()){
                var v = $it329.get_Current();
                result[counter] = p.get_Item$$TKey(v);
                counter++;
            }
            return result;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Prototype$Ranking$Centrality);
var Microsoft$Msagl$Prototype$Ranking$RankingLayout = {
    fullname: "Microsoft.Msagl.Prototype.Ranking.RankingLayout",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        },
        Standardize: function (x){
            var min = Infinity;
            var max = -Infinity;
            for (var i = 0; i < x.length; i++){
                max = System.Math.Max$$Double$$Double(max, x[i]);
                min = System.Math.Min$$Double$$Double(min, x[i]);
            }
            for (var i = 0; i < x.length; i++){
                x[i] = (x[i] - min) / (max - min);
            }
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (settings, geometryGraph){
            this.graph = null;
            this.settings = null;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.settings = settings;
            this.graph = geometryGraph;
        },
        SetNodePositionsAndMovedBoundaries: function (){
            var pivotNumber = System.Math.Min$$Int32$$Int32(this.graph.get_Nodes().get_Count(), this.settings.get_PivotNumber());
            var scaleX = this.settings.get_ScaleX();
            var scaleY = this.settings.get_ScaleY();
            var pivotArray = new Int32Array(pivotNumber);
            var pivotDistances = new Microsoft.Msagl.Layout.MDS.PivotDistances.ctor(this.graph, false, pivotArray);
            pivotDistances.Run();
            var c = pivotDistances.get_Result();
            var x,y;
            (function (){
                var $1 = {
                    Value: x
                };
                var $2 = {
                    Value: y
                };
                var $res = Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.LandmarkClassicalScaling(c, $1, $2, pivotArray);
                x = $1.Value;
                y = $2.Value;
                return $res;
            }).call(this);
            Microsoft.Msagl.Prototype.Ranking.RankingLayout.Standardize(x);
            var p = Microsoft.Msagl.Prototype.Ranking.Centrality.PageRank(this.graph, 0.85, false);
            Microsoft.Msagl.Prototype.Ranking.RankingLayout.Standardize(p);
            var index = 0;
            var $it330 = this.graph.get_Nodes().GetEnumerator();
            while ($it330.MoveNext()){
                var node = $it330.get_Current();
                node.set_Center(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(((x[index] * scaleX)) | 0, ((System.Math.Sqrt(p[index]) * scaleY)) | 0));
                index++;
            }
            Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MST.OverlapRemoval.RemoveOverlaps(this.graph, this.settings.get_NodeSeparation());
        },
        RunInternal: function (){
            this.SetNodePositionsAndMovedBoundaries();
            Microsoft.Msagl.Routing.StraightLineEdges.SetStraightLineEdgesWithUnderlyingPolylines(this.graph);
            this.SetGraphBoundingBox();
        },
        SetGraphBoundingBox: function (){
            this.graph.set_BoundingBox(this.graph.PumpTheBoxToTheGraphWithMargins());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Prototype$Ranking$RankingLayout);
var Microsoft$Msagl$Prototype$Ranking$RankingLayoutSettings = {
    fullname: "Microsoft.Msagl.Prototype.Ranking.RankingLayoutSettings",
    baseTypeName: "Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.pivotNumber = 50;
            this.scaleX = 200;
            this.scaleY = 200;
            this.omegaX = 0.15;
            this.omegaY = 0.15;
            Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings.ctor.call(this);
            this.set_NodeSeparation(0);
        },
        PivotNumber$$: "System.Int32",
        get_PivotNumber: function (){
            return this.pivotNumber;
        },
        set_PivotNumber: function (value){
            this.pivotNumber = value;
        },
        OmegaX$$: "System.Double",
        get_OmegaX: function (){
            return this.omegaX;
        },
        set_OmegaX: function (value){
            this.omegaX = value;
        },
        OmegaY$$: "System.Double",
        get_OmegaY: function (){
            return this.omegaY;
        },
        set_OmegaY: function (value){
            this.omegaY = value;
        },
        ScaleX$$: "System.Double",
        get_ScaleX: function (){
            return this.scaleX;
        },
        set_ScaleX: function (value){
            this.scaleX = value;
        },
        ScaleY$$: "System.Double",
        get_ScaleY: function (){
            return this.scaleY;
        },
        set_ScaleY: function (value){
            this.scaleY = value;
        },
        Clone: function (){
            return As(this.MemberwiseClone(), Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings.ctor);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Prototype$Ranking$RankingLayoutSettings);
var Microsoft$Msagl$Routing$ClusterBoundaryPort = {
    fullname: "Microsoft.Msagl.Routing.ClusterBoundaryPort",
    baseTypeName: "Microsoft.Msagl.Core.Layout.RelativeFloatingPort",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$Func$1$ICurve$$Func$1$Point$$Point: function (curveDelegate, centerDelegate, locationOffset){
            this.loosePolyline = null;
            Microsoft.Msagl.Core.Layout.RelativeFloatingPort.ctor$$Func$1$ICurve$$Func$1$Point$$Point.call(this, curveDelegate, centerDelegate, locationOffset);
        },
        LoosePolyline$$: "Microsoft.Msagl.Core.Geometry.Curves.Polyline",
        get_LoosePolyline: function (){
            return this.loosePolyline;
        },
        set_LoosePolyline: function (value){
            this.loosePolyline = value;
        },
        ctor$$Func$1$ICurve$$Func$1$Point: function (curveDelegate, centerDelegate){
            this.loosePolyline = null;
            Microsoft.Msagl.Core.Layout.RelativeFloatingPort.ctor$$Func$1$ICurve$$Func$1$Point.call(this, curveDelegate, centerDelegate);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$ClusterBoundaryPort);
var Microsoft$Msagl$Routing$CdtEdge = {
    fullname: "Microsoft.Msagl.Routing.CdtEdge",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (a, b){
            this.upperSite = null;
            this.lowerSite = null;
            this.ccwTriangle = null;
            this.cwTriangle = null;
            this.Constrained = false;
            this.Capacity = 1000000;
            this._ResidualCapacity = 0;
            System.Object.ctor.call(this);
            var above = Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.Above$$Point$$Point(a.Point, b.Point);
            if (above == 1){
                this.upperSite = a;
                this.lowerSite = b;
            }
            else {
                System.Diagnostics.Debug.Assert$$Boolean(above != 0);
                this.lowerSite = a;
                this.upperSite = b;
            }
            this.upperSite.AddEdgeToSite(this);
        },
        ResidualCapacity$$: "System.Double",
        get_ResidualCapacity: function (){
            return this._ResidualCapacity;
        },
        set_ResidualCapacity: function (value){
            this._ResidualCapacity = value;
        },
        CcwTriangle$$: "Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle",
        get_CcwTriangle: function (){
            return this.ccwTriangle;
        },
        set_CcwTriangle: function (value){
            System.Diagnostics.Debug.Assert$$Boolean(value == null || this.cwTriangle == null || value.OppositeSite(this) != this.cwTriangle.OppositeSite(this));
            this.ccwTriangle = value;
        },
        CwTriangle$$: "Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle",
        get_CwTriangle: function (){
            return this.cwTriangle;
        },
        set_CwTriangle: function (value){
            System.Diagnostics.Debug.Assert$$Boolean(value == null || this.ccwTriangle == null || value.OppositeSite(this) != this.ccwTriangle.OppositeSite(this));
            this.cwTriangle = value;
        },
        GetOtherTriangle$$CdtSite: function (p){
            return this.cwTriangle.Contains(p) ? this.ccwTriangle : this.cwTriangle;
        },
        IsAdjacent: function (pi){
            return pi == this.upperSite || pi == this.lowerSite;
        },
        GetOtherTriangle$$CdtTriangle: function (triangle){
            return this.ccwTriangle == triangle ? this.cwTriangle : this.ccwTriangle;
        },
        toString: function (){
            return System.String.Format$$String$$Object$$Object("({0},{1})", this.upperSite, this.lowerSite);
        },
        OtherSite: function (site){
            System.Diagnostics.Debug.Assert$$Boolean(this.IsAdjacent(site));
            return this.upperSite == site ? this.lowerSite : this.upperSite;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$CdtEdge);
var Microsoft$Msagl$Routing$ConstrainedDelaunayTriangulation$CdtFront = {
    fullname: "Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtFront",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (p_1, p0, p_2){
            this.front = new Microsoft.Msagl.Core.DataStructures.RbTree$1.ctor$$Func$3(Microsoft.Msagl.Routing.CdtSite.ctor, $CreateAnonymousDelegate(this, function (a, b){
                return a.Point.get_X().CompareTo$$Double(b.Point.get_X());
            }));
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$ConstrainedDelaunayTriangulation$CdtFront);
var Microsoft$Msagl$Routing$ConstrainedDelaunayTriangulation$CdtFrontElement = {
    fullname: "Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtFrontElement",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (leftSite, edge){
            this.LeftSite = null;
            this.Edge = null;
            this.RightSite = null;
            System.Object.ctor.call(this);
            System.Diagnostics.Debug.Assert$$Boolean(edge.upperSite.Point.get_X() != edge.lowerSite.Point.get_X() && edge.upperSite.Point.get_X() < edge.lowerSite.Point.get_X() && leftSite == edge.upperSite || edge.upperSite.Point.get_X() > edge.lowerSite.Point.get_X() && leftSite == edge.lowerSite);
            this.RightSite = edge.upperSite == leftSite ? edge.lowerSite : edge.upperSite;
            this.LeftSite = leftSite;
            this.Edge = edge;
        },
        X$$: "System.Double",
        get_X: function (){
            return this.LeftSite.Point.get_X();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$ConstrainedDelaunayTriangulation$CdtFrontElement);
var Microsoft$Msagl$Routing$CdtSite = {
    fullname: "Microsoft.Msagl.Routing.CdtSite",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (isolatedSite){
            this.Point = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.Edges = null;
            this.InEdges = null;
            this._Owner = null;
            System.Object.ctor.call(this);
            this.Point = isolatedSite;
        },
        Owner$$: "System.Object",
        get_Owner: function (){
            return this._Owner;
        },
        set_Owner: function (value){
            this._Owner = value;
        },
        AllEdges$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Routing.CdtEdge]]",
        get_AllEdges: function (){
            var $yield = [];
            if (this.Edges != null){
                var $it331 = this.Edges.GetEnumerator();
                while ($it331.MoveNext()){
                    var e = $it331.get_Current();
                    $yield.push(e);
                }
            }
            if (this.InEdges != null){
                var $it332 = this.InEdges.GetEnumerator();
                while ($it332.MoveNext()){
                    var e = $it332.get_Current();
                    $yield.push(e);
                }
            }
            return $yield;
        },
        AddEdgeToSite: function (edge){
            if (this.Edges == null)
                this.Edges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.CdtEdge.ctor);
            this.Edges.Add(edge);
        },
        EdgeBetweenUpperSiteAndLowerSite: function (b){
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.Above$$CdtSite$$CdtSite(this, b) > 0);
            if (this.Edges != null){
                var $it333 = this.Edges.GetEnumerator();
                while ($it333.MoveNext()){
                    var edge = $it333.get_Current();
                    if (edge.lowerSite == b)
                        return edge;
                }
            }
            return null;
        },
        AddInEdge: function (e){
            if (this.InEdges == null)
                this.InEdges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.CdtEdge.ctor);
            this.InEdges.Add(e);
        },
        Triangles$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle]]",
        get_Triangles: function (){
            var $yield = [];
            var edge;
            if (this.Edges != null && this.Edges.get_Count() > 0)
                edge = this.Edges.get_Item$$Int32(0);
            else if (this.InEdges != null && this.InEdges.get_Count() > 0)
                edge = this.InEdges.get_Item$$Int32(0);
            else
                return $yield;
            var e = edge;
            do{
                var t = e.upperSite == this ? e.get_CcwTriangle() : e.get_CwTriangle();
                if (t == null){
                    e = null;
                    break;
                }
                $yield.push(t);
                e = t.Edges.get_Item$$Int32(t.Edges.Index(e) + 2);
            }
            while (e != edge)
            if (e != edge){
                e = edge;
                do{
                    var t = e.upperSite == this ? e.get_CwTriangle() : e.get_CcwTriangle();
                    if (t == null){
                        break;
                    }
                    $yield.push(t);
                    e = t.Edges.get_Item$$Int32(t.Edges.Index(e) + 1);
                }
                while (true)
            }
            return $yield;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$CdtSite);
var Microsoft$Msagl$Routing$ConstrainedDelaunayTriangulation$CdtSweeper = {
    fullname: "Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        },
        FindPivot: function (firstPerimeterEdge){
            var pivot = firstPerimeterEdge;
            var e = firstPerimeterEdge;
            do{
                e = e.Next;
                if (e.Start.Point.get_X() < pivot.Start.Point.get_X() || e.Start.Point.get_X() == pivot.Start.Point.get_X() && e.Start.Point.get_Y() < pivot.Start.Point.get_Y())
                    pivot = e;
            }
            while (e != firstPerimeterEdge)
            return pivot;
        },
        FindNextEdgeOnPerimeter: function (e){
            var t = (e.get_CwTriangle() != null ? e.get_CwTriangle() : e.get_CcwTriangle());
            e = t.Edges.get_Item$$Int32(t.Edges.Index(e) + 2);
            while (e.get_CwTriangle() != null && e.get_CcwTriangle() != null){
                t = e.GetOtherTriangle$$CdtTriangle(t);
                e = t.Edges.get_Item$$Int32(t.Edges.Index(e) + 2);
            }
            return e;
        },
        CreatePerimeterElementFromEdge: function (edge){
            var pe = new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.PerimeterEdge.ctor(edge);
            if (edge.get_CwTriangle() != null){
                pe.Start = edge.upperSite;
                pe.End = edge.lowerSite;
            }
            else {
                pe.End = edge.upperSite;
                pe.Start = edge.lowerSite;
            }
            return pe;
        },
        RemoveTriangleWithEdges: function (cdtTriangles, t){
            cdtTriangles.Remove(t);
            var $it336 = t.Edges.GetEnumerator();
            while ($it336.MoveNext()){
                var e = $it336.get_Current();
                if (e.get_CwTriangle() == t)
                    e.set_CwTriangle(null);
                else
                    e.set_CcwTriangle(null);
                if (e.get_CwTriangle() == null && e.get_CcwTriangle() == null)
                    e.upperSite.Edges.Remove(e);
            }
        },
        RemoveTriangleButLeaveEdges: function (cdtTriangles, t){
            cdtTriangles.Remove(t);
            var $it337 = t.Edges.GetEnumerator();
            while ($it337.MoveNext()){
                var e = $it337.get_Current();
                if (e.get_CwTriangle() == t)
                    e.set_CwTriangle(null);
                else
                    e.set_CcwTriangle(null);
            }
        },
        EdgeIsProcessed: function (edge){
            return edge.get_CwTriangle() != null || edge.get_CcwTriangle() != null;
        },
        DropsSharpEnoughToTheLeft: function (frontElement){
            var edge = frontElement.Edge;
            if (frontElement.RightSite != edge.upperSite)
                return false;
            var d = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(edge.lowerSite.Point, edge.upperSite.Point);
            System.Diagnostics.Debug.Assert$$Boolean(d.get_X() < 0 && d.get_Y() <= 0);
            return d.get_X() >= 0.5 * d.get_Y();
        },
        DropsSharpEnoughToTheRight: function (frontElement){
            var edge = frontElement.Edge;
            if (frontElement.LeftSite != edge.upperSite)
                return false;
            var d = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(edge.lowerSite.Point, edge.upperSite.Point);
            System.Diagnostics.Debug.Assert$$Boolean(d.get_X() > 0 && d.get_Y() <= 0);
            return d.get_X() <= -0.5 * d.get_Y();
        },
        FindNodeInFrontBySite: function (cdtFrontElements, piSite){
            return cdtFrontElements.FindLast$$Func$2(function (x){
                return x.LeftSite.Point.get_X() <= piSite.Point.get_X();
            });
        },
        IsIllegal: function (pi, a, b, c){
            return Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.InCone(pi, a, b, c) && Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.InCircle(pi, a, b, c);
        },
        InCircle: function (d, a, b, c){
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientationWithNoEpsilon(a.Point, b.Point, c.Point) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise);
            var axdx = a.Point.get_X() - d.Point.get_X();
            var aydy = a.Point.get_Y() - d.Point.get_Y();
            var bxdx = b.Point.get_X() - d.Point.get_X();
            var bydy = b.Point.get_Y() - d.Point.get_Y();
            var cxdx = c.Point.get_X() - d.Point.get_X();
            var cydy = c.Point.get_Y() - d.Point.get_Y();
            var t0 = axdx * axdx + aydy * aydy;
            var t1 = bxdx * bxdx + bydy * bydy;
            var t2 = cxdx * cxdx + cydy * cydy;
            return axdx * (bydy * t2 - cydy * t1) - bxdx * (aydy * t2 - cydy * t0) + cxdx * (aydy * t1 - bydy * t0) > Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance();
        },
        InCone: function (pi, a, b, c){
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientationWithNoEpsilon(a.Point, b.Point, c.Point) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise);
            return Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientationWithNoEpsilon(a.Point, pi.Point, b.Point) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise && Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientationWithNoEpsilon(b.Point, pi.Point, c.Point) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise;
        },
        Flip: function (pi, edge){
            System.Diagnostics.Debug.Assert$$Boolean(!edge.IsAdjacent(pi));
            System.Diagnostics.Debug.Assert$$Boolean(edge.get_CcwTriangle().Contains(pi) || edge.get_CwTriangle().Contains(pi));
            var t,ot;
            if (edge.get_CcwTriangle().Contains(pi)){
                t = edge.get_CcwTriangle();
                ot = edge.get_CwTriangle();
            }
            else {
                t = edge.get_CwTriangle();
                ot = edge.get_CcwTriangle();
            }
            System.Diagnostics.Debug.Assert$$Boolean(t.Contains(pi));
            var eIndex = t.Edges.Index(edge);
            var eOtherIndex = ot.Edges.Index(edge);
            System.Diagnostics.Debug.Assert$$Boolean(eIndex > -1 && eOtherIndex > -1);
            var pl = ot.Sites.get_Item$$Int32(eOtherIndex + 2);
            var edgeBeforPi = t.Edges.get_Item$$Int32(eIndex + 1);
            var edgeBeforPl = ot.Edges.get_Item$$Int32(eOtherIndex + 1);
            var newEdge = Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.GetOrCreateEdge(pi, pl);
            t.Sites.set_Item$$Int32(eIndex + 1, pl);
            t.Edges.set_Item$$Int32(eIndex, edgeBeforPl);
            t.Edges.set_Item$$Int32(eIndex + 1, newEdge);
            ot.Sites.set_Item$$Int32(eOtherIndex + 1, pi);
            ot.Edges.set_Item$$Int32(eOtherIndex, edgeBeforPi);
            ot.Edges.set_Item$$Int32(eOtherIndex + 1, newEdge);
            if (edgeBeforPl.lowerSite == pl)
                edgeBeforPl.set_CcwTriangle(t);
            else
                edgeBeforPl.set_CwTriangle(t);
            if (edgeBeforPi.lowerSite == pi)
                edgeBeforPi.set_CcwTriangle(ot);
            else
                edgeBeforPi.set_CwTriangle(ot);
            if (newEdge.upperSite == pi){
                newEdge.set_CcwTriangle(ot);
                newEdge.set_CwTriangle(t);
            }
            else {
                newEdge.set_CcwTriangle(t);
                newEdge.set_CwTriangle(ot);
            }
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.CheckTriangle(t));
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.CheckTriangle(t));
            edge.upperSite.Edges.Remove(edge);
            return newEdge;
        },
        CheckTriangle: function (t){
            if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientationWithNoEpsilon(t.Sites.get_Item$$Int32(0).Point, t.Sites.get_Item$$Int32(1).Point, t.Sites.get_Item$$Int32(2).Point) != Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise){
                return false;
            }
            for (var i = 0; i < 3; i++){
                var e = t.Edges.get_Item$$Int32(i);
                var a = t.Sites.get_Item$$Int32(i);
                var b = t.Sites.get_Item$$Int32(i + 1);
                if (!e.IsAdjacent(a) || !e.IsAdjacent(b))
                    return false;
                if (e.upperSite == a){
                    if (e.get_CcwTriangle() != t)
                        return false;
                }
                else if (e.get_CwTriangle() != t)
                    return false;
            }
            return true;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (listOfSites, p_1, p_2, createEdgeDelegate){
            this.front = new Microsoft.Msagl.Core.DataStructures.RbTree$1.ctor$$Func$3(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtFrontElement.ctor, $CreateAnonymousDelegate(this, function (a, b){
                return a.get_X().CompareTo$$Double(b.get_X());
            }));
            this.triangles = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle.ctor);
            this.listOfSites = null;
            this.p_2 = null;
            this.createEdgeDelegate = null;
            this.p_1 = null;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.listOfSites = listOfSites;
            var firstTriangle = new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle.ctor$$CdtSite$$CdtSite$$CdtSite$$Func$3$CdtSite$CdtSite$CdtEdge(p_1, p_2, listOfSites.get_Item$$Int32(0), createEdgeDelegate);
            this.get_Triangles().Insert(firstTriangle);
            this.front.Insert(new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtFrontElement.ctor(p_1, firstTriangle.Edges.get_Item$$Int32(2)));
            this.front.Insert(new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtFrontElement.ctor(listOfSites.get_Item$$Int32(0), firstTriangle.Edges.get_Item$$Int32(1)));
            this.p_1 = p_1;
            this.p_2 = p_2;
            this.createEdgeDelegate = createEdgeDelegate;
        },
        Triangles$$: "Microsoft.Msagl.Core.DataStructures.Set`1[[Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle]]",
        get_Triangles: function (){
            return this.triangles;
        },
        RunInternal: function (){
            for (var i = 1; i < this.listOfSites.get_Count(); i++)
                this.ProcessSite(this.listOfSites.get_Item$$Int32(i));
            this.FinalizeTriangulation();
        },
        FinalizeTriangulation: function (){
            var list = this.CreateDoubleLinkedListOfPerimeter();
            this.MakePerimeterConvex(list);
            this.RemoveP1AndP2Triangles();
        },
        MakePerimeterConvex: function (firstPerimeterEdge){
            firstPerimeterEdge = Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.FindPivot(firstPerimeterEdge);
            var firstSite = firstPerimeterEdge.Start;
            var a = firstPerimeterEdge;
            var b;
            do{
                b = a.Next;
                if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientationWithNoEpsilon(a.Start.Point, a.End.Point, b.End.Point) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise){
                    a = this.ShortcutTwoListElements(a);
                    while (a.Start != firstSite){
                        var c = a.Prev;
                        if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientationWithNoEpsilon(c.Start.Point, c.End.Point, a.End.Point) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise){
                            a = this.ShortcutTwoListElements(c);
                        }
                        else
                            break;
                    }
                }
                else
                    a = b;
            }
            while (a.End != firstSite)
        },
        CreateDoubleLinkedListOfPerimeter: function (){
            var firstEdge = System.Linq.Enumerable.First$1$$IEnumerable$1(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtFrontElement.ctor, this.front).Edge;
            var edge = firstEdge;
            var pe,prevPe = null,listStart = null;
            do{
                pe = Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.CreatePerimeterElementFromEdge(edge);
                edge = Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.FindNextEdgeOnPerimeter(edge);
                if (prevPe != null){
                    pe.Prev = prevPe;
                    prevPe.Next = pe;
                }
                else
                    listStart = pe;
                prevPe = pe;
            }
            while (edge != firstEdge)
            listStart.Prev = pe;
            pe.Next = listStart;
            return listStart;
        },
        RemoveP1AndP2Triangles: function (){
            var trianglesToRemove = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle.ctor);
            var $it334 = this.triangles.GetEnumerator();
            while ($it334.MoveNext()){
                var t = $it334.get_Current();
                if (t.Sites.Contains(this.p_1) || t.Sites.Contains(this.p_2))
                    trianglesToRemove.Insert(t);
            }
            var $it335 = trianglesToRemove.GetEnumerator();
            while ($it335.MoveNext()){
                var t = $it335.get_Current();
                Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.RemoveTriangleWithEdges(this.triangles, t);
            }
        },
        ProcessSite: function (site){
            this.PointEvent(site);
            for (var i = 0; i < site.Edges.get_Count(); i++){
                var edge = site.Edges.get_Item$$Int32(i);
                if (edge.Constrained)
                    this.EdgeEvent(edge);
            }
        },
        EdgeEvent: function (edge){
            System.Diagnostics.Debug.Assert$$Boolean(edge.Constrained);
            if (Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.EdgeIsProcessed(edge))
                return;
            var edgeInserter = new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.EdgeInserter.ctor(edge, this.get_Triangles(), this.front, this.createEdgeDelegate);
            edgeInserter.Run();
        },
        PointEvent: function (pi){
            var hittedFrontElementNode;
            (function (){
                var $1 = {
                    Value: hittedFrontElementNode
                };
                var $res = this.ProjectToFront(pi, $1);
                hittedFrontElementNode = $1.Value;
                return $res;
            }).call(this);
            var rightSite;
            var leftSite = hittedFrontElementNode.Item.get_X() + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon < pi.Point.get_X() ? (function (){
                var $1 = {
                    Value: rightSite
                };
                var $res = this.MiddleCase(pi, hittedFrontElementNode, $1);
                rightSite = $1.Value;
                return $res;
            }).call(this) : (function (){
                var $1 = {
                    Value: rightSite
                };
                var $res = this.LeftCase(pi, hittedFrontElementNode, $1);
                rightSite = $1.Value;
                return $res;
            }).call(this);
            var piNode = this.InsertSiteIntoFront(leftSite, pi, rightSite);
            this.TriangulateEmptySpaceToTheRight(piNode);
            piNode = Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.FindNodeInFrontBySite(this.front, leftSite);
            this.TriangulateEmptySpaceToTheLeft(piNode);
        },
        LeftCase: function (pi, hittedFrontElementNode, rightSite){
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(pi.Point.get_X(), hittedFrontElementNode.Item.get_X()));
            var hittedFrontElement = hittedFrontElementNode.Item;
            this.InsertAndLegalizeTriangle(pi, hittedFrontElement);
            var prevToHitted = this.front.Previous(hittedFrontElementNode);
            var leftSite = prevToHitted.Item.LeftSite;
            rightSite.Value = hittedFrontElementNode.Item.RightSite;
            this.InsertAndLegalizeTriangle(pi, prevToHitted.Item);
            this.front.DeleteNodeInternal(prevToHitted);
            var d = this.front.Remove(hittedFrontElement);
            System.Diagnostics.Debug.Assert$$Boolean(d != null);
            return leftSite;
        },
        MiddleCase: function (pi, hittedFrontElementNode, rightSite){
            var leftSite = hittedFrontElementNode.Item.LeftSite;
            rightSite.Value = hittedFrontElementNode.Item.RightSite;
            this.InsertAndLegalizeTriangle(pi, hittedFrontElementNode.Item);
            this.front.DeleteNodeInternal(hittedFrontElementNode);
            return leftSite;
        },
        TriangulateEmptySpaceToTheLeft: function (leftLegNode){
            var peakSite = leftLegNode.Item.RightSite;
            var previousNode = this.front.Previous(leftLegNode);
            while (previousNode != null){
                var prevElement = previousNode.Item;
                var rp = prevElement.LeftSite;
                var r = prevElement.RightSite;
                if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(r.Point, peakSite.Point)), (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(rp.Point, r.Point))) < 0){
                    leftLegNode = this.ShortcutTwoFrontElements(previousNode, leftLegNode);
                    previousNode = this.front.Previous(leftLegNode);
                }
                else {
                    this.TryTriangulateBasinToTheLeft(leftLegNode);
                    break;
                }
            }
        },
        ShortcutTwoListElements: function (a){
            var b = a.Next;
            System.Diagnostics.Debug.Assert$$Boolean(a.End == b.Start);
            var t = new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle.ctor$$CdtSite$$CdtSite$$CdtSite$$CdtEdge$$CdtEdge$$Func$3$CdtSite$CdtSite$CdtEdge(a.Start, a.End, b.End, a.Edge, b.Edge, this.createEdgeDelegate);
            this.get_Triangles().Insert(t);
            var newEdge = t.Edges.get_Item$$Int32(2);
            System.Diagnostics.Debug.Assert$$Boolean(newEdge.IsAdjacent(a.Start) && newEdge.IsAdjacent(b.End));
            this.LegalizeEdge(a.Start, t.OppositeEdge(a.Start));
            t = (newEdge.get_CcwTriangle() != null ? newEdge.get_CcwTriangle() : newEdge.get_CwTriangle());
            this.LegalizeEdge(b.End, t.OppositeEdge(b.End));
            var c = (function (){
                var $v67 = new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.PerimeterEdge.ctor(newEdge);
                $v67.Start = a.Start;
                $v67.End = b.End;
                return $v67;
            }).call(this);
            a.Prev.Next = c;
            c.Prev = a.Prev;
            c.Next = b.Next;
            b.Next.Prev = c;
            return c;
        },
        ShortcutTwoFrontElements: function (aNode, bNode){
            var aElem = aNode.Item;
            var bElem = bNode.Item;
            System.Diagnostics.Debug.Assert$$Boolean(aElem.RightSite == bElem.LeftSite);
            var t = new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle.ctor$$CdtSite$$CdtSite$$CdtSite$$CdtEdge$$CdtEdge$$Func$3$CdtSite$CdtSite$CdtEdge(aElem.LeftSite, aElem.RightSite, bElem.RightSite, aElem.Edge, bElem.Edge, this.createEdgeDelegate);
            this.get_Triangles().Insert(t);
            this.front.DeleteNodeInternal(aNode);
            this.front.Remove(bElem);
            var newEdge = t.Edges.get_Item$$Int32(2);
            System.Diagnostics.Debug.Assert$$Boolean(newEdge.IsAdjacent(aElem.LeftSite) && newEdge.IsAdjacent(bElem.RightSite));
            this.LegalizeEdge(aElem.LeftSite, t.OppositeEdge(aElem.LeftSite));
            t = (newEdge.get_CcwTriangle() != null ? newEdge.get_CcwTriangle() : newEdge.get_CwTriangle());
            this.LegalizeEdge(bElem.RightSite, t.OppositeEdge(bElem.RightSite));
            return this.front.Insert(new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtFrontElement.ctor(aElem.LeftSite, newEdge));
        },
        TryTriangulateBasinToTheLeft: function (leftLegNode){
            if (!Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.DropsSharpEnoughToTheLeft(leftLegNode.Item))
                return;
            var stack = new System.Collections.Generic.Stack$1.ctor(Microsoft.Msagl.Routing.CdtSite.ctor);
            stack.Push(leftLegNode.Item.LeftSite);
            while (true){
                var site = stack.Pop();
                leftLegNode = Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.FindNodeInFrontBySite(this.front, site);
                var prev = this.front.Previous(leftLegNode);
                if (prev == null)
                    return;
                if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientationWithNoEpsilon(prev.Item.LeftSite.Point, leftLegNode.Item.LeftSite.Point, leftLegNode.Item.RightSite.Point) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise){
                    stack.Push(prev.Item.LeftSite);
                    this.ShortcutTwoFrontElements(prev, leftLegNode);
                }
                else {
                    if (leftLegNode.Item.LeftSite.Point.get_Y() > leftLegNode.Item.RightSite.Point.get_Y()){
                        stack.Push(prev.Item.LeftSite);
                    }
                    else {
                        if (prev.Item.LeftSite.Point.get_Y() <= prev.Item.RightSite.Point.get_Y())
                            return;
                        stack.Push(prev.Item.LeftSite);
                    }
                }
            }
        },
        InsertSiteIntoFront: function (leftSite, pi, rightSite){
            var leftEdge = null,rightEdge = null;
            var $it338 = pi.Edges.GetEnumerator();
            while ($it338.MoveNext()){
                var edge = $it338.get_Current();
                if (leftEdge == null && edge.lowerSite == leftSite)
                    leftEdge = edge;
                if (rightEdge == null && edge.lowerSite == rightSite)
                    rightEdge = edge;
                if (leftEdge != null && rightEdge != null)
                    break;
            }
            System.Diagnostics.Debug.Assert$$Boolean(leftEdge != null && rightEdge != null);
            this.front.Insert(new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtFrontElement.ctor(leftSite, leftEdge));
            return this.front.Insert(new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtFrontElement.ctor(pi, rightEdge));
        },
        TriangulateEmptySpaceToTheRight: function (piNode){
            var piSite = piNode.Item.LeftSite;
            var piPoint = piSite.Point;
            var piNext = this.front.Next(piNode);
            while (piNext != null){
                var frontElem = piNext.Item;
                var r = frontElem.LeftSite;
                var rp = frontElem.RightSite;
                if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(r.Point, piPoint)), (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(rp.Point, r.Point))) < 0){
                    piNode = this.ShortcutTwoFrontElements(piNode, piNext);
                    piNext = this.front.Next(piNode);
                }
                else {
                    this.TryTriangulateBasinToTheRight(piNode);
                    break;
                }
            }
        },
        TryTriangulateBasinToTheRight: function (piNode){
            if (!Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.DropsSharpEnoughToTheRight(piNode.Item))
                return;
            var stack = new System.Collections.Generic.Stack$1.ctor(Microsoft.Msagl.Routing.CdtSite.ctor);
            stack.Push(piNode.Item.LeftSite);
            while (true){
                var site = stack.Pop();
                piNode = Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.FindNodeInFrontBySite(this.front, site);
                var next = this.front.Next(piNode);
                if (next == null)
                    return;
                if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientationWithNoEpsilon(piNode.Item.LeftSite.Point, piNode.Item.RightSite.Point, next.Item.RightSite.Point) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise){
                    this.ShortcutTwoFrontElements(piNode, next);
                    stack.Push(site);
                }
                else {
                    if (piNode.Item.LeftSite.Point.get_Y() > piNode.Item.RightSite.Point.get_Y()){
                        stack.Push(piNode.Item.RightSite);
                    }
                    else {
                        if (next.Item.LeftSite.Point.get_Y() >= next.Item.RightSite.Point.get_Y())
                            return;
                        stack.Push(piNode.Item.RightSite);
                    }
                }
            }
        },
        InsertAndLegalizeTriangle: function (pi, frontElement){
            if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientationWithNoEpsilon(pi.Point, frontElement.LeftSite.Point, frontElement.RightSite.Point) != Microsoft.Msagl.Core.Geometry.TriangleOrientation.Collinear){
                var tr = new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle.ctor$$CdtSite$$CdtEdge$$Func$3$CdtSite$CdtSite$CdtEdge(pi, frontElement.Edge, this.createEdgeDelegate);
                this.get_Triangles().Insert(tr);
                this.LegalizeEdge(pi, tr.Edges.get_Item$$Int32(0));
            }
            else {
                var e = frontElement.Edge;
                e.upperSite.Edges.Remove(e);
                var t = (e.get_CcwTriangle() != null ? e.get_CcwTriangle() : e.get_CwTriangle());
                var oppositeSite = t.OppositeSite(e);
                Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.RemoveTriangleButLeaveEdges(this.triangles, t);
                t = new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle.ctor$$CdtSite$$CdtSite$$CdtSite$$Func$3$CdtSite$CdtSite$CdtEdge(frontElement.LeftSite, oppositeSite, pi, this.createEdgeDelegate);
                var t1 = new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle.ctor$$CdtSite$$CdtSite$$CdtSite$$Func$3$CdtSite$CdtSite$CdtEdge(frontElement.RightSite, oppositeSite, pi, this.createEdgeDelegate);
                this.triangles.Insert(t);
                this.triangles.Insert(t1);
                this.LegalizeEdge(pi, t.OppositeEdge(pi));
                this.LegalizeEdge(pi, t1.OppositeEdge(pi));
            }
        },
        LegalizeEdge: function (pi, edge){
            System.Diagnostics.Debug.Assert$$Boolean(pi != edge.upperSite && pi != edge.lowerSite);
            if (edge.Constrained || edge.get_CcwTriangle() == null || edge.get_CwTriangle() == null)
                return;
            if (edge.get_CcwTriangle().Contains(pi))
                this.LegalizeEdgeForOtherCwTriangle(pi, edge);
            else
                this.LegalizeEdgeForOtherCcwTriangle(pi, edge);
        },
        LegalizeEdgeForOtherCcwTriangle: function (pi, edge){
            var i = edge.get_CcwTriangle().Edges.Index(edge);
            if (Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.IsIllegal(pi, edge.lowerSite, edge.get_CcwTriangle().Sites.get_Item$$Int32(i + 2), edge.upperSite)){
                var e = Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.Flip(pi, edge);
                this.LegalizeEdge(pi, e.get_CwTriangle().OppositeEdge(pi));
                this.LegalizeEdge(pi, e.get_CcwTriangle().OppositeEdge(pi));
            }
        },
        LegalizeEdgeForOtherCwTriangle: function (pi, edge){
            var i = edge.get_CwTriangle().Edges.Index(edge);
            System.Diagnostics.Debug.Assert$$Boolean(i >= 0);
            if (Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.IsIllegal(pi, edge.upperSite, edge.get_CwTriangle().Sites.get_Item$$Int32(i + 2), edge.lowerSite)){
                var e = Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.Flip(pi, edge);
                this.LegalizeEdge(pi, e.get_CwTriangle().OppositeEdge(pi));
                this.LegalizeEdge(pi, e.get_CcwTriangle().OppositeEdge(pi));
            }
        },
        ProjectToFront: function (site, frontElement){
            frontElement.Value = this.front.FindLast$$Func$2($CreateAnonymousDelegate(this, function (s){
                return s.get_X() <= site.Point.get_X();
            }));
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$ConstrainedDelaunayTriangulation$CdtSweeper);
var Microsoft$Msagl$Routing$ConstrainedDelaunayTriangulation$Cdt = {
    fullname: "Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        },
        GetOrCreateEdge: function (a, b){
            if (Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.Above$$Point$$Point(a.Point, b.Point) == 1){
                var e = a.EdgeBetweenUpperSiteAndLowerSite(b);
                if (e != null)
                    return e;
                return Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.CreateEdgeOnOrderedCouple(a, b);
            }
            else {
                var e = b.EdgeBetweenUpperSiteAndLowerSite(a);
                if (e != null)
                    return e;
                return Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.CreateEdgeOnOrderedCouple(b, a);
            }
        },
        CreateEdgeOnOrderedCouple: function (upperPoint, lowerPoint){
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.Above$$Point$$Point(upperPoint.Point, lowerPoint.Point) == 1);
            return new Microsoft.Msagl.Routing.CdtEdge.ctor(upperPoint, lowerPoint);
        },
        OnComparison: function (a, b){
            return Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.Above$$Point$$Point(a.Point, b.Point);
        },
        Above$$Point$$Point: function (a, b){
            var del = a.get_Y() - b.get_Y();
            if (del > 0)
                return 1;
            if (del < 0)
                return -1;
            del = a.get_X() - b.get_X();
            return del > 0 ? -1 : (del < 0 ? 1 : 0);
        },
        Above$$CdtSite$$CdtSite: function (a, b){
            var del = a.Point.get_Y() - b.Point.get_Y();
            if (del > 0)
                return 1;
            if (del < 0)
                return -1;
            del = a.Point.get_X() - b.Point.get_X();
            return del > 0 ? -1 : (del < 0 ? 1 : 0);
        },
        PointIsInsideOfTriangle: function (point, t){
            for (var i = 0; i < 3; i++){
                var a = t.Sites.get_Item$$Int32(i).Point;
                var b = t.Sites.get_Item$$Int32(i + 1).Point;
                if (Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(point, a, b) < -Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                    return false;
            }
            return true;
        },
        EdgeIsPierced: function (e, source, target, cdtTriangle){
            var area0 = Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(e.upperSite.Point, source, target);
            var area1 = Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(e.lowerSite.Point, source, target);
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Sign(area0) * Microsoft.Msagl.Core.Geometry.ApproximateComparer.Sign(area1) > 0)
                return false;
            area0 = Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(e.upperSite.Point, e.lowerSite.Point, source);
            area1 = Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(e.upperSite.Point, e.lowerSite.Point, target);
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Sign(area0) * Microsoft.Msagl.Core.Geometry.ApproximateComparer.Sign(area1) > 0)
                return false;
            var otherT = e.GetOtherTriangle$$CdtTriangle(cdtTriangle);
            if (otherT == null)
                return true;
            var otherSite = otherT.OppositeSite(e);
            area0 = Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(e.upperSite.Point, e.lowerSite.Point, otherSite.Point);
            return (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Sign(area0) * Microsoft.Msagl.Core.Geometry.ApproximateComparer.Sign(area1) >= 0);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$IEnumerable$1$Point$$IEnumerable$1$Polyline$$IEnumerable$1: function (isolatedSites, obstacles, isolatedSegments){
            this.isolatedSitesWithObject = null;
            this.isolatedSites = null;
            this.obstacles = null;
            this.isolatedSegments = null;
            this.P1 = null;
            this.P2 = null;
            this.sweeper = null;
            this.PointsToSites = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Routing.CdtSite.ctor);
            this.allInputSites = null;
            this.cdtTree = null;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.isolatedSites = isolatedSites;
            this.obstacles = obstacles;
            this.isolatedSegments = isolatedSegments;
        },
        ctor$$IEnumerable$1: function (isolatedSites){
            this.isolatedSitesWithObject = null;
            this.isolatedSites = null;
            this.obstacles = null;
            this.isolatedSegments = null;
            this.P1 = null;
            this.P2 = null;
            this.sweeper = null;
            this.PointsToSites = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Routing.CdtSite.ctor);
            this.allInputSites = null;
            this.cdtTree = null;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.isolatedSitesWithObject = isolatedSites;
        },
        FillAllInputSites: function (){
            if (this.isolatedSitesWithObject != null){
                var $it339 = this.isolatedSitesWithObject.GetEnumerator();
                while ($it339.MoveNext()){
                    var tuple = $it339.get_Current();
                    this.AddSite(tuple.get_Item1(), tuple.get_Item2());
                }
            }
            if (this.isolatedSites != null){
                var $it340 = this.isolatedSites.GetEnumerator();
                while ($it340.MoveNext()){
                    var isolatedSite = $it340.get_Current();
                    this.AddSite(isolatedSite, null);
                }
            }
            if (this.obstacles != null){
                var $it341 = this.obstacles.GetEnumerator();
                while ($it341.MoveNext()){
                    var poly = $it341.get_Current();
                    this.AddPolylineToAllInputSites(poly);
                }
            }
            if (this.isolatedSegments != null){
                var $it342 = this.isolatedSegments.GetEnumerator();
                while ($it342.MoveNext()){
                    var isolatedSegment = $it342.get_Current();
                    this.AddConstrainedEdge(isolatedSegment.get_Item1(), isolatedSegment.get_Item2(), null);
                }
            }
            this.AddP1AndP2();
            this.allInputSites = new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Microsoft.Msagl.Routing.CdtSite.ctor, this.PointsToSites.get_Values());
        },
        AddSite: function (point, relatedObject){
            var site;
            if ((function (){
                var $1 = {
                    Value: site
                };
                var $res = this.PointsToSites.TryGetValue(point, $1);
                site = $1.Value;
                return $res;
            }).call(this)){
                site.set_Owner(relatedObject);
                return site;
            }
            this.PointsToSites.set_Item$$TKey(point, site = (function (){
                var $v68 = new Microsoft.Msagl.Routing.CdtSite.ctor(point);
                $v68.set_Owner(relatedObject);
                return $v68;
            }).call(this));
            return site;
        },
        AddP1AndP2: function (){
            var box = Microsoft.Msagl.Core.Geometry.Rectangle.CreateAnEmptyBox();
            var $it343 = this.PointsToSites.get_Keys().GetEnumerator();
            while ($it343.MoveNext()){
                var site = $it343.get_Current();
                box.Add$$Point(site);
            }
            var delx = box.get_Width() / 3;
            var dely = box.get_Height() / 3;
            this.P1 = new Microsoft.Msagl.Routing.CdtSite.ctor(Microsoft.Msagl.Core.Geometry.Point.op_Addition(box.get_LeftBottom(), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-delx, -dely)));
            this.P2 = new Microsoft.Msagl.Routing.CdtSite.ctor(Microsoft.Msagl.Core.Geometry.Point.op_Addition(box.get_RightBottom(), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(delx, -dely)));
        },
        AddPolylineToAllInputSites: function (poly){
            for (var pp = poly.get_StartPoint(); pp.get_Next() != null; pp = pp.get_Next())
                this.AddConstrainedEdge(pp.get_Point(), pp.get_Next().get_Point(), poly);
            if (poly.get_Closed())
                this.AddConstrainedEdge(poly.get_EndPoint().get_Point(), poly.get_StartPoint().get_Point(), poly);
        },
        AddConstrainedEdge: function (a, b, poly){
            var ab = Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.Above$$Point$$Point(a, b);
            System.Diagnostics.Debug.Assert$$Boolean(ab != 0);
            var upperPoint;
            var lowerPoint;
            if (ab > 0){
                upperPoint = this.AddSite(a, poly);
                lowerPoint = this.AddSite(b, poly);
            }
            else {
                System.Diagnostics.Debug.Assert$$Boolean(ab < 0);
                upperPoint = this.AddSite(b, poly);
                lowerPoint = this.AddSite(a, poly);
            }
            var edge = Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.CreateEdgeOnOrderedCouple(upperPoint, lowerPoint);
            edge.Constrained = true;
        },
        GetTriangles: function (){
            return this.sweeper.get_Triangles();
        },
        RunInternal: function (){
            this.Initialization();
            this.SweepAndFinalize();
        },
        SweepAndFinalize: function (){
            this.sweeper = new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.ctor(this.allInputSites, this.P1, this.P2, Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.GetOrCreateEdge);
            this.sweeper.Run();
        },
        Initialization: function (){
            this.FillAllInputSites();
            this.allInputSites.Sort$$Comparison$1(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.OnComparison);
        },
        RestoreEdgeCapacities: function (){
            var $it344 = this.allInputSites.GetEnumerator();
            while ($it344.MoveNext()){
                var site = $it344.get_Current();
                var $it345 = site.Edges.GetEnumerator();
                while ($it345.MoveNext()){
                    var e = $it345.get_Current();
                    if (!e.Constrained)
                        e.set_ResidualCapacity(e.Capacity);
                }
            }
        },
        SetInEdges: function (){
            var $it346 = this.PointsToSites.get_Values().GetEnumerator();
            while ($it346.MoveNext()){
                var site = $it346.get_Current();
                var edges = site.Edges;
                for (var i = edges.get_Count() - 1; i >= 0; i--){
                    var e = edges.get_Item$$Int32(i);
                    var oSite = e.lowerSite;
                    System.Diagnostics.Debug.Assert$$Boolean(oSite != site);
                    oSite.AddInEdge(e);
                }
            }
        },
        FindSite: function (point){
            return this.PointsToSites.get_Item$$TKey(point);
        },
        ThreadEdgeThroughTriangles: function (startSite, end){
            var $yield = [];
            var piercedEdge;
            var triangle = (function (){
                var $1 = {
                    Value: piercedEdge
                };
                var $res = this.FindFirstPiercedTriangle(startSite, end, $1);
                piercedEdge = $1.Value;
                return $res;
            }).call(this);
            if (triangle == null)
                return $yield;
            var start = startSite.Point;
            var $it347 = this.ThreadThroughTriangles(start, end, triangle, piercedEdge).GetEnumerator();
            while ($it347.MoveNext()){
                var cdtEdge = $it347.get_Current();
                $yield.push(cdtEdge);
            }
            return $yield;
        },
        ThreadThroughTriangles: function (start, end, triangle, piercedEdge){
            var ret = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.CdtEdge.ctor);
            do{
                if (piercedEdge.upperSite.get_Owner() != piercedEdge.lowerSite.get_Owner())
                    ret.Add(piercedEdge);
            }
            while ((function (){
                var $1 = {
                    Value: triangle
                };
                var $2 = {
                    Value: piercedEdge
                };
                var $res = this.FindNextPierced(start, end, $1, $2);
                triangle = $1.Value;
                piercedEdge = $2.Value;
                return $res;
            }).call(this))
            return ret;
        },
        FindNextPierced: function (start, end, t, piercedEdge){
            t.Value = piercedEdge.Value.GetOtherTriangle$$CdtTriangle(t.Value);
            if (t.Value == null)
                return false;
            var i = t.Value.Edges.Index(piercedEdge.Value);
            for (var j = i + 1; j <= i + 2; j++){
                var pe = t.Value.Edges.get_Item$$Int32(j);
                piercedEdge.Value = this.PiercedEdgeQuery(pe, start, end, t.Value);
                if (piercedEdge.Value != null){
                    break;
                }
            }
            return !Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.PointIsInsideOfTriangle(end, t.Value);
        },
        FindFirstPiercedTriangle: function (startSite, target, piercedEdge){
            if (startSite != null){
                var $it348 = startSite.get_Triangles().GetEnumerator();
                while ($it348.MoveNext()){
                    var t = $it348.get_Current();
                    piercedEdge.Value = this.GetPiercedEdgeInSiteTriangle(t, startSite, target);
                    if (piercedEdge.Value != null)if (!Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.PointIsInsideOfTriangle(target, t))
                        return t;
                }
            }
            piercedEdge.Value = null;
            return null;
        },
        GetPiercedEdgeInSiteTriangle: function (t, site, target){
            var e = t.OppositeEdge(site);
            return this.PiercedEdgeQuery(e, site.Point, target, t);
        },
        PiercedEdgeQuery: function (e, source, target, cdtTriangle){
            return Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.EdgeIsPierced(e, source, target, cdtTriangle) ? e : null;
        },
        GetCdtTree: function (){
            if (this.cdtTree == null){
                this.cdtTree = Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnEnumeration(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle.ctor, Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, this.GetTriangles(), $CreateAnonymousDelegate(this, function (t){
                    return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle.ctor, t, t.BoundingBox());
                })));
            }
            return this.cdtTree;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$ConstrainedDelaunayTriangulation$Cdt);
var Microsoft$Msagl$Routing$ConstrainedDelaunayTriangulation$CdtTriangle = {
    fullname: "Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$CdtSite$$CdtSite$$CdtSite$$Func$3$CdtSite$CdtSite$CdtEdge: function (a, b, c, createEdgeDelegate){
            this.Edges = new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.ThreeArray$1.ctor(Microsoft.Msagl.Routing.CdtEdge.ctor);
            this.Sites = new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.ThreeArray$1.ctor(Microsoft.Msagl.Routing.CdtSite.ctor);
            System.Object.ctor.call(this);
            var orientation = Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientationWithNoEpsilon(a.Point, b.Point, c.Point);
            switch (orientation){
                case Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise:
                    this.FillCcwTriangle(a, b, c, createEdgeDelegate);
                    break;
                case Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise:
                    this.FillCcwTriangle(a, c, b, createEdgeDelegate);
                    break;
                default:
                    throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            }
        },
        ctor$$CdtSite$$CdtEdge$$Func$3$CdtSite$CdtSite$CdtEdge: function (pi, edge, createEdgeDelegate){
            this.Edges = new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.ThreeArray$1.ctor(Microsoft.Msagl.Routing.CdtEdge.ctor);
            this.Sites = new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.ThreeArray$1.ctor(Microsoft.Msagl.Routing.CdtSite.ctor);
            System.Object.ctor.call(this);
            switch (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientationWithNoEpsilon(edge.upperSite.Point, edge.lowerSite.Point, pi.Point)){
                case Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise:
                    edge.set_CcwTriangle(this);
                    this.Sites.set_Item$$Int32(0, edge.upperSite);
                    this.Sites.set_Item$$Int32(1, edge.lowerSite);
                    break;
                case Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise:
                    edge.set_CwTriangle(this);
                    this.Sites.set_Item$$Int32(0, edge.lowerSite);
                    this.Sites.set_Item$$Int32(1, edge.upperSite);
                    break;
                default:
                    throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            }
            this.Edges.set_Item$$Int32(0, edge);
            this.Sites.set_Item$$Int32(2, pi);
            this.CreateEdge(1, createEdgeDelegate);
            this.CreateEdge(2, createEdgeDelegate);
        },
        ctor$$CdtSite$$CdtSite$$CdtSite$$CdtEdge$$CdtEdge$$Func$3$CdtSite$CdtSite$CdtEdge: function (aLeft, aRight, bRight, a, b, createEdgeDelegate){
            this.Edges = new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.ThreeArray$1.ctor(Microsoft.Msagl.Routing.CdtEdge.ctor);
            this.Sites = new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.ThreeArray$1.ctor(Microsoft.Msagl.Routing.CdtSite.ctor);
            System.Object.ctor.call(this);
            this.Sites.set_Item$$Int32(0, aLeft);
            this.Sites.set_Item$$Int32(1, aRight);
            this.Sites.set_Item$$Int32(2, bRight);
            this.Edges.set_Item$$Int32(0, a);
            this.Edges.set_Item$$Int32(1, b);
            this.BindEdgeToTriangle(aLeft, a);
            this.BindEdgeToTriangle(aRight, b);
            this.CreateEdge(2, createEdgeDelegate);
        },
        BindEdgeToTriangle: function (site, edge){
            if (site == edge.upperSite)
                edge.set_CcwTriangle(this);
            else
                edge.set_CwTriangle(this);
        },
        EdgeIsReversed$$Int32: function (i){
            return this.Edges.get_Item$$Int32(i).get_CwTriangle() == this;
        },
        EdgeIsReversed$$CdtEdge: function (edge){
            return edge.get_CwTriangle() == this;
        },
        FillCcwTriangle: function (a, b, c, createEdgeDelegate){
            this.Sites.set_Item$$Int32(0, a);
            this.Sites.set_Item$$Int32(1, b);
            this.Sites.set_Item$$Int32(2, c);
            for (var i = 0; i < 3; i++)
                this.CreateEdge(i, createEdgeDelegate);
        },
        CreateEdge: function (i, createEdgeDelegate){
            var a = this.Sites.get_Item$$Int32(i);
            var b = this.Sites.get_Item$$Int32(i + 1);
            var edge = (function ($p30){
                this.Edges.set_Item$$Int32(i, $p30);
                return $p30;
            }).call(this, createEdgeDelegate(a, b));
            this.BindEdgeToTriangle(a, edge);
        },
        Contains: function (cdtSite){
            return this.Sites.Contains(cdtSite);
        },
        OppositeEdge: function (pi){
            var index = this.Sites.Index(pi);
            System.Diagnostics.Debug.Assert$$Boolean(index != -1);
            return this.Edges.get_Item$$Int32(index + 1);
        },
        OppositeSite: function (cdtEdge){
            var i = this.Edges.Index(cdtEdge);
            return this.Sites.get_Item$$Int32(i + 2);
        },
        BoundingBox: function (){
            var rect = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(this.Sites.get_Item$$Int32(0).Point, this.Sites.get_Item$$Int32(1).Point);
            rect.Add$$Point(this.Sites.get_Item$$Int32(2).Point);
            return rect;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$ConstrainedDelaunayTriangulation$CdtTriangle);
var Microsoft$Msagl$Routing$ConstrainedDelaunayTriangulation$EdgeInserter = {
    fullname: "Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.EdgeInserter",
    baseTypeName: "System.Object",
    staticDefinition: {
        LocalInCircle: function (v, a, b, c, reverseTrangleWhenCompare){
            return reverseTrangleWhenCompare ? Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.InCircle(v, a, c, b) : Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.InCircle(v, a, b, c);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (edge, triangles, front, createEdgeDelegate){
            this.edge = null;
            this.triangles = null;
            this.front = null;
            this.createEdgeDelegate = null;
            this.rightPolygon = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.CdtSite.ctor);
            this.leftPolygon = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.CdtSite.ctor);
            this.addedTriangles = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle.ctor);
            System.Object.ctor.call(this);
            this.edge = edge;
            this.triangles = triangles;
            this.front = front;
            this.createEdgeDelegate = createEdgeDelegate;
        },
        Run: function (){
            this.TraceEdgeThroughTriangles();
            this.TriangulatePolygon$$List$1$CdtSite$$CdtSite$$CdtSite$$Boolean(this.rightPolygon, this.edge.upperSite, this.edge.lowerSite, true);
            this.TriangulatePolygon$$List$1$CdtSite$$CdtSite$$CdtSite$$Boolean(this.leftPolygon, this.edge.upperSite, this.edge.lowerSite, false);
            this.UpdateFront();
        },
        UpdateFront: function (){
            var newFrontEdges = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Routing.CdtEdge.ctor);
            var $it349 = this.addedTriangles.GetEnumerator();
            while ($it349.MoveNext()){
                var t = $it349.get_Current();
                var $it350 = t.Edges.GetEnumerator();
                while ($it350.MoveNext()){
                    var e = $it350.get_Current();
                    if (e.get_CwTriangle() == null || e.get_CcwTriangle() == null)
                        newFrontEdges.Insert(e);
                }
            }
            var $it351 = newFrontEdges.GetEnumerator();
            while ($it351.MoveNext()){
                var e = $it351.get_Current();
                this.AddEdgeToFront(e);
            }
        },
        AddEdgeToFront: function (e){
            var leftSite = e.upperSite.Point.get_X() < e.lowerSite.Point.get_X() ? e.upperSite : e.lowerSite;
            this.front.Insert(new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtFrontElement.ctor(leftSite, e));
        },
        TriangulatePolygon$$List$1$CdtSite$$CdtSite$$CdtSite$$Boolean: function (polygon, a, b, reverseTrangleWhenCompare){
            if (polygon.get_Count() > 0)
                this.TriangulatePolygon$$Int32$$Int32$$List$1$CdtSite$$CdtSite$$CdtSite$$Boolean(0, polygon.get_Count() - 1, polygon, a, b, reverseTrangleWhenCompare);
        },
        TriangulatePolygon$$Int32$$Int32$$List$1$CdtSite$$CdtSite$$CdtSite$$Boolean: function (start, end, polygon, a, b, reverseTrangleWhenCompare){
            var c = polygon.get_Item$$Int32(start);
            var cIndex = start;
            for (var i = start + 1; i <= end; i++){
                var v = polygon.get_Item$$Int32(i);
                if (Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.EdgeInserter.LocalInCircle(v, a, b, c, reverseTrangleWhenCompare)){
                    cIndex = i;
                    c = v;
                }
            }
            var t = new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle.ctor$$CdtSite$$CdtSite$$CdtSite$$Func$3$CdtSite$CdtSite$CdtEdge(a, b, c, this.createEdgeDelegate);
            this.triangles.Insert(t);
            this.addedTriangles.Add(t);
            if (start < cIndex)
                this.TriangulatePolygon$$Int32$$Int32$$List$1$CdtSite$$CdtSite$$CdtSite$$Boolean(start, cIndex - 1, polygon, a, c, reverseTrangleWhenCompare);
            if (cIndex < end)
                this.TriangulatePolygon$$Int32$$Int32$$List$1$CdtSite$$CdtSite$$CdtSite$$Boolean(cIndex + 1, end, polygon, c, b, reverseTrangleWhenCompare);
        },
        TraceEdgeThroughTriangles: function (){
            var edgeTracer = new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.EdgeTracer.ctor(this.edge, this.triangles, this.front, this.leftPolygon, this.rightPolygon);
            edgeTracer.Run();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$ConstrainedDelaunayTriangulation$EdgeInserter);
var Microsoft$Msagl$Routing$ConstrainedDelaunayTriangulation$EdgeTracer = {
    fullname: "Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.EdgeTracer",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (edge, triangles, front, leftPolygon, rightPolygon){
            this.edge = null;
            this.triangles = null;
            this.front = null;
            this.leftPolygon = null;
            this.rightPolygon = null;
            this.a = null;
            this.b = null;
            this.piercedEdge = null;
            this.piercedTriangle = null;
            this.piercedToTheLeftFrontElemNode = null;
            this.piercedToTheRightFrontElemNode = null;
            this.elementsToBeRemovedFromFront = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtFrontElement.ctor);
            this.removedTriangles = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle.ctor);
            System.Object.ctor.call(this);
            this.edge = edge;
            this.triangles = triangles;
            this.front = front;
            this.leftPolygon = leftPolygon;
            this.rightPolygon = rightPolygon;
            this.a = edge.upperSite;
            this.b = edge.lowerSite;
        },
        Run: function (){
            this.Init();
            this.Traverse();
        },
        Traverse: function (){
            while (!this.BIsReached()){
                if (this.piercedToTheLeftFrontElemNode != null){
                    this.ProcessLeftFrontPiercedElement();
                }
                else if (this.piercedToTheRightFrontElemNode != null){
                    this.ProcessRightFrontPiercedElement();
                }
                else
                    this.ProcessPiercedEdge();
            }
            if (this.piercedTriangle != null)
                this.RemovePiercedTriangle(this.piercedTriangle);
            this.FindMoreRemovedFromFrontElements();
            var $it352 = this.elementsToBeRemovedFromFront.GetEnumerator();
            while ($it352.MoveNext()){
                var elem = $it352.get_Current();
                this.front.Remove(elem);
            }
        },
        ProcessLeftFrontPiercedElement: function (){
            var v = this.piercedToTheLeftFrontElemNode;
            do{
                this.elementsToBeRemovedFromFront.Add(v.Item);
                this.AddSiteToLeftPolygon(v.Item.LeftSite);
                v = this.front.Previous(v);
            }
            while (Microsoft.Msagl.Core.Geometry.Point.PointToTheLeftOfLine(v.Item.LeftSite.Point, this.a.Point, this.b.Point))
            this.elementsToBeRemovedFromFront.Add(v.Item);
            this.AddSiteToRightPolygon(v.Item.LeftSite);
            if (v.Item.LeftSite == this.b){
                this.piercedToTheLeftFrontElemNode = v;
                return;
            }
            this.FindPiercedTriangle(v);
            this.piercedToTheLeftFrontElemNode = null;
        },
        FindPiercedTriangle: function (v){
            var e = v.Item.Edge;
            var t = (e.get_CcwTriangle() != null ? e.get_CcwTriangle() : e.get_CwTriangle());
            var eIndex = t.Edges.Index(e);
            for (var i = 1; i <= 2; i++){
                var ei = t.Edges.get_Item$$Int32(i + eIndex);
                var signedArea0 = Microsoft.Msagl.Core.Geometry.ApproximateComparer.Sign(Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(ei.lowerSite.Point, this.a.Point, this.b.Point));
                var signedArea1 = Microsoft.Msagl.Core.Geometry.ApproximateComparer.Sign(Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(ei.upperSite.Point, this.a.Point, this.b.Point));
                if (signedArea1 * signedArea0 <= 0){
                    this.piercedTriangle = t;
                    this.piercedEdge = ei;
                    break;
                }
            }
        },
        FindMoreRemovedFromFrontElements: function (){
            var $it353 = this.removedTriangles.GetEnumerator();
            while ($it353.MoveNext()){
                var triangle = $it353.get_Current();
                var $it354 = triangle.Edges.GetEnumerator();
                while ($it354.MoveNext()){
                    var e = $it354.get_Current();
                    if (e.get_CcwTriangle() == null && e.get_CwTriangle() == null){
                        var site = e.upperSite.Point.get_X() < e.lowerSite.Point.get_X() ? e.upperSite : e.lowerSite;
                        var frontNode = Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.FindNodeInFrontBySite(this.front, site);
                        if (frontNode.Item.Edge == e)
                            this.elementsToBeRemovedFromFront.Add(frontNode.Item);
                    }
                }
            }
        },
        ProcessPiercedEdge: function (){
            if (this.piercedEdge.get_CcwTriangle() == this.piercedTriangle){
                this.AddSiteToLeftPolygon(this.piercedEdge.lowerSite);
                this.AddSiteToRightPolygon(this.piercedEdge.upperSite);
            }
            else {
                this.AddSiteToLeftPolygon(this.piercedEdge.upperSite);
                this.AddSiteToRightPolygon(this.piercedEdge.lowerSite);
            }
            this.RemovePiercedTriangle(this.piercedTriangle);
            this.PrepareNextStateAfterPiercedEdge();
        },
        PrepareNextStateAfterPiercedEdge: function (){
            var t = (this.piercedEdge.get_CwTriangle() != null ? this.piercedEdge.get_CwTriangle() : this.piercedEdge.get_CcwTriangle());
            var eIndex = t.Edges.Index(this.piercedEdge);
            for (var i = 1; i <= 2; i++){
                var e = t.Edges.get_Item$$Int32(i + eIndex);
                var signedArea0 = Microsoft.Msagl.Core.Geometry.ApproximateComparer.Sign(Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(e.lowerSite.Point, this.a.Point, this.b.Point));
                var signedArea1 = Microsoft.Msagl.Core.Geometry.ApproximateComparer.Sign(Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(e.upperSite.Point, this.a.Point, this.b.Point));
                if (signedArea1 * signedArea0 <= 0){
                    if (e.get_CwTriangle() != null && e.get_CcwTriangle() != null){
                        this.piercedTriangle = t;
                        this.piercedEdge = e;
                        break;
                    }
                    this.piercedTriangle = null;
                    this.piercedEdge = null;
                    var leftSite = e.upperSite.Point.get_X() < e.lowerSite.Point.get_X() ? e.upperSite : e.lowerSite;
                    var frontElem = Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.FindNodeInFrontBySite(this.front, leftSite);
                    System.Diagnostics.Debug.Assert$$Boolean(frontElem != null);
                    if (leftSite.Point.get_X() < this.a.Point.get_X())
                        this.piercedToTheLeftFrontElemNode = frontElem;
                    else
                        this.piercedToTheRightFrontElemNode = frontElem;
                    this.RemovePiercedTriangle((e.get_CwTriangle() != null ? e.get_CwTriangle() : e.get_CcwTriangle()));
                    break;
                }
            }
        },
        RemovePiercedTriangle: function (t){
            this.triangles.Remove(t);
            var $it355 = t.Edges.GetEnumerator();
            while ($it355.MoveNext()){
                var e = $it355.get_Current();
                if (e.get_CwTriangle() == t)
                    e.set_CwTriangle(null);
                else
                    e.set_CcwTriangle(null);
            }
            this.removedTriangles.Add(t);
        },
        ProcessRightFrontPiercedElement: function (){
            var v = this.piercedToTheRightFrontElemNode;
            do{
                this.elementsToBeRemovedFromFront.Add(v.Item);
                this.AddSiteToRightPolygon(v.Item.RightSite);
                v = this.front.Next(v);
            }
            while (Microsoft.Msagl.Core.Geometry.Point.PointToTheRightOfLine(v.Item.RightSite.Point, this.a.Point, this.b.Point))
            this.elementsToBeRemovedFromFront.Add(v.Item);
            this.AddSiteToLeftPolygon(v.Item.RightSite);
            if (v.Item.RightSite == this.b){
                this.piercedToTheRightFrontElemNode = v;
                return;
            }
            this.FindPiercedTriangle(v);
            this.piercedToTheRightFrontElemNode = null;
        },
        AddSiteToLeftPolygon: function (site){
            this.AddSiteToPolygonWithCheck(site, this.leftPolygon);
        },
        AddSiteToPolygonWithCheck: function (site, list){
            if (site == this.b)
                return;
            if (list.get_Count() == 0 || list.get_Item$$Int32(list.get_Count() - 1) != site)
                list.Add(site);
        },
        AddSiteToRightPolygon: function (site){
            this.AddSiteToPolygonWithCheck(site, this.rightPolygon);
        },
        BIsReached: function (){
            var node = (this.piercedToTheLeftFrontElemNode != null ? this.piercedToTheLeftFrontElemNode : this.piercedToTheRightFrontElemNode);
            if (node != null)
                return node.Item.Edge.IsAdjacent(this.b);
            return this.piercedEdge.IsAdjacent(this.b);
        },
        Init: function (){
            var frontElemNodeRightOfA = Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.FindNodeInFrontBySite(this.front, this.a);
            var frontElemNodeLeftOfA = this.front.Previous(frontElemNodeRightOfA);
            if (Microsoft.Msagl.Core.Geometry.Point.PointToTheLeftOfLine(this.b.Point, frontElemNodeLeftOfA.Item.LeftSite.Point, frontElemNodeLeftOfA.Item.RightSite.Point))
                this.piercedToTheLeftFrontElemNode = frontElemNodeLeftOfA;
            else if (Microsoft.Msagl.Core.Geometry.Point.PointToTheRightOfLine(this.b.Point, frontElemNodeRightOfA.Item.RightSite.Point, frontElemNodeRightOfA.Item.LeftSite.Point))
                this.piercedToTheRightFrontElemNode = frontElemNodeRightOfA;
            else {
                var $it356 = this.a.Edges.GetEnumerator();
                while ($it356.MoveNext()){
                    var e = $it356.get_Current();
                    var t = e.get_CcwTriangle();
                    if (t == null)
                        continue;
                    if (Microsoft.Msagl.Core.Geometry.Point.PointToTheLeftOfLine(this.b.Point, e.lowerSite.Point, e.upperSite.Point))
                        continue;
                    var eIndex = t.Edges.Index(e);
                    var site = t.Sites.get_Item$$Int32(eIndex + 2);
                    if (Microsoft.Msagl.Core.Geometry.Point.PointToTheLeftOfLineOrOnLine(this.b.Point, site.Point, e.upperSite.Point)){
                        this.piercedEdge = t.Edges.get_Item$$Int32(eIndex + 1);
                        this.piercedTriangle = t;
                        break;
                    }
                }
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$ConstrainedDelaunayTriangulation$EdgeTracer);
var Microsoft$Msagl$Routing$ConstrainedDelaunayTriangulation$PerimeterEdge = {
    fullname: "Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.PerimeterEdge",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (edge){
            this.Start = null;
            this.End = null;
            this.Prev = null;
            this.Next = null;
            this.Edge = null;
            System.Object.ctor.call(this);
            System.Diagnostics.Debug.Assert$$Boolean(edge.get_CcwTriangle() == null || edge.get_CwTriangle() == null);
            this.Edge = edge;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$ConstrainedDelaunayTriangulation$PerimeterEdge);
var Microsoft$Msagl$Routing$ConstrainedDelaunayTriangulation$ThreeArray$1 = {
    fullname: "Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.ThreeArray$1",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IEnumerable$1"],
    Kind: "Class",
    definition: {
        ctor$$T$$T$$T: function (T, item0, item1, item2){
            this.T = T;
            this.item0 = null;
            this.item1 = null;
            this.item2 = null;
            System.Object.ctor.call(this);
            this.item0 = item0;
            this.item1 = item1;
            this.item2 = item2;
        },
        Contains: function (t){
            return t.Equals$$Object(this.item0) || t.Equals$$Object(this.item1) || t.Equals$$Object(this.item2);
        },
        Index: function (t){
            if (t.Equals$$Object(this.item0))
                return 0;
            if (t.Equals$$Object(this.item1))
                return 1;
            if (t.Equals$$Object(this.item2))
                return 2;
            return -1;
        },
        ctor: function (T){
            this.T = T;
            this.item0 = null;
            this.item1 = null;
            this.item2 = null;
            System.Object.ctor.call(this);
        },
        Item$$: "`0",
        get_Item$$Int32: function (i){
            switch (i){
                case 0:
                case 3:
                case -3:
                    return this.item0;
                case 1:
                case 4:
                case -2:
                    return this.item1;
                case 2:
                case 5:
                case -1:
                    return this.item2;
                default:
                    throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            }
        },
        set_Item$$Int32: function (i, value){
            switch (i){
                case 0:
                case 3:
                case -3:
                    this.item0 = value;
                    break;
                case 1:
                case 4:
                case -2:
                    this.item1 = value;
                    break;
                case 2:
                case 5:
                case -1:
                    this.item2 = value;
                    break;
                default:
                    throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            }
        },
        GetEnumerator: function (){
            var $yield = [];
            $yield.push(this.item0);
            $yield.push(this.item1);
            $yield.push(this.item2);
            return $yield.GetEnumerator();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$ConstrainedDelaunayTriangulation$ThreeArray$1);
var Microsoft$Msagl$Routing$Corner = {
    fullname: "Microsoft.Msagl.Routing.Corner",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (a, b, c){
            this._hashKey = null;
            this.a = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.b = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.c = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            System.Object.ctor.call(this);
            this.a = a;
            this.b = b;
            this.c = c;
            this.UpdateHashKey();
        },
        Equals$$Corner: function (other){
            return Microsoft.Msagl.Core.Geometry.Point.op_Equality(this.b, other.b) && ((Microsoft.Msagl.Core.Geometry.Point.op_Equality(this.a, other.a) && Microsoft.Msagl.Core.Geometry.Point.op_Equality(this.c, other.c)) || (Microsoft.Msagl.Core.Geometry.Point.op_Equality(this.a, other.c) && Microsoft.Msagl.Core.Geometry.Point.op_Equality(this.c, other.a)));
        },
        GetHashCode: function (){
            return this.b.GetHashCode() ^ ((this.a.GetHashCode() ^ this.c.GetHashCode()) * 397);
        },
        UpdateHashKey: function (){
            this._hashKey = this.GetHashCode().toString();
        },
        Equals$$Object: function (obj){
            if (System.Object.ReferenceEquals(null, obj))
                return false;
            if (System.Object.ReferenceEquals(this, obj))
                return true;
            var corner = As(obj, Microsoft.Msagl.Routing.Corner.ctor);
            if (System.Object.ReferenceEquals(corner, null))
                return false;
            return this.Equals$$Corner(corner);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Corner);
var Microsoft$Msagl$Routing$MultiEdgeRouter = {
    fullname: "Microsoft.Msagl.Routing.MultiEdgeRouter",
    baseTypeName: "System.Object",
    staticDefinition: {
        GetIntersectionGraphOfPreGraphs: function (preGraphs){
            var intersectingPairs = Microsoft.Msagl.Routing.MultiEdgeRouter.EnumeratePairsOfIntersectedPreGraphs(preGraphs);
            if (System.Linq.Enumerable.Any$1$$IEnumerable$1(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, intersectingPairs))
                return new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor$$IEnumerable$1$$Int32(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, intersectingPairs, preGraphs.get_Count());
            return null;
        },
        EnumeratePairsOfIntersectedPreGraphs: function (preGraphs){
            var rn = Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnData(System.Linq.Enumerable.Range(0, preGraphs.get_Count()), function (i){
                return preGraphs.get_Item$$Int32(i).boundingBox;
            });
            var list = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor);
            Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$1$$RectangleNode$1$$RectangleNode$1$$Action$2(System.Int32.ctor, rn, rn, function (a, b){
                list.Add(new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(a, b));
            });
            return list;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (multiEdgeGeoms, interactiveEdgeRouter, nodeBoundaryCurves, bundlingSettings, transparentShapeSetter){
            this.multiEdgeGeometries = null;
            this.interactiveEdgeRouter = null;
            this.bundlingSettings = null;
            this.transparentShapeSetter = null;
            this.nodeTree = null;
            System.Object.ctor.call(this);
            this.multiEdgeGeometries = System.Linq.Enumerable.ToList$1(Array, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Array, Array, multiEdgeGeoms, $CreateAnonymousDelegate(this, function (l){
                return System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, l, $CreateAnonymousDelegate(this, function (e){
                    return e.get_EdgeGeometry();
                })));
            })));
            this.interactiveEdgeRouter = interactiveEdgeRouter;
            this.bundlingSettings = bundlingSettings;
            this.transparentShapeSetter = transparentShapeSetter;
            this.nodeTree = Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnData(nodeBoundaryCurves, $CreateAnonymousDelegate(this, function (c){
                return c.get_BoundingBox();
            }));
        },
        Run: function (){
            var $it357 = this.GetGeometryGraphs().GetEnumerator();
            while ($it357.MoveNext()){
                var graph = $it357.get_Current();
                var br = new Microsoft.Msagl.Routing.Spline.Bundling.BundleRouter.ctor(graph, new Microsoft.Msagl.Routing.Spline.Bundling.SdShortestPath.ctor(this.transparentShapeSetter, null, null), this.interactiveEdgeRouter.get_VisibilityGraph(), this.bundlingSettings, this.interactiveEdgeRouter.get_LoosePadding(), this.interactiveEdgeRouter.get_TightHierarchy(), this.interactiveEdgeRouter.get_LooseHierarchy(), null, null, null);
                br.Run();
            }
        },
        GetGeometryGraphs: function (){
            var $yield = [];
            var $it358 = this.GetIndependantPreGraphs().GetEnumerator();
            while ($it358.MoveNext()){
                var preGraph = $it358.get_Current();
                $yield.push(this.CreateGeometryGraph(preGraph));
            }
            return $yield;
        },
        CreateGeometryGraph: function (preGraph){
            var graph = new Microsoft.Msagl.Core.Layout.GeometryGraph.ctor();
            var nodeDictionary = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor, Microsoft.Msagl.Core.Layout.Node.ctor);
            var $it359 = preGraph.nodeBoundaries.GetEnumerator();
            while ($it359.MoveNext()){
                var curve = $it359.get_Current();
                var node = new Microsoft.Msagl.Core.Layout.Node.ctor$$ICurve(curve);
                nodeDictionary.set_Item$$TKey(curve, node);
                graph.get_Nodes().Add(node);
            }
            var $it360 = preGraph.edgeGeometries.GetEnumerator();
            while ($it360.MoveNext()){
                var eg = $it360.get_Current();
                this.AddEdgeGeometryToGraph(eg, graph, nodeDictionary);
            }
            return graph;
        },
        AddEdgeGeometryToGraph: function (eg, graph, nodeDictionary){
            var sourceNode = this.GetOrCreateNode(eg.get_SourcePort(), nodeDictionary);
            var targetNode = this.GetOrCreateNode(eg.get_TargetPort(), nodeDictionary);
            var edge = (function (){
                var $v69 = new Microsoft.Msagl.Core.Layout.Edge.ctor$$Node$$Node(sourceNode, targetNode);
                $v69.set_EdgeGeometry(eg);
                return $v69;
            }).call(this);
            graph.get_Edges().Add(edge);
        },
        GetOrCreateNode: function (port, nodeDictionary){
            var curve = this.GetPortCurve(port);
            var node;
            if (!(function (){
                var $1 = {
                    Value: node
                };
                var $res = nodeDictionary.TryGetValue(curve, $1);
                node = $1.Value;
                return $res;
            }).call(this))
                nodeDictionary.set_Item$$TKey(curve, node = new Microsoft.Msagl.Core.Layout.Node.ctor$$ICurve(curve));
            return node;
        },
        GetPortCurve: function (port){
            var curve = this.nodeTree.FirstHitNode$$Point$$Func$3(port.get_Location(), $CreateAnonymousDelegate(this, function (point, c){
                return Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(point, c) != Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside ? Microsoft.Msagl.Core.Geometry.HitTestBehavior.Stop : Microsoft.Msagl.Core.Geometry.HitTestBehavior.Continue;
            })).get_UserData();
            return curve;
        },
        GetIndependantPreGraphs: function (){
            var preGraphs = this.CreateInitialPregraphs();
            do{
                var count = preGraphs.get_Count();
                (function (){
                    var $1 = {
                        Value: preGraphs
                    };
                    var $res = this.UniteConnectedPreGraphs($1);
                    preGraphs = $1.Value;
                    return $res;
                }).call(this);
                if (count <= preGraphs.get_Count())
                    break;
            }
            while (true)
            return preGraphs;
        },
        UniteConnectedPreGraphs: function (preGraphs){
            var intersectionGraph = Microsoft.Msagl.Routing.MultiEdgeRouter.GetIntersectionGraphOfPreGraphs(preGraphs.Value);
            if (intersectionGraph == null)
                return;
            var connectedComponents = Microsoft.Msagl.Core.GraphAlgorithms.ConnectedComponentCalculator$1.GetComponents(intersectionGraph);
            var newPreGraphList = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.PreGraph.ctor);
            var $it361 = connectedComponents.GetEnumerator();
            while ($it361.MoveNext()){
                var component = $it361.get_Current();
                var preGraph = null;
                var $it362 = component.GetEnumerator();
                while ($it362.MoveNext()){
                    var i = $it362.get_Current();
                    if (preGraph == null){
                        preGraph = preGraphs.Value.get_Item$$Int32(i);
                        newPreGraphList.Add(preGraph);
                    }
                    else
                        preGraph.AddGraph(preGraphs.Value.get_Item$$Int32(i));
                }
            }
            preGraphs.Value = newPreGraphList;
            var $it363 = preGraphs.Value.GetEnumerator();
            while ($it363.MoveNext()){
                var pg = $it363.get_Current();
                this.AddIntersectingNodes(pg);
            }
        },
        AddIntersectingNodes: function (pg){
            var rect = pg.boundingBox;
            var $it364 = this.nodeTree.GetNodeItemsIntersectingRectangle(rect).GetEnumerator();
            while ($it364.MoveNext()){
                var curve = $it364.get_Current();
                pg.AddNodeBoundary(curve);
            }
        },
        CreateInitialPregraphs: function (){
            return new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Microsoft.Msagl.Routing.PreGraph.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Array, Microsoft.Msagl.Routing.PreGraph.ctor, this.multiEdgeGeometries, $CreateDelegate(this, this.CreatePregraphFromSetOfEdgeGeometries)));
        },
        CreatePregraphFromSetOfEdgeGeometries: function (egs){
            var nodeBoundaries = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor);
            var eg = egs[0];
            var c = this.GetPortCurve(eg.get_SourcePort());
            var rect = c.get_BoundingBox();
            nodeBoundaries.Insert(c);
            nodeBoundaries.Insert(eg.get_TargetPort().get_Curve());
            rect.Add$$Rectangle(eg.get_TargetPort().get_Curve().get_BoundingBox());
            var overlapped = this.nodeTree.GetNodeItemsIntersectingRectangle(rect);
            var $it365 = overlapped.GetEnumerator();
            while ($it365.MoveNext()){
                var nodeBoundary = $it365.get_Current();
                nodeBoundaries.Insert(nodeBoundary);
            }
            return new Microsoft.Msagl.Routing.PreGraph.ctor$$EdgeGeometry$Array$$Set$1$ICurve(egs, nodeBoundaries);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$MultiEdgeRouter);
var Microsoft$Msagl$Routing$MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph = {
    fullname: "Microsoft.Msagl.Routing.MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph",
    baseTypeName: "System.Object",
    staticDefinition: {
        IsForbidden: function (e){
            return e.get_IsPassable() != null && !e.get_IsPassable()() || Is(e, Microsoft.Msagl.Routing.Visibility.TollFreeVisibilityEdge.ctor);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (sourceVisVertices, targetVisVertices, visibilityGraph){
            this.sources = null;
            this.targets = null;
            this._current = null;
            this.closestTarget = null;
            this.upperBound = Infinity;
            this._visGraph = null;
            System.Object.ctor.call(this);
            this._visGraph = visibilityGraph;
            visibilityGraph.ClearPrevEdgesTable();
            var $it366 = visibilityGraph.Vertices().GetEnumerator();
            while ($it366.MoveNext()){
                var v = $it366.get_Current();
                v.set_Distance(Infinity);
            }
            this.sources = sourceVisVertices;
            this.targets = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor, targetVisVertices);
        },
        GetPath: function (){
            var pq = new Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueue$1.ctor(Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor);
            var $it367 = this.sources.GetEnumerator();
            while ($it367.MoveNext()){
                var v = $it367.get_Current();
                v.set_Distance(0);
                pq.Enqueue(v, 0);
            }
            while (!pq.IsEmpty()){
                this._current = pq.Dequeue();
                if (this.targets.Contains$$T(this._current))
                    break;
                var $it368 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor, this._current.get_OutEdges(), $CreateDelegate(this, this.PassableOutEdge)).GetEnumerator();
                while ($it368.MoveNext()){
                    var e = $it368.get_Current();
                    this.ProcessNeighbor(pq, e, e.get_Target());
                }
                var $it369 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor, this._current.get_InEdges(), $CreateDelegate(this, this.PassableInEdge)).GetEnumerator();
                while ($it369.MoveNext()){
                    var e = $it369.get_Current();
                    this.ProcessNeighbor(pq, e, e.get_Source());
                }
            }
            return this._visGraph.PreviosVertex(this._current) == null ? null : this.CalculatePath();
        },
        PassableOutEdge: function (e){
            return e.get_Source() == this.sources || this.targets.Contains$$T(e.get_Target()) || !Microsoft.Msagl.Routing.MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph.IsForbidden(e);
        },
        PassableInEdge: function (e){
            return this.targets.Contains$$T(e.get_Source()) || e.get_Target() == this.sources || !Microsoft.Msagl.Routing.MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph.IsForbidden(e);
        },
        ProcessNeighbor: function (pq, l, v){
            var len = l.get_Length();
            var c = this._current.get_Distance() + len;
            if (c >= this.upperBound)
                return;
            if (this.targets.Contains$$T(v)){
                this.upperBound = c;
                this.closestTarget = v;
            }
            if (v != this.sources && this._visGraph.PreviosVertex(v) == null){
                v.set_Distance(c);
                this._visGraph.SetPreviousEdge(v, l);
                pq.Enqueue(v, c);
            }
            else if (c < v.get_Distance()){
                v.set_Distance(c);
                this._visGraph.SetPreviousEdge(v, l);
                pq.DecreasePriority(v, c);
            }
        },
        CalculatePath: function (){
            if (this.closestTarget == null)
                return null;
            var ret = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor);
            var v = this.closestTarget;
            do{
                ret.Add(v);
                v = this._visGraph.PreviosVertex(v);
            }
            while (v.get_Distance() > 0)
            ret.Add(v);
            ret.Reverse();
            return ret;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph);
var Microsoft$Msagl$Routing$PreGraph = {
    fullname: "Microsoft.Msagl.Routing.PreGraph",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$EdgeGeometry$Array$$Set$1$ICurve: function (egs, nodeBoundaries){
            this.edgeGeometries = null;
            this.nodeBoundaries = null;
            this.boundingBox = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
            System.Object.ctor.call(this);
            this.edgeGeometries = new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, egs);
            this.nodeBoundaries = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor, nodeBoundaries);
            this.boundingBox = Microsoft.Msagl.Core.Geometry.Rectangle.CreateAnEmptyBox();
            var $it370 = nodeBoundaries.GetEnumerator();
            while ($it370.MoveNext()){
                var curve = $it370.get_Current();
                this.boundingBox.Add$$Rectangle(curve.get_BoundingBox());
            }
        },
        ctor: function (){
            this.edgeGeometries = null;
            this.nodeBoundaries = null;
            this.boundingBox = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
            System.Object.ctor.call(this);
        },
        AddGraph: function (a){
            this.edgeGeometries.AddRange(a.edgeGeometries);
            this.nodeBoundaries = Microsoft.Msagl.Core.DataStructures.Set$1.op_Addition(this.nodeBoundaries, a.nodeBoundaries);
            this.boundingBox.Add$$Rectangle(a.boundingBox);
        },
        AddNodeBoundary: function (curve){
            this.nodeBoundaries.Insert(curve);
            this.boundingBox.Add$$Rectangle(curve.get_BoundingBox());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$PreGraph);
var Microsoft$Msagl$Routing$Rectilinear$AxisCoordinateEvent = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.AxisCoordinateEvent",
    baseTypeName: "Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (p){
            this.site = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent.ctor.call(this);
            this.site = p;
        },
        Site$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Site: function (){
            return this.site;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$AxisCoordinateEvent);
var Microsoft$Msagl$Routing$Rectilinear$Clump = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.Clump",
    baseTypeName: "System.Collections.Generic.List$1",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (obstacles){
            System.Collections.Generic.List$1.ctor.call(this, Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor);
            this.AddRange(obstacles);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$Clump);
var Microsoft$Msagl$Routing$Rectilinear$EnumeratorWrapper$1 = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.EnumeratorWrapper$1",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (T, enumerable){
            this.T = T;
            this.state = Microsoft.Msagl.Routing.Rectilinear.EnumeratorWrapper.MoveNextState$1.NotCalled;
            this.enumerator = null;
            System.Object.ctor.call(this);
            this.enumerator = enumerable.GetEnumerator();
        },
        HasCurrent$$: "System.Boolean",
        get_HasCurrent: function (){
            return this.state == Microsoft.Msagl.Routing.Rectilinear.EnumeratorWrapper.MoveNextState$1.True;
        },
        Current$$: "`0",
        get_Current: function (){
            System.Diagnostics.Debug.Assert$$Boolean$$String(this.get_HasCurrent(), "MoveNext has not been called or has returned false");
            return this.enumerator.get_Current();
        },
        MoveNext: function (){
            System.Diagnostics.Debug.Assert$$Boolean$$String(this.state != Microsoft.Msagl.Routing.Rectilinear.EnumeratorWrapper.MoveNextState$1.False, "MoveNext has returned false");
            if (this.enumerator.MoveNext()){
                this.state = Microsoft.Msagl.Routing.Rectilinear.EnumeratorWrapper.MoveNextState$1.True;
                return true;
            }
            this.state = Microsoft.Msagl.Routing.Rectilinear.EnumeratorWrapper.MoveNextState$1.False;
            return false;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$EnumeratorWrapper$1);
var Microsoft$Msagl$Routing$Rectilinear$EnumeratorWrapper$MoveNextState$1 = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.EnumeratorWrapper.MoveNextState$1",
    staticDefinition: {
        NotCalled: 0,
        True: 1,
        False: 2
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$EnumeratorWrapper$MoveNextState$1);
var Microsoft$Msagl$Routing$Rectilinear$FullVisibilityGraphGenerator = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.FullVisibilityGraphGenerator",
    baseTypeName: "Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator",
    staticDefinition: {
        cctor: function (){
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.hintScanSegment = null;
            Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.ctor.call(this, true);
        },
        GenerateVisibilityGraph: function (){
            if (null == this.ObstacleTree.get_Root()){
                return;
            }
            Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.commonPrototype.GenerateVisibilityGraph.call(this);
            this.HorizontalScanSegments.MergeSegments();
            this.VerticalScanSegments.MergeSegments();
            this.IntersectScanSegments();
            Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.Debug_AssertGraphIsRectilinear(this.get_VisibilityGraph(), this.ObstacleTree);
        },
        IntersectScanSegments: function (){
            var si = new Microsoft.Msagl.Routing.Rectilinear.SegmentIntersector.ctor();
            this.set_VisibilityGraph(si.Generate(this.HorizontalScanSegments.get_Segments(), this.VerticalScanSegments.get_Segments()));
            si.RemoveSegmentsWithNoVisibility(this.HorizontalScanSegments, this.VerticalScanSegments);
        },
        InitializeEventQueue: function (scanDir){
            Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.commonPrototype.InitializeEventQueue.call(this, scanDir);
            this.hintScanSegment = null;
        },
        Clear: function (){
            Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.commonPrototype.Clear.call(this);
            this.hintScanSegment = null;
        },
        InsertPerpendicularReflectionSegment: function (start, end){
            if (null != this.get_PerpendicularScanSegments().Find(start, end)){
                return false;
            }
            this.get_PerpendicularScanSegments().InsertUnique(new Microsoft.Msagl.Routing.Rectilinear.ScanSegment.ctor$$Point$$Point$$Double$$PointAndCrossingsList(start, end, 5, null));
            return true;
        },
        InsertParallelReflectionSegment: function (start, end, eventObstacle, lowNborSide, highNborSide, action){
            if (null != this.get_ParallelScanSegments().Find(start, end)){
                return false;
            }
            return this.AddSegment(start, end, eventObstacle, lowNborSide, highNborSide, action, 5);
        },
        AddSegment: function (start, end, eventObstacle, lowNborSide, highNborSide, action, weight){
            if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(start, end)){
                return false;
            }
            var gbcList = this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(start, end);
            var extendStart,extendEnd;
            var wasSubsumed = (function (){
                var $1 = {
                    Value: this.hintScanSegment
                };
                var $2 = {
                    Value: extendStart
                };
                var $3 = {
                    Value: extendEnd
                };
                var $res = Microsoft.Msagl.Routing.Rectilinear.ScanSegment.Subsume($1, start, end, weight, gbcList, this.ScanDirection, this.get_ParallelScanSegments(), $2, $3);
                this.hintScanSegment = $1.Value;
                extendStart = $2.Value;
                extendEnd = $3.Value;
                return $res;
            }).call(this);
            if (!wasSubsumed){
                System.Diagnostics.Debug.Assert$$Boolean$$String((weight != 5) || (this.get_ParallelScanSegments().Find(start, end) == null), "Reflection segments already in the ScanSegmentTree should should have been detected before calling AddSegment");
                this.hintScanSegment = this.get_ParallelScanSegments().InsertUnique(new Microsoft.Msagl.Routing.Rectilinear.ScanSegment.ctor$$Point$$Point$$Double$$PointAndCrossingsList(start, end, weight, gbcList)).Item;
            }
            else if (weight == 5){
                return false;
            }
            if (500 != weight){
                System.Diagnostics.Debug.Assert$$Boolean$$String(Is(lowNborSide, Microsoft.Msagl.Routing.Rectilinear.HighObstacleSide.ctor), "lowNbor is not HighObstacleSide");
                System.Diagnostics.Debug.Assert$$Boolean$$String(Is(highNborSide, Microsoft.Msagl.Routing.Rectilinear.LowObstacleSide.ctor), "highNbor is not LowObstacleSide");
                if (Is(action, Microsoft.Msagl.Routing.Rectilinear.CloseVertexEvent.ctor)){
                    if (!this.SideReflectsUpward(lowNborSide) || !this.SideReflectsUpward(highNborSide)){
                        if (extendStart){
                            this.StoreLookaheadSite(highNborSide.get_Obstacle(), lowNborSide, start, false);
                        }
                        if (extendEnd){
                            this.StoreLookaheadSite(lowNborSide.get_Obstacle(), highNborSide, end, false);
                        }
                    }
                }
                else {
                    if (extendStart){
                        this.StoreLookaheadSite$$Obstacle$$BasicObstacleSide$$BasicObstacleSide$$Point(eventObstacle, this.LowNeighborSides.get_GroupSideInterveningBeforeLowNeighbor(), lowNborSide, start);
                    }
                    if (extendEnd){
                        this.StoreLookaheadSite$$Obstacle$$BasicObstacleSide$$BasicObstacleSide$$Point(eventObstacle, this.HighNeighborSides.get_GroupSideInterveningBeforeHighNeighbor(), highNborSide, end);
                    }
                }
            }
            return true;
        },
        StoreLookaheadSite$$Obstacle$$BasicObstacleSide$$BasicObstacleSide$$Point: function (eventObstacle, interveningGroupSide, neighborSide, siteOnSide){
            if (null == interveningGroupSide){
                this.StoreLookaheadSite(eventObstacle, neighborSide, siteOnSide, false);
            }
            else {
                var siteOnGroup = Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.ScanLineIntersectSide$$Point$$BasicObstacleSide$$ScanDirection(siteOnSide, interveningGroupSide, this.ScanDirection);
                this.StoreLookaheadSite(eventObstacle, interveningGroupSide, siteOnGroup, false);
            }
        },
        IntersectionAtSideIsInsideAnotherObstacle$$BasicObstacleSide$$BasicVertexEvent: function (side, vertexEvent){
            var intersect = this.ScanLineIntersectSide$$Point$$BasicObstacleSide(vertexEvent.get_Site(), side);
            return this.IntersectionAtSideIsInsideAnotherObstacle$$BasicObstacleSide$$Obstacle$$Point(side, vertexEvent.get_Obstacle(), intersect);
        },
        IntersectionAtSideIsInsideAnotherObstacle$$BasicObstacleSide$$Obstacle$$Point: function (side, eventObstacle, intersect){
            if (!side.get_Obstacle().get_IsOverlapped()){
                return false;
            }
            if (!side.get_Obstacle().get_IsGroup() && !eventObstacle.get_IsGroup() && (side.get_Obstacle().get_Clump() != eventObstacle.get_Clump())){
                return false;
            }
            return this.ObstacleTree.IntersectionIsInsideAnotherObstacle(side.get_Obstacle(), eventObstacle, intersect, this.ScanDirection);
        },
        CreateScanSegments$$Obstacle$$HighObstacleSide$$BasicObstacleSide$$BasicObstacleSide$$LowObstacleSide$$BasicVertexEvent: function (obstacle, lowNborSide, lowOverlapSide, highOverlapSide, highNborSide, vertexEvent){
            if ((null == highOverlapSide) || this.IntersectionAtSideIsInsideAnotherObstacle$$BasicObstacleSide$$BasicVertexEvent(highOverlapSide, vertexEvent)){
                highOverlapSide = highNborSide;
            }
            if ((null == lowOverlapSide) || this.IntersectionAtSideIsInsideAnotherObstacle$$BasicObstacleSide$$BasicVertexEvent(lowOverlapSide, vertexEvent)){
                lowOverlapSide = lowNborSide;
            }
            var lowNborIntersect = this.ScanLineIntersectSide$$Point$$BasicObstacleSide(vertexEvent.get_Site(), lowNborSide);
            var highNborIntersect = this.ScanLineIntersectSide$$Point$$BasicObstacleSide(vertexEvent.get_Site(), highNborSide);
            var lowNborEndpointIsOverlapped = this.IntersectionAtSideIsInsideAnotherObstacle$$BasicObstacleSide$$Obstacle$$Point(lowNborSide, vertexEvent.get_Obstacle(), lowNborIntersect);
            if (!lowNborEndpointIsOverlapped && (lowNborSide == lowOverlapSide)){
                this.AddSegment(lowNborIntersect, highNborIntersect, obstacle, lowNborSide, highNborSide, vertexEvent, 1);
                return;
            }
            var highOverlapIntersect = (highOverlapSide == highNborSide) ? highNborIntersect : this.ScanLineIntersectSide$$Point$$BasicObstacleSide(vertexEvent.get_Site(), highOverlapSide);
            var lowOverlapIntersect = (lowOverlapSide == lowNborSide) ? lowNborIntersect : this.ScanLineIntersectSide$$Point$$BasicObstacleSide(vertexEvent.get_Site(), lowOverlapSide);
            if (!lowNborEndpointIsOverlapped){
                this.AddSegment(lowNborIntersect, lowOverlapIntersect, obstacle, lowNborSide, lowOverlapSide, vertexEvent, 1);
                this.AddSegment(lowOverlapIntersect, highOverlapIntersect, obstacle, lowOverlapSide, highOverlapSide, vertexEvent, 500);
                if (highOverlapSide != highNborSide){
                    this.AddSegment(highOverlapIntersect, highNborIntersect, obstacle, highOverlapSide, highNborSide, vertexEvent, 1);
                }
            }
            else {
                this.AddSegment(lowNborIntersect, highOverlapIntersect, obstacle, lowNborSide, highOverlapSide, vertexEvent, 500);
                if (highOverlapSide != highNborSide){
                    this.AddSegment(highOverlapIntersect, highNborIntersect, obstacle, highOverlapSide, highNborSide, vertexEvent, 1);
                }
            }
        },
        CreateScanSegments$$Obstacle$$NeighborSides$$BasicVertexEvent: function (obstacle, neighborSides, vertexEvent){
            this.CreateScanSegments$$Obstacle$$HighObstacleSide$$BasicObstacleSide$$BasicObstacleSide$$LowObstacleSide$$BasicVertexEvent(obstacle, Cast(neighborSides.get_LowNeighbor().Item, Microsoft.Msagl.Routing.Rectilinear.HighObstacleSide.ctor), (null == neighborSides.get_LowOverlapEnd()) ? null : neighborSides.get_LowOverlapEnd().Item, (null == neighborSides.get_HighOverlapEnd()) ? null : neighborSides.get_HighOverlapEnd().Item, Cast(neighborSides.get_HighNeighbor().Item, Microsoft.Msagl.Routing.Rectilinear.LowObstacleSide.ctor), vertexEvent);
        },
        CreateScanSegmentFromLowSide: function (lowSideNode, vertexEvent){
            this.CreateScanSegments$$Obstacle$$NeighborSides$$BasicVertexEvent(lowSideNode.Item.get_Obstacle(), this.LowNeighborSides, vertexEvent);
        },
        CreateScanSegmentFromHighSide: function (highSideNode, vertexEvent){
            this.CreateScanSegments$$Obstacle$$NeighborSides$$BasicVertexEvent(highSideNode.Item.get_Obstacle(), this.HighNeighborSides, vertexEvent);
        },
        ProcessVertexEvent: function (lowSideNode, highSideNode, vertexEvent){
            this.CreateScanSegmentFromLowSide(lowSideNode, vertexEvent);
            if (this.LowNeighborSides.get_HighNeighbor().Item != this.HighNeighborSides.get_HighNeighbor().Item){
                this.CreateScanSegmentFromHighSide(highSideNode, vertexEvent);
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$FullVisibilityGraphGenerator);
var Microsoft$Msagl$Routing$Rectilinear$VisibilityGraphGenerator = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.SentinelOffset = 1;
        },
        NewVisibilityGraph: function (){
            return (function (){
                var $v70 = new Microsoft.Msagl.Routing.Visibility.VisibilityGraph.ctor();
                $v70.set_VertexFactory((function (point){
                    return new Microsoft.Msagl.Routing.Rectilinear.VisibilityVertexRectilinear.ctor(point);
                }));
                return $v70;
            })();
        },
        Debug_AssertGraphIsRectilinear: function (graph, obstacleTree){
            if (System.Linq.Enumerable.Any$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor, graph.get_Edges(), function (edge){
                return !Microsoft.Msagl.Routing.Rectilinear.PointComparer.IsPureDirection$$Directions(Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(edge.get_SourcePoint(), edge.get_TargetPoint()));
            })){
                Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.Assert(false, "Generated VisibilityGraph contains non-rectilinear lines", obstacleTree, graph);
                return;
            }
        },
        ScanLineIntersectSide$$Point$$BasicObstacleSide$$ScanDirection: function (site, side, scanDir){
            System.Diagnostics.Debug.Assert$$Boolean$$String(!scanDir.IsFlat$$SegmentBase(side), "flat sides should not be in the scanline or encountered on lookahead scan");
            var dir = side.get_Direction();
            var intersect = side.get_Start().Clone();
            if (scanDir.get_IsHorizontal()){
                intersect.set_X(intersect.get_X() + (dir.get_X() / dir.get_Y()) * (site.get_Y() - side.get_Start().get_Y()));
                intersect.set_X(Microsoft.Msagl.Routing.Rectilinear.SpliceUtility.MungeIntersect(site.get_X(), intersect.get_X(), side.get_Start().get_X(), side.get_End().get_X()));
                intersect.set_Y(site.get_Y());
            }
            else {
                intersect.set_X(site.get_X());
                intersect.set_Y(intersect.get_Y() + (dir.get_Y() / dir.get_X()) * (site.get_X() - side.get_Start().get_X()));
                intersect.set_Y(Microsoft.Msagl.Routing.Rectilinear.SpliceUtility.MungeIntersect(site.get_Y(), intersect.get_Y(), side.get_Start().get_Y(), side.get_End().get_Y()));
            }
            return intersect;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (wantReflections){
            this.ScanDirection = null;
            this.eventQueue = null;
            this.HorizontalScanSegments = null;
            this.VerticalScanSegments = null;
            this.lookaheadScan = null;
            this.wantReflections = false;
            this.ObstacleTree = new Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.ctor();
            this.scanLine = null;
            this.CurrentGroupBoundaryCrossingMap = new Microsoft.Msagl.Routing.Rectilinear.GroupBoundaryCrossingMap.ctor();
            this.LowNeighborSides = new Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.NeighborSides.ctor();
            this.HighNeighborSides = new Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.NeighborSides.ctor();
            this._VisibilityGraph = null;
            System.Object.ctor.call(this);
            this.ScanDirection = Microsoft.Msagl.Routing.Rectilinear.ScanDirection.get_HorizontalInstance();
            this.eventQueue = new Microsoft.Msagl.Routing.Rectilinear.EventQueue.ctor();
            this.HorizontalScanSegments = new Microsoft.Msagl.Routing.Rectilinear.ScanSegmentTree.ctor(Microsoft.Msagl.Routing.Rectilinear.ScanDirection.get_HorizontalInstance());
            this.VerticalScanSegments = new Microsoft.Msagl.Routing.Rectilinear.ScanSegmentTree.ctor(Microsoft.Msagl.Routing.Rectilinear.ScanDirection.get_VerticalInstance());
            this.wantReflections = wantReflections;
        },
        VisibilityGraph$$: "Microsoft.Msagl.Routing.Visibility.VisibilityGraph",
        get_VisibilityGraph: function (){
            return this._VisibilityGraph;
        },
        set_VisibilityGraph: function (value){
            this._VisibilityGraph = value;
        },
        ParallelScanSegments$$: "Microsoft.Msagl.Routing.Rectilinear.ScanSegmentTree",
        get_ParallelScanSegments: function (){
            return this.ScanDirection.get_IsHorizontal() ? this.HorizontalScanSegments : this.VerticalScanSegments;
        },
        PerpendicularScanSegments$$: "Microsoft.Msagl.Routing.Rectilinear.ScanSegmentTree",
        get_PerpendicularScanSegments: function (){
            return this.ScanDirection.get_IsHorizontal() ? this.VerticalScanSegments : this.HorizontalScanSegments;
        },
        GenerateVisibilityGraph: function (){
            if (null == this.ObstacleTree.get_Root()){
                return;
            }
            this.InitializeEventQueue(Microsoft.Msagl.Routing.Rectilinear.ScanDirection.get_HorizontalInstance());
            if ((this.ObstacleTree.get_GraphBox().get_Left() <= (-1.79769313486232E+308)) || (this.ObstacleTree.get_GraphBox().get_Bottom() <= (-1.79769313486232E+308)) || (this.ObstacleTree.get_GraphBox().get_Right() >= (1.79769313486232E+308)) || (this.ObstacleTree.get_GraphBox().get_Top() >= (1.79769313486232E+308))){
                throw $CreateException(new System.InvalidOperationException.ctor$$String("One or more obstacle boundaries are out of range"), new Error());
            }
            var scanlineSentinelOrdinal = 1;
            var lowerCorner = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.ObstacleTree.get_GraphBox().get_Left() - 1, this.ObstacleTree.get_GraphBox().get_Bottom() - 1);
            var upperCorner = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.ObstacleTree.get_GraphBox().get_Left() - 1, this.ObstacleTree.get_GraphBox().get_Top() + 1);
            var sentinel = Microsoft.Msagl.Routing.Rectilinear.Obstacle.CreateSentinel(lowerCorner, upperCorner, this.ScanDirection, scanlineSentinelOrdinal++);
            this.scanLine.Insert(sentinel.get_ActiveHighSide(), this.ObstacleTree.get_GraphBox().get_LeftBottom());
            lowerCorner = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.ObstacleTree.get_GraphBox().get_Right() + 1, this.ObstacleTree.get_GraphBox().get_Bottom() - 1);
            upperCorner = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.ObstacleTree.get_GraphBox().get_Right() + 1, this.ObstacleTree.get_GraphBox().get_Top() + 1);
            sentinel = Microsoft.Msagl.Routing.Rectilinear.Obstacle.CreateSentinel(lowerCorner, upperCorner, this.ScanDirection, scanlineSentinelOrdinal++);
            this.scanLine.Insert(sentinel.get_ActiveLowSide(), this.ObstacleTree.get_GraphBox().get_LeftBottom());
            this.ProcessEvents();
            this.InitializeEventQueue(Microsoft.Msagl.Routing.Rectilinear.ScanDirection.get_VerticalInstance());
            lowerCorner = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.ObstacleTree.get_GraphBox().get_Left() - 1, this.ObstacleTree.get_GraphBox().get_Bottom() - 1);
            upperCorner = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.ObstacleTree.get_GraphBox().get_Right() + 1, this.ObstacleTree.get_GraphBox().get_Bottom() - 1);
            sentinel = Microsoft.Msagl.Routing.Rectilinear.Obstacle.CreateSentinel(lowerCorner, upperCorner, this.ScanDirection, scanlineSentinelOrdinal++);
            this.scanLine.Insert(sentinel.get_ActiveHighSide(), this.ObstacleTree.get_GraphBox().get_LeftBottom());
            lowerCorner = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.ObstacleTree.get_GraphBox().get_Left() - 1, this.ObstacleTree.get_GraphBox().get_Top() + 1);
            upperCorner = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.ObstacleTree.get_GraphBox().get_Right() + 1, this.ObstacleTree.get_GraphBox().get_Top() + 1);
            sentinel = Microsoft.Msagl.Routing.Rectilinear.Obstacle.CreateSentinel(lowerCorner, upperCorner, this.ScanDirection, scanlineSentinelOrdinal);
            this.scanLine.Insert(sentinel.get_ActiveLowSide(), this.ObstacleTree.get_GraphBox().get_LeftBottom());
            this.ProcessEvents();
        },
        GetOpenVertex: function (poly){
            var lowest = poly.get_StartPoint();
            var next = this.TraversePolylineForEvents(lowest);
            var iPrevCmp = this.PointCompare(next.get_Point(), lowest.get_Point());
            for (; ; next = this.TraversePolylineForEvents(next)){
                var iCurCmp = this.PointCompare(next.get_Point(), lowest.get_Point());
                if (iCurCmp <= 0){
                    lowest = next;
                }
                else if ((iCurCmp > 0) && (iPrevCmp <= 0)){
                    break;
                }
                iPrevCmp = iCurCmp;
            }
            return lowest;
        },
        TraversePolylineForEvents: function (polyPoint){
            if (this.ScanDirection.get_IsHorizontal()){
                return polyPoint.get_NextOnPolyline();
            }
            return polyPoint.get_PrevOnPolyline();
        },
        InitializeEventQueue: function (scanDir){
            this.ScanDirection = scanDir;
            this.eventQueue.Reset(this.ScanDirection);
            this.EnqueueBottomVertexEvents();
            this.scanLine = new Microsoft.Msagl.Routing.Rectilinear.RectilinearScanLine.ctor(this.ScanDirection, this.ObstacleTree.get_GraphBox().get_LeftBottom());
            this.lookaheadScan = new Microsoft.Msagl.Routing.Rectilinear.LookaheadScan.ctor(this.ScanDirection);
        },
        EnqueueBottomVertexEvents: function (){
            var $it371 = this.ObstacleTree.GetAllPrimaryObstacles().GetEnumerator();
            while ($it371.MoveNext()){
                var obstacle = $it371.get_Current();
                var bottomVertex = this.GetOpenVertex(obstacle.get_VisibilityPolyline());
                this.eventQueue.Enqueue(new Microsoft.Msagl.Routing.Rectilinear.OpenVertexEvent.ctor(obstacle, bottomVertex));
            }
        },
        IsFlat: function (side){
            return this.ScanDirection.IsFlat$$SegmentBase(side);
        },
        IsPerpendicular: function (side){
            return this.ScanDirection.IsPerpendicular$$SegmentBase(side);
        },
        ScanLineIntersectSide$$Point$$BasicObstacleSide: function (site, side){
            return Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.ScanLineIntersectSide$$Point$$BasicObstacleSide$$ScanDirection(site, side, this.ScanDirection);
        },
        SideReflectsUpward: function (side){
            if (Is(side, Microsoft.Msagl.Routing.Rectilinear.LowObstacleSide.ctor)){
                return this.ScanDirection.Coord(side.get_End()) > this.ScanDirection.Coord(side.get_Start());
            }
            return this.ScanDirection.Coord(side.get_End()) < this.ScanDirection.Coord(side.get_Start());
        },
        SideReflectsDownward: function (side){
            if (Is(side, Microsoft.Msagl.Routing.Rectilinear.LowObstacleSide.ctor)){
                return this.ScanDirection.Coord(side.get_End()) < this.ScanDirection.Coord(side.get_Start());
            }
            return this.ScanDirection.Coord(side.get_End()) > this.ScanDirection.Coord(side.get_Start());
        },
        StoreLookaheadSite: function (initialObstacle, reflectingSide, reflectionSite, wantExtreme){
            if (!this.wantReflections){
                return;
            }
            if (!this.IsPerpendicular(reflectingSide)){
                if (!wantExtreme && !Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.PointIsInRectangleInterior(reflectionSite, reflectingSide.get_Obstacle().get_VisibilityBoundingBox())){
                    return;
                }
                if (this.SideReflectsUpward(reflectingSide)){
                    if (null == this.lookaheadScan.Find(reflectionSite)){
                        this.lookaheadScan.Add(new Microsoft.Msagl.Routing.Rectilinear.BasicReflectionEvent.ctor$$Obstacle$$Obstacle$$Point(initialObstacle, reflectingSide.get_Obstacle(), reflectionSite));
                    }
                    else {
                    }
                }
            }
        },
        LoadReflectionEvents$$BasicObstacleSide: function (sideToQueue){
            this.LoadReflectionEvents$$BasicObstacleSide$$BasicObstacleSide(sideToQueue, sideToQueue);
        },
        LoadReflectionEvents$$BasicObstacleSide$$BasicObstacleSide: function (sideToQueue, sideWithRange){
            if ((null == sideToQueue) || this.SideReflectsUpward(sideToQueue) || this.IsPerpendicular(sideToQueue)){
                return;
            }
            var bbox1 = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(sideToQueue.get_Start(), sideToQueue.get_End());
            var bbox2 = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(sideWithRange.get_Start(), sideWithRange.get_End());
            if ((this.ScanDirection.get_IsHorizontal()) ? !bbox1.IntersectsOnX(bbox2) : !bbox1.IntersectsOnY(bbox2)){
                return;
            }
            var bboxIntersect = Microsoft.Msagl.Core.Geometry.Rectangle.Intersect(bbox1, bbox2);
            var low = bboxIntersect.get_LeftBottom();
            var high = bboxIntersect.get_RightTop();
            var lookaheadSiteNode = this.lookaheadScan.FindFirstInRange(low, high);
            while (null != lookaheadSiteNode){
                var intersect = Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.ScanLineIntersectSide$$Point$$BasicObstacleSide$$ScanDirection(lookaheadSiteNode.Item.get_Site(), sideToQueue, this.ScanDirection.get_PerpendicularInstance());
                if (this.ScanDirection.ComparePerpCoord(intersect, lookaheadSiteNode.Item.get_Site()) > 0){
                    this.AddReflectionEvent(lookaheadSiteNode.Item, sideToQueue, intersect);
                }
                else {
                    if (lookaheadSiteNode.Item.get_ReflectingObstacle() != sideToQueue.get_Obstacle()){
                        this.lookaheadScan.MarkStaleSite(lookaheadSiteNode.Item);
                    }
                    else {
                    }
                }
                lookaheadSiteNode = this.lookaheadScan.FindNextInRange(lookaheadSiteNode, high);
            }
            this.lookaheadScan.RemoveStaleSites();
        },
        AddPerpendicularReflectionSegment: function (currentEvent, eventSide, nborSide){
            System.Diagnostics.Debug.Assert$$Boolean$$String(null != eventSide, "eventSide should not be null");
            if (this.lookaheadScan.RemoveExact(currentEvent.get_PreviousSite())){
                System.Diagnostics.Debug.Assert$$Boolean$$String(currentEvent.get_InitialObstacle() == currentEvent.get_PreviousSite().get_ReflectingObstacle(), "Inconsistency: currentEvent.InitialObstacle != currentEvent.PreviousSite.ReflectingObstacle");
                if (null == eventSide){
                    return false;
                }
                System.Diagnostics.Debug.Assert$$Boolean$$String(!this.IsFlat(eventSide), "Flat sides should not be encountered in reflections");
                if (currentEvent.get_PreviousSite().IsStaircaseStep(currentEvent.get_ReflectingObstacle())){
                    if (!Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.PointIsInRectangleInterior(currentEvent.get_Site(), currentEvent.get_ReflectingObstacle().get_VisibilityBoundingBox())){
                        return false;
                    }
                    if (!this.InsertPerpendicularReflectionSegment(currentEvent.get_PreviousSite().get_Site(), currentEvent.get_Site())){
                        return false;
                    }
                    if ((null != nborSide) && currentEvent.IsStaircaseStep(nborSide.get_Obstacle())){
                        return this.ScanLineCrossesObstacle(currentEvent.get_Site(), nborSide.get_Obstacle());
                    }
                }
                else {
                }
            }
            else {
            }
            return false;
        },
        AddParallelReflectionSegment: function (eventObstacle, lowNborSide, highNborSide, action){
            var intersect = this.ScanLineIntersectSide$$Point$$BasicObstacleSide(action.get_Site(), (lowNborSide != null ? lowNborSide : highNborSide));
            var start = (null != lowNborSide) ? intersect : action.get_Site();
            var end = (null != lowNborSide) ? action.get_Site() : intersect;
            if (null == lowNborSide){
                lowNborSide = this.scanLine.NextLow$$BasicObstacleSide(highNborSide).Item;
            }
            else {
                highNborSide = this.scanLine.NextHigh$$BasicObstacleSide(lowNborSide).Item;
            }
            return this.InsertParallelReflectionSegment(start, end, eventObstacle, lowNborSide, highNborSide, action);
        },
        AddReflectionEvent: function (previousSite, side, site){
            System.Diagnostics.Debug.Assert$$Boolean$$String(null != this.scanLine.Find(side), "AddReflectionEvent could not find \'side\' in the scanline");
            var lowSide = As(side, Microsoft.Msagl.Routing.Rectilinear.LowObstacleSide.ctor);
            if (lowSide != null){
                this.eventQueue.Enqueue(new Microsoft.Msagl.Routing.Rectilinear.LowReflectionEvent.ctor(previousSite, lowSide, site));
            }
            else {
                this.eventQueue.Enqueue(new Microsoft.Msagl.Routing.Rectilinear.HighReflectionEvent.ctor(previousSite, Cast(side, Microsoft.Msagl.Routing.Rectilinear.HighObstacleSide.ctor), site));
            }
        },
        AddSideToScanLine: function (side, scanPos){
            var node = this.scanLine.Insert(side, scanPos);
            this.LoadReflectionEvents$$BasicObstacleSide(side);
            return node;
        },
        RemoveSideFromScanLine: function (sideNode, scanPos){
            this.scanLine.Remove(sideNode.Item, scanPos);
        },
        PointCompare: function (lhs, rhs){
            return this.ScanDirection.Compare(lhs, rhs);
        },
        Clear: function (){
            this.ObstacleTree.Clear();
            this.eventQueue = new Microsoft.Msagl.Routing.Rectilinear.EventQueue.ctor();
            this.HorizontalScanSegments = new Microsoft.Msagl.Routing.Rectilinear.ScanSegmentTree.ctor(Microsoft.Msagl.Routing.Rectilinear.ScanDirection.get_HorizontalInstance());
            this.VerticalScanSegments = new Microsoft.Msagl.Routing.Rectilinear.ScanSegmentTree.ctor(Microsoft.Msagl.Routing.Rectilinear.ScanDirection.get_VerticalInstance());
            this.set_VisibilityGraph(null);
        },
        ProcessEvents: function (){
            while (this.eventQueue.get_Count() > 0){
                var evt = this.eventQueue.Dequeue();
                if (Is(evt, Microsoft.Msagl.Routing.Rectilinear.OpenVertexEvent.ctor)){
                    this.ProcessEvent$$OpenVertexEvent(As(evt, Microsoft.Msagl.Routing.Rectilinear.OpenVertexEvent.ctor));
                }
                else if (Is(evt, Microsoft.Msagl.Routing.Rectilinear.LowBendVertexEvent.ctor)){
                    this.ProcessEvent$$LowBendVertexEvent(As(evt, Microsoft.Msagl.Routing.Rectilinear.LowBendVertexEvent.ctor));
                }
                else if (Is(evt, Microsoft.Msagl.Routing.Rectilinear.HighBendVertexEvent.ctor)){
                    this.ProcessEvent$$HighBendVertexEvent(As(evt, Microsoft.Msagl.Routing.Rectilinear.HighBendVertexEvent.ctor));
                }
                else if (Is(evt, Microsoft.Msagl.Routing.Rectilinear.CloseVertexEvent.ctor)){
                    this.ProcessEvent$$CloseVertexEvent(As(evt, Microsoft.Msagl.Routing.Rectilinear.CloseVertexEvent.ctor));
                }
                else if (Is(evt, Microsoft.Msagl.Routing.Rectilinear.LowReflectionEvent.ctor)){
                    this.ProcessEvent$$LowReflectionEvent(As(evt, Microsoft.Msagl.Routing.Rectilinear.LowReflectionEvent.ctor));
                }
                else if (Is(evt, Microsoft.Msagl.Routing.Rectilinear.HighReflectionEvent.ctor)){
                    this.ProcessEvent$$HighReflectionEvent(As(evt, Microsoft.Msagl.Routing.Rectilinear.HighReflectionEvent.ctor));
                }
                else {
                    this.ProcessCustomEvent(evt);
                }
                this.LowNeighborSides.Clear();
                this.HighNeighborSides.Clear();
            }
            System.Diagnostics.Debug.Assert$$Boolean$$String(2 == this.scanLine.get_Count(), "There are leftovers in the scanline");
        },
        ProcessCustomEvent: function (evt){
            System.Diagnostics.Debug.Assert$$Boolean$$String(false, "Unknown event type");
        },
        ScanLineCrossesObstacle: function (eventSite, obstacle){
            return (this.ScanDirection.ComparePerpCoord(eventSite, obstacle.get_VisibilityBoundingBox().get_LeftBottom()) > 0) && (this.ScanDirection.ComparePerpCoord(eventSite, obstacle.get_VisibilityBoundingBox().get_RightTop()) < 0);
        },
        FindInitialNeighborSides: function (sideNode, lowNborSideNode, highNborSideNode){
            lowNborSideNode.Value = this.scanLine.NextLow$$RBNode$1$BasicObstacleSide(sideNode);
            highNborSideNode.Value = this.scanLine.NextHigh$$RBNode$1$BasicObstacleSide(sideNode);
        },
        FindNeighbors$$BasicVertexEvent$$RBNode$1$BasicObstacleSide$$RBNode$1$BasicObstacleSide: function (vertexEvent, lowSideNode, highSideNode){
            this.LowNeighborSides.Clear();
            this.HighNeighborSides.Clear();
            this.FindNeighbors$$BasicVertexEvent$$RBNode$1$BasicObstacleSide$$NeighborSides(vertexEvent, lowSideNode, this.LowNeighborSides);
            this.FindNeighbors$$BasicVertexEvent$$RBNode$1$BasicObstacleSide$$NeighborSides(vertexEvent, highSideNode, this.HighNeighborSides);
        },
        FindNeighbors$$BasicVertexEvent$$RBNode$1$BasicObstacleSide$$NeighborSides: function (vertexEvent, sideNode, neighborSides){
            var sideReferencePoint = (Is(vertexEvent, Microsoft.Msagl.Routing.Rectilinear.OpenVertexEvent.ctor)) ? sideNode.Item.get_Start() : sideNode.Item.get_End();
            var initialLowNbor,initialHighNbor;
            (function (){
                var $1 = {
                    Value: initialLowNbor
                };
                var $2 = {
                    Value: initialHighNbor
                };
                var $res = this.FindInitialNeighborSides(sideNode, $1, $2);
                initialLowNbor = $1.Value;
                initialHighNbor = $2.Value;
                return $res;
            }).call(this);
            this.SkipToNeighbor(this.ScanDirection.get_OppositeDirection(), sideNode.Item, sideReferencePoint, initialLowNbor, neighborSides);
            this.SkipToNeighbor(this.ScanDirection.get_Direction(), sideNode.Item, sideReferencePoint, initialHighNbor, neighborSides);
        },
        SkipToNeighbor: function (nborSearchDir, side, sideReferencePoint, nborNode, neighborSides){
            var overlapSideNode = null;
            var interveningGroupSide = null;
            for (; ; nborNode = this.scanLine.Next$$Directions$$RBNode$1$BasicObstacleSide(nborSearchDir, nborNode)){
                if (nborNode.Item.get_Obstacle() == side.get_Obstacle()){
                    continue;
                }
                if (nborNode.Item.get_Obstacle().get_IsGroup()){
                    if (this.ProcessGroupSideEncounteredOnTraversalToNeighbor(nborNode, sideReferencePoint, nborSearchDir)){
                        if (null == interveningGroupSide){
                            interveningGroupSide = nborNode.Item;
                        }
                    }
                    continue;
                }
                if ((Is(nborNode.Item, Microsoft.Msagl.Routing.Rectilinear.HighObstacleSide.ctor)) == Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsAscending$$Directions(nborSearchDir)){
                    if (this.ScanLineCrossesObstacle(sideReferencePoint, nborNode.Item.get_Obstacle())){
                        overlapSideNode = nborNode;
                        interveningGroupSide = null;
                    }
                    continue;
                }
                break;
            }
            neighborSides.SetSides(nborSearchDir, nborNode, overlapSideNode, interveningGroupSide);
        },
        ProcessGroupSideEncounteredOnTraversalToNeighbor: function (nborNode, sideReferencePoint, nborSearchDir){
            if (!this.ScanLineCrossesObstacle(sideReferencePoint, nborNode.Item.get_Obstacle())){
                return false;
            }
            var dirToInsideOfGroup = ((Is(nborNode.Item, Microsoft.Msagl.Routing.Rectilinear.LowObstacleSide.ctor)) == Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsAscending$$Directions(nborSearchDir)) ? nborSearchDir : Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(nborSearchDir);
            var intersect = this.ScanLineIntersectSide$$Point$$BasicObstacleSide(sideReferencePoint, nborNode.Item);
            this.CurrentGroupBoundaryCrossingMap.AddIntersection(intersect, nborNode.Item.get_Obstacle(), dirToInsideOfGroup);
            return true;
        },
        FindNeighborsAndProcessVertexEvent: function (lowSideNode, highSideNode, vertexEvent){
            this.CurrentGroupBoundaryCrossingMap.Clear();
            this.FindNeighbors$$BasicVertexEvent$$RBNode$1$BasicObstacleSide$$RBNode$1$BasicObstacleSide(vertexEvent, lowSideNode, highSideNode);
            this.ProcessVertexEvent(lowSideNode, highSideNode, vertexEvent);
            this.CurrentGroupBoundaryCrossingMap.Clear();
        },
        DevTrace_DumpScanSegmentsDuringAdd: function (verboseLevel){
        },
        ProcessEvent$$OpenVertexEvent: function (openVertEvent){
            var obstacle = openVertEvent.get_Obstacle();
            obstacle.CreateInitialSides(openVertEvent.get_Vertex(), this.ScanDirection);
            System.Diagnostics.Debug.Assert$$Boolean$$String(!this.IsFlat(obstacle.get_ActiveLowSide()), "OpenVertexEvent ActiveLowSide should not be flat");
            System.Diagnostics.Debug.Assert$$Boolean$$String(!this.IsFlat(obstacle.get_ActiveHighSide()), "RemoveCollinearSides should have been called");
            this.AddSideToScanLine(obstacle.get_ActiveLowSide(), openVertEvent.get_Site());
            var highSideNode = this.AddSideToScanLine(obstacle.get_ActiveHighSide(), openVertEvent.get_Site());
            var lowSideNode = this.scanLine.Find(obstacle.get_ActiveLowSide());
            this.FindNeighborsAndProcessVertexEvent(lowSideNode, highSideNode, openVertEvent);
            var lowReflector = (this.LowNeighborSides.get_GroupSideInterveningBeforeLowNeighbor() != null ? this.LowNeighborSides.get_GroupSideInterveningBeforeLowNeighbor() : this.LowNeighborSides.get_LowNeighborSide());
            if (this.SideReflectsUpward(lowReflector)){
                this.LoadReflectionEvents$$BasicObstacleSide(obstacle.get_ActiveLowSide());
            }
            var highReflector = (this.HighNeighborSides.get_GroupSideInterveningBeforeHighNeighbor() != null ? this.HighNeighborSides.get_GroupSideInterveningBeforeHighNeighbor() : this.HighNeighborSides.get_HighNeighborSide());
            if (this.SideReflectsUpward(highReflector)){
                this.LoadReflectionEvents$$BasicObstacleSide(obstacle.get_ActiveHighSide());
            }
            if (Microsoft.Msagl.Core.Geometry.Point.op_Inequality(obstacle.get_ActiveHighSide().get_Start(), obstacle.get_ActiveLowSide().get_Start())){
                var tempSide = new Microsoft.Msagl.Routing.Rectilinear.HighObstacleSide.ctor(obstacle, openVertEvent.get_Vertex(), this.ScanDirection);
                this.lookaheadScan.RemoveSitesForFlatBottom(tempSide.get_Start(), tempSide.get_End());
            }
            this.EnqueueLowBendVertexEvent(obstacle.get_ActiveLowSide());
            this.EnqueueHighBendOrCloseVertexEvent(obstacle.get_ActiveHighSide());
        },
        ProcessEvent$$LowBendVertexEvent: function (lowVertEvent){
            var obstacle = lowVertEvent.get_Obstacle();
            var lowSide = new Microsoft.Msagl.Routing.Rectilinear.LowObstacleSide.ctor(obstacle, lowVertEvent.get_Vertex(), this.ScanDirection);
            if (this.ScanDirection.ComparePerpCoord(lowSide.get_End(), lowSide.get_Start()) > 0){
                this.RemoveSideFromScanLine(this.scanLine.Find(obstacle.get_ActiveLowSide()), lowVertEvent.get_Site());
                this.AddSideToScanLine(lowSide, lowVertEvent.get_Site());
                obstacle.set_ActiveLowSide(lowSide);
                this.EnqueueLowBendVertexEvent(lowSide);
            }
        },
        EnqueueLowBendVertexEvent: function (lowSide){
            this.eventQueue.Enqueue(new Microsoft.Msagl.Routing.Rectilinear.LowBendVertexEvent.ctor(lowSide.get_Obstacle(), lowSide.get_EndVertex()));
        },
        ProcessEvent$$HighBendVertexEvent: function (highVertEvent){
            var obstacle = highVertEvent.get_Obstacle();
            var highSide = new Microsoft.Msagl.Routing.Rectilinear.HighObstacleSide.ctor(obstacle, highVertEvent.get_Vertex(), this.ScanDirection);
            this.RemoveSideFromScanLine(this.scanLine.Find(obstacle.get_ActiveHighSide()), highVertEvent.get_Site());
            var highSideNode = this.AddSideToScanLine(highSide, highVertEvent.get_Site());
            obstacle.set_ActiveHighSide(highSide);
            this.EnqueueHighBendOrCloseVertexEvent(obstacle.get_ActiveHighSide());
            if (this.wantReflections && this.ScanDirection.get_IsHorizontal() && (highSide.get_Start().get_X() == obstacle.get_VisibilityBoundingBox().get_Right()) && this.SideReflectsUpward(highSide)){
                var nborSideNode = this.scanLine.NextHigh$$RBNode$1$BasicObstacleSide(highSideNode);
                if ((Is(nborSideNode.Item, Microsoft.Msagl.Routing.Rectilinear.LowObstacleSide.ctor)) && this.SideReflectsDownward(nborSideNode.Item)){
                    if (!obstacle.get_IsOverlapped() || !this.ObstacleTree.PointIsInsideAnObstacle$$Point$$ScanDirection(highSide.get_Start(), this.ScanDirection)){
                        this.StoreLookaheadSite(nborSideNode.Item.get_Obstacle(), highSide, highSide.get_Start(), true);
                        this.LoadReflectionEvents$$BasicObstacleSide(nborSideNode.Item);
                    }
                }
            }
        },
        EnqueueHighBendOrCloseVertexEvent: function (highSide){
            var obstacle = highSide.get_Obstacle();
            var nextHighSideEnd = this.ScanDirection.get_IsHorizontal() ? highSide.get_EndVertex().get_PrevOnPolyline() : highSide.get_EndVertex().get_NextOnPolyline();
            if (this.ScanDirection.ComparePerpCoord(nextHighSideEnd.get_Point(), highSide.get_End()) > 0){
                this.eventQueue.Enqueue(new Microsoft.Msagl.Routing.Rectilinear.HighBendVertexEvent.ctor(obstacle, highSide.get_EndVertex()));
            }
            else {
                this.eventQueue.Enqueue(new Microsoft.Msagl.Routing.Rectilinear.CloseVertexEvent.ctor(obstacle, highSide.get_EndVertex()));
            }
        },
        CreateCloseEventSegmentsAndFindNeighbors: function (closeVertEvent){
            var obstacle = closeVertEvent.get_Obstacle();
            var lowSideNode = this.scanLine.Find(obstacle.get_ActiveLowSide());
            var highSideNode = this.scanLine.Find(obstacle.get_ActiveHighSide());
            if (1 == this.scanLine.Compare(obstacle.get_ActiveLowSide(), obstacle.get_ActiveHighSide())){
                var temp = lowSideNode;
                lowSideNode = highSideNode;
                highSideNode = temp;
            }
            this.FindNeighborsAndProcessVertexEvent(lowSideNode, highSideNode, closeVertEvent);
            if (this.wantReflections && obstacle.get_IsOverlapped()){
                for (var nextNode = this.scanLine.NextHigh$$RBNode$1$BasicObstacleSide(lowSideNode); nextNode.Item != highSideNode.Item; nextNode = this.scanLine.NextHigh$$RBNode$1$BasicObstacleSide(nextNode)){
                    this.LoadReflectionEvents$$BasicObstacleSide(nextNode.Item);
                }
            }
            this.scanLine.Remove(obstacle.get_ActiveLowSide(), closeVertEvent.get_Site());
            this.scanLine.Remove(obstacle.get_ActiveHighSide(), closeVertEvent.get_Site());
        },
        ProcessEvent$$CloseVertexEvent: function (closeVertEvent){
            this.CreateCloseEventSegmentsAndFindNeighbors(closeVertEvent);
            var lowNborSide = Cast(this.LowNeighborSides.get_LowNeighbor().Item, Microsoft.Msagl.Routing.Rectilinear.HighObstacleSide.ctor);
            var highNborSide = Cast(this.HighNeighborSides.get_HighNeighbor().Item, Microsoft.Msagl.Routing.Rectilinear.LowObstacleSide.ctor);
            var obstacle = closeVertEvent.get_Obstacle();
            this.LoadReflectionEvents$$BasicObstacleSide(lowNborSide);
            this.LoadReflectionEvents$$BasicObstacleSide(highNborSide);
            obstacle.Close();
        },
        ProcessEvent$$LowReflectionEvent: function (lowIntEvent){
            var obstacle = lowIntEvent.get_Side().get_Obstacle();
            var lowNborSide = As(this.scanLine.NextLow$$BasicObstacleSide(lowIntEvent.get_Side()).Item, Microsoft.Msagl.Routing.Rectilinear.HighObstacleSide.ctor);
            if (this.AddPerpendicularReflectionSegment(lowIntEvent, lowIntEvent.get_Side(), lowNborSide)){
                if (this.AddParallelReflectionSegment(obstacle, lowNborSide, null, lowIntEvent)){
                    this.LoadReflectionEvents$$BasicObstacleSide(obstacle.get_ActiveLowSide());
                }
            }
        },
        ProcessEvent$$HighReflectionEvent: function (highIntEvent){
            var obstacle = highIntEvent.get_Side().get_Obstacle();
            var highNborSide = As(this.scanLine.NextHigh$$BasicObstacleSide(highIntEvent.get_Side()).Item, Microsoft.Msagl.Routing.Rectilinear.LowObstacleSide.ctor);
            if (this.AddPerpendicularReflectionSegment(highIntEvent, highIntEvent.get_Side(), highNborSide)){
                if (this.AddParallelReflectionSegment(obstacle, null, highNborSide, highIntEvent)){
                    this.LoadReflectionEvents$$BasicObstacleSide(obstacle.get_ActiveHighSide());
                }
            }
        },
        MakeInBoundsLocation: function (location){
            var xPos = System.Math.Max$$Double$$Double(location.get_X(), this.ObstacleTree.get_GraphBox().get_Left());
            var yPos = System.Math.Max$$Double$$Double(location.get_Y(), this.ObstacleTree.get_GraphBox().get_Bottom());
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(System.Math.Min$$Double$$Double(xPos, this.ObstacleTree.get_GraphBox().get_Right()), System.Math.Min$$Double$$Double(yPos, this.ObstacleTree.get_GraphBox().get_Top()));
        },
        IsInBounds$$VisibilityVertex: function (vertex){
            return this.IsInBounds$$Point(vertex.Point);
        },
        IsInBounds$$Point: function (p){
            return Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(p, this.MakeInBoundsLocation(p));
        },
        DevTraceInfoVgGen: function (verboseLevel, format, args){
        },
        DevTraceIfFlatSide: function (isObstacleOpen, lowEndpoint, highEndpoint){
        },
        DevTraceScanSegmentDump: function (verboseLevel){
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$VisibilityGraphGenerator);
var Microsoft$Msagl$Routing$Rectilinear$VisibilityGraphGenerator$NeighborSides = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.NeighborSides",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this._LowNeighbor = null;
            this._LowOverlapEnd = null;
            this._GroupSideInterveningBeforeLowNeighbor = null;
            this._HighNeighbor = null;
            this._HighOverlapEnd = null;
            this._GroupSideInterveningBeforeHighNeighbor = null;
            System.Object.ctor.call(this);
        },
        LowNeighbor$$: "Microsoft.Msagl.Core.DataStructures.RBNode`1[[Microsoft.Msagl.Routing.Rectilinear.BasicObstacleSide]]",
        get_LowNeighbor: function (){
            return this._LowNeighbor;
        },
        set_LowNeighbor: function (value){
            this._LowNeighbor = value;
        },
        LowNeighborSide$$: "Microsoft.Msagl.Routing.Rectilinear.BasicObstacleSide",
        get_LowNeighborSide: function (){
            return (null == this.get_LowNeighbor()) ? null : this.get_LowNeighbor().Item;
        },
        LowOverlapEnd$$: "Microsoft.Msagl.Core.DataStructures.RBNode`1[[Microsoft.Msagl.Routing.Rectilinear.BasicObstacleSide]]",
        get_LowOverlapEnd: function (){
            return this._LowOverlapEnd;
        },
        set_LowOverlapEnd: function (value){
            this._LowOverlapEnd = value;
        },
        GroupSideInterveningBeforeLowNeighbor$$: "Microsoft.Msagl.Routing.Rectilinear.BasicObstacleSide",
        get_GroupSideInterveningBeforeLowNeighbor: function (){
            return this._GroupSideInterveningBeforeLowNeighbor;
        },
        set_GroupSideInterveningBeforeLowNeighbor: function (value){
            this._GroupSideInterveningBeforeLowNeighbor = value;
        },
        HighNeighbor$$: "Microsoft.Msagl.Core.DataStructures.RBNode`1[[Microsoft.Msagl.Routing.Rectilinear.BasicObstacleSide]]",
        get_HighNeighbor: function (){
            return this._HighNeighbor;
        },
        set_HighNeighbor: function (value){
            this._HighNeighbor = value;
        },
        HighNeighborSide$$: "Microsoft.Msagl.Routing.Rectilinear.BasicObstacleSide",
        get_HighNeighborSide: function (){
            return (null == this.get_HighNeighbor()) ? null : this.get_HighNeighbor().Item;
        },
        HighOverlapEnd$$: "Microsoft.Msagl.Core.DataStructures.RBNode`1[[Microsoft.Msagl.Routing.Rectilinear.BasicObstacleSide]]",
        get_HighOverlapEnd: function (){
            return this._HighOverlapEnd;
        },
        set_HighOverlapEnd: function (value){
            this._HighOverlapEnd = value;
        },
        GroupSideInterveningBeforeHighNeighbor$$: "Microsoft.Msagl.Routing.Rectilinear.BasicObstacleSide",
        get_GroupSideInterveningBeforeHighNeighbor: function (){
            return this._GroupSideInterveningBeforeHighNeighbor;
        },
        set_GroupSideInterveningBeforeHighNeighbor: function (value){
            this._GroupSideInterveningBeforeHighNeighbor = value;
        },
        Clear: function (){
            this.set_LowNeighbor(null);
            this.set_LowOverlapEnd(null);
            this.set_GroupSideInterveningBeforeLowNeighbor(null);
            this.set_HighNeighbor(null);
            this.set_HighOverlapEnd(null);
            this.set_GroupSideInterveningBeforeHighNeighbor(null);
        },
        SetSides: function (dir, neighborNode, overlapEndNode, interveningGroupSide){
            if (Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsAscending$$Directions(dir)){
                this.set_HighNeighbor(neighborNode);
                this.set_HighOverlapEnd(overlapEndNode);
                this.set_GroupSideInterveningBeforeHighNeighbor(interveningGroupSide);
                return;
            }
            this.set_LowNeighbor(neighborNode);
            this.set_LowOverlapEnd(overlapEndNode);
            this.set_GroupSideInterveningBeforeLowNeighbor(interveningGroupSide);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$VisibilityGraphGenerator$NeighborSides);
var Microsoft$Msagl$Routing$Rectilinear$OverlapConvexHull = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.OverlapConvexHull",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (polyline, obstacles){
            this._Polyline = null;
            this._PrimaryObstacle = null;
            this._Obstacles = null;
            System.Object.ctor.call(this);
            this.set_Polyline(polyline);
            this.set_Obstacles(System.Linq.Enumerable.ToList$1(Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor, obstacles));
            this.set_PrimaryObstacle(this.get_Obstacles().get_Item$$Int32(0));
            Microsoft.Msagl.Routing.Rectilinear.Obstacle.RoundVertices(this.get_Polyline());
        },
        Polyline$$: "Microsoft.Msagl.Core.Geometry.Curves.Polyline",
        get_Polyline: function (){
            return this._Polyline;
        },
        set_Polyline: function (value){
            this._Polyline = value;
        },
        PrimaryObstacle$$: "Microsoft.Msagl.Routing.Rectilinear.Obstacle",
        get_PrimaryObstacle: function (){
            return this._PrimaryObstacle;
        },
        set_PrimaryObstacle: function (value){
            this._PrimaryObstacle = value;
        },
        Obstacles$$: "System.Collections.Generic.List`1[[Microsoft.Msagl.Routing.Rectilinear.Obstacle]]",
        get_Obstacles: function (){
            return this._Obstacles;
        },
        set_Obstacles: function (value){
            this._Obstacles = value;
        },
        toString: function (){
            return this.get_Polyline().toString();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$OverlapConvexHull);
var Microsoft$Msagl$Routing$Rectilinear$SparseVisibilityGraphGenerator = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator",
    baseTypeName: "Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator",
    staticDefinition: {
        cctor: function (){
        },
        GetBoundingCorners: function (boundingBox, isLowSide, isHorizontal, lowCorner, highCorner){
            if (isLowSide){
                lowCorner.Value = boundingBox.get_LeftBottom();
                highCorner.Value = isHorizontal ? boundingBox.get_RightBottom() : boundingBox.get_LeftTop();
                return;
            }
            lowCorner.Value = isHorizontal ? boundingBox.get_LeftTop() : boundingBox.get_RightBottom();
            highCorner.Value = boundingBox.get_RightTop();
        },
        FindIntersectingSlot: function (segmentVector, coordMap, site, directionIfMiss){
            var coord = segmentVector.GetParallelCoord(site);
            var slot;
            if ((function (){
                var $1 = {
                    Value: slot
                };
                var $res = coordMap.TryGetValue(coord, $1);
                slot = $1.Value;
                return $res;
            })()){
                return slot;
            }
            return (0 == directionIfMiss) ? -1 : segmentVector.FindNearest(coord, directionIfMiss);
        },
        CreateScanSegmentTree: function (segmentVector, segmentTree){
            var $it376 = segmentVector.get_Items().GetEnumerator();
            while ($it376.MoveNext()){
                var item = $it376.get_Current();
                for (var segment = item.FirstSegment; segment != null; segment = segment.get_NextSegment()){
                    if (segment.HasVisibility()){
                        segmentTree.InsertUnique(segment);
                    }
                }
            }
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.horizontalVertexPoints = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            this.verticalVertexPoints = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            this.boundingBoxSteinerPoints = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            this.xCoordAccumulator = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(System.Double.ctor);
            this.yCoordAccumulator = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(System.Double.ctor);
            this.horizontalScanSegmentVector = null;
            this.verticalScanSegmentVector = null;
            this.horizontalCoordMap = new System.Collections.Generic.Dictionary$2.ctor(System.Double.ctor, System.Int32.ctor);
            this.verticalCoordMap = new System.Collections.Generic.Dictionary$2.ctor(System.Double.ctor, System.Int32.ctor);
            this.perpendicularCoordMap = null;
            this.parallelSegmentVector = null;
            this.perpendicularSegmentVector = null;
            this.currentAxisPointComparer = null;
            Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.ctor.call(this, false);
        },
        Clear: function (){
            Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.commonPrototype.Clear.call(this);
            this.Cleanup();
        },
        Cleanup: function (){
            this.horizontalVertexPoints.Clear();
            this.verticalVertexPoints.Clear();
            this.boundingBoxSteinerPoints.Clear();
            this.xCoordAccumulator.Clear();
            this.yCoordAccumulator.Clear();
            this.horizontalCoordMap.Clear();
            this.verticalCoordMap.Clear();
        },
        GenerateVisibilityGraph: function (){
            this.AccumulateVertexCoords();
            this.CreateSegmentVectorsAndPopulateCoordinateMaps();
            this.RunScanLineToCreateSegmentsAndBoundingBoxSteinerPoints();
            this.GenerateSparseIntersectionsFromVertexPoints();
            this.CreateScanSegmentTrees();
            Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.Debug_AssertGraphIsRectilinear(this.get_VisibilityGraph(), this.ObstacleTree);
            this.Cleanup();
        },
        AccumulateVertexCoords: function (){
            var $it372 = this.ObstacleTree.GetAllObstacles().GetEnumerator();
            while ($it372.MoveNext()){
                var obstacle = $it372.get_Current();
                this.xCoordAccumulator.Insert(obstacle.get_VisibilityBoundingBox().get_Left());
                this.xCoordAccumulator.Insert(obstacle.get_VisibilityBoundingBox().get_Right());
                this.yCoordAccumulator.Insert(obstacle.get_VisibilityBoundingBox().get_Top());
                this.yCoordAccumulator.Insert(obstacle.get_VisibilityBoundingBox().get_Bottom());
            }
        },
        CreateSegmentVectorsAndPopulateCoordinateMaps: function (){
            this.horizontalScanSegmentVector = new Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVector.ctor(this.yCoordAccumulator, true);
            this.verticalScanSegmentVector = new Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVector.ctor(this.xCoordAccumulator, false);
            for (var slot = 0; slot < this.horizontalScanSegmentVector.get_Length(); ++slot){
                this.horizontalCoordMap.set_Item$$TKey(this.horizontalScanSegmentVector.get_Item$$Int32(slot).get_Coord(), slot);
            }
            for (var slot = 0; slot < this.verticalScanSegmentVector.get_Length(); ++slot){
                this.verticalCoordMap.set_Item$$TKey(this.verticalScanSegmentVector.get_Item$$Int32(slot).get_Coord(), slot);
            }
        },
        RunScanLineToCreateSegmentsAndBoundingBoxSteinerPoints: function (){
            Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.commonPrototype.GenerateVisibilityGraph.call(this);
            this.horizontalScanSegmentVector.ScanSegmentsComplete();
            this.verticalScanSegmentVector.ScanSegmentsComplete();
            this.xCoordAccumulator.Clear();
            this.yCoordAccumulator.Clear();
        },
        InitializeEventQueue: function (scanDir){
            Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.commonPrototype.InitializeEventQueue.call(this, scanDir);
            this.SetVectorsAndCoordMaps(scanDir);
            this.AddAxisCoordinateEvents(scanDir);
        },
        AddAxisCoordinateEvents: function (scanDir){
            if (scanDir.get_IsHorizontal()){
                var $it373 = this.yCoordAccumulator.GetEnumerator();
                while ($it373.MoveNext()){
                    var coord = $it373.get_Current();
                    this.eventQueue.Enqueue(new Microsoft.Msagl.Routing.Rectilinear.AxisCoordinateEvent.ctor(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.ObstacleTree.get_GraphBox().get_Left() - 1, coord)));
                }
                return;
            }
            var $it374 = this.xCoordAccumulator.GetEnumerator();
            while ($it374.MoveNext()){
                var coord = $it374.get_Current();
                this.eventQueue.Enqueue(new Microsoft.Msagl.Routing.Rectilinear.AxisCoordinateEvent.ctor(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(coord, this.ObstacleTree.get_GraphBox().get_Bottom() - 1)));
            }
        },
        ProcessCustomEvent: function (evt){
            if (!this.ProcessAxisCoordinate(evt)){
                Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.commonPrototype.ProcessCustomEvent.call(this, evt);
            }
        },
        ProcessAxisCoordinate: function (evt){
            var axisEvent = As(evt, Microsoft.Msagl.Routing.Rectilinear.AxisCoordinateEvent.ctor);
            if (null != axisEvent){
                this.CreateScanSegmentsOnAxisCoordinate(axisEvent.get_Site());
                return true;
            }
            return false;
        },
        InsertPerpendicularReflectionSegment: function (start, end){
            System.Diagnostics.Debug.Assert$$Boolean$$String(false, "base.wantReflections is false in Sparse mode so this should never be called");
            return false;
        },
        InsertParallelReflectionSegment: function (start, end, eventObstacle, lowNborSide, highNborSide, action){
            System.Diagnostics.Debug.Assert$$Boolean$$String(false, "base.wantReflections is false in Sparse mode so this should never be called");
            return false;
        },
        ProcessVertexEvent: function (lowSideNode, highSideNode, vertexEvent){
            var vertexPoints = (this.ScanDirection.get_IsHorizontal()) ? this.horizontalVertexPoints : this.verticalVertexPoints;
            vertexPoints.Insert(vertexEvent.get_Site());
            var lowNborSide = this.LowNeighborSides.get_LowNeighbor().Item;
            var highNborSide = this.HighNeighborSides.get_HighNeighbor().Item;
            var highDir = this.ScanDirection.get_Direction();
            var lowDir = this.ScanDirection.get_OppositeDirection();
            var lowSteiner = this.ScanLineIntersectSide$$Point$$BasicObstacleSide(vertexEvent.get_Site(), lowNborSide);
            var highSteiner = this.ScanLineIntersectSide$$Point$$BasicObstacleSide(vertexEvent.get_Site(), highNborSide);
            if (this.ObstacleTree.get_GraphBox().Contains$$Point(lowSteiner)){
                var bboxIntersectBeforeLowSteiner = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.RectangleBorderIntersect(lowNborSide.get_Obstacle().get_VisibilityBoundingBox(), lowSteiner, highDir);
                if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.IsPureLower(bboxIntersectBeforeLowSteiner, vertexEvent.get_Site())){
                    this.boundingBoxSteinerPoints.Insert(bboxIntersectBeforeLowSteiner);
                }
            }
            if (this.ObstacleTree.get_GraphBox().Contains$$Point(highSteiner)){
                var bboxIntersectBeforeHighSteiner = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.RectangleBorderIntersect(highNborSide.get_Obstacle().get_VisibilityBoundingBox(), highSteiner, lowDir);
                if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.IsPureLower(vertexEvent.get_Site(), bboxIntersectBeforeHighSteiner)){
                    this.boundingBoxSteinerPoints.Insert(bboxIntersectBeforeHighSteiner);
                }
            }
            var lowCorner,highCorner;
            (function (){
                var $1 = {
                    Value: lowCorner
                };
                var $2 = {
                    Value: highCorner
                };
                var $res = Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.GetBoundingCorners(lowSideNode.Item.get_Obstacle().get_VisibilityBoundingBox(), Is(vertexEvent, Microsoft.Msagl.Routing.Rectilinear.OpenVertexEvent.ctor), this.ScanDirection.get_IsHorizontal(), $1, $2);
                lowCorner = $1.Value;
                highCorner = $2.Value;
                return $res;
            }).call(this);
            if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.IsPureLower(lowSteiner, lowCorner) || lowNborSide.get_Obstacle().IsInSameClump(vertexEvent.get_Obstacle())){
                vertexPoints.Insert(lowCorner);
            }
            if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.IsPureLower(highCorner, highSteiner) || highNborSide.get_Obstacle().IsInSameClump(vertexEvent.get_Obstacle())){
                vertexPoints.Insert(highCorner);
            }
        },
        CreateScanSegmentsOnAxisCoordinate: function (site){
            this.CurrentGroupBoundaryCrossingMap.Clear();
            var sideNode = this.scanLine.Lowest();
            var nextNode = this.scanLine.NextHigh$$RBNode$1$BasicObstacleSide(sideNode);
            var overlapDepth = 0;
            var start = site;
            var isInsideOverlappedObstacle = false;
            for (; null != nextNode; nextNode = this.scanLine.NextHigh$$RBNode$1$BasicObstacleSide(nextNode)){
                if (this.SkipSide(start, nextNode.Item)){
                    continue;
                }
                if (nextNode.Item.get_Obstacle().get_IsGroup()){
                    if ((overlapDepth == 0) || isInsideOverlappedObstacle){
                        this.HandleGroupCrossing(site, nextNode.Item);
                    }
                    continue;
                }
                var isLowSide = Is(nextNode.Item, Microsoft.Msagl.Routing.Rectilinear.LowObstacleSide.ctor);
                if (isLowSide){
                    if (overlapDepth > 0){
                        ++overlapDepth;
                        continue;
                    }
                    start = this.CreateScanSegment(start, nextNode.Item, 1);
                    this.CurrentGroupBoundaryCrossingMap.Clear();
                    overlapDepth = 1;
                    isInsideOverlappedObstacle = nextNode.Item.get_Obstacle().get_IsOverlapped();
                    continue;
                }
                System.Diagnostics.Debug.Assert$$Boolean$$String(overlapDepth > 0, "Overlap depth must be positive");
                --overlapDepth;
                if (overlapDepth > 0){
                    continue;
                }
                start = (nextNode.Item.get_Obstacle().get_IsOverlapped() || nextNode.Item.get_Obstacle().get_OverlapsGroupCorner()) ? this.CreateScanSegment(start, nextNode.Item, 500) : this.ScanLineIntersectSide$$Point$$BasicObstacleSide(start, nextNode.Item);
                this.CurrentGroupBoundaryCrossingMap.Clear();
                isInsideOverlappedObstacle = false;
            }
            var end = this.ScanDirection.get_IsHorizontal() ? new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.ObstacleTree.get_GraphBox().get_Right() + 1, start.get_Y()) : new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(start.get_X(), this.ObstacleTree.get_GraphBox().get_Top() + 1);
            this.parallelSegmentVector.CreateScanSegment(start, end, 1, this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(start, end));
            this.parallelSegmentVector.ScanSegmentsCompleteForCurrentSlot();
        },
        HandleGroupCrossing: function (site, groupSide){
            if (!Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.commonPrototype.ScanLineCrossesObstacle.call(this, site, groupSide.get_Obstacle())){
                return;
            }
            var dirToInsideOfGroup = (Is(groupSide, Microsoft.Msagl.Routing.Rectilinear.LowObstacleSide.ctor)) ? this.ScanDirection.get_Direction() : this.ScanDirection.get_OppositeDirection();
            var intersect = this.ScanLineIntersectSide$$Point$$BasicObstacleSide(site, groupSide);
            var crossing = this.CurrentGroupBoundaryCrossingMap.AddIntersection(intersect, groupSide.get_Obstacle(), dirToInsideOfGroup);
            this.AddPerpendicularCoordForGroupCrossing(intersect);
            var interiorPoint = crossing.GetInteriorVertexPoint(intersect);
            this.AddPerpendicularCoordForGroupCrossing(interiorPoint);
        },
        AddPerpendicularCoordForGroupCrossing: function (intersect){
            var nonCrossingPerpSlot = this.FindPerpendicularSlot(intersect, 0);
            if (-1 != nonCrossingPerpSlot){
                this.perpendicularSegmentVector.get_Item$$Int32(nonCrossingPerpSlot).AddPendingPerpendicularCoord(this.parallelSegmentVector.get_CurrentSlot().get_Coord());
            }
        },
        SkipSide: function (start, side){
            if (side.get_Obstacle().get_IsSentinel()){
                return true;
            }
            var bbox = side.get_Obstacle().get_VisibilityBoundingBox();
            if (this.ScanDirection.get_IsHorizontal()){
                return ((start.get_Y() == bbox.get_Bottom()) || (start.get_Y() == bbox.get_Top()));
            }
            return ((start.get_X() == bbox.get_Left()) || (start.get_X() == bbox.get_Right()));
        },
        CreateScanSegment: function (start, side, weight){
            var end = this.ScanLineIntersectSide$$Point$$BasicObstacleSide(start, side);
            if (Microsoft.Msagl.Core.Geometry.Point.op_Inequality(start, end)){
                this.parallelSegmentVector.CreateScanSegment(start, end, weight, this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(start, end));
            }
            return end;
        },
        GenerateSparseIntersectionsFromVertexPoints: function (){
            this.set_VisibilityGraph(Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.NewVisibilityGraph());
            this.GenerateSparseIntersectionsAlongHorizontalAxis();
            this.GenerateSparseIntersectionsAlongVerticalAxis();
            this.ConnectAdjoiningScanSegments();
            this.horizontalScanSegmentVector.CreateSparseVerticesAndEdges(this.get_VisibilityGraph());
            this.verticalScanSegmentVector.CreateSparseVerticesAndEdges(this.get_VisibilityGraph());
        },
        GenerateSparseIntersectionsAlongHorizontalAxis: function (){
            this.currentAxisPointComparer = new Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.HorizontalPointComparer.ctor();
            var vertexPoints = System.Linq.Enumerable.OrderBy$2$$IEnumerable$1$$Func$2$$IComparer$1(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, this.horizontalVertexPoints, $CreateAnonymousDelegate(this, function (point){
                return point;
            }), this.currentAxisPointComparer).GetEnumerator();
            var bboxSteinerPoints = new Microsoft.Msagl.Routing.Rectilinear.EnumeratorWrapper$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Linq.Enumerable.OrderBy$2$$IEnumerable$1$$Func$2$$IComparer$1(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, this.boundingBoxSteinerPoints, $CreateAnonymousDelegate(this, function (point){
                return point;
            }), this.currentAxisPointComparer));
            this.ScanDirection = Microsoft.Msagl.Routing.Rectilinear.ScanDirection.get_HorizontalInstance();
            this.SetVectorsAndCoordMaps(this.ScanDirection);
            this.GenerateSparseIntersections(vertexPoints, bboxSteinerPoints);
        },
        GenerateSparseIntersectionsAlongVerticalAxis: function (){
            this.currentAxisPointComparer = new Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.VerticalPointComparer.ctor();
            var vertexPoints = System.Linq.Enumerable.OrderBy$2$$IEnumerable$1$$Func$2$$IComparer$1(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, this.verticalVertexPoints, $CreateAnonymousDelegate(this, function (point){
                return point;
            }), this.currentAxisPointComparer).GetEnumerator();
            var bboxSteinerPoints = new Microsoft.Msagl.Routing.Rectilinear.EnumeratorWrapper$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Linq.Enumerable.OrderBy$2$$IEnumerable$1$$Func$2$$IComparer$1(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, this.boundingBoxSteinerPoints, $CreateAnonymousDelegate(this, function (point){
                return point;
            }), this.currentAxisPointComparer));
            this.ScanDirection = Microsoft.Msagl.Routing.Rectilinear.ScanDirection.get_VerticalInstance();
            this.SetVectorsAndCoordMaps(this.ScanDirection);
            this.GenerateSparseIntersections(vertexPoints, bboxSteinerPoints);
        },
        SetVectorsAndCoordMaps: function (scanDir){
            if (scanDir.get_IsHorizontal()){
                this.parallelSegmentVector = this.horizontalScanSegmentVector;
                this.perpendicularSegmentVector = this.verticalScanSegmentVector;
                this.perpendicularCoordMap = this.verticalCoordMap;
            }
            else {
                this.parallelSegmentVector = this.verticalScanSegmentVector;
                this.perpendicularSegmentVector = this.horizontalScanSegmentVector;
                this.perpendicularCoordMap = this.horizontalCoordMap;
            }
        },
        ConnectAdjoiningScanSegments: function (){
            this.horizontalScanSegmentVector.ConnectAdjoiningSegmentEndpoints();
            this.verticalScanSegmentVector.ConnectAdjoiningSegmentEndpoints();
        },
        GenerateSparseIntersections: function (vertexPoints, bboxSteinerPoints){
            this.perpendicularSegmentVector.ResetForIntersections();
            this.parallelSegmentVector.ResetForIntersections();
            vertexPoints.MoveNext();
            bboxSteinerPoints.MoveNext();
            var $it375 = this.parallelSegmentVector.get_Items().GetEnumerator();
            while ($it375.MoveNext()){
                var item = $it375.get_Current();
                for (; ;){
                    if (!item.CurrentSegment.ContainsPoint(vertexPoints.get_Current())){
                        if (!this.AddSteinerPointsToInterveningSegments(vertexPoints.get_Current(), bboxSteinerPoints, item) || !item.TraverseToSegmentContainingPoint(vertexPoints.get_Current())){
                            break;
                        }
                    }
                    this.AddPointsToCurrentSegmentIntersections(bboxSteinerPoints, item);
                    this.GenerateIntersectionsFromVertexPointForCurrentSegment(vertexPoints.get_Current(), item);
                    if (item.PointIsCurrentEndAndNextStart(vertexPoints.get_Current())){
                        item.MoveNext();
                        System.Diagnostics.Debug.Assert$$Boolean$$String(item.get_HasCurrent(), "MoveNext ended before EndAndNextStart");
                        continue;
                    }
                    if (!vertexPoints.MoveNext()){
                        System.Diagnostics.Debug.Assert$$Boolean$$String(!bboxSteinerPoints.get_HasCurrent(), "Some boundingBoxSteinerPoints remain");
                        return;
                    }
                }
            }
            System.Diagnostics.Debug.Assert$$Boolean$$String(false, "Mismatch in points and segments");
        },
        AddSteinerPointsToInterveningSegments: function (currentVertexPoint, bboxSteinerPoints, item){
            while (bboxSteinerPoints.get_HasCurrent() && (this.currentAxisPointComparer.Compare(bboxSteinerPoints.get_Current(), currentVertexPoint) == -1)){
                if (!item.TraverseToSegmentContainingPoint(bboxSteinerPoints.get_Current())){
                    return false;
                }
                this.AddPointsToCurrentSegmentIntersections(bboxSteinerPoints, item);
            }
            return true;
        },
        AddPointsToCurrentSegmentIntersections: function (pointsToAdd, parallelItem){
            for (; pointsToAdd.get_HasCurrent() && parallelItem.CurrentSegment.ContainsPoint(pointsToAdd.get_Current()); pointsToAdd.MoveNext()){
                var steinerSlot = this.FindPerpendicularSlot(pointsToAdd.get_Current(), 0);
                this.AddSlotToSegmentIntersections(parallelItem, steinerSlot);
            }
        },
        GenerateIntersectionsFromVertexPointForCurrentSegment: function (site, parallelItem){
            var perpStartSlot = this.FindPerpendicularSlot(parallelItem.CurrentSegment.get_Start(), 1);
            var perpEndSlot = this.FindPerpendicularSlot(parallelItem.CurrentSegment.get_End(), -1);
            var siteSlot = this.FindPerpendicularSlot(site, 0);
            if (perpStartSlot >= perpEndSlot){
                return;
            }
            this.AddSlotToSegmentIntersections(parallelItem, perpStartSlot);
            this.AddSlotToSegmentIntersections(parallelItem, perpEndSlot);
            if ((siteSlot > perpStartSlot) && (siteSlot < perpEndSlot)){
                this.AddSlotToSegmentIntersections(parallelItem, siteSlot);
                this.AddBinaryDivisionSlotsToSegmentIntersections(parallelItem, perpStartSlot, siteSlot, perpEndSlot);
            }
        },
        FindPerpendicularSlot: function (site, directionIfMiss){
            return Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.FindIntersectingSlot(this.perpendicularSegmentVector, this.perpendicularCoordMap, site, directionIfMiss);
        },
        AddSlotToSegmentIntersections: function (parallelItem, perpSlot){
            var perpItem = this.perpendicularSegmentVector.get_Item$$Int32(perpSlot);
            parallelItem.CurrentSegment.AddSparseVertexCoord(perpItem.get_Coord());
            perpItem.AddPerpendicularCoord(parallelItem.get_Coord());
        },
        AddBinaryDivisionSlotsToSegmentIntersections: function (parallelItem, startSlot, siteSlot, endSlot){
            var low = 0;
            var high = this.perpendicularSegmentVector.get_Length() - 1;
            while ((high - low) > 1){
                var mid = low + (((high - low) / 2) | 0);
                if (siteSlot <= mid){
                    high = mid;
                    if ((siteSlot < high) && (high <= endSlot)){
                        this.AddSlotToSegmentIntersections(parallelItem, high);
                    }
                    continue;
                }
                low = mid;
                if ((siteSlot > low) && (low >= startSlot)){
                    this.AddSlotToSegmentIntersections(parallelItem, low);
                }
            }
        },
        CreateScanSegmentTrees: function (){
            Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.CreateScanSegmentTree(this.horizontalScanSegmentVector, this.HorizontalScanSegments);
            Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.CreateScanSegmentTree(this.verticalScanSegmentVector, this.VerticalScanSegments);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$SparseVisibilityGraphGenerator);
var Microsoft$Msagl$Routing$Rectilinear$SparseVisibilityGraphGenerator$ScanSegmentVectorItem = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVectorItem",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (coord){
            this.FirstSegment = null;
            this.CurrentSegment = null;
            this.pendingPerpCoords = null;
            this._Coord = 0;
            System.Object.ctor.call(this);
            this.set_Coord(coord);
        },
        AddPendingPerpendicularCoord: function (coord){
            if (this.pendingPerpCoords == null){
                this.pendingPerpCoords = new System.Collections.Generic.List$1.ctor(System.Double.ctor);
            }
            this.pendingPerpCoords.Add(coord);
        },
        ResetForIntersections: function (){
            System.Diagnostics.Debug.Assert$$Boolean$$String(null != this.FirstSegment, "Empty ScanSegmentVectorItem");
            this.CurrentSegment = this.FirstSegment;
        },
        IsHorizontal$$: "System.Boolean",
        get_IsHorizontal: function (){
            return !this.FirstSegment.get_IsVertical();
        },
        Coord$$: "System.Double",
        get_Coord: function (){
            return this._Coord;
        },
        set_Coord: function (value){
            this._Coord = value;
        },
        TraverseToSegmentContainingPoint: function (point){
            if (this.CurrentSegment.ContainsPoint(point)){
                return true;
            }
            var pointCoord = this.get_IsHorizontal() ? point.get_Y() : point.get_X();
            if (!Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Double$$Double(this.get_Coord(), pointCoord)){
                System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Double$$Double(this.get_Coord(), pointCoord) == -1, "point is before current Coord");
                while (this.MoveNext()){
                }
                return false;
            }
            for (; ;){
                if ((null == this.CurrentSegment.get_NextSegment()) || Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(this.CurrentSegment.get_End(), point) == Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(point, this.CurrentSegment.get_NextSegment().get_Start())){
                    if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.CloseIntersections(this.CurrentSegment.get_End(), point)){
                        this.CurrentSegment.Update(this.CurrentSegment.get_Start(), point);
                        return true;
                    }
                }
                if (!this.MoveNext()){
                    return false;
                }
                if (this.CurrentSegment.ContainsPoint(point)){
                    return true;
                }
                if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.IsPureLower(point, this.CurrentSegment.get_Start())){
                    System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Core.Geometry.ApproximateComparer.CloseIntersections(this.CurrentSegment.get_Start(), point), "Skipped over the point in the ScanSegment linked list");
                    this.CurrentSegment.Update(point, this.CurrentSegment.get_End());
                    return true;
                }
            }
        },
        MoveNext: function (){
            this.CurrentSegment = this.CurrentSegment.get_NextSegment();
            return this.get_HasCurrent();
        },
        HasCurrent$$: "System.Boolean",
        get_HasCurrent: function (){
            return (null != this.CurrentSegment);
        },
        PointIsCurrentEndAndNextStart: function (point){
            return (Microsoft.Msagl.Core.Geometry.Point.op_Equality(point, this.CurrentSegment.get_End())) && (null != this.CurrentSegment.get_NextSegment()) && (Microsoft.Msagl.Core.Geometry.Point.op_Equality(point, this.CurrentSegment.get_NextSegment().get_Start()));
        },
        AddPerpendicularCoord: function (perpCoord){
            var point = this.get_IsHorizontal() ? new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(perpCoord, this.get_Coord()) : new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.get_Coord(), perpCoord);
            this.TraverseToSegmentContainingPoint(point);
            this.CurrentSegment.AddSparseVertexCoord(perpCoord);
        },
        toString: function (){
            if (null == this.FirstSegment){
                return "-0- " + this.get_Coord();
            }
            return (this.get_IsHorizontal() ? "(H) Y == " : "(V) X == ") + this.get_Coord();
        },
        CreatePointFromPerpendicularCoord: function (endPerpCoord){
            return this.get_IsHorizontal() ? new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(endPerpCoord, this.get_Coord()) : new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.get_Coord(), endPerpCoord);
        },
        AppendScanSegment: function (segment){
            if (null == this.FirstSegment){
                this.FirstSegment = segment;
            }
            else {
                this.CurrentSegment.set_NextSegment(segment);
            }
            this.CurrentSegment = segment;
        },
        AddPendingPerpendicularCoordsToScanSegments: function (){
            if (this.pendingPerpCoords != null){
                this.ResetForIntersections();
                var $it377 = this.pendingPerpCoords.GetEnumerator();
                while ($it377.MoveNext()){
                    var point = $it377.get_Current();
                    this.AddPerpendicularCoord(point);
                }
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$SparseVisibilityGraphGenerator$ScanSegmentVectorItem);
var Microsoft$Msagl$Routing$Rectilinear$SparseVisibilityGraphGenerator$ScanSegmentVector = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVector",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (coordMap, isHorizontal){
            this.vector = null;
            this._CurrentSlotIndex = 0;
            this._IsHorizontal = false;
            System.Object.ctor.call(this);
            this.vector = new Array(coordMap.get_Count());
            this.set_IsHorizontal(isHorizontal);
            var coords = System.Linq.Enumerable.OrderBy$2$$IEnumerable$1$$Func$2(System.Double.ctor, System.Double.ctor, coordMap, $CreateAnonymousDelegate(this, function (coord){
                return coord;
            })).GetEnumerator();
            coords.MoveNext();
            for (var ii = 0; ii < this.vector.length; ++ii){
                this.vector[ii] = new Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVectorItem.ctor(coords.get_Current());
                coords.MoveNext();
            }
        },
        CurrentSlotIndex$$: "System.Int32",
        get_CurrentSlotIndex: function (){
            return this._CurrentSlotIndex;
        },
        set_CurrentSlotIndex: function (value){
            this._CurrentSlotIndex = value;
        },
        Length$$: "System.Int32",
        get_Length: function (){
            return this.vector.length;
        },
        FirstSlot$$: "Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator+ScanSegmentVectorItem",
        get_FirstSlot: function (){
            return this.vector[0];
        },
        LastSlot$$: "Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator+ScanSegmentVectorItem",
        get_LastSlot: function (){
            return this.vector[this.vector.length - 1];
        },
        CurrentSlot$$: "Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator+ScanSegmentVectorItem",
        get_CurrentSlot: function (){
            return this.vector[this.get_CurrentSlotIndex()];
        },
        Item$$: "Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator+ScanSegmentVectorItem",
        get_Item$$Int32: function (slot){
            return this.vector[slot];
        },
        CreateScanSegment: function (start, end, weight, gbcList){
            this.get_CurrentSlot().AppendScanSegment(new Microsoft.Msagl.Routing.Rectilinear.ScanSegment.ctor$$Point$$Point$$Double$$PointAndCrossingsList(start, end, weight, gbcList));
        },
        ScanSegmentsCompleteForCurrentSlot: function (){
            this.set_CurrentSlotIndex(this.get_CurrentSlotIndex() + 1);
        },
        ScanSegmentsComplete: function (){
            for (var $i379 = 0,$t379 = this.vector,$l379 = $t379.length,item = $t379[$i379]; $i379 < $l379; $i379++, item = $t379[$i379]){
                item.AddPendingPerpendicularCoordsToScanSegments();
            }
        },
        Items$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator+ScanSegmentVectorItem]]",
        get_Items: function (){
            return this.vector;
        },
        ResetForIntersections: function (){
            for (var $i380 = 0,$t380 = this.vector,$l380 = $t380.length,t = $t380[$i380]; $i380 < $l380; $i380++, t = $t380[$i380]){
                t.ResetForIntersections();
            }
        },
        IsHorizontal$$: "System.Boolean",
        get_IsHorizontal: function (){
            return this._IsHorizontal;
        },
        set_IsHorizontal: function (value){
            this._IsHorizontal = value;
        },
        FindNearest: function (coord, directionIfMiss){
            var low = 0;
            var high = this.vector.length - 1;
            if (coord <= this.vector[low].get_Coord()){
                return low;
            }
            if (coord >= this.vector[high].get_Coord()){
                return high;
            }
            while ((high - low) > 2){
                var mid = low + (((high - low) / 2) | 0);
                var item = this.vector[mid];
                if (coord < item.get_Coord()){
                    high = mid;
                    continue;
                }
                if (coord > item.get_Coord()){
                    low = mid;
                    continue;
                }
                System.Diagnostics.Debug.Assert$$Boolean$$String(false, "Should not be here if coord is in the vector");
                return mid;
            }
            for (++low; low <= high; ++low){
                var item = this.vector[low];
                if (coord < item.get_Coord()){
                    return (directionIfMiss > 0) ? low : low - 1;
                }
                if (coord == item.get_Coord()){
                    break;
                }
            }
            System.Diagnostics.Debug.Assert$$Boolean$$String(false, "Should not be here if coord is in the vector");
            return low;
        },
        CreateSparseVerticesAndEdges: function (vg){
            for (var $i381 = 0,$t381 = this.vector,$l381 = $t381.length,item = $t381[$i381]; $i381 < $l381; $i381++, item = $t381[$i381]){
                item.ResetForIntersections();
                for (var segment = item.FirstSegment; segment != null; segment = segment.get_NextSegment()){
                    segment.CreateSparseVerticesAndEdges(vg);
                }
            }
        },
        GetParallelCoord: function (site){
            return this.get_IsHorizontal() ? site.get_Y() : site.get_X();
        },
        GetPerpendicularCoord: function (site){
            return this.get_IsHorizontal() ? site.get_X() : site.get_Y();
        },
        ConnectAdjoiningSegmentEndpoints: function (){
            for (var $i382 = 0,$t382 = this.vector,$l382 = $t382.length,item = $t382[$i382]; $i382 < $l382; $i382++, item = $t382[$i382]){
                item.ResetForIntersections();
                var prevSegment = item.FirstSegment;
                for (var segment = prevSegment.get_NextSegment(); segment != null; segment = segment.get_NextSegment()){
                    if (segment.get_HasSparsePerpendicularCoords() && prevSegment.get_HasSparsePerpendicularCoords()){
                        if (Microsoft.Msagl.Core.Geometry.Point.op_Equality(segment.get_Start(), prevSegment.get_End())){
                            var perpCoord = this.GetPerpendicularCoord(segment.get_Start());
                            prevSegment.AddSparseEndpoint(perpCoord);
                            segment.AddSparseEndpoint(perpCoord);
                        }
                    }
                    prevSegment = segment;
                }
            }
        },
        toString: function (){
            return (this.get_IsHorizontal() ? "(H) count == " : "(V) count == ") + System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVectorItem.ctor, this.vector);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$SparseVisibilityGraphGenerator$ScanSegmentVector);
var Microsoft$Msagl$Routing$Rectilinear$SparseVisibilityGraphGenerator$HorizontalPointComparer = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.HorizontalPointComparer",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IComparer$1"],
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        },
        Compare: function (lhs, rhs){
            var cmp = lhs.get_Y().CompareTo$$Double(rhs.get_Y());
            return (0 != cmp) ? cmp : lhs.get_X().CompareTo$$Double(rhs.get_X());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$SparseVisibilityGraphGenerator$HorizontalPointComparer);
var Microsoft$Msagl$Routing$Rectilinear$SparseVisibilityGraphGenerator$VerticalPointComparer = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.VerticalPointComparer",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IComparer$1"],
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        },
        Compare: function (lhs, rhs){
            var cmp = lhs.get_X().CompareTo$$Double(rhs.get_X());
            return (0 != cmp) ? cmp : lhs.get_Y().CompareTo$$Double(rhs.get_Y());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$SparseVisibilityGraphGenerator$VerticalPointComparer);
var Microsoft$Msagl$Routing$Rectilinear$VertexEntry = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.VertexEntry",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (vertex, prevEntry, length, numberOfBends, cost){
            this._Cost = 0;
            this._Vertex = null;
            this._Direction = Microsoft.Msagl.Core.Geometry.Directions.None;
            this._Length = 0;
            this._NumberOfBends = 0;
            this._PreviousEntry = null;
            this._IsClosed = false;
            System.Object.ctor.call(this);
            this.set_Vertex(vertex);
            this.set_Direction((prevEntry != null) ? Microsoft.Msagl.Core.Geometry.CompassVector.PureDirectionFromPointToPoint(prevEntry.get_Vertex().Point, vertex.Point) : Microsoft.Msagl.Core.Geometry.Directions.None);
            this.ResetEntry(prevEntry, length, numberOfBends, cost);
        },
        ResetEntry: function (prevEntry, length, numberOfBends, cost){
            if (this.get_PreviousEntry() != null){
                System.Diagnostics.Debug.Assert$$Boolean$$String(this.get_PreviousEntry().get_Vertex() == prevEntry.get_Vertex(), "Inconsistent prevEntry vertex");
                System.Diagnostics.Debug.Assert$$Boolean$$String(this.get_PreviousEntry().get_Direction() != prevEntry.get_Direction(), "Duplicate prevEntry direction");
                System.Diagnostics.Debug.Assert$$Boolean$$String(this.get_Direction() == Microsoft.Msagl.Core.Geometry.CompassVector.PureDirectionFromPointToPoint(this.get_PreviousEntry().get_Vertex().Point, this.get_Vertex().Point), "Inconsistent entryDir");
            }
            this.set_PreviousEntry(prevEntry);
            this.set_Length(length);
            this.set_NumberOfBends(numberOfBends);
            this.set_Cost(cost);
        },
        Cost$$: "System.Double",
        get_Cost: function (){
            return this._Cost;
        },
        set_Cost: function (value){
            this._Cost = value;
        },
        Vertex$$: "Microsoft.Msagl.Routing.Rectilinear.VisibilityVertexRectilinear",
        get_Vertex: function (){
            return this._Vertex;
        },
        set_Vertex: function (value){
            this._Vertex = value;
        },
        PreviousVertex$$: "Microsoft.Msagl.Routing.Rectilinear.VisibilityVertexRectilinear",
        get_PreviousVertex: function (){
            return (this.get_PreviousEntry() == null) ? null : this.get_PreviousEntry().get_Vertex();
        },
        Direction$$: "Microsoft.Msagl.Core.Geometry.Directions",
        get_Direction: function (){
            return this._Direction;
        },
        set_Direction: function (value){
            this._Direction = value;
        },
        Length$$: "System.Double",
        get_Length: function (){
            return this._Length;
        },
        set_Length: function (value){
            this._Length = value;
        },
        NumberOfBends$$: "System.Int32",
        get_NumberOfBends: function (){
            return this._NumberOfBends;
        },
        set_NumberOfBends: function (value){
            this._NumberOfBends = value;
        },
        PreviousEntry$$: "Microsoft.Msagl.Routing.Rectilinear.VertexEntry",
        get_PreviousEntry: function (){
            return this._PreviousEntry;
        },
        set_PreviousEntry: function (value){
            this._PreviousEntry = value;
        },
        IsClosed$$: "System.Boolean",
        get_IsClosed: function (){
            return this._IsClosed;
        },
        set_IsClosed: function (value){
            this._IsClosed = value;
        },
        toString: function (){
            return this.get_Vertex().Point + " " + this.get_Direction() + " " + this.get_IsClosed() + " " + this.get_Cost();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$VertexEntry);
var Microsoft$Msagl$Routing$Rectilinear$VisibilityVertexRectilinear = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.VisibilityVertexRectilinear",
    baseTypeName: "Microsoft.Msagl.Routing.Visibility.VisibilityVertex",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (point){
            this._VertexEntries = null;
            Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor.call(this, point);
        },
        VertexEntries$$: "Microsoft.Msagl.Routing.Rectilinear.VertexEntry[]",
        get_VertexEntries: function (){
            return this._VertexEntries;
        },
        set_VertexEntries: function (value){
            this._VertexEntries = value;
        },
        SetVertexEntry: function (entry){
            if (this.get_VertexEntries() == null){
                this.set_VertexEntries(new Array(4));
            }
            this.get_VertexEntries()[Microsoft.Msagl.Core.Geometry.CompassVector.ToIndex(entry.get_Direction())] = entry;
        },
        RemoveVertexEntries: function (){
            this.set_VertexEntries(null);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$VisibilityVertexRectilinear);
var Microsoft$Msagl$Routing$ShapeCreator = {
    fullname: "Microsoft.Msagl.Routing.ShapeCreator",
    baseTypeName: "System.Object",
    staticDefinition: {
        GetShapes: function (graph){
            var nodesToShapes = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Routing.Shape.ctor);
            var interestingNodes = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Layout.Node.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Node.ctor, graph.get_Nodes(), function (n){
                return !n.UnderCollapsedCluster();
            }));
            for (var $i383 = 0,$l383 = interestingNodes.length,v = interestingNodes[$i383]; $i383 < $l383; $i383++, v = interestingNodes[$i383])
                nodesToShapes.set_Item$$TKey(v, Microsoft.Msagl.Routing.ShapeCreator.CreateShapeWithCenterPort(v));
            var $it383 = graph.get_RootCluster().AllClustersDepthFirst().GetEnumerator();
            while ($it383.MoveNext()){
                var c = $it383.get_Current();
                if (!c.get_IsCollapsed()){
                    var $it384 = c.get_Nodes().GetEnumerator();
                    while ($it384.MoveNext()){
                        var v = $it384.get_Current();
                        if (!nodesToShapes.ContainsKey(v))
                            nodesToShapes.set_Item$$TKey(v, Microsoft.Msagl.Routing.ShapeCreator.CreateShapeWithCenterPort(v));
                    }
                }
                if (c == graph.get_RootCluster())
                    continue;
                var parent = (function ($p31){
                    nodesToShapes.set_Item$$TKey(c, $p31);
                    return $p31;
                })(Microsoft.Msagl.Routing.ShapeCreator.CreateShapeWithClusterBoundaryPort(c));
                if (c.get_IsCollapsed())
                    continue;
                var $it385 = c.get_Nodes().GetEnumerator();
                while ($it385.MoveNext()){
                    var v = $it385.get_Current();
                    parent.AddChild(nodesToShapes.get_Item$$TKey(v));
                }
                var $it386 = c.get_Clusters().GetEnumerator();
                while ($it386.MoveNext()){
                    var d = $it386.get_Current();
                    parent.AddChild(nodesToShapes.get_Item$$TKey(d));
                }
            }
            var $it387 = graph.get_Edges().GetEnumerator();
            while ($it387.MoveNext()){
                var edge = $it387.get_Current();
                var shape;
                if ((function (){
                    var $1 = {
                        Value: shape
                    };
                    var $res = nodesToShapes.TryGetValue(edge.get_Source(), $1);
                    shape = $1.Value;
                    return $res;
                })()){
                    if (edge.get_SourcePort() != null)
                        shape.get_Ports().Insert(edge.get_SourcePort());
                }
                if ((function (){
                    var $1 = {
                        Value: shape
                    };
                    var $res = nodesToShapes.TryGetValue(edge.get_Target(), $1);
                    shape = $1.Value;
                    return $res;
                })()){
                    if (edge.get_TargetPort() != null)
                        shape.get_Ports().Insert(edge.get_TargetPort());
                }
            }
            return nodesToShapes.get_Values();
        },
        CreateShapeWithCenterPort: function (node){
            var shape = new Microsoft.Msagl.Routing.RelativeShape.ctor(function (){
                return node.get_BoundaryCurve();
            });
            var port = new Microsoft.Msagl.Core.Layout.RelativeFloatingPort.ctor$$Func$1$ICurve$$Func$1$Point(function (){
                return node.get_BoundaryCurve();
            }, function (){
                return node.get_Center();
            });
            shape.get_Ports().Insert(port);
            var $it388 = node.get_InEdges().GetEnumerator();
            while ($it388.MoveNext()){
                var e = $it388.get_Current();
                Microsoft.Msagl.Routing.ShapeCreator.FixPortAtTarget(shape, port, e);
            }
            var $it389 = node.get_OutEdges().GetEnumerator();
            while ($it389.MoveNext()){
                var e = $it389.get_Current();
                Microsoft.Msagl.Routing.ShapeCreator.FixPortAtSource(shape, port, e);
            }
            var $it390 = node.get_SelfEdges().GetEnumerator();
            while ($it390.MoveNext()){
                var e = $it390.get_Current();
                Microsoft.Msagl.Routing.ShapeCreator.FixPortAtSource(shape, port, e);
                Microsoft.Msagl.Routing.ShapeCreator.FixPortAtTarget(shape, port, e);
            }
            return shape;
        },
        CreateShapeWithClusterBoundaryPort: function (node){
            System.Diagnostics.Debug.Assert$$Boolean(Is(node, Microsoft.Msagl.Core.Layout.Cluster.ctor));
            var shape = new Microsoft.Msagl.Routing.RelativeShape.ctor(function (){
                return node.get_BoundaryCurve();
            });
            var port = new Microsoft.Msagl.Routing.ClusterBoundaryPort.ctor$$Func$1$ICurve$$Func$1$Point(function (){
                return node.get_BoundaryCurve();
            }, function (){
                return node.get_Center();
            });
            shape.get_Ports().Insert(port);
            var $it391 = node.get_InEdges().GetEnumerator();
            while ($it391.MoveNext()){
                var e = $it391.get_Current();
                Microsoft.Msagl.Routing.ShapeCreator.FixPortAtTarget(shape, port, e);
            }
            var $it392 = node.get_OutEdges().GetEnumerator();
            while ($it392.MoveNext()){
                var e = $it392.get_Current();
                Microsoft.Msagl.Routing.ShapeCreator.FixPortAtSource(shape, port, e);
            }
            var $it393 = node.get_SelfEdges().GetEnumerator();
            while ($it393.MoveNext()){
                var e = $it393.get_Current();
                Microsoft.Msagl.Routing.ShapeCreator.FixPortAtSource(shape, port, e);
                Microsoft.Msagl.Routing.ShapeCreator.FixPortAtTarget(shape, port, e);
            }
            shape.set_UserData(node.toString());
            return shape;
        },
        FixPortAtSource: function (shape, port, e){
            if (e.get_SourcePort() == null)
                e.set_SourcePort(port);
            else
                shape.get_Ports().Insert(e.get_SourcePort());
        },
        FixPortAtTarget: function (shape, port, e){
            if (e.get_TargetPort() == null)
                e.set_TargetPort(port);
            else
                shape.get_Ports().Insert(e.get_TargetPort());
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$ShapeCreator);
var Microsoft$Msagl$Routing$ShapeCreatorForRoutingToParents = {
    fullname: "Microsoft.Msagl.Routing.ShapeCreatorForRoutingToParents",
    baseTypeName: "System.Object",
    staticDefinition: {
        GetShapes: function (inParentEdges, outParentEdges){
            var nodesToShapes = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Routing.Shape.ctor);
            var $it394 = inParentEdges.GetEnumerator();
            while ($it394.MoveNext()){
                var edge = $it394.get_Current();
                Microsoft.Msagl.Routing.ShapeCreatorForRoutingToParents.ProcessAncestorDescendantCouple(Cast(edge.get_Target(), Microsoft.Msagl.Core.Layout.Cluster.ctor), edge.get_Source(), nodesToShapes);
                Microsoft.Msagl.Routing.ShapeCreatorForRoutingToParents.InsertEdgePortsToShapes(nodesToShapes, edge);
            }
            var $it395 = outParentEdges.GetEnumerator();
            while ($it395.MoveNext()){
                var edge = $it395.get_Current();
                Microsoft.Msagl.Routing.ShapeCreatorForRoutingToParents.ProcessAncestorDescendantCouple(Cast(edge.get_Source(), Microsoft.Msagl.Core.Layout.Cluster.ctor), edge.get_Target(), nodesToShapes);
                Microsoft.Msagl.Routing.ShapeCreatorForRoutingToParents.InsertEdgePortsToShapes(nodesToShapes, edge);
            }
            Microsoft.Msagl.Routing.ShapeCreatorForRoutingToParents.BindShapes(nodesToShapes);
            return nodesToShapes.get_Values();
        },
        InsertEdgePortsToShapes: function (nodesToShapes, edge){
            nodesToShapes.get_Item$$TKey(edge.get_Target()).get_Ports().Insert(edge.get_TargetPort());
            nodesToShapes.get_Item$$TKey(edge.get_Source()).get_Ports().Insert(edge.get_SourcePort());
        },
        BindShapes: function (nodesToShapes){
            var $it396 = nodesToShapes.GetEnumerator();
            while ($it396.MoveNext()){
                var nodeShape = $it396.get_Current();
                var cluster = As(nodeShape.get_Key(), Microsoft.Msagl.Core.Layout.Cluster.ctor);
                if (cluster == null)
                    continue;
                var shape = nodeShape.get_Value();
                var $it397 = Microsoft.Msagl.Routing.ShapeCreatorForRoutingToParents.Children(cluster).GetEnumerator();
                while ($it397.MoveNext()){
                    var child = $it397.get_Current();
                    var childShape;
                    if ((function (){
                        var $1 = {
                            Value: childShape
                        };
                        var $res = nodesToShapes.TryGetValue(child, $1);
                        childShape = $1.Value;
                        return $res;
                    })())
                        shape.AddChild(childShape);
                }
            }
        },
        ProcessAncestorDescendantCouple: function (ancestor, node, nodesToShapes){
            var parent = Microsoft.Msagl.Routing.ShapeCreatorForRoutingToParents.Parent(node);
            do{
                var $it398 = Microsoft.Msagl.Routing.ShapeCreatorForRoutingToParents.Children(parent).GetEnumerator();
                while ($it398.MoveNext()){
                    var n = $it398.get_Current();
                    Microsoft.Msagl.Routing.ShapeCreatorForRoutingToParents.CreateShapeIfNeeeded(n, nodesToShapes);
                }
                if (parent == ancestor)
                    break;
                parent = Microsoft.Msagl.Routing.ShapeCreatorForRoutingToParents.Parent(parent);
            }
            while (true)
            Microsoft.Msagl.Routing.ShapeCreatorForRoutingToParents.CreateShapeIfNeeeded(parent, nodesToShapes);
        },
        CreateShapeIfNeeeded: function (n, nodesToShapes){
            if (nodesToShapes.ContainsKey(n))
                return;
            nodesToShapes.set_Item$$TKey(n, (function (){
                var $v71 = new Microsoft.Msagl.Routing.RelativeShape.ctor(function (){
                    return n.get_BoundaryCurve();
                });
                $v71.set_UserData(n.toString());
                return $v71;
            })());
        },
        Children: function (parent){
            return System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Layout.Node.ctor, parent.get_Clusters(), parent.get_Nodes());
        },
        Parent: function (node){
            return System.Linq.Enumerable.First$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, node.get_ClusterParents());
        },
        NumberOfActiveNodesIsUnderThreshold: function (inParentEdges, outParentEdges, threshold){
            var usedNodeSet = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor);
            var $it399 = inParentEdges.GetEnumerator();
            while ($it399.MoveNext()){
                var edge = $it399.get_Current();
                if (Microsoft.Msagl.Routing.ShapeCreatorForRoutingToParents.SetOfActiveNodesIsLargerThanThreshold(Cast(edge.get_Target(), Microsoft.Msagl.Core.Layout.Cluster.ctor), edge.get_Source(), usedNodeSet, threshold))
                    return false;
            }
            var $it400 = outParentEdges.GetEnumerator();
            while ($it400.MoveNext()){
                var edge = $it400.get_Current();
                if (Microsoft.Msagl.Routing.ShapeCreatorForRoutingToParents.SetOfActiveNodesIsLargerThanThreshold(Cast(edge.get_Source(), Microsoft.Msagl.Core.Layout.Cluster.ctor), edge.get_Target(), usedNodeSet, threshold))
                    return false;
            }
            return true;
        },
        SetOfActiveNodesIsLargerThanThreshold: function (ancestor, node, usedNodeSet, threshold){
            var parent = Microsoft.Msagl.Routing.ShapeCreatorForRoutingToParents.Parent(node);
            do{
                var $it401 = Microsoft.Msagl.Routing.ShapeCreatorForRoutingToParents.Children(parent).GetEnumerator();
                while ($it401.MoveNext()){
                    var n = $it401.get_Current();
                    usedNodeSet.Insert(n);
                    if (usedNodeSet.get_Count() > threshold)
                        return true;
                }
                if (parent == ancestor)
                    break;
                parent = Microsoft.Msagl.Routing.ShapeCreatorForRoutingToParents.Parent(parent);
            }
            while (true)
            usedNodeSet.Insert(parent);
            return usedNodeSet.get_Count() > threshold;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$ShapeCreatorForRoutingToParents);
var Microsoft$Msagl$Routing$ShapeObstacleCalculator = {
    fullname: "Microsoft.Msagl.Routing.ShapeObstacleCalculator",
    baseTypeName: "System.Object",
    staticDefinition: {
        ShapeIsInsideOfPoly: function (shape, tightPolyline){
            return Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(shape.get_BoundaryCurve().get_Start(), tightPolyline) == Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Inside;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (shape, tightPadding, loosePadding, shapeToTightLooseCouples){
            this.tightHierarchy = null;
            this.coupleHierarchy = null;
            this._RootOfLooseHierarchy = null;
            this._ShapesToTightLooseCouples = null;
            this._TightPadding = 0;
            this._LoosePadding = 0;
            this._MainShape = null;
            this._OverlapsDetected = false;
            System.Object.ctor.call(this);
            this.set_MainShape(shape);
            this.set_TightPadding(tightPadding);
            this.set_LoosePadding(loosePadding);
            this.set_ShapesToTightLooseCouples(shapeToTightLooseCouples);
        },
        RootOfLooseHierarchy$$: "Microsoft.Msagl.Core.Geometry.RectangleNode`1[[Microsoft.Msagl.Routing.Shape]]",
        get_RootOfLooseHierarchy: function (){
            return this._RootOfLooseHierarchy;
        },
        set_RootOfLooseHierarchy: function (value){
            this._RootOfLooseHierarchy = value;
        },
        ShapesToTightLooseCouples$$: "System.Collections.Generic.Dictionary`2[[Microsoft.Msagl.Routing.Shape],[Microsoft.Msagl.Routing.TightLooseCouple]]",
        get_ShapesToTightLooseCouples: function (){
            return this._ShapesToTightLooseCouples;
        },
        set_ShapesToTightLooseCouples: function (value){
            this._ShapesToTightLooseCouples = value;
        },
        TightPadding$$: "System.Double",
        get_TightPadding: function (){
            return this._TightPadding;
        },
        set_TightPadding: function (value){
            this._TightPadding = value;
        },
        LoosePadding$$: "System.Double",
        get_LoosePadding: function (){
            return this._LoosePadding;
        },
        set_LoosePadding: function (value){
            this._LoosePadding = value;
        },
        MainShape$$: "Microsoft.Msagl.Routing.Shape",
        get_MainShape: function (){
            return this._MainShape;
        },
        set_MainShape: function (value){
            this._MainShape = value;
        },
        OverlapsDetected$$: "System.Boolean",
        get_OverlapsDetected: function (){
            return this._OverlapsDetected;
        },
        set_OverlapsDetected: function (value){
            this._OverlapsDetected = value;
        },
        Calculate: function (){
            if (System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Routing.Shape.ctor, this.get_MainShape().get_Children()) == 0)
                return;
            this.CreateTightObstacles();
            this.CreateTigthLooseCouples();
            this.FillTheMapOfShapeToTightLooseCouples();
        },
        FillTheMapOfShapeToTightLooseCouples: function (){
            var childrenShapeHierarchy = Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnEnumeration(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, this.get_MainShape().get_Children(), $CreateAnonymousDelegate(this, function (s){
                return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(Microsoft.Msagl.Routing.Shape.ctor, s, s.get_BoundingBox());
            })));
            Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$2$$RectangleNode$1$$RectangleNode$1$$Action$2(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Routing.TightLooseCouple.ctor, childrenShapeHierarchy, this.coupleHierarchy, $CreateDelegate(this, this.TryMapShapeToTightLooseCouple));
        },
        TryMapShapeToTightLooseCouple: function (shape, tightLooseCouple){
            if (Microsoft.Msagl.Routing.ShapeObstacleCalculator.ShapeIsInsideOfPoly(shape, tightLooseCouple.get_TightPolyline()))
                this.get_ShapesToTightLooseCouples().set_Item$$TKey(shape, tightLooseCouple);
        },
        CreateTigthLooseCouples: function (){
            var couples = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.TightLooseCouple.ctor);
            var $it402 = this.tightHierarchy.GetAllLeaves().GetEnumerator();
            while ($it402.MoveNext()){
                var tightPolyline = $it402.get_Current();
                var distance = Microsoft.Msagl.Routing.InteractiveObstacleCalculator.FindMaxPaddingForTightPolyline(this.tightHierarchy, tightPolyline, this.get_LoosePadding());
                var loosePoly = Microsoft.Msagl.Routing.InteractiveObstacleCalculator.LoosePolylineWithFewCorners(tightPolyline, distance);
                couples.Add(new Microsoft.Msagl.Routing.TightLooseCouple.ctor(tightPolyline, new Microsoft.Msagl.Routing.Shape.ctor$$ICurve(loosePoly), distance));
            }
            this.coupleHierarchy = Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnEnumeration(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.TightLooseCouple.ctor, Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, couples, $CreateAnonymousDelegate(this, function (c){
                return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(Microsoft.Msagl.Routing.TightLooseCouple.ctor, c, c.get_TightPolyline().get_BoundingBox());
            })));
        },
        CreateTightObstacles: function (){
            var tightObstacles = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, this.get_MainShape().get_Children(), $CreateDelegate(this, this.InitialTightPolyline)));
            var initialNumberOfTightObstacles = tightObstacles.get_Count();
            this.tightHierarchy = Microsoft.Msagl.Routing.InteractiveObstacleCalculator.RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(tightObstacles);
            this.set_OverlapsDetected(initialNumberOfTightObstacles > tightObstacles.get_Count());
        },
        InitialTightPolyline: function (shape){
            var poly = Microsoft.Msagl.Routing.InteractiveObstacleCalculator.PaddedPolylineBoundaryOfNode(shape.get_BoundaryCurve(), this.get_TightPadding());
            var stickingPointsArray = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Linq.Enumerable.SelectMany$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, this.LoosePolylinesUnderShape(shape), $CreateAnonymousDelegate(this, function (l){
                return l;
            })), $CreateAnonymousDelegate(this, function (p){
                return Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(p, poly) == Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside;
            })));
            if (stickingPointsArray.length <= 0)
                return poly;
            return (function (){
                var $v72 = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor$$IEnumerable$1$Point(Microsoft.Msagl.Core.Geometry.ConvexHull.CalculateConvexHull(System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Geometry.Point.ctor, poly, stickingPointsArray)));
                $v72.set_Closed(true);
                return $v72;
            }).call(this);
        },
        LoosePolylinesUnderShape: function (shape){
            return System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, shape.get_Children(), $CreateAnonymousDelegate(this, function (child){
                return Cast((this.get_ShapesToTightLooseCouples().get_Item$$TKey(child).get_LooseShape().get_BoundaryCurve()), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            }));
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$ShapeObstacleCalculator);
var Microsoft$Msagl$Routing$Spline$Bundling$CdtThreader = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.CdtThreader",
    baseTypeName: "System.Object",
    staticDefinition: {
        PointLocationForTriangle: function (p, triangle){
            var seenBoundary = false;
            for (var i = 0; i < 3; i++){
                var area = Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(p, triangle.Sites.get_Item$$Int32(i).Point, triangle.Sites.get_Item$$Int32(i + 1).Point);
                if (area < -Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                    return Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside;
                if (area < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                    seenBoundary = true;
            }
            return seenBoundary ? Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Boundary : Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Inside;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (startTriangle, start, end){
            this.start = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.end = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.positiveSign = 0;
            this.negativeSign = 0;
            this.currentPiercedEdge = null;
            this.currentTriangle = null;
            System.Object.ctor.call(this);
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Routing.Spline.Bundling.CdtThreader.PointLocationForTriangle(start, startTriangle) != Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside);
            this.currentTriangle = startTriangle;
            this.start = start;
            this.end = end;
        },
        CurrentPiercedEdge$$: "Microsoft.Msagl.Routing.CdtEdge",
        get_CurrentPiercedEdge: function (){
            return this.currentPiercedEdge;
        },
        CurrentTriangle$$: "Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle",
        get_CurrentTriangle: function (){
            return this.currentTriangle;
        },
        Triangles: function (){
            var $yield = [];
            while (this.MoveNext())
                $yield.push(this.get_CurrentTriangle());
            return $yield;
        },
        FindFirstPiercedEdge: function (){
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Routing.Spline.Bundling.CdtThreader.PointLocationForTriangle(this.start, this.currentTriangle) != Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside);
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Routing.Spline.Bundling.CdtThreader.PointLocationForTriangle(this.end, this.currentTriangle) == Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside);
            var sign0 = this.GetHyperplaneSign(this.currentTriangle.Sites.get_Item$$Int32(0));
            var sign1 = this.GetHyperplaneSign(this.currentTriangle.Sites.get_Item$$Int32(1));
            if (sign0 != sign1){
                if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(this.end, this.currentTriangle.Sites.get_Item$$Int32(0).Point, this.currentTriangle.Sites.get_Item$$Int32(1).Point) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise){
                    this.positiveSign = sign0;
                    this.negativeSign = sign1;
                    return this.currentTriangle.Edges.get_Item$$Int32(0);
                }
            }
            var sign2 = this.GetHyperplaneSign(this.currentTriangle.Sites.get_Item$$Int32(2));
            if (sign1 != sign2){
                if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(this.end, this.currentTriangle.Sites.get_Item$$Int32(1).Point, this.currentTriangle.Sites.get_Item$$Int32(2).Point) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise){
                    this.positiveSign = sign1;
                    this.negativeSign = sign2;
                    return this.currentTriangle.Edges.get_Item$$Int32(1);
                }
            }
            this.positiveSign = sign2;
            this.negativeSign = sign0;
            System.Diagnostics.Debug.Assert$$Boolean(this.positiveSign > this.negativeSign);
            return this.currentTriangle.Edges.get_Item$$Int32(2);
        },
        FindNextPierced: function (){
            System.Diagnostics.Debug.Assert$$Boolean(this.negativeSign < this.positiveSign);
            this.currentTriangle = this.currentPiercedEdge.GetOtherTriangle$$CdtTriangle(this.currentTriangle);
            if (this.currentTriangle == null){
                this.currentPiercedEdge = null;
                return;
            }
            var i = this.currentTriangle.Edges.Index(this.currentPiercedEdge);
            var j;
            var oppositeSite = this.currentTriangle.Sites.get_Item$$Int32(i + 2);
            var oppositeSiteSign = this.GetHyperplaneSign(oppositeSite);
            if (this.negativeSign == 0){
                System.Diagnostics.Debug.Assert$$Boolean(this.positiveSign == 1);
                if (oppositeSiteSign == -1 || oppositeSiteSign == 0){
                    this.negativeSign = oppositeSiteSign;
                    j = i + 1;
                }
                else {
                    j = i + 2;
                }
            }
            else if (this.positiveSign == 0){
                System.Diagnostics.Debug.Assert$$Boolean(this.negativeSign == -1);
                if (oppositeSiteSign == 1 || oppositeSiteSign == 0){
                    this.positiveSign = oppositeSiteSign;
                    j = i + 2;
                }
                else {
                    j = i + 1;
                }
            }
            else if (oppositeSiteSign != this.positiveSign){
                this.negativeSign = oppositeSiteSign;
                j = i + 1;
            }
            else {
                System.Diagnostics.Debug.Assert$$Boolean(this.negativeSign != oppositeSiteSign);
                this.positiveSign = oppositeSiteSign;
                j = i + 2;
            }
            this.currentPiercedEdge = Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(this.end, this.currentTriangle.Sites.get_Item$$Int32(j).Point, this.currentTriangle.Sites.get_Item$$Int32(j + 1).Point) < -Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon ? this.currentTriangle.Edges.get_Item$$Int32(j) : null;
        },
        GetHyperplaneSign: function (cdtSite){
            var area = Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(this.start, cdtSite.Point, this.end);
            if (area > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return 1;
            if (area < -Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return -1;
            return 0;
        },
        MoveNext: function (){
            if (this.currentPiercedEdge == null)
                this.currentPiercedEdge = this.FindFirstPiercedEdge();
            else
                this.FindNextPierced();
            return this.currentPiercedEdge != null;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$CdtThreader);
var Microsoft$Msagl$Routing$Spline$Bundling$SdBoneEdge = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.SdBoneEdge",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (visibilityEdge, source, target){
            this.VisibilityEdge = null;
            this.Source = null;
            this.Target = null;
            this.numberOfPassedPaths = 0;
            this._CrossedCdtEdges = null;
            System.Object.ctor.call(this);
            this.VisibilityEdge = visibilityEdge;
            this.Source = source;
            this.Target = target;
        },
        TargetPoint$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_TargetPoint: function (){
            return this.Target.get_Point();
        },
        SourcePoint$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_SourcePoint: function (){
            return this.Source.get_Point();
        },
        IsOccupied$$: "System.Boolean",
        get_IsOccupied: function (){
            return this.numberOfPassedPaths > 0;
        },
        CrossedCdtEdges$$: "Microsoft.Msagl.Core.DataStructures.Set`1[[Microsoft.Msagl.Routing.CdtEdge]]",
        get_CrossedCdtEdges: function (){
            return this._CrossedCdtEdges;
        },
        set_CrossedCdtEdges: function (value){
            this._CrossedCdtEdges = value;
        },
        IsPassable$$: "System.Boolean",
        get_IsPassable: function (){
            return this.Target.get_IsTargetOfRouting() || this.Source.get_IsSourceOfRouting() || this.VisibilityEdge.get_IsPassable() == null || this.VisibilityEdge.get_IsPassable()();
        },
        AddOccupiedEdge: function (){
            this.numberOfPassedPaths++;
        },
        RemoveOccupiedEdge: function (){
            this.numberOfPassedPaths--;
            System.Diagnostics.Debug.Assert$$Boolean(this.numberOfPassedPaths >= 0);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$SdBoneEdge);
var Microsoft$Msagl$Routing$Spline$Bundling$SdVertex = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.SdVertex",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (visibilityVertex){
            this.VisibilityVertex = null;
            this.InBoneEdges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Spline.Bundling.SdBoneEdge.ctor);
            this.OutBoneEdges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Spline.Bundling.SdBoneEdge.ctor);
            this.Triangle = null;
            this.cost = 0;
            this._PrevEdge = null;
            this._IsSourceOfRouting = false;
            this._IsTargetOfRouting = false;
            System.Object.ctor.call(this);
            this.VisibilityVertex = visibilityVertex;
        },
        Prev$$: "Microsoft.Msagl.Routing.Spline.Bundling.SdVertex",
        get_Prev: function (){
            if (this.get_PrevEdge() == null)
                return null;
            return this.get_PrevEdge().Source == this ? this.get_PrevEdge().Target : this.get_PrevEdge().Source;
        },
        PrevEdge$$: "Microsoft.Msagl.Routing.Spline.Bundling.SdBoneEdge",
        get_PrevEdge: function (){
            return this._PrevEdge;
        },
        set_PrevEdge: function (value){
            this._PrevEdge = value;
        },
        IsSourceOfRouting$$: "System.Boolean",
        get_IsSourceOfRouting: function (){
            return this._IsSourceOfRouting;
        },
        set_IsSourceOfRouting: function (value){
            this._IsSourceOfRouting = value;
        },
        IsTargetOfRouting$$: "System.Boolean",
        get_IsTargetOfRouting: function (){
            return this._IsTargetOfRouting;
        },
        set_IsTargetOfRouting: function (value){
            this._IsTargetOfRouting = value;
        },
        Point$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Point: function (){
            return this.VisibilityVertex.Point;
        },
        Cost$$: "System.Double",
        get_Cost: function (){
            if (this.get_IsSourceOfRouting())
                return this.cost;
            return this.get_Prev() == null ? Infinity : this.cost;
        },
        set_Cost: function (value){
            this.cost = value;
        },
        SetPreviousToNull: function (){
            this.set_PrevEdge(null);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$SdVertex);
var Microsoft$Msagl$Routing$Spline$Bundling$SdShortestPath = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.SdShortestPath",
    baseTypeName: "System.Object",
    staticDefinition: {
        ExtendPolylineEndToClusterBoundary: function (poly, curve){
            var par = curve.ClosestParameter(poly.get_End());
            poly.AddPoint$$Point(curve.get_Item$$Double(par));
        },
        ExtendPolylineStartToClusterBoundary: function (poly, curve){
            var par = curve.ClosestParameter(poly.get_Start());
            poly.PrependPoint(curve.get_Item$$Double(par));
        },
        CostOfCrossingCdtEdge: function (capacityOverflMult, bundlingSettings, currentEdgeGeometry, e){
            var w = currentEdgeGeometry.get_LineWidth();
            if (e.Capacity != e.get_ResidualCapacity())
                w += bundlingSettings.get_EdgeSeparation();
            var del = e.get_ResidualCapacity() - w;
            if (del >= 0)
                return 0;
            return -del * capacityOverflMult;
        },
        CalculateCdtEdgeCapacityForEdge: function (e){
            if (e.Constrained || e.get_CwTriangle() == null || e.get_CcwTriangle() == null)
                return;
            var startPoly = As(e.upperSite.get_Owner(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            var endPoly = As(e.lowerSite.get_Owner(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            if (startPoly != endPoly){
                var distA = Microsoft.Msagl.Routing.Visibility.Polygon.Distance$$Polygon$$Point(new Microsoft.Msagl.Routing.Visibility.Polygon.ctor(startPoly), e.lowerSite.Point);
                var distB = Microsoft.Msagl.Routing.Visibility.Polygon.Distance$$Polygon$$Point(new Microsoft.Msagl.Routing.Visibility.Polygon.ctor(endPoly), e.upperSite.Point);
                e.Capacity = (distA + distB) / 2;
            }
        },
        CapacityOverflowPenaltyMultiplier: function (bundlingSettings){
            return bundlingSettings.get_CapacityOverflowCoefficient() * (bundlingSettings.get_PathLengthImportance() + bundlingSettings.get_InkImportance());
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (makeTransparentShapesOfEdgeGeometryAndGetTheShapes, cdt, gates){
            this.vertexArray = null;
            this.EdgesToRoutes = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, System.Collections.Generic.List$1.ctor);
            this.EdgesToRouteSources = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, Microsoft.Msagl.Routing.Spline.Bundling.SdVertex.ctor);
            this.CurrentEdgeGeometry = null;
            this.VisibilityVerticesToSdVerts = null;
            this.LengthCoefficient = 0;
            this.Queue = null;
            this.LowestCostToTarget = 0;
            this.ClosestTargetVertex = null;
            this.capacityOverlowPenaltyMultiplier = 0;
            this.sourceLoosePoly = null;
            this.targetLoosePoly = null;
            this._VisibilityGraph = null;
            this._MakeTransparentShapesOfEdgeGeometry = null;
            this._BundlingSettings = null;
            this._EdgeGeometries = null;
            this._ObstacleHierarchy = null;
            this._Cdt = null;
            this._Gates = null;
            System.Object.ctor.call(this);
            this.set_MakeTransparentShapesOfEdgeGeometry(makeTransparentShapesOfEdgeGeometryAndGetTheShapes);
            this.set_Cdt(cdt);
            this.set_Gates(gates);
        },
        VisibilityGraph$$: "Microsoft.Msagl.Routing.Visibility.VisibilityGraph",
        get_VisibilityGraph: function (){
            return this._VisibilityGraph;
        },
        set_VisibilityGraph: function (value){
            this._VisibilityGraph = value;
        },
        MakeTransparentShapesOfEdgeGeometry$$: "System.Func`2[[Microsoft.Msagl.Core.Layout.EdgeGeometry],[System.Collections.Generic.List`1[[Microsoft.Msagl.Routing.Shape]]]]",
        get_MakeTransparentShapesOfEdgeGeometry: function (){
            return this._MakeTransparentShapesOfEdgeGeometry;
        },
        set_MakeTransparentShapesOfEdgeGeometry: function (value){
            this._MakeTransparentShapesOfEdgeGeometry = value;
        },
        BundlingSettings$$: "Microsoft.Msagl.Core.Routing.BundlingSettings",
        get_BundlingSettings: function (){
            return this._BundlingSettings;
        },
        set_BundlingSettings: function (value){
            this._BundlingSettings = value;
        },
        EdgeGeometries$$: "Microsoft.Msagl.Core.Layout.EdgeGeometry[]",
        get_EdgeGeometries: function (){
            return this._EdgeGeometries;
        },
        set_EdgeGeometries: function (value){
            this._EdgeGeometries = value;
        },
        ObstacleHierarchy$$: "Microsoft.Msagl.Core.Geometry.RectangleNode`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]",
        get_ObstacleHierarchy: function (){
            return this._ObstacleHierarchy;
        },
        set_ObstacleHierarchy: function (value){
            this._ObstacleHierarchy = value;
        },
        Cdt$$: "Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt",
        get_Cdt: function (){
            return this._Cdt;
        },
        set_Cdt: function (value){
            this._Cdt = value;
        },
        Gates$$: "Microsoft.Msagl.Core.DataStructures.Set`1[[Microsoft.Msagl.Routing.CdtEdge]]",
        get_Gates: function (){
            return this._Gates;
        },
        set_Gates: function (value){
            this._Gates = value;
        },
        CreateGraphElements: function (){
            for (var $i404 = 0,$t404 = this.vertexArray,$l404 = $t404.length,sdVertex = $t404[$i404]; $i404 < $l404; $i404++, sdVertex = $t404[$i404]){
                var vv = sdVertex.VisibilityVertex;
                var $it404 = vv.get_InEdges().GetEnumerator();
                while ($it404.MoveNext()){
                    var vEdge = $it404.get_Current();
                    var boneEdge = new Microsoft.Msagl.Routing.Spline.Bundling.SdBoneEdge.ctor(vEdge, this.VisibilityVerticesToSdVerts.get_Item$$TKey(vEdge.get_Source()), this.VisibilityVerticesToSdVerts.get_Item$$TKey(vEdge.get_Target()));
                    var otherSdVertex = this.VisibilityVerticesToSdVerts.get_Item$$TKey(vEdge.get_Source());
                    sdVertex.InBoneEdges.Add(boneEdge);
                    otherSdVertex.OutBoneEdges.Add(boneEdge);
                }
            }
        },
        CreateRoutingGraph: function (){
            this.vertexArray = new Array(this.get_VisibilityGraph().get_VertexCount());
            var i = 0;
            this.VisibilityVerticesToSdVerts = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor, Microsoft.Msagl.Routing.Spline.Bundling.SdVertex.ctor);
            var $it405 = this.get_VisibilityGraph().Vertices().GetEnumerator();
            while ($it405.MoveNext()){
                var v = $it405.get_Current();
                var sdVert = new Microsoft.Msagl.Routing.Spline.Bundling.SdVertex.ctor(v);
                this.vertexArray[i++] = sdVert;
                this.VisibilityVerticesToSdVerts.set_Item$$TKey(v, sdVert);
            }
            this.CreateGraphElements();
        },
        RouteEdges: function (){
            this.Initialize();
            this.RestoreCapacities();
            for (var $i407 = 0,$t407 = this.get_EdgeGeometries(),$l407 = $t407.length,edgeGeometry = $t407[$i407]; $i407 < $l407; $i407++, edgeGeometry = $t407[$i407]){
                this.EdgesToRoutes.set_Item$$TKey(edgeGeometry, this.RouteEdge(edgeGeometry));
            }
            this.RerouteEdges();
            for (var $i408 = 0,$t408 = this.get_EdgeGeometries(),$l408 = $t408.length,edgeGeometry = $t408[$i408]; $i408 < $l408; $i408++, edgeGeometry = $t408[$i408])
                this.SetEdgeGeometryCurve(edgeGeometry);
        },
        SetEdgeGeometryCurve: function (edgeGeometry){
            var poly = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
            var curV = this.EdgesToRouteSources.get_Item$$TKey(edgeGeometry);
            poly.AddPoint$$Point(curV.get_Point());
            var $it408 = this.EdgesToRoutes.get_Item$$TKey(edgeGeometry).GetEnumerator();
            while ($it408.MoveNext()){
                var edge = $it408.get_Current();
                if (Microsoft.Msagl.Core.Geometry.Point.op_Equality(edge.get_SourcePoint(), curV.get_Point())){
                    poly.AddPoint$$Point(edge.get_TargetPoint());
                    curV = edge.Target;
                }
                else {
                    poly.AddPoint$$Point(edge.get_SourcePoint());
                    curV = edge.Source;
                }
            }
            edgeGeometry.set_Curve(poly);
            var clusterSourcePort = As(edgeGeometry.get_SourcePort(), Microsoft.Msagl.Routing.ClusterBoundaryPort.ctor);
            if (clusterSourcePort != null)
                Microsoft.Msagl.Routing.Spline.Bundling.SdShortestPath.ExtendPolylineStartToClusterBoundary(poly, clusterSourcePort.get_Curve());
            var clusterTargetPort = As(edgeGeometry.get_TargetPort(), Microsoft.Msagl.Routing.ClusterBoundaryPort.ctor);
            if (clusterTargetPort != null)
                Microsoft.Msagl.Routing.Spline.Bundling.SdShortestPath.ExtendPolylineEndToClusterBoundary(poly, clusterTargetPort.get_Curve());
        },
        RerouteEdges: function (){
            this.RestoreCapacities();
            for (var $i410 = 0,$t410 = this.get_EdgeGeometries(),$l410 = $t410.length,edgeGeometry = $t410[$i410]; $i410 < $l410; $i410++, edgeGeometry = $t410[$i410]){
                var newRoute = this.RerouteEdge(edgeGeometry);
                this.EdgesToRoutes.set_Item$$TKey(edgeGeometry, newRoute);
            }
        },
        RestoreCapacities: function (){
            if (this.get_Cdt() != null)
                this.get_Cdt().RestoreEdgeCapacities();
        },
        RerouteEdge: function (edgeGeometry){
            var route = this.EdgesToRoutes.get_Item$$TKey(edgeGeometry);
            var $it410 = route.GetEnumerator();
            while ($it410.MoveNext()){
                var edge = $it410.get_Current();
                edge.RemoveOccupiedEdge();
            }
            return this.RouteEdge(edgeGeometry);
        },
        RouteEdge: function (edgeGeometry){
            this.CurrentEdgeGeometry = edgeGeometry;
            for (var i = 0; i < this.vertexArray.length; i++){
                var sdv = this.vertexArray[i];
                sdv.SetPreviousToNull();
                sdv.set_IsSourceOfRouting((function ($p32){
                    sdv.set_IsTargetOfRouting($p32);
                    return $p32;
                }).call(this, false));
            }
            var transparentShapes = this.get_MakeTransparentShapesOfEdgeGeometry()(edgeGeometry);
            var ret = this.RouteEdgeWithGroups();
            var $it411 = transparentShapes.GetEnumerator();
            while ($it411.MoveNext()){
                var shape = $it411.get_Current();
                shape.set_IsTransparent(false);
            }
            return ret;
        },
        RouteEdgeWithGroups: function (){
            for (var i = 0; i < 2; i++){
                this.SetLengthCoefficient();
                this.Queue = new Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueue$1.ctor(Microsoft.Msagl.Routing.Spline.Bundling.SdVertex.ctor);
                (function (){
                    var $1 = {
                        Value: this.sourceLoosePoly
                    };
                    var $res = this.SetPortVerticesAndObstacles(this.CurrentEdgeGeometry.get_SourcePort(), true, $1);
                    this.sourceLoosePoly = $1.Value;
                    return $res;
                }).call(this);
                (function (){
                    var $1 = {
                        Value: this.targetLoosePoly
                    };
                    var $res = this.SetPortVerticesAndObstacles(this.CurrentEdgeGeometry.get_TargetPort(), false, $1);
                    this.targetLoosePoly = $1.Value;
                    return $res;
                }).call(this);
                var ret = this.RouteOnKnownSourceTargetVertices((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.CurrentEdgeGeometry.get_TargetPort().get_Location(), this.CurrentEdgeGeometry.get_SourcePort().get_Location())).Normalize(), i == 0);
                if (ret != null)
                    return ret;
                for (var j = 0; j < this.vertexArray.length; j++){
                    this.vertexArray[j].SetPreviousToNull();
                }
            }
            throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
        },
        RouteOnKnownSourceTargetVertices: function (pathDirection, lookingForMonotonePath){
            this.LowestCostToTarget = Infinity;
            this.ClosestTargetVertex = null;
            while (this.Queue.get_Count() > 0){
                var hu;
                var bestNode = (function (){
                    var $1 = {
                        Value: hu
                    };
                    var $res = this.Queue.Dequeue$$Double($1);
                    hu = $1.Value;
                    return $res;
                }).call(this);
                if (hu >= this.LowestCostToTarget)
                    continue;
                for (var i = 0; i < bestNode.OutBoneEdges.get_Count(); i++){
                    var outBoneEdge = bestNode.OutBoneEdges.get_Item$$Int32(i);
                    if (outBoneEdge.get_IsPassable())
                        this.ProcessOutcomingBoneEdge(bestNode, outBoneEdge, pathDirection, lookingForMonotonePath);
                }
                for (var i = 0; i < bestNode.InBoneEdges.get_Count(); i++){
                    var inBoneEdge = bestNode.InBoneEdges.get_Item$$Int32(i);
                    if (inBoneEdge.get_IsPassable())
                        this.ProcessIncomingBoneEdge(bestNode, inBoneEdge, pathDirection, lookingForMonotonePath);
                }
            }
            return this.GetPathAndUpdateRelatedCosts();
        },
        ProcessOutcomingBoneEdge: function (v, outBoneEdge, pathDirection, lookingForMonotonePath){
            System.Diagnostics.Debug.Assert$$Boolean(v == outBoneEdge.Source);
            if (lookingForMonotonePath && Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(pathDirection, (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(outBoneEdge.get_TargetPoint(), outBoneEdge.get_SourcePoint()))) < 0)
                return;
            this.ProcessBoneEdge(v, outBoneEdge.Target, outBoneEdge);
        },
        ProcessIncomingBoneEdge: function (v, inBoneEdge, pathDirection, lookingForMonotonePath){
            System.Diagnostics.Debug.Assert$$Boolean(v == inBoneEdge.Target);
            if (lookingForMonotonePath && Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(pathDirection, (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(inBoneEdge.get_SourcePoint(), inBoneEdge.get_TargetPoint()))) < 0)
                return;
            this.ProcessBoneEdge(v, inBoneEdge.Source, inBoneEdge);
        },
        ProcessBoneEdge: function (v, queueCandidate, boneEdge){
            var newCost = this.GetEdgeAdditionalCost(boneEdge, v.get_Cost());
            if (queueCandidate.get_Cost() <= newCost)
                return;
            queueCandidate.set_Cost(newCost);
            queueCandidate.set_PrevEdge(boneEdge);
            if (this.Queue.ContainsElement(queueCandidate))
                this.Queue.DecreasePriority(queueCandidate, newCost);
            else {
                if (queueCandidate.get_IsTargetOfRouting()){
                    var costToTarget = 0;
                    if (Is(this.CurrentEdgeGeometry.get_TargetPort(), Microsoft.Msagl.Routing.ClusterBoundaryPort.ctor))
                        costToTarget = this.LengthCoefficient * (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(queueCandidate.get_Point(), this.CurrentEdgeGeometry.get_TargetPort().get_Location())).get_Length();
                    if (newCost + costToTarget < this.LowestCostToTarget){
                        this.LowestCostToTarget = newCost + costToTarget;
                        this.ClosestTargetVertex = queueCandidate;
                    }
                    return;
                }
                this.Enqueue(queueCandidate);
            }
        },
        GetPathAndUpdateRelatedCosts: function (){
            var current = this.ClosestTargetVertex;
            if (current == null)
                return null;
            var result = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Spline.Bundling.SdBoneEdge.ctor);
            while (current.get_PrevEdge() != null){
                result.Add(current.get_PrevEdge());
                this.RegisterPathInBoneEdge(current.get_PrevEdge());
                current = current.get_Prev();
            }
            this.EdgesToRouteSources.set_Item$$TKey(this.CurrentEdgeGeometry, current);
            result.Reverse();
            System.Diagnostics.Debug.Assert$$Boolean(result.get_Count() > 0);
            return result;
        },
        RegisterPathInBoneEdge: function (boneEdge){
            boneEdge.AddOccupiedEdge();
            if (this.get_Cdt() != null && this.get_BundlingSettings().get_CapacityOverflowCoefficient() != 0)
                this.UpdateResidualCostsOfCrossedCdtEdges(boneEdge);
        },
        UpdateResidualCostsOfCrossedCdtEdges: function (boneEdge){
            var $it412 = boneEdge.get_CrossedCdtEdges().GetEnumerator();
            while ($it412.MoveNext()){
                var cdtEdge = $it412.get_Current();
                if (this.AdjacentToSourceOrTarget(cdtEdge))
                    continue;
                if (cdtEdge.get_ResidualCapacity() == cdtEdge.Capacity)
                    cdtEdge.set_ResidualCapacity(cdtEdge.get_ResidualCapacity() - this.CurrentEdgeGeometry.get_LineWidth());
                else
                    cdtEdge.set_ResidualCapacity(cdtEdge.get_ResidualCapacity() - (this.CurrentEdgeGeometry.get_LineWidth() + this.get_BundlingSettings().get_EdgeSeparation()));
            }
        },
        H: function (v){
            return v.get_Cost() + this.LengthCoefficient * (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v.get_Point(), this.CurrentEdgeGeometry.get_TargetPort().get_Location())).get_Length();
        },
        GetEdgeAdditionalCost: function (boneEdge, previousCost){
            var len = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(boneEdge.get_TargetPoint(), boneEdge.get_SourcePoint())).get_Length();
            return this.LengthCoefficient * len + previousCost + (boneEdge.get_IsOccupied() ? 0 : this.get_BundlingSettings().get_InkImportance() * len) + this.CapacityOverflowCost(boneEdge);
        },
        CapacityOverflowCost: function (boneEdge){
            if (this.get_Cdt() == null || this.get_BundlingSettings().get_CapacityOverflowCoefficient() == 0)
                return 0;
            var ret = 0;
            var $it413 = this.CrossedCdtEdgesOfBoneEdge(boneEdge).GetEnumerator();
            while ($it413.MoveNext()){
                var cdtEdge = $it413.get_Current();
                ret += this.CostOfCrossingCdtEdgeLocal(this.capacityOverlowPenaltyMultiplier, this.get_BundlingSettings(), this.CurrentEdgeGeometry, cdtEdge);
            }
            return ret;
        },
        CrossedCdtEdgesOfBoneEdge: function (boneEdge){
            if (Microsoft.Msagl.Core.DataStructures.Set$1.op_Inequality(boneEdge.get_CrossedCdtEdges(), null))
                return boneEdge.get_CrossedCdtEdges();
            boneEdge.set_CrossedCdtEdges(this.ThreadBoneEdgeThroughCdt(boneEdge));
            return boneEdge.get_CrossedCdtEdges();
        },
        ThreadBoneEdgeThroughCdt: function (boneEdge){
            var start = boneEdge.get_SourcePoint();
            var currentTriangle = boneEdge.Source.Triangle;
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.PointIsInsideOfTriangle(start, currentTriangle));
            var crossedEdges = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Routing.CdtEdge.ctor);
            var end = boneEdge.get_TargetPoint();
            if (Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.PointIsInsideOfTriangle(end, currentTriangle))
                return crossedEdges;
            var threader = new Microsoft.Msagl.Routing.Spline.Bundling.CdtThreader.ctor(currentTriangle, start, end);
            while (threader.MoveNext()){
                var piercedEdge = threader.get_CurrentPiercedEdge();
                System.Diagnostics.Debug.Assert$$Boolean(piercedEdge != null);
                if (this.get_Gates().Contains$$T(piercedEdge))
                    crossedEdges.Insert(piercedEdge);
            }
            return crossedEdges;
        },
        CostOfCrossingCdtEdgeLocal: function (capacityOverflMult, bundlingSettings, currentEdgeGeometry, e){
            if (this.AdjacentToSourceOrTarget(e))
                return 0;
            return Microsoft.Msagl.Routing.Spline.Bundling.SdShortestPath.CostOfCrossingCdtEdge(capacityOverflMult, bundlingSettings, currentEdgeGeometry, e);
        },
        AdjacentToSourceOrTarget: function (e){
            return e.upperSite.get_Owner() == this.sourceLoosePoly || e.lowerSite.get_Owner() == this.sourceLoosePoly || e.upperSite.get_Owner() == this.targetLoosePoly || e.lowerSite.get_Owner() == this.targetLoosePoly;
        },
        GetIdealDistanceBetweenHookUpAnywherePortAndPort: function (hookPort, port){
            var poly = hookPort.get_LoosePolyline();
            var point = port.get_Location();
            var closestPar = poly.ClosestParameter(point);
            return (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(point, poly.get_Item$$Double(closestPar))).get_Length();
        },
        GetIdealDistanceBetweenClusterPortAndPort: function (clsp, port){
            var poly = clsp.get_LoosePolyline();
            var otherClsp = As(port, Microsoft.Msagl.Routing.ClusterBoundaryPort.ctor);
            if (otherClsp != null){
                var polygon0 = new Microsoft.Msagl.Routing.Visibility.Polygon.ctor(poly);
                var polygon1 = new Microsoft.Msagl.Routing.Visibility.Polygon.ctor(otherClsp.get_LoosePolyline());
                return Microsoft.Msagl.Routing.Visibility.Polygon.Distance$$Polygon$$Polygon(polygon0, polygon1);
            }
            var point = port.get_Location();
            var closestPar = poly.ClosestParameter(point);
            return (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(point, poly.get_Item$$Double(closestPar))).get_Length();
        },
        SetLengthCoefficient: function (){
            var idealEdgeLength = this.GetIdealDistanceBetweenSourceAndTarget(this.CurrentEdgeGeometry);
            this.LengthCoefficient = this.get_BundlingSettings().get_PathLengthImportance() / idealEdgeLength;
        },
        GetIdealDistanceBetweenSourceAndTarget: function (edgeGeometry){
            return (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(edgeGeometry.get_SourcePort().get_Location(), edgeGeometry.get_TargetPort().get_Location())).get_Length();
        },
        SetPortVerticesAndObstacles: function (port, sources, poly){
            poly.Value = null;
            var cbport = As(port, Microsoft.Msagl.Routing.ClusterBoundaryPort.ctor);
            if (cbport != null){
                poly.Value = cbport.get_LoosePolyline();
                var $it414 = poly.Value.GetEnumerator();
                while ($it414.MoveNext()){
                    var point = $it414.get_Current();
                    var initialCost = 0;
                    if (sources){
                        initialCost = this.LengthCoefficient * (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(point, this.CurrentEdgeGeometry.get_SourcePort().get_Location())).get_Length();
                    }
                    this.AddAndEnqueueVertexToEnds(point, sources, initialCost);
                }
            }
            else {
                var anywherePort = As(port, Microsoft.Msagl.Core.Layout.HookUpAnywhereFromInsidePort.ctor);
                if (anywherePort != null){
                    poly.Value = anywherePort.get_LoosePolyline();
                    var $it415 = poly.Value.GetEnumerator();
                    while ($it415.MoveNext()){
                        var point = $it415.get_Current();
                        this.AddAndEnqueueVertexToEnds(point, sources, 0);
                    }
                }
                else {
                    this.AddAndEnqueueVertexToEnds(port.get_Location(), sources, 0);
                    var polys = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, this.get_ObstacleHierarchy().GetNodeItemsIntersectingRectangle(port.get_Curve().get_BoundingBox()));
                    var mindiag = polys[0].get_BoundingBox().get_Diagonal();
                    poly.Value = polys[0];
                    for (var i = 1; i < polys.length; i++){
                        var pl = polys[i];
                        var diag = pl.get_BoundingBox().get_Diagonal();
                        if (diag < mindiag){
                            mindiag = diag;
                            poly.Value = pl;
                        }
                    }
                }
            }
        },
        Enqueue: function (simpleSdVertex){
            this.Queue.Enqueue(simpleSdVertex, this.H(simpleSdVertex));
        },
        AddAndEnqueueVertexToEnds: function (point, isSource, initialCost){
            var v = this.FindVertex(point);
            var sdVert = this.VisibilityVerticesToSdVerts.get_Item$$TKey(v);
            if (isSource){
                sdVert.set_IsSourceOfRouting(true);
                sdVert.set_Cost(initialCost);
                this.Enqueue(sdVert);
            }
            else {
                sdVert.set_IsTargetOfRouting(true);
            }
        },
        FindVertex: function (p){
            return (this.get_VisibilityGraph().FindVertex(p) != null ? this.get_VisibilityGraph().FindVertex(p) : this.get_VisibilityGraph().FindVertex(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Point(p)));
        },
        Initialize: function (){
            this.CreateRoutingGraph();
            if (this.get_Cdt() != null){
                this.capacityOverlowPenaltyMultiplier = Microsoft.Msagl.Routing.Spline.Bundling.SdShortestPath.CapacityOverflowPenaltyMultiplier(this.get_BundlingSettings());
                this.SetVertexTriangles();
                this.CalculateCapacitiesOfTrianglulation();
            }
        },
        CalculateCapacitiesOfTrianglulation: function (){
            var $it416 = this.get_Gates().GetEnumerator();
            while ($it416.MoveNext()){
                var e = $it416.get_Current();
                Microsoft.Msagl.Routing.Spline.Bundling.SdShortestPath.CalculateCdtEdgeCapacityForEdge(e);
            }
        },
        SetVertexTriangles: function (){
            var triangleTree = Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnEnumeration(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle.ctor, Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, this.get_Cdt().GetTriangles(), $CreateAnonymousDelegate(this, function (t){
                return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle.ctor, t, t.BoundingBox());
            })));
            var vertexTree = Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnEnumeration(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Spline.Bundling.SdVertex.ctor, Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, this.vertexArray, $CreateAnonymousDelegate(this, function (v){
                return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(Microsoft.Msagl.Routing.Spline.Bundling.SdVertex.ctor, v, new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point(v.get_Point()));
            })));
            Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$2$$RectangleNode$1$$RectangleNode$1$$Action$2(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle.ctor, Microsoft.Msagl.Routing.Spline.Bundling.SdVertex.ctor, triangleTree, vertexTree, $CreateDelegate(this, this.TryToAssigenTriangleToVertex));
            for (var $i418 = 0,$t418 = this.vertexArray,$l418 = $t418.length,v = $t418[$i418]; $i418 < $l418; $i418++, v = $t418[$i418]){
                System.Diagnostics.Debug.Assert$$Boolean(v.Triangle != null);
            }
        },
        TryToAssigenTriangleToVertex: function (triangle, vertex){
            if (vertex.Triangle != null)
                return;
            if (Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.PointIsInsideOfTriangle(vertex.get_Point(), triangle))
                vertex.Triangle = triangle;
        },
        FillCrossedCdtEdges: function (crossedCdtEdges){
            for (var $i419 = 0,$t419 = this.get_EdgeGeometries(),$l419 = $t419.length,geometryEdge = $t419[$i419]; $i419 < $l419; $i419++, geometryEdge = $t419[$i419]){
                (function (){
                    var $1 = {
                        Value: this.sourceLoosePoly
                    };
                    var $res = this.SetPortVerticesAndObstacles(geometryEdge.get_SourcePort(), true, $1);
                    this.sourceLoosePoly = $1.Value;
                    return $res;
                }).call(this);
                (function (){
                    var $1 = {
                        Value: this.targetLoosePoly
                    };
                    var $res = this.SetPortVerticesAndObstacles(geometryEdge.get_TargetPort(), false, $1);
                    this.targetLoosePoly = $1.Value;
                    return $res;
                }).call(this);
                var $it419 = this.EdgesToRoutes.get_Item$$TKey(geometryEdge).GetEnumerator();
                while ($it419.MoveNext()){
                    var boneEdge = $it419.get_Current();
                    var $it420 = this.CrossedCdtEdgesOfBoneEdge(boneEdge).GetEnumerator();
                    while ($it420.MoveNext()){
                        var cdtEdge = $it420.get_Current();
                        if (this.AdjacentToSourceOrTarget(cdtEdge))
                            continue;
                        Microsoft.Msagl.Core.DataStructures.CollectionUtilities.AddToMap$3(Microsoft.Msagl.Routing.CdtEdge.ctor, Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, Microsoft.Msagl.Core.DataStructures.Set$1.ctor, crossedCdtEdges, geometryEdge, cdtEdge);
                    }
                }
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$SdShortestPath);
var Microsoft$Msagl$Routing$SingleSourceMultipleTargetsShortestPathOnVisibilityGraph = {
    fullname: "Microsoft.Msagl.Routing.SingleSourceMultipleTargetsShortestPathOnVisibilityGraph",
    baseTypeName: "System.Object",
    staticDefinition: {
        IsForbidden: function (e){
            return e.get_IsPassable() != null && !e.get_IsPassable()() || Is(e, Microsoft.Msagl.Routing.Visibility.TollFreeVisibilityEdge.ctor);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (sourceVisVertex, targetVisVertices, visibilityGraph){
            this.source = null;
            this.targets = null;
            this.current = null;
            this.closestTarget = null;
            this.upperBound = Infinity;
            this._visGraph = null;
            System.Object.ctor.call(this);
            this._visGraph = visibilityGraph;
            this._visGraph.ClearPrevEdgesTable();
            var $it421 = visibilityGraph.Vertices().GetEnumerator();
            while ($it421.MoveNext()){
                var v = $it421.get_Current();
                v.set_Distance(Infinity);
            }
            this.source = sourceVisVertex;
            this.targets = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor, targetVisVertices);
            this.source.set_Distance(0);
        },
        GetPath: function (){
            var pq = new Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueue$1.ctor(Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor);
            this.source.set_Distance(0);
            pq.Enqueue(this.source, 0);
            while (!pq.IsEmpty()){
                this.current = pq.Dequeue();
                if (this.targets.Contains$$T(this.current))
                    break;
                var $it422 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor, this.current.get_OutEdges(), $CreateDelegate(this, this.PassableOutEdge)).GetEnumerator();
                while ($it422.MoveNext()){
                    var e = $it422.get_Current();
                    this.ProcessNeighbor(pq, e, e.get_Target());
                }
                var $it423 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor, this.current.get_InEdges(), $CreateDelegate(this, this.PassableInEdge)).GetEnumerator();
                while ($it423.MoveNext()){
                    var e = $it423.get_Current();
                    this.ProcessNeighbor(pq, e, e.get_Source());
                }
            }
            return this._visGraph.PreviosVertex(this.current) == null ? null : this.CalculatePath();
        },
        PassableOutEdge: function (e){
            return e.get_Source() == this.source || this.targets.Contains$$T(e.get_Target()) || !Microsoft.Msagl.Routing.SingleSourceMultipleTargetsShortestPathOnVisibilityGraph.IsForbidden(e);
        },
        PassableInEdge: function (e){
            return this.targets.Contains$$T(e.get_Source()) || e.get_Target() == this.source || !Microsoft.Msagl.Routing.SingleSourceMultipleTargetsShortestPathOnVisibilityGraph.IsForbidden(e);
        },
        ProcessNeighbor: function (pq, l, v){
            var len = l.get_Length();
            var c = this.current.get_Distance() + len;
            if (c >= this.upperBound)
                return;
            if (this.targets.Contains$$T(v)){
                this.upperBound = c;
                this.closestTarget = v;
            }
            if (v != this.source && this._visGraph.PreviosVertex(v) == null){
                v.set_Distance(c);
                this._visGraph.SetPreviousEdge(v, l);
                pq.Enqueue(v, c);
            }
            else if (c < v.get_Distance()){
                v.set_Distance(c);
                this._visGraph.SetPreviousEdge(v, l);
                pq.DecreasePriority(v, c);
            }
        },
        CalculatePath: function (){
            if (this.closestTarget == null)
                return null;
            var ret = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor);
            var v = this.closestTarget;
            do{
                ret.Add(v);
                v = this._visGraph.PreviosVertex(v);
            }
            while (v != this.source)
            ret.Add(this.source);
            ret.Reverse();
            return ret;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$SingleSourceMultipleTargetsShortestPathOnVisibilityGraph);
var Microsoft$Msagl$Routing$SingleSourceMultipleTargetsShortestPathOnVisibilityGraph$ddType = {
    fullname: "Microsoft.Msagl.Routing.SingleSourceMultipleTargetsShortestPathOnVisibilityGraph.ddType",
    Kind: "Delegate",
    definition: {
        ctor: function (obj, func){
            System.MulticastDelegate.ctor.call(this, obj, func);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$SingleSourceMultipleTargetsShortestPathOnVisibilityGraph$ddType);
var Microsoft$Msagl$Routing$Spline$Bundling$BundleBase = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.BundleBase",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (count, boundaryCurve, position, belongsToRealNode, stationIndex){
            this.OutgoingBundleInfo = null;
            this.IncomingBundleInfo = null;
            this.points = null;
            this.tangents = null;
            this.OrientedHubSegments = null;
            this.Curve = null;
            this.IsParent = false;
            this.BelongsToRealNode = false;
            this.Position = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.stationIndex = 0;
            this.initialMidParameter = 0;
            this.parRight = 0;
            this.parLeft = 0;
            this.Prev = null;
            this.Next = null;
            this.ParameterSpan = 0;
            this._InitialMidPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._RightPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._LeftPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            System.Object.ctor.call(this);
            this.BelongsToRealNode = belongsToRealNode;
            this.Curve = boundaryCurve;
            this.Position = position;
            this.stationIndex = stationIndex;
            this.points = new Array(count);
            this.tangents = new Array(count);
            this.OrientedHubSegments = new Array(count);
            this.ParameterSpan = this.Curve.get_ParEnd() - this.Curve.get_ParStart();
        },
        BundleInfo$$: "Microsoft.Msagl.Routing.Spline.Bundling.BundleInfo",
        get_BundleInfo: function (){
            return (this.OutgoingBundleInfo != null ? this.OutgoingBundleInfo : this.IncomingBundleInfo);
        },
        CurveCenter$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_CurveCenter: function (){
            return this.Curve.get_BoundingBox().get_Center();
        },
        OppositeBase$$: "Microsoft.Msagl.Routing.Spline.Bundling.BundleBase",
        get_OppositeBase: function (){
            return this.OutgoingBundleInfo != null ? this.OutgoingBundleInfo.TargetBase : this.IncomingBundleInfo.SourceBase;
        },
        TotalRequiredWidth$$: "System.Double",
        get_TotalRequiredWidth: function (){
            return this.get_BundleInfo().TotalRequiredWidth;
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this.points.length;
        },
        Points$$: "Microsoft.Msagl.Core.Geometry.Point[]",
        get_Points: function (){
            return this.points;
        },
        Tangents$$: "Microsoft.Msagl.Core.Geometry.Point[]",
        get_Tangents: function (){
            return this.tangents;
        },
        InitialMidParameter$$: "System.Double",
        get_InitialMidParameter: function (){
            return this.initialMidParameter;
        },
        set_InitialMidParameter: function (value){
            this.initialMidParameter = value;
            this.set_InitialMidPoint(this.Curve.get_Item$$Double(value));
        },
        InitialMidPoint$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_InitialMidPoint: function (){
            return this._InitialMidPoint;
        },
        set_InitialMidPoint: function (value){
            this._InitialMidPoint = value;
        },
        ParRight$$: "System.Double",
        get_ParRight: function (){
            return this.parRight;
        },
        set_ParRight: function (value){
            this.parRight = value;
            this.set_RightPoint(this.Curve.get_Item$$Double(this.parRight));
        },
        ParLeft$$: "System.Double",
        get_ParLeft: function (){
            return this.parLeft;
        },
        set_ParLeft: function (value){
            this.parLeft = value;
            this.set_LeftPoint(this.Curve.get_Item$$Double(this.parLeft));
        },
        ParMid$$: "System.Double",
        get_ParMid: function (){
            return (this.parRight + this.parLeft) / 2;
        },
        RightPoint$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_RightPoint: function (){
            return this._RightPoint;
        },
        set_RightPoint: function (value){
            this._RightPoint = value;
        },
        LeftPoint$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_LeftPoint: function (){
            return this._LeftPoint;
        },
        set_LeftPoint: function (value){
            this._LeftPoint = value;
        },
        MidPoint$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_MidPoint: function (){
            return Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.get_RightPoint(), this.get_LeftPoint())), 2);
        },
        Span$$: "System.Double",
        get_Span: function (){
            return this.SpanBetweenTwoPoints(this.parRight, this.parLeft);
        },
        SpanBetweenTwoPoints: function (right, left){
            return (right <= left ? left - right : left - right + this.ParameterSpan);
        },
        RotateLeftPoint: function (rotationOfSourceLeftPoint, parameterChange){
            if (rotationOfSourceLeftPoint == 0)
                return this.get_LeftPoint();
            return this.RotatePoint(rotationOfSourceLeftPoint, this.parLeft, parameterChange);
        },
        RotateRigthPoint: function (rotationOfSourceRightPoint, parameterChange){
            if (rotationOfSourceRightPoint == 0)
                return this.get_RightPoint();
            return this.RotatePoint(rotationOfSourceRightPoint, this.parRight, parameterChange);
        },
        RotatePoint: function (rotation, t, parameterChange){
            var change = this.ParameterSpan * parameterChange;
            t = t + rotation * change;
            t = this.AdjustParam(t);
            return this.Curve.get_Item$$Double(t);
        },
        AdjustParam: function (t){
            if (t > this.Curve.get_ParEnd())
                t = this.Curve.get_ParStart() + (t - this.Curve.get_ParEnd());
            else if (t < this.Curve.get_ParStart())
                t = this.Curve.get_ParEnd() - (this.Curve.get_ParStart() - t);
            return t;
        },
        RotateBy: function (rotationOfRightPoint, rotationOfLeftPoint, parameterChange){
            var change = this.ParameterSpan * parameterChange;
            if (rotationOfRightPoint != 0)
                this.set_ParRight(this.AdjustParam(this.get_ParRight() + rotationOfRightPoint * change));
            if (rotationOfLeftPoint != 0)
                this.set_ParLeft(this.AdjustParam(this.get_ParLeft() + rotationOfLeftPoint * change));
        },
        Intersect$$BundleBase: function (other){
            return this.Intersect$$Double$$Double$$Double$$Double(this.parRight, this.parLeft, other.parRight, other.parLeft);
        },
        Intersect$$Double$$Double$$Double$$Double: function (lParRight, lParLeft, rParRight, rParLeft){
            if (lParRight > lParLeft)
                return this.Intersect$$Double$$Double$$Double$$Double(lParRight, this.Curve.get_ParEnd(), rParRight, rParLeft) || this.Intersect$$Double$$Double$$Double$$Double(this.Curve.get_ParStart(), lParLeft, rParRight, rParLeft);
            if (rParRight > rParLeft)
                return this.Intersect$$Double$$Double$$Double$$Double(lParRight, lParLeft, rParRight, this.Curve.get_ParEnd()) || this.Intersect$$Double$$Double$$Double$$Double(lParRight, lParLeft, this.Curve.get_ParStart(), rParLeft);
            System.Diagnostics.Debug.Assert$$Boolean(lParRight <= lParLeft);
            System.Diagnostics.Debug.Assert$$Boolean(rParRight <= rParLeft);
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.LessOrEqual(lParLeft, rParRight))
                return false;
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.LessOrEqual(rParLeft, lParRight))
                return false;
            return true;
        },
        RelativeOrderOfBasesIsPreserved: function (rotationOfRightPoint, rotationOfLeftPoint, parameterChange){
            var change = this.ParameterSpan * parameterChange;
            var rnew = this.parRight + rotationOfRightPoint * change;
            var lnew = (this.parRight < this.parLeft ? this.parLeft + rotationOfLeftPoint * change : this.parLeft + this.ParameterSpan + rotationOfLeftPoint * change);
            if (rnew > lnew)
                return false;
            if (this.SpanBetweenTwoPoints(rnew, lnew) > this.ParameterSpan / 2)
                return false;
            if (this.Prev == null)
                return true;
            if (this.SpanBetweenTwoPoints(this.Prev.get_ParMid(), this.get_ParMid()) > change && this.SpanBetweenTwoPoints(this.get_ParMid(), this.Next.get_ParMid()) > change)
                return true;
            var rSoP = this.RotateLeftPoint(rotationOfLeftPoint, parameterChange);
            var lSoP = this.RotateRigthPoint(rotationOfRightPoint, parameterChange);
            var newMidPoint = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Addition(rSoP, lSoP)), 2);
            var curMidPoint = this.get_MidPoint();
            if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(this.get_CurveCenter(), this.Prev.get_MidPoint(), curMidPoint) != Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(this.get_CurveCenter(), this.Prev.get_MidPoint(), newMidPoint))
                return false;
            if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(this.get_CurveCenter(), this.Next.get_MidPoint(), curMidPoint) != Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(this.get_CurveCenter(), this.Next.get_MidPoint(), newMidPoint))
                return false;
            return true;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$BundleBase);
var Microsoft$Msagl$Routing$Spline$Bundling$BundleBasesCalculator = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.BundleBasesCalculator",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Routing.Spline.Bundling.BundleBasesCalculator.Deltas = [new Int32Array([1, 1]), new Int32Array([0, 1]), new Int32Array([-1, 1]), new Int32Array([1, 0]), new Int32Array([-1, 0]), new Int32Array([1, -1]), new Int32Array([0, -1]), new Int32Array([-1, -1]), new Int32Array([0, 0])];
            Microsoft.Msagl.Routing.Spline.Bundling.BundleBasesCalculator.SeparationCoeff = 1;
            Microsoft.Msagl.Routing.Spline.Bundling.BundleBasesCalculator.SqueezeCoeff = 1;
            Microsoft.Msagl.Routing.Spline.Bundling.BundleBasesCalculator.CenterCoeff = 10;
            Microsoft.Msagl.Routing.Spline.Bundling.BundleBasesCalculator.AssymetryCoeff = 1;
            Microsoft.Msagl.Routing.Spline.Bundling.BundleBasesCalculator.MaxIterations = 200;
            Microsoft.Msagl.Routing.Spline.Bundling.BundleBasesCalculator.MaxParameterChange = 0.0222222222222222;
            Microsoft.Msagl.Routing.Spline.Bundling.BundleBasesCalculator.MinParameterChange = 0.000277777777777778;
            Microsoft.Msagl.Routing.Spline.Bundling.BundleBasesCalculator.CostThreshold = 1E-05;
            Microsoft.Msagl.Routing.Spline.Bundling.BundleBasesCalculator.CostDeltaThreshold = 0.01;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (metroOrdering, metroGraphData, bundlingSettings){
            this.metroOrdering = null;
            this.metroGraphData = null;
            this.bundlingSettings = null;
            this.Bundles = null;
            this.externalBases = null;
            this.internalBases = null;
            this.fixedBundles = new System.Collections.Generic.HashSet$1.ctor(Microsoft.Msagl.Routing.Spline.Bundling.BundleInfo.ctor);
            this.stepsWithProgress = 0;
            System.Object.ctor.call(this);
            this.metroOrdering = metroOrdering;
            this.metroGraphData = metroGraphData;
            this.bundlingSettings = bundlingSettings;
        },
        Run: function (){
            this.AllocateBundleBases();
            this.SetBasesRightLeftParamsToTheMiddles();
            if (this.bundlingSettings.get_KeepOverlaps()){
                this.UpdateSourceAndTargetBases();
                this.CreateOrientedSegs();
            }
            else {
                this.SetRightLeftParamsFeasiblySymmetrically();
                this.AdjustStartEndParamsToAvoidBaseOverlaps();
                this.UpdateSourceAndTargetBases();
                this.CreateOrientedSegs();
                this.Optimize();
                this.AdjustStartEndParamsToAvoidBaseOverlaps();
                this.UpdateSourceAndTargetBases();
            }
        },
        AllocateBundleBases: function (){
            this.externalBases = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor, System.Collections.Generic.List$1.ctor);
            this.internalBases = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor, System.Collections.Generic.List$1.ctor);
            this.Bundles = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Spline.Bundling.BundleInfo.ctor);
            var $it424 = this.metroGraphData.Stations.GetEnumerator();
            while ($it424.MoveNext()){
                var station = $it424.get_Current();
                if (station.BoundaryCurve == null)
                    station.BoundaryCurve = new Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor$$Double$$Double$$Point(station.Radius, station.Radius, station.Position);
            }
            var $it425 = this.metroGraphData.Stations.GetEnumerator();
            while ($it425.MoveNext()){
                var station = $it425.get_Current();
                for (var $i427 = 0,$t427 = station.Neighbors,$l427 = $t427.length,neighbor = $t427[$i427]; $i427 < $l427; $i427++, neighbor = $t427[$i427]){
                    if (Microsoft.Msagl.Routing.Spline.Bundling.Station.op_LessThan(station, neighbor)){
                        var bb = new Microsoft.Msagl.Routing.Spline.Bundling.BundleBase.ctor(this.metroGraphData.RealEdgeCount$$Station$$Station(station, neighbor), station.BoundaryCurve, station.Position, station.IsRealNode, neighbor.SerialNumber);
                        station.BundleBases.set_Item$$TKey(neighbor, bb);
                        var bb2 = new Microsoft.Msagl.Routing.Spline.Bundling.BundleBase.ctor(this.metroGraphData.RealEdgeCount$$Station$$Station(station, neighbor), neighbor.BoundaryCurve, neighbor.Position, neighbor.IsRealNode, station.SerialNumber);
                        neighbor.BundleBases.set_Item$$TKey(station, bb2);
                        if (Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(neighbor.Position, station.BoundaryCurve) != Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside){
                            bb.IsParent = true;
                            Microsoft.Msagl.Core.DataStructures.CollectionUtilities.AddToMap$3(Microsoft.Msagl.Routing.Spline.Bundling.BundleBase.ctor, Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor, System.Collections.Generic.List$1.ctor, this.internalBases, station.BoundaryCurve, bb);
                            Microsoft.Msagl.Core.DataStructures.CollectionUtilities.AddToMap$3(Microsoft.Msagl.Routing.Spline.Bundling.BundleBase.ctor, Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor, System.Collections.Generic.List$1.ctor, this.externalBases, neighbor.BoundaryCurve, bb2);
                        }
                        else if (Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(station.Position, neighbor.BoundaryCurve) != Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside){
                            bb2.IsParent = true;
                            Microsoft.Msagl.Core.DataStructures.CollectionUtilities.AddToMap$3(Microsoft.Msagl.Routing.Spline.Bundling.BundleBase.ctor, Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor, System.Collections.Generic.List$1.ctor, this.externalBases, station.BoundaryCurve, bb);
                            Microsoft.Msagl.Core.DataStructures.CollectionUtilities.AddToMap$3(Microsoft.Msagl.Routing.Spline.Bundling.BundleBase.ctor, Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor, System.Collections.Generic.List$1.ctor, this.internalBases, neighbor.BoundaryCurve, bb2);
                        }
                        else {
                            Microsoft.Msagl.Core.DataStructures.CollectionUtilities.AddToMap$3(Microsoft.Msagl.Routing.Spline.Bundling.BundleBase.ctor, Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor, System.Collections.Generic.List$1.ctor, this.externalBases, station.BoundaryCurve, bb);
                            Microsoft.Msagl.Core.DataStructures.CollectionUtilities.AddToMap$3(Microsoft.Msagl.Routing.Spline.Bundling.BundleBase.ctor, Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor, System.Collections.Generic.List$1.ctor, this.externalBases, neighbor.BoundaryCurve, bb2);
                        }
                        var obstaclesToIgnore = this.metroGraphData.tightIntersections.ObstaclesToIgnoreForBundle(station, neighbor);
                        var bundle = new Microsoft.Msagl.Routing.Spline.Bundling.BundleInfo.ctor(bb, bb2, obstaclesToIgnore, this.bundlingSettings.get_EdgeSeparation(), System.Linq.Enumerable.ToArray$1(System.Double.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Spline.Bundling.Metroline.ctor, System.Double.ctor, this.metroOrdering.GetOrder(station, neighbor), $CreateAnonymousDelegate(this, function (l){
                            return l.Width / 2;
                        }))));
                        bb.OutgoingBundleInfo = bb2.IncomingBundleInfo = bundle;
                        this.Bundles.Add(bundle);
                    }
                }
            }
            this.SetBundleBaseNeighbors();
        },
        SetBundleBaseNeighbors: function (){
            var $it427 = this.externalBases.get_Keys().GetEnumerator();
            while ($it427.MoveNext()){
                var c = $it427.get_Current();
                var list = this.externalBases.get_Item$$TKey(c);
                this.SortBundlesCounterClockwise(list);
                this.SetLeftRightBases(list);
            }
            var $it428 = this.internalBases.get_Keys().GetEnumerator();
            while ($it428.MoveNext()){
                var c = $it428.get_Current();
                var list = this.internalBases.get_Item$$TKey(c);
                this.SortBundlesCounterClockwise(list);
                this.SetLeftRightBases(list);
            }
        },
        SortBundlesCounterClockwise: function (list){
            if (list.get_Count() > 2){
                var pivot = list.get_Item$$Int32(0).get_OppositeBase().Position;
                var center = list.get_Item$$Int32(0).get_CurveCenter();
                list.Sort$$Comparison$1($CreateAnonymousDelegate(this, function (u, v){
                    return Microsoft.Msagl.Core.Geometry.Point.GetOrientationOf3Vectors(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(pivot, center), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(u.get_OppositeBase().Position, center), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v.get_OppositeBase().Position, center));
                }));
            }
        },
        SetLeftRightBases: function (bases){
            var count = bases.get_Count();
            if (count <= 1)
                return;
            for (var i = 0; i < count; i++){
                bases.get_Item$$Int32(i).Prev = bases.get_Item$$Int32((i - 1 + count) % count);
                bases.get_Item$$Int32(i).Next = bases.get_Item$$Int32((i + 1) % count);
            }
        },
        CreateOrientedSegs: function (){
            var $it429 = this.metroGraphData.get_Metrolines().GetEnumerator();
            while ($it429.MoveNext()){
                var metroline = $it429.get_Current();
                this.CreateOrientedSegsOnLine(metroline);
            }
        },
        CreateOrientedSegsOnLine: function (line){
            for (var polyPoint = line.get_Polyline().get_StartPoint().get_Next(); polyPoint.get_Next() != null; polyPoint = polyPoint.get_Next())
                this.CreateOrientedSegsOnLineVertex(line, polyPoint);
        },
        CreateOrientedSegsOnLineVertex: function (line, polyPoint){
            var u = this.metroGraphData.PointToStations.get_Item$$TKey(polyPoint.get_Prev().get_Point());
            var v = this.metroGraphData.PointToStations.get_Item$$TKey(polyPoint.get_Point());
            var w = this.metroGraphData.PointToStations.get_Item$$TKey(polyPoint.get_Next().get_Point());
            var h0 = v.BundleBases.get_Item$$TKey(u);
            var h1 = v.BundleBases.get_Item$$TKey(w);
            var j0 = this.metroOrdering.GetLineIndexInOrder(u, v, line);
            var j1 = this.metroOrdering.GetLineIndexInOrder(w, v, line);
            var or0 = h0.OrientedHubSegments[j0] = new Microsoft.Msagl.Routing.Spline.Bundling.OrientedHubSegment.ctor(null, false, j0, h0);
            var or1 = h1.OrientedHubSegments[j1] = new Microsoft.Msagl.Routing.Spline.Bundling.OrientedHubSegment.ctor(null, true, j1, h1);
            or1.set_Other(or0);
            or0.set_Other(or1);
        },
        UpdateSourceAndTargetBases: function (){
            var $it430 = this.Bundles.GetEnumerator();
            while ($it430.MoveNext()){
                var bundleInfo = $it430.get_Current();
                bundleInfo.UpdateSourceAndTargetBases(true, true);
            }
        },
        SetBasesRightLeftParamsToTheMiddles: function (){
            var $it431 = this.Bundles.GetEnumerator();
            while ($it431.MoveNext()){
                var bundle = $it431.get_Current();
                var sbase = bundle.SourceBase;
                var tbase = bundle.TargetBase;
                sbase.set_ParRight((function ($p33){
                    sbase.set_ParLeft($p33);
                    return $p33;
                }).call(this, this.GetBaseMiddleParamInDirection(sbase, sbase.Position, tbase.Position)));
                tbase.set_ParRight((function ($p34){
                    tbase.set_ParLeft($p34);
                    return $p34;
                }).call(this, this.GetBaseMiddleParamInDirection(tbase, tbase.Position, sbase.Position)));
            }
        },
        GetBaseMiddleParamInDirection: function (targetBase, sPos, neighbPos){
            var curve = targetBase.Curve;
            var circle = As(curve, Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor);
            if (circle != null && circle.IsArc())
                return Microsoft.Msagl.Core.Geometry.Point.Angle$$Point$$Point(circle.get_AxisA(), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(neighbPos, sPos));
            var intersections = Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(curve, new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(sPos, neighbPos), true);
            var $it432 = intersections.GetEnumerator();
            while ($it432.MoveNext()){
                var intersectionInfo = $it432.get_Current();
                var xP = intersectionInfo.get_IntersectionPoint();
                if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(xP, sPos)), (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(xP, neighbPos))) <= 0){
                    return intersectionInfo.get_Par0();
                }
            }
            throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
        },
        SetRightLeftParamsFeasiblySymmetrically: function (){
            var $it433 = this.Bundles.GetEnumerator();
            while ($it433.MoveNext()){
                var bundle = $it433.get_Current();
                bundle.SetParamsFeasiblySymmetrically(this.metroGraphData.get_TightTree());
            }
        },
        AdjustStartEndParamsToAvoidBaseOverlaps: function (){
            var $it434 = this.externalBases.get_Keys().GetEnumerator();
            while ($it434.MoveNext()){
                var c = $it434.get_Current();
                this.AdjustCurrentBundleWidthsOnCurve(this.externalBases.get_Item$$TKey(c));
            }
            var $it435 = this.internalBases.get_Keys().GetEnumerator();
            while ($it435.MoveNext()){
                var c = $it435.get_Current();
                this.AdjustCurrentBundleWidthsOnCurve(this.internalBases.get_Item$$TKey(c));
            }
        },
        AdjustCurrentBundleWidthsOnCurve: function (bases){
            var count = bases.get_Count();
            if (count <= 1)
                return;
            for (var i = 0; i < count; i++){
                var rBase = bases.get_Item$$Int32(i);
                var lBase = rBase.Next;
                this.ShrinkBasesToMakeTwoConsecutiveNeighborsHappy(rBase, lBase);
                System.Diagnostics.Debug.Assert$$Boolean(!rBase.Intersect$$BundleBase(lBase));
            }
        },
        ShrinkBasesToMakeTwoConsecutiveNeighborsHappy: function (rBase, lBase){
            if (!rBase.Intersect$$BundleBase(lBase))
                return;
            var l1 = rBase.get_ParRight();
            var r1 = rBase.get_ParLeft();
            var l2 = lBase.get_ParRight();
            var r2 = lBase.get_ParLeft();
            var span = lBase.ParameterSpan;
            if (l1 > r1)
                l1 -= span;
            if (l2 > r2)
                l2 -= span;
            if (l2 > r1){
                l2 -= span;
                r2 -= span;
            }
            if (l1 > r2){
                l1 -= span;
                r1 -= span;
            }
            System.Diagnostics.Debug.Assert$$Boolean(!(l2 >= r1) && !(l1 >= r2));
            var t = this.RegularCut(l1, r1, l2, r2, rBase.get_Span(), lBase.get_Span());
            var to = Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(lBase.get_CurveCenter(), lBase.get_OppositeBase().get_InitialMidPoint(), rBase.get_OppositeBase().get_InitialMidPoint());
            if (to == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise){
                r1 = t;
                l2 = t;
            }
            else if (to == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise){
                r2 = t;
                l1 = t;
            }
            else {
                if (r2 - l1 >= r1 - l2){
                    r1 = t;
                    l2 = t;
                }
                else {
                    r2 = t;
                    l1 = t;
                }
            }
            System.Diagnostics.Debug.Assert$$Boolean(!rBase.Intersect$$Double$$Double$$Double$$Double(l1, r1, l2, r2));
            lBase.set_ParRight(lBase.AdjustParam(l2));
            lBase.set_ParLeft(lBase.AdjustParam(r2));
            rBase.set_ParRight(rBase.AdjustParam(l1));
            rBase.set_ParLeft(rBase.AdjustParam(r1));
        },
        RegularCut: function (l1, r1, l2, r2, span1, span2){
            var cutParam = (span1 * r2 + span2 * l1) / (span1 + span2);
            var mn = System.Math.Min$$Double$$Double(r1, r2);
            var mx = System.Math.Max$$Double$$Double(l1, l2);
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.ApproximateComparer.LessOrEqual(mx, cutParam) && Microsoft.Msagl.Core.Geometry.ApproximateComparer.LessOrEqual(cutParam, mn));
            if (cutParam < mx)
                cutParam = mx;
            if (cutParam > mn)
                cutParam = mn;
            return cutParam;
        },
        Optimize: function (){
            var parameterChange = 0.0222222222222222;
            var cost = this.Cost();
            var iteration = 0;
            while (iteration++ < 200){
                var oldCost = cost;
                (function (){
                    var $1 = {
                        Value: cost
                    };
                    var $res = this.OptimizeBundles(parameterChange, $1);
                    cost = $1.Value;
                    return $res;
                }).call(this);
                parameterChange = this.UpdateParameterChange(parameterChange, oldCost, cost);
                if (parameterChange < 0.000277777777777778)
                    break;
                if (iteration % 10 == 0){
                }
            }
        },
        UpdateParameterChange: function (step, oldEnergy, newEnergy){
            var T = 0.8;
            if (newEnergy + 1 < oldEnergy){
                this.stepsWithProgress++;
                if (this.stepsWithProgress >= 5){
                    this.stepsWithProgress = 0;
                    this.fixedBundles.Clear();
                }
            }
            else {
                this.stepsWithProgress = 0;
                step *= T;
                this.fixedBundles.Clear();
            }
            return step;
        },
        OptimizeBundles: function (parameterChange, cost){
            var progress = false;
            var $it436 = this.Bundles.GetEnumerator();
            while ($it436.MoveNext()){
                var bundleInfo = $it436.get_Current();
                if (this.fixedBundles.Contains(bundleInfo))
                    continue;
                if (this.OptimizeBundle(bundleInfo, parameterChange, cost)){
                    progress = true;
                }
                else
                    this.fixedBundles.Add(bundleInfo);
            }
            return progress;
        },
        OptimizeBundle: function (bundleInfo, parameterChange, cost){
            var bundleCost = this.Cost$$BundleInfo(bundleInfo);
            if (bundleCost < 1E-05)
                return false;
            var bestDelta = 0;
            var bestI = -1,bestJ = -1;
            for (var i = 0; i < Microsoft.Msagl.Routing.Spline.Bundling.BundleBasesCalculator.Deltas.length - 1; i++){
                var delta = this.DeltaWithChangedAngles(Microsoft.Msagl.Routing.Spline.Bundling.BundleBasesCalculator.Deltas[i][0], Microsoft.Msagl.Routing.Spline.Bundling.BundleBasesCalculator.Deltas[i][1], 0, 0, bundleInfo, bundleCost, parameterChange);
                if (delta > 0.01 && delta > bestDelta){
                    bestI = i;
                    bestJ = Microsoft.Msagl.Routing.Spline.Bundling.BundleBasesCalculator.Deltas.length - 1;
                    bestDelta = delta;
                }
                delta = this.DeltaWithChangedAngles(0, 0, Microsoft.Msagl.Routing.Spline.Bundling.BundleBasesCalculator.Deltas[i][0], Microsoft.Msagl.Routing.Spline.Bundling.BundleBasesCalculator.Deltas[i][1], bundleInfo, bundleCost, parameterChange);
                if (delta > 0.01 && delta > bestDelta){
                    bestI = Microsoft.Msagl.Routing.Spline.Bundling.BundleBasesCalculator.Deltas.length - 1;
                    bestJ = i;
                    bestDelta = delta;
                }
            }
            if (bestDelta < 0.01)
                return false;
            cost.Value -= bestDelta;
            bundleInfo.RotateBy(Microsoft.Msagl.Routing.Spline.Bundling.BundleBasesCalculator.Deltas[bestI][0], Microsoft.Msagl.Routing.Spline.Bundling.BundleBasesCalculator.Deltas[bestI][1], Microsoft.Msagl.Routing.Spline.Bundling.BundleBasesCalculator.Deltas[bestJ][0], Microsoft.Msagl.Routing.Spline.Bundling.BundleBasesCalculator.Deltas[bestJ][1], parameterChange);
            return true;
        },
        DeltaWithChangedAngles: function (rotationOfSourceRigthPoint, rotationOfSourceLeftPoint, rotationOfTargetRigthPoint, rotationOfTargetLeftPoint, bundleInfo, bundleCost, parameterChange){
            if (!bundleInfo.RotationIsLegal(rotationOfSourceRigthPoint, rotationOfSourceLeftPoint, rotationOfTargetRigthPoint, rotationOfTargetLeftPoint, parameterChange))
                return 0;
            bundleInfo.RotateBy(rotationOfSourceRigthPoint, rotationOfSourceLeftPoint, rotationOfTargetRigthPoint, rotationOfTargetLeftPoint, parameterChange);
            var newCost = this.Cost$$BundleInfo$$Double(bundleInfo, bundleCost);
            bundleInfo.RotateBy(-rotationOfSourceRigthPoint, -rotationOfSourceLeftPoint, -rotationOfTargetRigthPoint, -rotationOfTargetLeftPoint, parameterChange);
            return bundleCost - newCost;
        },
        Cost$$BundleInfo: function (bundleInfo){
            return 1 * this.SeparationCost(bundleInfo) + 1 * this.SqueezeCost(bundleInfo) + 1 * this.AssymetryCost(bundleInfo) + 10 * this.CenterCost$$BundleInfo(bundleInfo);
        },
        Cost$$BundleInfo$$Double: function (bundleInfo, limit){
            var cost = 0;
            cost += 10 * this.CenterCost$$BundleInfo(bundleInfo);
            if (cost > limit)
                return cost;
            cost += 1 * this.SeparationCost(bundleInfo);
            if (cost > limit)
                return cost;
            cost += 1 * this.SqueezeCost(bundleInfo);
            if (cost > limit)
                return cost;
            cost += 1 * this.AssymetryCost(bundleInfo);
            return cost;
        },
        SqueezeCost: function (bundleInfo){
            var middleLineDir = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(bundleInfo.TargetBase.get_MidPoint(), bundleInfo.SourceBase.get_MidPoint())).Normalize();
            var perp = middleLineDir.Rotate90Ccw();
            var projecton0 = System.Math.Abs$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(bundleInfo.SourceBase.get_RightPoint(), bundleInfo.SourceBase.get_LeftPoint())), perp));
            var projecton1 = System.Math.Abs$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(bundleInfo.TargetBase.get_RightPoint(), bundleInfo.TargetBase.get_LeftPoint())), perp));
            var del0 = System.Math.Abs$$Double(bundleInfo.TotalRequiredWidth - projecton0) / bundleInfo.TotalRequiredWidth;
            var del1 = System.Math.Abs$$Double(bundleInfo.TotalRequiredWidth - projecton1) / bundleInfo.TotalRequiredWidth;
            var del = System.Math.Abs$$Double(projecton0 - projecton1) / bundleInfo.TotalRequiredWidth;
            var cost = System.Math.Exp(del0 * 10) - 1 + System.Math.Exp(del1 * 10) - 1;
            cost += del;
            return cost;
        },
        CenterCost$$BundleInfo: function (bundleInfo){
            if (!bundleInfo.SourceBase.BelongsToRealNode && !bundleInfo.TargetBase.BelongsToRealNode)
                return 0;
            return this.CenterCost$$BundleBase(bundleInfo.SourceBase) + this.CenterCost$$BundleBase(bundleInfo.TargetBase);
        },
        CenterCost$$BundleBase: function (bundleBase){
            if (!bundleBase.BelongsToRealNode)
                return 0;
            var currentMid = bundleBase.get_ParMid();
            var mn = System.Math.Min$$Double$$Double(bundleBase.get_InitialMidParameter(), currentMid);
            var mx = System.Math.Max$$Double$$Double(bundleBase.get_InitialMidParameter(), currentMid);
            var dist = System.Math.Min$$Double$$Double(mx - mn, mn + bundleBase.ParameterSpan - mx);
            if (Microsoft.Msagl.Core.Geometry.Point.op_Equality(bundleBase.get_CurveCenter(), bundleBase.Position) || bundleBase.IsParent)
                return 25 * dist * dist;
            else
                return 500 * dist * dist;
        },
        AssymetryCost: function (bundleInfo){
            return this.GetAssymetryCostForBase(bundleInfo.SourceBase) + this.GetAssymetryCostForBase(bundleInfo.TargetBase);
        },
        GetAssymetryCostForBase: function (bundleBase){
            if (bundleBase.BelongsToRealNode)
                return 0;
            var assymetryWeight = bundleBase.get_OppositeBase().BelongsToRealNode ? 200 : 500;
            var cost = 0;
            for (var $i438 = 0,$t438 = bundleBase.OrientedHubSegments,$l438 = $t438.length,o = $t438[$i438]; $i438 < $l438; $i438++, o = $t438[$i438]){
                var i0 = o.Index;
                var i1 = o.get_Other().Index;
                var a = bundleBase.get_Points()[i0];
                var ta = bundleBase.get_Tangents()[i0];
                var oppositeBase = o.get_Other().BundleBase;
                var b = oppositeBase.get_Points()[i1];
                var tb = oppositeBase.get_Tangents()[i1];
                var s = bundleBase.get_Count() + oppositeBase.get_Count();
                cost += this.GetAssymetryCostOnData(a, ta, b, tb, assymetryWeight) / s;
            }
            return cost;
        },
        GetAssymetryCostOnData: function (a, tangentA, b, tangentB, assymetryWeight){
            var xAxis = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a, b));
            var len = xAxis.get_Length();
            if (len < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return 0;
            xAxis = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(xAxis, len);
            var delx = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Addition(tangentA, tangentB)), xAxis);
            var ay = Microsoft.Msagl.Core.Geometry.Point.CrossProduct(xAxis, tangentA);
            var by = Microsoft.Msagl.Core.Geometry.Point.CrossProduct(xAxis, tangentB);
            var dely = ay - by;
            var ac = delx * delx + dely * dely;
            var bc = ay * ay + by * by;
            return 10 * ac + assymetryWeight * bc;
        },
        SeparationCost: function (bundleInfo){
            return this.SeparationCostForBundleBase(bundleInfo.SourceBase) + this.SeparationCostForBundleBase(bundleInfo.TargetBase);
        },
        SeparationCostForBundleBase: function (bBase){
            if (bBase.Prev == null)
                return 0;
            return this.SeparationCostForAdjacentBundleBases(bBase, bBase.Prev) + this.SeparationCostForAdjacentBundleBases(bBase, bBase.Next);
        },
        SeparationCostForAdjacentBundleBases: function (base0, base1){
            System.Diagnostics.Debug.Assert$$Boolean(base0.Curve == base1.Curve);
            var boundaryCurve = base0.Curve;
            var len = this.IntervalsOverlapLength(base0.get_ParRight(), base0.get_ParLeft(), base1.get_ParRight(), base1.get_ParLeft(), boundaryCurve);
            var mn = System.Math.Min$$Double$$Double(base0.get_Span(), base1.get_Span());
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.ApproximateComparer.LessOrEqual(len, mn));
            System.Diagnostics.Debug.Assert$$Boolean(mn > 0);
            return System.Math.Exp(len / mn * 10) - 1;
        },
        IntervalsOverlapLength: function (a, b, c, d, curve){
            var s = curve.get_ParStart();
            var e = curve.get_ParEnd();
            if (a < b){
                if (c < d)
                    return this.IntersectRegularIntervals(a, b, c, d);
                return this.IntersectRegularIntervals(a, b, c, e) + this.IntersectRegularIntervals(a, b, s, d);
            }
            if (c < d)
                return this.IntersectRegularIntervals(a, e, c, d) + this.IntersectRegularIntervals(s, b, c, d);
            return this.IntersectRegularIntervals(a, e, c, e) + this.IntersectRegularIntervals(s, b, s, d);
        },
        IntersectRegularIntervals: function (a, b, c, d){
            var low = System.Math.Max$$Double$$Double(a, c);
            var up = System.Math.Min$$Double$$Double(b, d);
            if (low < up){
                return up - low;
            }
            return 0;
        },
        Cost: function (){
            var cost = 0;
            var $it438 = this.Bundles.GetEnumerator();
            while ($it438.MoveNext()){
                var bundleInfo = $it438.get_Current();
                var c1 = 1 * this.SeparationCost(bundleInfo);
                var c2 = 1 * this.AssymetryCost(bundleInfo);
                var c3 = 1 * this.SqueezeCost(bundleInfo);
                var c4 = 10 * this.CenterCost$$BundleInfo(bundleInfo);
                cost += c1 / 2 + c2 / 2 + c3 + c4;
                System.Diagnostics.Debug.Assert$$Boolean(cost < Infinity);
            }
            return cost;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$BundleBasesCalculator);
var Microsoft$Msagl$Routing$Spline$Bundling$BundleInfo = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.BundleInfo",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Routing.Spline.Bundling.BundleInfo.FeasibleWidthEpsilon = 0.1;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (sourceBase, targetBase, obstaclesToIgnore, edgeSeparation, halfWidthArray){
            this.SourceBase = null;
            this.TargetBase = null;
            this.obstaclesToIgnore = null;
            this.EdgeSeparation = 0;
            this.HalfWidthArray = null;
            this.longEnoughSideLength = 0;
            this.tightObstaclesInTheBoundingBox = null;
            this.TotalRequiredWidth = 0;
            System.Object.ctor.call(this);
            this.SourceBase = sourceBase;
            this.TargetBase = targetBase;
            this.obstaclesToIgnore = obstaclesToIgnore;
            this.EdgeSeparation = edgeSeparation;
            this.HalfWidthArray = halfWidthArray;
            this.TotalRequiredWidth = this.EdgeSeparation * this.HalfWidthArray.length + System.Linq.Enumerable.Sum$$IEnumerable$1$Double(this.HalfWidthArray) * 2;
            this.longEnoughSideLength = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Rectangle$$Rectangle(sourceBase.Curve.get_BoundingBox(), targetBase.Curve.get_BoundingBox()).get_Diagonal();
            var mn = System.Math.Max$$Double$$Double(sourceBase.Curve.get_BoundingBox().get_Diagonal(), targetBase.Curve.get_BoundingBox().get_Diagonal());
            if (this.TotalRequiredWidth > mn){
                var scale = this.TotalRequiredWidth / mn;
                for (var i = 0; i < this.HalfWidthArray.length; i++)
                    this.HalfWidthArray[i] /= scale;
                this.TotalRequiredWidth /= scale;
                this.EdgeSeparation /= scale;
            }
        },
        SetParamsFeasiblySymmetrically: function (tightTree){
            this.CalculateTightObstaclesForBundle(tightTree, this.obstaclesToIgnore);
            this.SetEndParamsSymmetrically();
        },
        CalculateTightObstaclesForBundle: function (tightTree, obstaclesToIgnore){
            var sRadius = this.SourceBase.Curve.get_BoundingBox().get_Diagonal() / 2;
            var tRadius = this.TargetBase.Curve.get_BoundingBox().get_Diagonal() / 2;
            var bundle = Microsoft.Msagl.Routing.Spline.Bundling.Intersections.Create4gon(this.SourceBase.Position, this.TargetBase.Position, sRadius * 2, tRadius * 2);
            this.tightObstaclesInTheBoundingBox = System.Linq.Enumerable.ToList$1(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, tightTree.AllHitItems$$Rectangle$$Func$2(bundle.get_BoundingBox(), $CreateAnonymousDelegate(this, function (p){
                return !obstaclesToIgnore.Contains$$T(p) && Microsoft.Msagl.Core.Geometry.Curves.Curve.ClosedCurveInteriorsIntersect(bundle, p);
            })));
        },
        SetEndParamsSymmetrically: function (){
            var targetPos = this.TargetBase.Position;
            var sourcePos = this.SourceBase.Position;
            var dir = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(targetPos, sourcePos)).Normalize();
            var perp = dir.Rotate90Ccw();
            var middle = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(0.5, (Microsoft.Msagl.Core.Geometry.Point.op_Addition(targetPos, sourcePos)));
            var a = Microsoft.Msagl.Core.Geometry.Point.op_Addition(middle, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(this.longEnoughSideLength, dir));
            var b = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(middle, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(this.longEnoughSideLength, dir));
            if (this.SetRLParamsIfWidthIsFeasible$$Point$$Point$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(this.TotalRequiredWidth, perp), 2), a, b)){
                this.SetInitialMidParams();
                return;
            }
            var uw = this.TotalRequiredWidth;
            var lw = 0;
            var mw = uw / 2;
            while (uw - lw > 0.1){
                if (this.SetRLParamsIfWidthIsFeasible$$Point$$Point$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(mw, perp), 2), a, b))
                    lw = mw;
                else
                    uw = mw;
                mw = 0.5 * (uw + lw);
            }
            if (mw <= 0.1){
                if (this.SetRLParamsIfWidthIsFeasible$$Point$$Point$$Point$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(0.2, perp), 2), new Microsoft.Msagl.Core.Geometry.Point.ctor(), a, b)){
                    mw = 0.2;
                }
                else if (this.SetRLParamsIfWidthIsFeasible$$Point$$Point$$Point$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor(), Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(-0.2, perp), 2), a, b)){
                    mw = 0.2;
                }
            }
            System.Diagnostics.Debug.Assert$$Boolean(mw > 0.1);
            this.SetInitialMidParams();
        },
        SetRLParamsIfWidthIsFeasible$$Point$$Point$$Point: function (perp, a, b){
            return this.SetRLParamsIfWidthIsFeasible$$Point$$Point$$Point$$Point(perp, Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(perp), a, b);
        },
        SetRLParamsIfWidthIsFeasible$$Point$$Point$$Point$$Point: function (perpL, perpR, a, b){
            var sourceRParam,targetRParam,sourceLParam,targetLParam;
            var ls = (function (){
                var $1 = {
                    Value: sourceLParam
                };
                var $2 = {
                    Value: targetRParam
                };
                var $res = this.TrimSegWithBoundaryCurves(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Addition(a, perpL), Microsoft.Msagl.Core.Geometry.Point.op_Addition(b, perpL)), $1, $2);
                sourceLParam = $1.Value;
                targetRParam = $2.Value;
                return $res;
            }).call(this);
            if (ls == null)
                return false;
            if (System.Linq.Enumerable.Any$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, this.tightObstaclesInTheBoundingBox, $CreateAnonymousDelegate(this, function (t){
                return Microsoft.Msagl.Routing.Spline.Bundling.Intersections.LineSegmentIntersectPolyline(ls.get_Start(), ls.get_End(), t);
            })))
                return false;
            ls = (function (){
                var $1 = {
                    Value: sourceRParam
                };
                var $2 = {
                    Value: targetLParam
                };
                var $res = this.TrimSegWithBoundaryCurves(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Addition(a, perpR), Microsoft.Msagl.Core.Geometry.Point.op_Addition(b, perpR)), $1, $2);
                sourceRParam = $1.Value;
                targetLParam = $2.Value;
                return $res;
            }).call(this);
            if (ls == null)
                return false;
            if (System.Linq.Enumerable.Any$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, this.tightObstaclesInTheBoundingBox, $CreateAnonymousDelegate(this, function (t){
                return Microsoft.Msagl.Routing.Spline.Bundling.Intersections.LineSegmentIntersectPolyline(ls.get_Start(), ls.get_End(), t);
            })))
                return false;
            if (this.SourceBase.IsParent){
                this.SourceBase.set_ParRight(sourceLParam);
                this.SourceBase.set_ParLeft(sourceRParam);
            }
            else {
                this.SourceBase.set_ParRight(sourceRParam);
                this.SourceBase.set_ParLeft(sourceLParam);
            }
            if (this.TargetBase.IsParent){
                this.TargetBase.set_ParRight(targetLParam);
                this.TargetBase.set_ParLeft(targetRParam);
            }
            else {
                this.TargetBase.set_ParRight(targetRParam);
                this.TargetBase.set_ParLeft(targetLParam);
            }
            return true;
        },
        SetInitialMidParams: function (){
            var sourceParam,targetParam;
            var ls = (function (){
                var $1 = {
                    Value: sourceParam
                };
                var $2 = {
                    Value: targetParam
                };
                var $res = this.TrimSegWithBoundaryCurves(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(this.TargetBase.get_CurveCenter(), this.SourceBase.get_CurveCenter()), $1, $2);
                sourceParam = $1.Value;
                targetParam = $2.Value;
                return $res;
            }).call(this);
            if (ls != null){
                this.SourceBase.set_InitialMidParameter(sourceParam);
                this.TargetBase.set_InitialMidParameter(targetParam);
            }
            else {
                this.SourceBase.set_InitialMidParameter(this.SourceBase.AdjustParam(this.SourceBase.get_ParRight() + this.SourceBase.get_Span() / 2));
                this.TargetBase.set_InitialMidParameter(this.TargetBase.AdjustParam(this.TargetBase.get_ParRight() + this.TargetBase.get_Span() / 2));
            }
        },
        TrimSegWithBoundaryCurves: function (ls, sourcePar, targetPar){
            var inters = Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(ls, this.SourceBase.Curve, true);
            if (inters.get_Count() == 0){
                sourcePar.Value = targetPar.Value = 0;
                return null;
            }
            var i0;
            if (inters.get_Count() == 1)
                i0 = inters.get_Item$$Int32(0);
            else {
                if (!this.SourceBase.IsParent)
                    i0 = inters.get_Item$$Int32(0).get_Par0() < inters.get_Item$$Int32(1).get_Par0() ? inters.get_Item$$Int32(0) : inters.get_Item$$Int32(1);
                else
                    i0 = inters.get_Item$$Int32(0).get_Par0() < inters.get_Item$$Int32(1).get_Par0() ? inters.get_Item$$Int32(1) : inters.get_Item$$Int32(0);
            }
            inters = Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(ls, this.TargetBase.Curve, true);
            if (inters.get_Count() == 0){
                sourcePar.Value = targetPar.Value = 0;
                return null;
            }
            var i1;
            if (inters.get_Count() == 1)
                i1 = inters.get_Item$$Int32(0);
            else {
                if (!this.TargetBase.IsParent)
                    i1 = inters.get_Item$$Int32(0).get_Par0() > inters.get_Item$$Int32(1).get_Par0() ? inters.get_Item$$Int32(0) : inters.get_Item$$Int32(1);
                else
                    i1 = inters.get_Item$$Int32(0).get_Par0() > inters.get_Item$$Int32(1).get_Par0() ? inters.get_Item$$Int32(1) : inters.get_Item$$Int32(0);
            }
            sourcePar.Value = i0.get_Par1();
            targetPar.Value = i1.get_Par1();
            return new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(i0.get_IntersectionPoint(), i1.get_IntersectionPoint());
        },
        RotateBy: function (rotationOfSourceRightPoint, rotationOfSourceLeftPoint, rotationOfTargetRightPoint, rotationOfTargetLeftPoint, parameterChange){
            var needToUpdateSource = rotationOfSourceRightPoint != 0 || rotationOfSourceLeftPoint != 0;
            var needToUpdateTarget = rotationOfTargetRightPoint != 0 || rotationOfTargetLeftPoint != 0;
            if (needToUpdateSource)
                this.SourceBase.RotateBy(rotationOfSourceRightPoint, rotationOfSourceLeftPoint, parameterChange);
            if (needToUpdateTarget)
                this.TargetBase.RotateBy(rotationOfTargetRightPoint, rotationOfTargetLeftPoint, parameterChange);
            this.UpdateSourceAndTargetBases(needToUpdateSource, needToUpdateTarget);
        },
        UpdateSourceAndTargetBases: function (sourceChanged, targetChanged){
            if (sourceChanged)
                this.UpdatePointsOnSourceBase();
            if (targetChanged)
                this.UpdatePointsOnTargetBase();
            this.UpdateTangentsOnBases();
        },
        UpdateTangentsOnBases: function (){
            var count = this.TargetBase.get_Count();
            for (var i = 0; i < count; i++){
                var d = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.TargetBase.get_Points()[i], this.SourceBase.get_Points()[count - 1 - i]);
                var len = d.get_Length();
                if (len >= Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance()){
                    d = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(d, len);
                    this.TargetBase.get_Tangents()[i] = d;
                    this.SourceBase.get_Tangents()[count - 1 - i] = d.Negate();
                }
            }
        },
        UpdatePointsOnSourceBase: function (){
            var count = this.SourceBase.get_Count();
            var pns = this.SourceBase.get_Points();
            var dir = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.SourceBase.get_RightPoint(), this.SourceBase.get_LeftPoint())), this.TotalRequiredWidth);
            pns[count - 1] = Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.SourceBase.get_LeftPoint(), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point((this.EdgeSeparation / 2 + this.HalfWidthArray[0]), dir));
            var j = 1;
            for (var i = count - 2; i >= 0; i--, j++)
                pns[i] = Microsoft.Msagl.Core.Geometry.Point.op_Addition(pns[i + 1], Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point((this.HalfWidthArray[j - 1] + this.EdgeSeparation + this.HalfWidthArray[j]), dir));
        },
        UpdatePointsOnTargetBase: function (){
            var count = this.TargetBase.get_Count();
            var pns = this.TargetBase.get_Points();
            var dir = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.TargetBase.get_LeftPoint(), this.TargetBase.get_RightPoint())), this.TotalRequiredWidth);
            pns[0] = Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.TargetBase.get_RightPoint(), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point((this.EdgeSeparation / 2 + this.HalfWidthArray[0]), dir));
            for (var i = 1; i < count; i++)
                pns[i] = Microsoft.Msagl.Core.Geometry.Point.op_Addition(pns[i - 1], Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point((this.HalfWidthArray[i - 1] + this.EdgeSeparation + this.HalfWidthArray[i]), dir));
        },
        RotationIsLegal: function (rotationOfSourceRightPoint, rotationOfSourceLeftPoint, rotationOfTargetRightPoint, rotationOfTargetLeftPoint, parameterChange){
            if (!this.SourceBase.IsParent && !this.TargetBase.IsParent){
                if (rotationOfSourceLeftPoint != 0 || rotationOfTargetRightPoint != 0){
                    var rSoP = this.SourceBase.RotateLeftPoint(rotationOfSourceLeftPoint, parameterChange);
                    var lTarP = this.TargetBase.RotateRigthPoint(rotationOfTargetRightPoint, parameterChange);
                    if (!this.LineIsLegal(rSoP, lTarP))
                        return false;
                }
                if (rotationOfSourceRightPoint != 0 || rotationOfTargetLeftPoint != 0){
                    var lSoP = this.SourceBase.RotateRigthPoint(rotationOfSourceRightPoint, parameterChange);
                    var rTarP = this.TargetBase.RotateLeftPoint(rotationOfTargetLeftPoint, parameterChange);
                    if (!this.LineIsLegal(lSoP, rTarP))
                        return false;
                }
            }
            else {
                if (rotationOfSourceLeftPoint != 0 || rotationOfTargetLeftPoint != 0){
                    var lSoP = this.SourceBase.RotateLeftPoint(rotationOfSourceLeftPoint, parameterChange);
                    var lTarP = this.TargetBase.RotateLeftPoint(rotationOfTargetLeftPoint, parameterChange);
                    if (!this.LineIsLegal(lSoP, lTarP))
                        return false;
                }
                if (rotationOfSourceRightPoint != 0 || rotationOfTargetRightPoint != 0){
                    var rSoP = this.SourceBase.RotateRigthPoint(rotationOfSourceRightPoint, parameterChange);
                    var rTarP = this.TargetBase.RotateRigthPoint(rotationOfTargetRightPoint, parameterChange);
                    if (!this.LineIsLegal(rSoP, rTarP))
                        return false;
                }
            }
            if (rotationOfSourceRightPoint != 0 || rotationOfSourceLeftPoint != 0)if (!this.SourceBase.RelativeOrderOfBasesIsPreserved(rotationOfSourceRightPoint, rotationOfSourceLeftPoint, parameterChange))
                return false;
            if (rotationOfTargetRightPoint != 0 || rotationOfTargetLeftPoint != 0)if (!this.TargetBase.RelativeOrderOfBasesIsPreserved(rotationOfTargetRightPoint, rotationOfTargetLeftPoint, parameterChange))
                return false;
            return true;
        },
        LineIsLegal: function (a, b){
            return System.Linq.Enumerable.All$1(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, this.tightObstaclesInTheBoundingBox, $CreateAnonymousDelegate(this, function (t){
                return !Microsoft.Msagl.Routing.Spline.Bundling.Intersections.LineSegmentIntersectPolyline(a, b, t);
            }));
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$BundleInfo);
var Microsoft$Msagl$Routing$Spline$Bundling$BundleRouter = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.BundleRouter",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Routing.Spline.Bundling.BundleRouter.SuperLoosePaddingCoefficient = 1.1;
        },
        CreateConstrainedDelaunayTriangulation: function (looseHierarchy){
            var obstacles = looseHierarchy.GetAllLeaves();
            var rectangle = looseHierarchy.get_Rectangle();
            var d = rectangle.get_Diagonal() / 4;
            var lb = Microsoft.Msagl.Core.Geometry.Point.op_Addition(rectangle.get_LeftBottom(), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-d, -d));
            var lt = Microsoft.Msagl.Core.Geometry.Point.op_Addition(rectangle.get_LeftTop(), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-d, d));
            var rt = Microsoft.Msagl.Core.Geometry.Point.op_Addition(rectangle.get_RightTop(), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(d, d));
            var rb = Microsoft.Msagl.Core.Geometry.Point.op_Addition(rectangle.get_RightBottom(), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(d, -d));
            var additionalObstacles = [(function (){
                var $v73 = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor$$Point$Array([lb, lt, rt, rb]);
                $v73.set_Closed(true);
                return $v73;
            })()];
            return Microsoft.Msagl.Routing.Spline.Bundling.BundleRouter.GetConstrainedDelaunayTriangulation(System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, obstacles, additionalObstacles));
        },
        GetConstrainedDelaunayTriangulation: function (obstacles){
            var constrainedDelaunayTriangulation = new Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.ctor$$IEnumerable$1$Point$$IEnumerable$1$Polyline$$IEnumerable$1(null, obstacles, null);
            constrainedDelaunayTriangulation.Run();
            return constrainedDelaunayTriangulation;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (geometryGraph, shortestPathRouter, visibilityGraph, bundlingSettings, loosePadding, tightHierarchy, looseHierarchy, edgeLooseEnterable, edgeTightEnterable, loosePolylineOfPort){
            this.bundlingSettings = null;
            this.geometryGraph = null;
            this.regularEdges = null;
            this.shortestPathRouter = null;
            this.loosePolylineOfPort = null;
            this._LoosePadding = 0;
            this._TightHierarchy = null;
            this._LooseHierarchy = null;
            this._Status = Microsoft.Msagl.Routing.Spline.Bundling.BundlingStatus.Success;
            this._VisibilityGraph = null;
            this._EdgeLooseEnterable = null;
            this._EdgeTightEnterable = null;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(geometryGraph, "geometryGraph");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(bundlingSettings, "bundlingSettings");
            this.geometryGraph = geometryGraph;
            this.bundlingSettings = bundlingSettings;
            this.regularEdges = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Layout.Edge.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, geometryGraph.get_Edges(), $CreateAnonymousDelegate(this, function (e){
                return e.get_Source() != e.get_Target();
            })));
            this.set_VisibilityGraph(visibilityGraph);
            this.shortestPathRouter = shortestPathRouter;
            this.set_LoosePadding(loosePadding);
            this.set_LooseHierarchy(looseHierarchy);
            this.set_TightHierarchy(tightHierarchy);
            this.set_EdgeLooseEnterable(edgeLooseEnterable);
            this.set_EdgeTightEnterable(edgeTightEnterable);
            this.loosePolylineOfPort = loosePolylineOfPort;
        },
        LoosePadding$$: "System.Double",
        get_LoosePadding: function (){
            return this._LoosePadding;
        },
        set_LoosePadding: function (value){
            this._LoosePadding = value;
        },
        TightHierarchy$$: "Microsoft.Msagl.Core.Geometry.RectangleNode`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]",
        get_TightHierarchy: function (){
            return this._TightHierarchy;
        },
        set_TightHierarchy: function (value){
            this._TightHierarchy = value;
        },
        LooseHierarchy$$: "Microsoft.Msagl.Core.Geometry.RectangleNode`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]",
        get_LooseHierarchy: function (){
            return this._LooseHierarchy;
        },
        set_LooseHierarchy: function (value){
            this._LooseHierarchy = value;
        },
        Status$$: "Microsoft.Msagl.Routing.Spline.Bundling.BundlingStatus",
        get_Status: function (){
            return this._Status;
        },
        set_Status: function (value){
            this._Status = value;
        },
        VisibilityGraph$$: "Microsoft.Msagl.Routing.Visibility.VisibilityGraph",
        get_VisibilityGraph: function (){
            return this._VisibilityGraph;
        },
        set_VisibilityGraph: function (value){
            this._VisibilityGraph = value;
        },
        ThereAreOverlaps: function (hierarchy){
            return Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.FindIntersectionWithProperty$1(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, hierarchy, hierarchy, Microsoft.Msagl.Core.Geometry.Curves.Curve.CurvesIntersect);
        },
        RunInternal: function (){
            if (this.ThereAreOverlaps(this.get_TightHierarchy())){
                this.set_Status(Microsoft.Msagl.Routing.Spline.Bundling.BundlingStatus.Overlaps);
                Microsoft.Msagl.Routing.Spline.Bundling.TimeMeasurer.DebugOutput("overlaps in edge bundling");
                return;
            }
            this.FixLocationsForHookAnywherePorts(this.geometryGraph.get_Edges());
            if (!this.RoutePathsWithSteinerDijkstra()){
                this.set_Status(Microsoft.Msagl.Routing.Spline.Bundling.BundlingStatus.EdgeSeparationIsTooLarge);
                return;
            }
            this.FixChildParentEdges();
            if (!this.bundlingSettings.get_StopAfterShortestPaths()){
                var metroGraphData = new Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData.ctor(System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, this.regularEdges, $CreateAnonymousDelegate(this, function (e){
                    return e.get_EdgeGeometry();
                }))), this.get_LooseHierarchy(), this.get_TightHierarchy(), this.bundlingSettings, this.shortestPathRouter.get_Cdt(), this.get_EdgeLooseEnterable(), this.get_EdgeTightEnterable(), this.loosePolylineOfPort);
                Microsoft.Msagl.Routing.Spline.Bundling.NodePositionsAdjuster.FixRouting(metroGraphData, this.bundlingSettings);
                new Microsoft.Msagl.Routing.Spline.Bundling.EdgeNudger.ctor(metroGraphData, this.bundlingSettings).Run();
            }
            this.RouteSelfEdges();
            this.FixArrowheads();
        },
        FixChildParentEdges: function (){
            for (var $i440 = 0,$t440 = this.regularEdges,$l440 = $t440.length,edge = $t440[$i440]; $i440 < $l440; $i440++, edge = $t440[$i440]){
                var sPort = edge.get_SourcePort();
                var ePort = edge.get_TargetPort();
                if (sPort.get_Curve().get_BoundingBox().Contains$$Rectangle(ePort.get_Curve().get_BoundingBox())){
                    var ii = Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveIntersectionOne(sPort.get_Curve(), new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(edge.get_Curve().get_Start(), edge.get_Curve().get_End()), true);
                    (Cast(edge.get_Curve(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor)).get_StartPoint().set_Point(ii.get_IntersectionPoint());
                }
                if (ePort.get_Curve().get_BoundingBox().Contains$$Rectangle(sPort.get_Curve().get_BoundingBox())){
                    var ii = Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveIntersectionOne(ePort.get_Curve(), new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(edge.get_Curve().get_Start(), edge.get_Curve().get_End()), true);
                    (Cast(edge.get_Curve(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor)).get_EndPoint().set_Point(ii.get_IntersectionPoint());
                }
            }
        },
        FixLocationsForHookAnywherePorts: function (edges){
            var $it440 = edges.GetEnumerator();
            while ($it440.MoveNext()){
                var edge = $it440.get_Current();
                var hookPort = As(edge.get_SourcePort(), Microsoft.Msagl.Core.Layout.HookUpAnywhereFromInsidePort.ctor);
                if (hookPort != null)
                    hookPort.SetLocation(this.FigureOutHookLocation(hookPort.get_LoosePolyline(), edge.get_TargetPort(), edge.get_EdgeGeometry()));
                else {
                    hookPort = As(edge.get_TargetPort(), Microsoft.Msagl.Core.Layout.HookUpAnywhereFromInsidePort.ctor);
                    if (hookPort != null)
                        hookPort.SetLocation(this.FigureOutHookLocation(hookPort.get_LoosePolyline(), edge.get_SourcePort(), edge.get_EdgeGeometry()));
                }
            }
        },
        FigureOutHookLocation: function (poly, otherEdgeEndPort, edgeGeom){
            var clusterPort = As(otherEdgeEndPort, Microsoft.Msagl.Routing.ClusterBoundaryPort.ctor);
            if (clusterPort == null){
                return this.FigureOutHookLocationForSimpleOtherPort(poly, otherEdgeEndPort, edgeGeom);
            }
            return this.FigureOutHookLocationForClusterOtherPort(poly, clusterPort, edgeGeom);
        },
        FigureOutHookLocationForClusterOtherPort: function (poly, otherEdgeEndPort, edgeGeom){
            var shapes = this.shortestPathRouter.get_MakeTransparentShapesOfEdgeGeometry()(edgeGeom);
            var s = new Microsoft.Msagl.Routing.MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph.ctor(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor, otherEdgeEndPort.get_LoosePolyline(), $CreateAnonymousDelegate(this, function (p){
                return this.get_VisibilityGraph().FindVertex(p);
            })), System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor, poly, $CreateAnonymousDelegate(this, function (p){
                return this.get_VisibilityGraph().FindVertex(p);
            })), this.get_VisibilityGraph());
            var path = s.GetPath();
            var $it441 = shapes.GetEnumerator();
            while ($it441.MoveNext()){
                var sh = $it441.get_Current();
                sh.set_IsTransparent(false);
            }
            return System.Linq.Enumerable.Last$1$$IEnumerable$1(Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor, path).Point;
        },
        FigureOutHookLocationForSimpleOtherPort: function (poly, otherEdgeEndPort, edgeGeom){
            var otherEdgeEnd = otherEdgeEndPort.get_Location();
            var shapes = this.shortestPathRouter.get_MakeTransparentShapesOfEdgeGeometry()(edgeGeom);
            var s = new Microsoft.Msagl.Routing.SingleSourceMultipleTargetsShortestPathOnVisibilityGraph.ctor(this.get_VisibilityGraph().FindVertex(otherEdgeEnd), System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor, Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor, poly.get_PolylinePoints(), $CreateAnonymousDelegate(this, function (p){
                return this.get_VisibilityGraph().FindVertex(p.get_Point());
            })), this.get_VisibilityGraph());
            var path = s.GetPath();
            var $it442 = shapes.GetEnumerator();
            while ($it442.MoveNext()){
                var sh = $it442.get_Current();
                sh.set_IsTransparent(false);
            }
            return System.Linq.Enumerable.Last$1$$IEnumerable$1(Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor, path).Point;
        },
        EdgeLooseEnterable$$: "System.Collections.Generic.Dictionary`2[[Microsoft.Msagl.Core.Layout.EdgeGeometry],[Microsoft.Msagl.Core.DataStructures.Set`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]]]",
        get_EdgeLooseEnterable: function (){
            return this._EdgeLooseEnterable;
        },
        set_EdgeLooseEnterable: function (value){
            this._EdgeLooseEnterable = value;
        },
        EdgeTightEnterable$$: "System.Collections.Generic.Dictionary`2[[Microsoft.Msagl.Core.Layout.EdgeGeometry],[Microsoft.Msagl.Core.DataStructures.Set`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]]]",
        get_EdgeTightEnterable: function (){
            return this._EdgeTightEnterable;
        },
        set_EdgeTightEnterable: function (value){
            this._EdgeTightEnterable = value;
        },
        RoutePathsWithSteinerDijkstra: function (){
            this.shortestPathRouter.set_VisibilityGraph(this.get_VisibilityGraph());
            this.shortestPathRouter.set_BundlingSettings(this.bundlingSettings);
            this.shortestPathRouter.set_EdgeGeometries(System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, this.regularEdges, $CreateAnonymousDelegate(this, function (e){
                return e.get_EdgeGeometry();
            }))));
            this.shortestPathRouter.set_ObstacleHierarchy(this.get_LooseHierarchy());
            this.shortestPathRouter.RouteEdges();
            if (this.shortestPathRouter.get_Cdt() != null)if (!this.AnalyzeEdgeSeparation())
                return false;
            return true;
        },
        AnalyzeEdgeSeparation: function (){
            var crossedCdtEdges = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, Microsoft.Msagl.Core.DataStructures.Set$1.ctor);
            this.shortestPathRouter.FillCrossedCdtEdges(crossedCdtEdges);
            var pathsOnCdtEdge = this.GetPathsOnCdtEdge(crossedCdtEdges);
            var es = this.CalculateMaxAllowedEdgeSeparation(pathsOnCdtEdge);
            if (es >= this.bundlingSettings.get_EdgeSeparation())
                return true;
            if (es <= 0.02){
                Microsoft.Msagl.Routing.Spline.Bundling.TimeMeasurer.DebugOutput("edge bundling can\'t be executed: not enough free space around obstacles");
                for (var $i444 = 0,$t444 = this.regularEdges,$l444 = $t444.length,e = $t444[$i444]; $i444 < $l444; $i444++, e = $t444[$i444])
                    e.set_Curve(null);
                return false;
            }
            this.bundlingSettings.set_EdgeSeparation(es);
            this.shortestPathRouter.RouteEdges();
            return true;
        },
        GetPathsOnCdtEdge: function (crossedEdges){
            var res = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.CdtEdge.ctor, Microsoft.Msagl.Core.DataStructures.Set$1.ctor);
            var $it444 = crossedEdges.get_Keys().GetEnumerator();
            while ($it444.MoveNext()){
                var edge = $it444.get_Current();
                var $it445 = crossedEdges.get_Item$$TKey(edge).GetEnumerator();
                while ($it445.MoveNext()){
                    var cdtEdge = $it445.get_Current();
                    Microsoft.Msagl.Core.DataStructures.CollectionUtilities.AddToMap$3(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, Microsoft.Msagl.Routing.CdtEdge.ctor, Microsoft.Msagl.Core.DataStructures.Set$1.ctor, res, cdtEdge, edge);
                }
            }
            return res;
        },
        CalculateMaxAllowedEdgeSeparation: function (pathsOnCdtEdge){
            var l = 0.01;
            var r = 10;
            if (this.EdgeSeparationIsOk$$Dictionary$2$$Double(pathsOnCdtEdge, r))
                return r;
            while (System.Math.Abs$$Double(r - l) > 0.01){
                var cen = (l + r) / 2;
                if (this.EdgeSeparationIsOk$$Dictionary$2$$Double(pathsOnCdtEdge, cen))
                    l = cen;
                else
                    r = cen;
            }
            return l;
        },
        EdgeSeparationIsOk$$Dictionary$2$$Double: function (pathsOnCdtEdge, separation){
            var total = pathsOnCdtEdge.get_Count();
            if (total == 0)
                return true;
            var ok = 0;
            var $it446 = pathsOnCdtEdge.get_Keys().GetEnumerator();
            while ($it446.MoveNext()){
                var edge = $it446.get_Current();
                if (this.EdgeSeparationIsOk$$CdtEdge$$Set$1$EdgeGeometry$$Double(edge, pathsOnCdtEdge.get_Item$$TKey(edge), separation))
                    ok++;
            }
            return (ok / total > this.bundlingSettings.get_MinimalRatioOfGoodCdtEdges());
        },
        EdgeSeparationIsOk$$CdtEdge$$Set$1$EdgeGeometry$$Double: function (edge, paths, separation){
            var requiredWidth = System.Linq.Enumerable.Sum$$IEnumerable$1$Double(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, System.Double.ctor, paths, $CreateAnonymousDelegate(this, function (v){
                return v.get_LineWidth();
            }))) + (paths.get_Count() - 1) * separation;
            var availableWidth = edge.Capacity;
            return (requiredWidth <= availableWidth);
        },
        RouteSelfEdges: function (){
            var $it447 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, this.geometryGraph.get_Edges(), $CreateAnonymousDelegate(this, function (e){
                return e.get_Source() == e.get_Target();
            })).GetEnumerator();
            while ($it447.MoveNext()){
                var edge = $it447.get_Current();
                var sp;
                edge.set_Curve((function (){
                    var $1 = {
                        Value: sp
                    };
                    var $res = Microsoft.Msagl.Core.Layout.Edge.RouteSelfEdge(edge.get_Source().get_BoundaryCurve(), this.get_LoosePadding() * 2, $1);
                    sp = $1.Value;
                    return $res;
                }).call(this));
            }
        },
        FixArrowheads: function (){
            var $it448 = this.geometryGraph.get_Edges().GetEnumerator();
            while ($it448.MoveNext()){
                var edge = $it448.get_Current();
                Microsoft.Msagl.Core.Layout.Arrowheads.TrimSplineAndCalculateArrowheads$$EdgeGeometry$$ICurve$$ICurve$$ICurve$$Boolean$$Boolean(edge.get_EdgeGeometry(), edge.get_Source().get_BoundaryCurve(), edge.get_Target().get_BoundaryCurve(), edge.get_Curve(), false, this.bundlingSettings.get_KeepOriginalSpline());
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$BundleRouter);
var Microsoft$Msagl$Routing$Spline$Bundling$BundlingStatus = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.BundlingStatus",
    staticDefinition: {
        Success: 0,
        Overlaps: 1,
        EdgeSeparationIsTooLarge: 2
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$BundlingStatus);
var Microsoft$Msagl$Routing$Spline$Bundling$CdtGeneralPolylineTracer = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.CdtGeneralPolylineTracer",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Routing.Spline.Bundling.CdtGeneralPolylineTracer.OutsideOfTriangulation = 0;
        },
        PointBelongsToInteriorOfTriangle: function (point, cdtTriangle){
            for (var i = 0; i < 3; i++)
                if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(cdtTriangle.Sites.get_Item$$Int32(i).Point, cdtTriangle.Sites.get_Item$$Int32(i + 1).Point, point) != Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise)
                    return false;
            return true;
        },
        TryCreateFeatureWhichIsNotSite: function (pp, triangle){
            System.Diagnostics.Debug.Assert$$Boolean(!System.Linq.Enumerable.Any$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.CdtSite.ctor, triangle.Sites, function (s){
                return Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(pp.get_Point(), s.Point);
            }));
            var a0 = Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(pp.get_Point(), triangle.Sites.get_Item$$Int32(0).Point, triangle.Sites.get_Item$$Int32(1).Point);
            if (a0 == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise)
                return null;
            var a1 = Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(pp.get_Point(), triangle.Sites.get_Item$$Int32(1).Point, triangle.Sites.get_Item$$Int32(2).Point);
            if (a1 == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise)
                return null;
            var a2 = Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(pp.get_Point(), triangle.Sites.get_Item$$Int32(2).Point, triangle.Sites.get_Item$$Int32(3).Point);
            if (a2 == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise)
                return null;
            if (a0 == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise && a1 == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise && a2 == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise)
                return triangle;
            if (a0 == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Collinear)
                return triangle.Edges.get_Item$$Int32(0);
            if (a1 == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Collinear)
                return triangle.Edges.get_Item$$Int32(1);
            System.Diagnostics.Debug.Assert$$Boolean(a2 == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Collinear);
            return triangle.Edges.get_Item$$Int32(2);
        },
        GetTriangleOnThePointSide: function (edge, p){
            return Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(edge.upperSite.Point, edge.lowerSite.Point, p) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise ? edge.get_CcwTriangle() : edge.get_CwTriangle();
        },
        PointIsInsideCone: function (p, apex, leftSideP, rightSideP){
            return Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(apex, leftSideP, p) != Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise && Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(apex, rightSideP, p) != Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (polylinePoints, siteHierarchy, triangleHierarchy){
            this.iterator = null;
            this.segStart = null;
            this.polylineHead = new System.Collections.Generic.Stack$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor);
            this.crossedEdges = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Routing.CdtEdge.ctor);
            this.lastCrossedFeature = null;
            this.segEnd = null;
            this._SiteHierarchy = null;
            this._TriangleHierarchy = null;
            System.Object.ctor.call(this);
            this.iterator = polylinePoints.GetEnumerator();
            this.set_TriangleHierarchy(triangleHierarchy);
            this.set_SiteHierarchy(siteHierarchy);
        },
        SiteHierarchy$$: "Microsoft.Msagl.Core.Geometry.RectangleNode`1[[Microsoft.Msagl.Routing.CdtSite]]",
        get_SiteHierarchy: function (){
            return this._SiteHierarchy;
        },
        set_SiteHierarchy: function (value){
            this._SiteHierarchy = value;
        },
        PrevSegStart$$: "Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint",
        get_PrevSegStart: function (){
            return this.polylineHead.get_Count() == 0 ? null : this.polylineHead.Peek();
        },
        TriangleHierarchy$$: "Microsoft.Msagl.Core.Geometry.RectangleNode`1[[Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle]]",
        get_TriangleHierarchy: function (){
            return this._TriangleHierarchy;
        },
        set_TriangleHierarchy: function (value){
            this._TriangleHierarchy = value;
        },
        TryInsertEdge: function (e){
            if (this.crossedEdges.Contains$$T(e))
                return;
            if (e.upperSite.get_Owner() != e.lowerSite.get_Owner() && this.RealCrossing(e))
                this.crossedEdges.Insert(e);
        },
        RealCrossing: function (cdtEdge){
            var segEndOrientation = Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(this.segEnd.get_Point(), cdtEdge.upperSite.Point, cdtEdge.lowerSite.Point);
            var segStartOrientation = Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(this.segStart.get_Point(), cdtEdge.upperSite.Point, cdtEdge.lowerSite.Point);
            return segStartOrientation != Microsoft.Msagl.Core.Geometry.TriangleOrientation.Collinear && segStartOrientation != segEndOrientation || this.SomePreviousPointIsOnOtherSiteOfEdge(cdtEdge, segEndOrientation);
        },
        SomePreviousPointIsOnOtherSiteOfEdge: function (cdtEdge, segEndOrientation){
            var $it449 = this.polylineHead.GetEnumerator();
            while ($it449.MoveNext()){
                var polylinePoint = $it449.get_Current();
                var orientation = Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(polylinePoint.get_Point(), cdtEdge.upperSite.Point, cdtEdge.lowerSite.Point);
                if (orientation != Microsoft.Msagl.Core.Geometry.TriangleOrientation.Collinear)
                    return orientation != segEndOrientation;
            }
            return false;
        },
        GetPointFeatureOnHierarchies: function (pp){
            var hitNode = this.get_SiteHierarchy().FirstHitNode$$Point(pp.get_Point());
            return hitNode != null ? hitNode.get_UserData() : this.GetFirstTriangleFeatureNotSite(pp);
        },
        GetFirstTriangleFeatureNotSite: function (pp){
            var $it450 = this.get_TriangleHierarchy().AllHitItems$$Point(pp.get_Point()).GetEnumerator();
            while ($it450.MoveNext()){
                var triangle = $it450.get_Current();
                var feature = Microsoft.Msagl.Routing.Spline.Bundling.CdtGeneralPolylineTracer.TryCreateFeatureWhichIsNotSite(pp, triangle);
                if (feature != null)
                    return feature;
            }
            return 0;
        },
        GetCrossedEdges: function (){
            if (this.iterator.MoveNext() == false)
                return this.crossedEdges;
            this.segStart = this.iterator.get_Current();
            this.lastCrossedFeature = this.GetPointFeatureOnHierarchies(this.segStart);
            if (this.iterator.MoveNext() == false)
                return this.crossedEdges;
            this.segEnd = this.iterator.get_Current();
            do{
                this.Step();
                if (this.LastCrossedFeatureContainsSegEnd()){
                    if (this.iterator.MoveNext() == false)
                        return this.crossedEdges;
                    this.MoveSegmentForward();
                }
            }
            while (true)
        },
        MoveSegmentForward: function (){
            this.polylineHead.Push(this.segStart);
            this.segStart = this.segEnd;
            this.segEnd = this.iterator.get_Current();
        },
        LastCrossedFeatureContainsSegEnd: function (){
            var triangle = As(this.lastCrossedFeature, Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle.ctor);
            if (triangle != null)
                return Microsoft.Msagl.Routing.Spline.Bundling.CdtGeneralPolylineTracer.PointBelongsToInteriorOfTriangle(this.segEnd.get_Point(), triangle);
            var edge = As(this.lastCrossedFeature, Microsoft.Msagl.Routing.CdtEdge.ctor);
            if (edge != null)
                return Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(edge.upperSite.Point, edge.lowerSite.Point, this.segEnd.get_Point()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Collinear;
            var site = As(this.lastCrossedFeature, Microsoft.Msagl.Routing.CdtSite.ctor);
            if (site != null)
                return Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(site.Point, this.segEnd.get_Point());
            return true;
        },
        Step: function (){
            if (this.get_PrevSegStart() == null)
                this.ProcessFirstSegment();
            else
                this.RegularStep();
        },
        RegularStep: function (){
            var triangle = As(this.lastCrossedFeature, Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle.ctor);
            if (triangle != null)
                this.StepFromTriangleInteriorPoint(triangle);
            else {
                var edge = As(this.lastCrossedFeature, Microsoft.Msagl.Routing.CdtEdge.ctor);
                if (edge != null)
                    this.StepFromEdgeInteriorPoint(edge);
                else {
                    var site = As(this.lastCrossedFeature, Microsoft.Msagl.Routing.CdtSite.ctor);
                    if (site != null)
                        this.RegularStepFromSite(site);
                    else {
                        this.lastCrossedFeature = this.GetPointFeatureOnHierarchies(this.segEnd);
                    }
                }
            }
        },
        RegularStepFromSite: function (site){
            var triangle = null;
            var $it451 = site.get_Triangles().GetEnumerator();
            while ($it451.MoveNext()){
                var t = $it451.get_Current();
                var index = t.Sites.Index(site);
                if (Microsoft.Msagl.Routing.Spline.Bundling.CdtGeneralPolylineTracer.PointIsInsideCone(this.segEnd.get_Point(), site.Point, t.Sites.get_Item$$Int32(index + 2).Point, t.Sites.get_Item$$Int32(index + 1).Point)){
                    triangle = t;
                    var segEndOrientation = Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(this.segEnd.get_Point(), t.Sites.get_Item$$Int32(index + 1).Point, t.Sites.get_Item$$Int32(index + 2).Point);
                    if (segEndOrientation != Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise){
                        this.CrossTriangleEdge(t.OppositeEdge(site));
                        return;
                    }
                }
            }
            if (triangle == null){
                this.lastCrossedFeature = 0;
                return;
            }
            if (Microsoft.Msagl.Routing.Spline.Bundling.CdtGeneralPolylineTracer.PointBelongsToInteriorOfTriangle(this.segEnd.get_Point(), triangle))
                this.lastCrossedFeature = triangle;
            else {
                var $it452 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.CdtEdge.ctor, triangle.Edges, $CreateAnonymousDelegate(this, function (e){
                    return e.IsAdjacent(site);
                })).GetEnumerator();
                while ($it452.MoveNext()){
                    var e = $it452.get_Current();
                    if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(e.upperSite.Point, e.lowerSite.Point, this.segEnd.get_Point()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Collinear){
                        this.lastCrossedFeature = e;
                        return;
                    }
                }
            }
        },
        ProcessFirstSegment: function (){
            var triangle = As(this.lastCrossedFeature, Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle.ctor);
            if (triangle != null)
                this.StepFromTriangleInteriorPoint(triangle);
            else {
                var edge = As(this.lastCrossedFeature, Microsoft.Msagl.Routing.CdtEdge.ctor);
                if (edge != null)
                    this.StepFromEdgeInteriorPoint(edge);
                else {
                    System.Diagnostics.Debug.Assert$$Boolean(Is(this.lastCrossedFeature, Microsoft.Msagl.Routing.CdtSite.ctor));
                    this.RegularStepFromSite(As(this.lastCrossedFeature, Microsoft.Msagl.Routing.CdtSite.ctor));
                }
            }
        },
        StepFromEdgeInteriorPoint: function (edge){
            var triangle = Microsoft.Msagl.Routing.Spline.Bundling.CdtGeneralPolylineTracer.GetTriangleOnThePointSide(edge, this.segEnd.get_Point());
            if (triangle == null){
                this.lastCrossedFeature = 0;
                return;
            }
            if (Microsoft.Msagl.Routing.Spline.Bundling.CdtGeneralPolylineTracer.PointBelongsToInteriorOfTriangle(this.segEnd.get_Point(), triangle)){
                this.lastCrossedFeature = triangle;
                return;
            }
            for (var i = 0; i < 3; i++){
                if (triangle.Edges.get_Item$$Int32(i) == edge)
                    continue;
                if (Microsoft.Msagl.Routing.Spline.Bundling.CdtGeneralPolylineTracer.PointIsInsideCone(this.segEnd.get_Point(), this.segStart.get_Point(), triangle.Sites.get_Item$$Int32(i + 1).Point, triangle.Sites.get_Item$$Int32(i).Point)){
                    this.CrossTriangleEdge(triangle.Edges.get_Item$$Int32(i));
                    return;
                }
            }
        },
        StepFromTriangleInteriorPoint: function (triangle){
            if (Microsoft.Msagl.Routing.Spline.Bundling.CdtGeneralPolylineTracer.PointBelongsToInteriorOfTriangle(this.segEnd.get_Point(), triangle)){
                this.lastCrossedFeature = triangle;
                return;
            }
            for (var i = 0; i < 3; i++)
                if (Microsoft.Msagl.Routing.Spline.Bundling.CdtGeneralPolylineTracer.PointIsInsideCone(this.segEnd.get_Point(), this.segStart.get_Point(), triangle.Sites.get_Item$$Int32(i + 1).Point, triangle.Sites.get_Item$$Int32(i).Point)){
                    this.CrossTriangleEdge(triangle.Edges.get_Item$$Int32(i));
                    return;
                }
        },
        CrossTriangleEdge: function (e){
            this.TryInsertEdge(e);
            if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(this.segStart.get_Point(), e.upperSite.Point, this.segEnd.get_Point()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Collinear){
                this.lastCrossedFeature = e.upperSite;
            }
            else if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(this.segStart.get_Point(), e.lowerSite.Point, this.segEnd.get_Point()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Collinear){
                this.lastCrossedFeature = e.lowerSite;
            }
            else
                this.lastCrossedFeature = e;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$CdtGeneralPolylineTracer);
var Microsoft$Msagl$Routing$Spline$Bundling$CdtIntersections = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.CdtIntersections",
    baseTypeName: "System.Object",
    staticDefinition: {
        GetHyperplaneSign: function (start, end, cdtSite){
            var area = Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(start, cdtSite.Point, end);
            if (area > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return 1;
            if (area < -Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return -1;
            return 0;
        },
        PointLocationInsideTriangle: function (p, triangle){
            var seenBoundary = false;
            for (var i = 0; i < 3; i++){
                var area = Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(p, triangle.Sites.get_Item$$Int32(i).Point, triangle.Sites.get_Item$$Int32(i + 1).Point);
                if (area < -Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                    return Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside;
                if (area < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                    seenBoundary = true;
            }
            return seenBoundary ? Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Boundary : Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Inside;
        },
        FindPolylinePoint: function (poly, point){
            var $it459 = poly.get_PolylinePoints().GetEnumerator();
            while ($it459.MoveNext()){
                var ppp = $it459.get_Current();
                if (Microsoft.Msagl.Core.Geometry.Point.op_Equality(ppp.get_Point(), point))
                    return ppp;
            }
            throw $CreateException(new System.NotSupportedException.ctor(), new Error());
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (metroGraphData, bundlingSettings){
            this.metroGraphData = null;
            this.bundlingSettings = null;
            this.ComputeForcesForBundles = false;
            System.Object.ctor.call(this);
            this.metroGraphData = metroGraphData;
            this.bundlingSettings = bundlingSettings;
        },
        BundleAvoidsObstacles: function (v, u, vPosition, uPosition, upperBound, closestDist){
            closestDist.Value = new System.Collections.Generic.List$1.ctor(System.Tuple$2.ctor);
            var obstaclesToIgnore = this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(v, u);
            var closeObstacles = this.FindCloseObstaclesForBundle(u.CdtTriangle, uPosition, vPosition, obstaclesToIgnore, upperBound);
            if (closeObstacles == null)
                return false;
            var $it453 = closeObstacles.GetEnumerator();
            while ($it453.MoveNext()){
                var item = $it453.get_Current();
                var dist = item.get_Value();
                closestDist.Value.Add(dist);
            }
            return true;
        },
        HubAvoidsObstacles: function (v, vPosition, upperBound, closestDist){
            closestDist.Value = new System.Collections.Generic.List$1.ctor(System.Double.ctor);
            var obstaclesToIgnore = this.metroGraphData.looseIntersections.ObstaclesToIgnoreForHub(v);
            var closeObstacles = this.FindCloseObstaclesForHub(v.CdtTriangle, v.Position, vPosition, obstaclesToIgnore, upperBound);
            if (closeObstacles == null)
                return false;
            var $it454 = closeObstacles.GetEnumerator();
            while ($it454.MoveNext()){
                var item = $it454.get_Current();
                var dist = item.get_Value();
                closestDist.Value.Add(dist);
            }
            return true;
        },
        FindCloseObstaclesForBundle: function (startTriangle, start, end, obstaclesToIgnore, upperBound){
            var obstacles = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, System.Tuple$2.ctor);
            var list;
            if (!(function (){
                var $1 = {
                    Value: list
                };
                var $res = this.ThreadLineSegmentThroughTriangles(startTriangle, start, end, obstaclesToIgnore, $1);
                list = $1.Value;
                return $res;
            }).call(this))
                return null;
            if (!this.ComputeForcesForBundles && !this.bundlingSettings.get_HighestQuality())
                return obstacles;
            var checkedSites = new System.Collections.Generic.HashSet$1.ctor(Microsoft.Msagl.Routing.CdtSite.ctor);
            var $it455 = list.GetEnumerator();
            while ($it455.MoveNext()){
                var t = $it455.get_Current();
                var $it456 = t.Sites.GetEnumerator();
                while ($it456.MoveNext()){
                    var s = $it456.get_Current();
                    if (!checkedSites.Add(s))
                        continue;
                    var poly = Cast(s.get_Owner(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
                    if (obstaclesToIgnore.Contains$$T(poly))
                        continue;
                    var pp = Microsoft.Msagl.Routing.Spline.Bundling.CdtIntersections.FindPolylinePoint(poly, s.Point);
                    var par11,par12,par21,par22;
                    var d12 = (function (){
                        var $1 = {
                            Value: par11
                        };
                        var $2 = {
                            Value: par12
                        };
                        var $res = Microsoft.Msagl.Core.Geometry.Point.MinDistBetweenLineSegments(pp.get_Point(), pp.get_NextOnPolyline().get_Point(), start, end, $1, $2);
                        par11 = $1.Value;
                        par12 = $2.Value;
                        return $res;
                    }).call(this);
                    var d22 = (function (){
                        var $1 = {
                            Value: par21
                        };
                        var $2 = {
                            Value: par22
                        };
                        var $res = Microsoft.Msagl.Core.Geometry.Point.MinDistBetweenLineSegments(pp.get_Point(), pp.get_PrevOnPolyline().get_Point(), start, end, $1, $2);
                        par21 = $1.Value;
                        par22 = $2.Value;
                        return $res;
                    }).call(this);
                    var r1,r2;
                    var dist;
                    if (d12 < d22){
                        dist = d12;
                        if (dist > upperBound)
                            continue;
                        r1 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(pp.get_Point(), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(pp.get_NextOnPolyline().get_Point(), pp.get_Point())), par11));
                        r2 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(start, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(end, start)), par12));
                    }
                    else {
                        dist = d22;
                        if (dist > upperBound)
                            continue;
                        r1 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(pp.get_Point(), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(pp.get_PrevOnPolyline().get_Point(), pp.get_Point())), par21));
                        r2 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(start, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(end, start)), par22));
                    }
                    var currentValue;
                    if (!(function (){
                        var $1 = {
                            Value: currentValue
                        };
                        var $res = obstacles.TryGetValue(poly, $1);
                        currentValue = $1.Value;
                        return $res;
                    }).call(this))
                        obstacles.Add(poly, new System.Tuple$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, r1, r2));
                }
            }
            return obstacles;
        },
        FindCloseObstaclesForHub: function (startTriangle, start, end, obstaclesToIgnore, upperBound){
            var obstacles = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, System.Double.ctor);
            var nearestTriangles;
            if (!(function (){
                var $1 = {
                    Value: nearestTriangles
                };
                var $res = this.ThreadLineSegmentThroughTriangles(startTriangle, start, end, obstaclesToIgnore, $1);
                nearestTriangles = $1.Value;
                return $res;
            }).call(this))
                return null;
            var checkedSites = new System.Collections.Generic.HashSet$1.ctor(Microsoft.Msagl.Routing.CdtSite.ctor);
            var $it457 = nearestTriangles.GetEnumerator();
            while ($it457.MoveNext()){
                var t = $it457.get_Current();
                var $it458 = t.Sites.GetEnumerator();
                while ($it458.MoveNext()){
                    var s = $it458.get_Current();
                    this.CheckSite(end, obstaclesToIgnore, checkedSites, s, upperBound, obstacles);
                    var edge = t.OppositeEdge(s);
                    var ot = edge.GetOtherTriangle$$CdtTriangle(t);
                    if (ot != null){
                        this.CheckSite(end, obstaclesToIgnore, checkedSites, ot.OppositeSite(edge), upperBound, obstacles);
                    }
                }
            }
            return obstacles;
        },
        CheckSite: function (end, obstaclesToIgnore, checkedSites, s, upperBound, obstacles){
            if (!checkedSites.Add(s))
                return;
            var poly = Cast(s.get_Owner(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            if (obstaclesToIgnore.Contains$$T(poly))
                return;
            var pp = Microsoft.Msagl.Routing.Spline.Bundling.CdtIntersections.FindPolylinePoint(poly, s.Point);
            var par;
            var d12 = (function (){
                var $1 = {
                    Value: par
                };
                var $res = Microsoft.Msagl.Core.Geometry.Point.DistToLineSegment(end, pp.get_Point(), pp.get_NextOnPolyline().get_Point(), $1);
                par = $1.Value;
                return $res;
            }).call(this);
            var d22 = (function (){
                var $1 = {
                    Value: par
                };
                var $res = Microsoft.Msagl.Core.Geometry.Point.DistToLineSegment(end, pp.get_Point(), pp.get_PrevOnPolyline().get_Point(), $1);
                par = $1.Value;
                return $res;
            }).call(this);
            var dist = System.Math.Min$$Double$$Double(d12, d22);
            if (dist > upperBound)
                return;
            var currentValue;
            if (!(function (){
                var $1 = {
                    Value: currentValue
                };
                var $res = obstacles.TryGetValue(poly, $1);
                currentValue = $1.Value;
                return $res;
            }).call(this)){
                obstacles.Add(poly, dist);
            }
            else if (currentValue > dist){
                obstacles.set_Item$$TKey(poly, dist);
            }
        },
        ThreadLineSegmentThroughTriangles: function (currentTriangle, start, end, obstaclesToIgnore, triangles){
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.PointIsInsideOfTriangle(start, currentTriangle));
            triangles.Value = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle.ctor);
            if (Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.PointIsInsideOfTriangle(end, currentTriangle)){
                triangles.Value.Add(currentTriangle);
                return true;
            }
            var threader = new Microsoft.Msagl.Routing.Spline.Bundling.CdtThreader.ctor(currentTriangle, start, end);
            triangles.Value.Add(currentTriangle);
            while (threader.MoveNext()){
                triangles.Value.Add(threader.get_CurrentTriangle());
                var piercedEdge = threader.get_CurrentPiercedEdge();
                if (piercedEdge.Constrained){
                    System.Diagnostics.Debug.Assert$$Boolean(piercedEdge.lowerSite.get_Owner() == piercedEdge.upperSite.get_Owner());
                    var poly = Cast(piercedEdge.lowerSite.get_Owner(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
                    if (!obstaclesToIgnore.Contains$$T(poly))
                        return false;
                }
            }
            if (threader.get_CurrentTriangle() != null)
                triangles.Value.Add(threader.get_CurrentTriangle());
            return true;
        },
        EdgeIsLegal$$Station$$Station$$Point$$Point: function (v, u, vPosition, uPosition){
            var list;
            var obstaclesToIgnore = this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(v, u);
            return (function (){
                var $1 = {
                    Value: list
                };
                var $res = this.ThreadLineSegmentThroughTriangles(v.CdtTriangle, vPosition, uPosition, obstaclesToIgnore, $1);
                list = $1.Value;
                return $res;
            }).call(this);
        },
        EdgeIsLegal$$Station$$Station$$Point$$Point$$Set$1$Polyline: function (v, u, vPosition, uPosition, obstaclesToIgnore){
            var start = v.Position;
            var currentTriangle = v.CdtTriangle;
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.PointIsInsideOfTriangle(start, currentTriangle));
            var end = u.Position;
            if (Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.PointIsInsideOfTriangle(end, currentTriangle)){
                return true;
            }
            var threader = new Microsoft.Msagl.Routing.Spline.Bundling.CdtThreader.ctor(currentTriangle, start, end);
            while (threader.MoveNext()){
                var piercedEdge = threader.get_CurrentPiercedEdge();
                if (piercedEdge.Constrained){
                    System.Diagnostics.Debug.Assert$$Boolean(piercedEdge.lowerSite.get_Owner() == piercedEdge.upperSite.get_Owner());
                    var poly = Cast(piercedEdge.lowerSite.get_Owner(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
                    if (!obstaclesToIgnore.Contains$$T(poly))
                        return false;
                }
            }
            return true;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$CdtIntersections);
var Microsoft$Msagl$Routing$Spline$Bundling$ChannelFlag = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.ChannelFlag",
    staticDefinition: {
        NotSet: 0,
        FromRight: 1,
        FromLeft: 2
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$ChannelFlag);
var Microsoft$Msagl$Routing$Spline$Bundling$EdgeNudger = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.EdgeNudger",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Routing.Spline.Bundling.EdgeNudger.SqueezeBound = 0.2;
        },
        FindCurveStart: function (metroGraphData, metroOrdering, metroline){
            var u = metroGraphData.PointToStations.get_Item$$TKey(metroline.get_Polyline().get_StartPoint().get_Point());
            var v = metroGraphData.PointToStations.get_Item$$TKey(metroline.get_Polyline().get_StartPoint().get_Next().get_Point());
            var bb = u.BundleBases.get_Item$$TKey(v);
            var index = (!bb.IsParent ? metroOrdering.GetLineIndexInOrder(v, u, metroline) : metroOrdering.GetLineIndexInOrder(u, v, metroline));
            return bb.get_Points()[index];
        },
        FindCurveEnd: function (metroGraphData, metroOrdering, metroline){
            var u = metroGraphData.PointToStations.get_Item$$TKey(metroline.get_Polyline().get_EndPoint().get_Prev().get_Point());
            var v = metroGraphData.PointToStations.get_Item$$TKey(metroline.get_Polyline().get_EndPoint().get_Point());
            var bb = v.BundleBases.get_Item$$TKey(u);
            var index = (!bb.IsParent ? metroOrdering.GetLineIndexInOrder(u, v, metroline) : metroOrdering.GetLineIndexInOrder(v, u, metroline));
            return bb.get_Points()[index];
        },
        BuildUnderlyingPolyline: function (start, end, cubicSegsOfLine){
            return null;
        },
        HubSegsOfLine: function (metroGraphData, metroOrdering, line){
            var $yield = [];
            for (var i = line.get_Polyline().get_StartPoint().get_Next(); i.get_Next() != null; i = i.get_Next())
                $yield.push(Microsoft.Msagl.Routing.Spline.Bundling.EdgeNudger.SegOnLineVertex(metroGraphData, metroOrdering, line, i));
            return $yield;
        },
        SegOnLineVertex: function (metroGraphData, metroOrdering, line, i){
            var u = metroGraphData.PointToStations.get_Item$$TKey(i.get_Prev().get_Point());
            var v = metroGraphData.PointToStations.get_Item$$TKey(i.get_Point());
            var h0 = v.BundleBases.get_Item$$TKey(u);
            var j0 = metroOrdering.GetLineIndexInOrder(u, v, line);
            if (h0.OrientedHubSegments[j0] == null || h0.OrientedHubSegments[j0].Segment == null){
                var w = metroGraphData.PointToStations.get_Item$$TKey(i.get_Next().get_Point());
                var otherBase = v.BundleBases.get_Item$$TKey(w);
                var j1 = metroOrdering.GetLineIndexInOrder(w, v, line);
                return new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(h0.get_Points()[j0], otherBase.get_Points()[j1]);
            }
            return h0.OrientedHubSegments[j0].Segment;
        },
        BiArc: function (p0, ts, p4, te){
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(ts.get_LengthSquared(), 1));
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(te.get_LengthSquared(), 1));
            var v = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(p0, p4);
            if (v.get_Length() < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return null;
            var vtse = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(v, (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(ts, te)));
            var tste = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(ts), te);
            var a = 2 * (tste - 1);
            var b = 2 * vtse;
            var c = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(v, v);
            var al;
            if (System.Math.Abs$$Double(a) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                if (System.Math.Abs$$Double(b) > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                    al = -c / b;
                }
                else {
                    return null;
                }
            }
            else {
                var d = b * b - 4 * a * c;
                System.Diagnostics.Debug.Assert$$Boolean(d >= -Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance());
                if (d < 0)
                    d = 0;
                d = System.Math.Sqrt(d);
                al = (-b + d) / (2 * a);
                if (al < 0)
                    al = (-b - d) / (2 * a);
            }
            var p1 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(p0, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(al, ts));
            var p3 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(p4, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(al, te));
            var p2 = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(0.5, (Microsoft.Msagl.Core.Geometry.Point.op_Addition(p1, p3)));
            var curve = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor();
            curve.AddSegs$$ICurve$$ICurve(Microsoft.Msagl.Routing.Spline.Bundling.EdgeNudger.ArcOn(p0, p1, p2), Microsoft.Msagl.Routing.Spline.Bundling.EdgeNudger.ArcOn(p2, p3, p4));
            if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(ts, (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(p4, p0))) <= 0 && Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(ts, te) <= 0){
                var curve2 = Microsoft.Msagl.Routing.Spline.Bundling.EdgeNudger.StandardBezier(p0, ts, p4, te);
                return curve2;
            }
            return curve;
        },
        ArcOn: function (a, b, c){
            var center;
            if (System.Math.Abs$$Double(Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(a, b, c)) < 0.0001 || !(function (){
                var $1 = {
                    Value: center
                };
                var $res = Microsoft.Msagl.Routing.Spline.Bundling.EdgeNudger.FindArcCenter(a, b, c, $1);
                center = $1.Value;
                return $res;
            })())
                return new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(a, c);
            var radius = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a, center)).get_Length();
            var chordLength = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a, b)).get_Length();
            if (chordLength / radius < 0.0001)
                return new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(a, c);
            var cenA = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a, center);
            var aAngle = System.Math.Atan2(cenA.get_Y(), cenA.get_X());
            var cenC = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(c, center);
            var cAngle = System.Math.Atan2(cenC.get_Y(), cenC.get_X());
            var delac = cAngle - aAngle;
            if (delac < 0){
                delac += 6.28318530717959;
                cAngle += 6.28318530717959;
            }
            if (delac <= 3.14159265358979){
                var el = new Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor$$Double$$Double$$Point$$Point$$Point(aAngle, cAngle, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(radius, 0), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, radius), center);
                return el;
            }
            if (cAngle > 6.28318530717959)
                cAngle -= 6.28318530717959;
            aAngle = 3.14159265358979 - aAngle;
            cAngle = 3.14159265358979 - cAngle;
            if (aAngle < 0)
                aAngle += 6.28318530717959;
            while (cAngle < aAngle)
                cAngle += 6.28318530717959;
            delac = cAngle - aAngle;
            System.Diagnostics.Debug.Assert$$Boolean(delac <= 3.14159265358979);
            return new Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor$$Double$$Double$$Point$$Point$$Point(aAngle, cAngle, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-radius, 0), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, radius), center);
        },
        FindArcCenter: function (a, b, c, center){
            var perp0 = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b, a)).Rotate90Cw();
            var perp1 = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b, c)).Rotate90Cw();
            return Microsoft.Msagl.Core.Geometry.Point.LineLineIntersection(a, Microsoft.Msagl.Core.Geometry.Point.op_Addition(a, perp0), c, Microsoft.Msagl.Core.Geometry.Point.op_Addition(c, perp1), center);
        },
        StandardBezier: function (segStart, tangentAtStart, segEnd, tangentAtEnd){
            var len = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(segStart, segEnd)).get_Length() / 4;
            return new Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ctor(segStart, Microsoft.Msagl.Core.Geometry.Point.op_Addition(segStart, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(tangentAtStart, len)), Microsoft.Msagl.Core.Geometry.Point.op_Addition(segEnd, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(tangentAtEnd, len)), segEnd);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (metroGraphData, bundlingSettings){
            this.bundlingSettings = null;
            this.metroGraphData = null;
            this.metroOrdering = null;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.metroGraphData = metroGraphData;
            this.bundlingSettings = bundlingSettings;
        },
        CreateUnderlyingPolylines$$: "System.Boolean",
        get_CreateUnderlyingPolylines: function (){
            return this.bundlingSettings.get_CreateUnderlyingPolyline();
        },
        RunInternal: function (){
            this.CreateMetroOrdering();
            this.InitRadii();
            this.FinalizePaths();
        },
        InitRadii: function (){
            new Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.ctor(this.metroGraphData, this.bundlingSettings).CreateNodeRadii();
        },
        CreateMetroOrdering: function (){
            if (this.bundlingSettings.get_UseGreedyMetrolineOrdering())
                this.metroOrdering = new Microsoft.Msagl.Routing.Spline.Bundling.GeneralMetroMapOrdering.ctor(this.metroGraphData.get_Metrolines());
            else
                this.metroOrdering = new Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.ctor(this.metroGraphData.get_Metrolines(), this.metroGraphData.PointToStations);
        },
        FinalizePaths: function (){
            this.CreateBundleBases();
            this.CreateSegmentsInsideHubs();
            this.CreateCurves();
        },
        CreateBundleBases: function (){
            var bbCalc = new Microsoft.Msagl.Routing.Spline.Bundling.BundleBasesCalculator.ctor(this.metroOrdering, this.metroGraphData, this.bundlingSettings);
            bbCalc.Run();
        },
        CreateCurves: function (){
            System.Diagnostics.Debug.Assert$$Boolean(this.metroGraphData.get_Metrolines().get_Count() == this.metroGraphData.get_Edges().length);
            for (var i = 0; i < this.metroGraphData.get_Metrolines().get_Count(); i++)
                this.CreateCurveLine(this.metroGraphData.get_Metrolines().get_Item$$Int32(i), this.metroGraphData.get_Edges()[i]);
        },
        CreateCurveLine: function (line, edge){
            var c = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor();
            var start = Microsoft.Msagl.Routing.Spline.Bundling.EdgeNudger.FindCurveStart(this.metroGraphData, this.metroOrdering, line);
            var currentEnd = start;
            var hubSegsOfLine = Microsoft.Msagl.Routing.Spline.Bundling.EdgeNudger.HubSegsOfLine(this.metroGraphData, this.metroOrdering, line);
            var $it460 = hubSegsOfLine.GetEnumerator();
            while ($it460.MoveNext()){
                var seg = $it460.get_Current();
                if (seg == null)
                    continue;
                c.AddSegment(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(currentEnd, seg.get_Start()));
                c.AddSegment(seg);
                currentEnd = seg.get_End();
            }
            c.AddSegment(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(currentEnd, Microsoft.Msagl.Routing.Spline.Bundling.EdgeNudger.FindCurveEnd(this.metroGraphData, this.metroOrdering, line)));
            edge.set_Curve(c);
            if (this.get_CreateUnderlyingPolylines())
                edge.set_SmoothedPolyline(Microsoft.Msagl.Routing.Spline.Bundling.EdgeNudger.BuildUnderlyingPolyline(start, currentEnd, hubSegsOfLine));
        },
        CreateSegmentsInsideHubs: function (){
            var $it461 = this.metroGraphData.get_Metrolines().GetEnumerator();
            while ($it461.MoveNext()){
                var metroline = $it461.get_Current();
                this.CreateOrientedSegsOnLine(metroline);
            }
            if (this.bundlingSettings.get_UseCubicBezierSegmentsInsideOfHubs())
                this.FanBezierSegs();
        },
        CreateOrientedSegsOnLine: function (line){
            for (var polyPoint = line.get_Polyline().get_StartPoint().get_Next(); polyPoint.get_Next() != null; polyPoint = polyPoint.get_Next())
                this.CreateOrientedSegsOnLineVertex(line, polyPoint);
        },
        CreateOrientedSegsOnLineVertex: function (line, polyPoint){
            var u = this.metroGraphData.PointToStations.get_Item$$TKey(polyPoint.get_Prev().get_Point());
            var v = this.metroGraphData.PointToStations.get_Item$$TKey(polyPoint.get_Point());
            var w = this.metroGraphData.PointToStations.get_Item$$TKey(polyPoint.get_Next().get_Point());
            var h0 = v.BundleBases.get_Item$$TKey(u);
            var h1 = v.BundleBases.get_Item$$TKey(w);
            var j0 = this.metroOrdering.GetLineIndexInOrder(u, v, line);
            var j1 = this.metroOrdering.GetLineIndexInOrder(w, v, line);
            var seg = this.bundlingSettings.get_UseCubicBezierSegmentsInsideOfHubs() ? Microsoft.Msagl.Routing.Spline.Bundling.EdgeNudger.StandardBezier(h0.get_Points()[j0], h0.get_Tangents()[j0], h1.get_Points()[j1], h1.get_Tangents()[j1]) : Microsoft.Msagl.Routing.Spline.Bundling.EdgeNudger.BiArc(h0.get_Points()[j0], h0.get_Tangents()[j0], h1.get_Points()[j1], h1.get_Tangents()[j1]);
            h0.OrientedHubSegments[j0].Segment = seg;
            h1.OrientedHubSegments[j1].Segment = seg;
        },
        FanBezierSegs: function (){
            var progress = true;
            var maxSteps = 5;
            var steps = 0;
            while (progress && steps++ < maxSteps){
                progress = false;
                var $it462 = this.metroGraphData.Stations.GetEnumerator();
                while ($it462.MoveNext()){
                    var s = $it462.get_Current();
                    var $it463 = s.BundleBases.get_Values().GetEnumerator();
                    while ($it463.MoveNext()){
                        var segmentHub = $it463.get_Current();
                        progress |= this.FanEdgesOfHubSegment(segmentHub);
                    }
                }
            }
        },
        FanEdgesOfHubSegment: function (bundleHub){
            var ret = false;
            for (var i = 0; i < bundleHub.get_Count() - 1; i++)
                ret |= this.FanCouple(bundleHub, i, bundleHub.get_CurveCenter(), bundleHub.Curve.get_BoundingBox().get_Diagonal() / 2);
            return ret;
        },
        FanCouple: function (bundleHub, i, center, radius){
            var lSeg = bundleHub.OrientedHubSegments[i];
            var rSeg = bundleHub.OrientedHubSegments[i + 1];
            if (lSeg == null)
                return false;
            var x;
            if ((function (){
                var $1 = {
                    Value: x
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.LineSegment.Intersect(lSeg.Segment.get_Start(), lSeg.Segment.get_End(), rSeg.Segment.get_Start(), rSeg.Segment.get_End(), $1);
                x = $1.Value;
                return $res;
            }).call(this))
                return false;
            if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(lSeg.get_Item$$Double(0), lSeg.get_Item$$Double(0.5), lSeg.get_Item$$Double(1)) != Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(rSeg.get_Item$$Double(0), rSeg.get_Item$$Double(0.5), rSeg.get_Item$$Double(1)))
                return false;
            var ll = this.BaseLength(lSeg);
            var rl = this.BaseLength(rSeg);
            if (System.Math.Abs$$Double(ll - rl) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_IntersectionEpsilon())
                return false;
            if (ll > rl)
                return this.AdjustLongerSeg(lSeg, rSeg, center, radius);
            return this.AdjustLongerSeg(rSeg, lSeg, center, radius);
        },
        AdjustLongerSeg: function (longerSeg, shorterSeg, center, radius){
            var del0 = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(longerSeg.get_Item$$Double(0), shorterSeg.get_Item$$Double(0));
            var del1 = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(longerSeg.get_Item$$Double(1), shorterSeg.get_Item$$Double(1));
            var minDelLength = System.Math.Min$$Double$$Double(del0.get_Length(), del1.get_Length());
            var midPointOfShorter = shorterSeg.get_Item$$Double(0.5);
            var maxDelLen = System.Math.Max$$Double$$Double(del0.get_Length(), del1.get_Length());
            if (this.NicelyAligned(Cast(longerSeg.Segment, Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ctor), del0, del1, midPointOfShorter, minDelLength, maxDelLen) == 0)
                return false;
            return this.FitLonger(longerSeg, del0, del1, midPointOfShorter, minDelLength, maxDelLen, center, radius);
        },
        FitLonger: function (longerOrientedSeg, del0, del1, midPointOfShorter, minDelLength, maxDel, center, radius){
            var seg = Cast(longerOrientedSeg.Segment, Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ctor);
            var start = seg.get_Start();
            var end = seg.get_End();
            var steps = 0;
            var maxSteps = 10;
            var lowP1 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point((0.8), seg.get_Start()), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(0.2, seg.B(1)));
            var lowP2 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point((0.8), seg.get_End()), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(0.2, seg.B(2)));
            var highP1 = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(2, seg.B(1)), seg.get_Start());
            var highP2 = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(2, seg.B(2)), seg.get_End());
            (function (){
                var $1 = {
                    Value: highP1
                };
                var $res = this.PullControlPointToTheCircle(seg.get_Start(), $1, center, radius);
                highP1 = $1.Value;
                return $res;
            }).call(this);
            var r = this.NicelyAligned(seg, del0, del1, midPointOfShorter, minDelLength, maxDel);
            do{
                if (r == -1){
                    var p1 = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Addition(seg.B(1), lowP1)), 2);
                    var p2 = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Addition(seg.B(2), lowP2)), 2);
                    highP1 = seg.B(1);
                    highP2 = seg.B(2);
                    seg = new Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ctor(start, p1, p2, end);
                }
                else {
                    System.Diagnostics.Debug.Assert$$Boolean(r == 1);
                    var p1 = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Addition(seg.B(1), highP1)), 2);
                    var p2 = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Addition(seg.B(2), highP2)), 2);
                    lowP1 = seg.B(1);
                    lowP2 = seg.B(2);
                    seg = new Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ctor(start, p1, p2, end);
                }
                if ((r = this.NicelyAligned(seg, del0, del1, midPointOfShorter, minDelLength, maxDel)) == 0){
                    longerOrientedSeg.get_Other().Segment = longerOrientedSeg.Segment = seg;
                    return true;
                }
                if (steps++ > maxSteps)
                    return false;
            }
            while (true)
        },
        PullControlPointToTheCircle: function (start, highP, center, radius){
            var closestPointOnLine = Microsoft.Msagl.Core.Geometry.Point.ProjectionToLine(start, highP.Value, center);
            var maxOffset = System.Math.Sqrt(radius * radius - (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(closestPointOnLine, center)).get_LengthSquared());
            var offsetNow = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(highP.Value, closestPointOnLine);
            var offsetLen = offsetNow.get_Length();
            if (offsetLen > maxOffset)
                highP.Value = Microsoft.Msagl.Core.Geometry.Point.op_Addition(closestPointOnLine, Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(maxOffset, offsetNow), offsetLen));
        },
        NicelyAligned: function (longerSeg, del0, del1, midPointOfShorter, minDelLength, maxDelLen){
            var eps = 0.001;
            var midDel = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(longerSeg.get_Item$$Double(0.5), midPointOfShorter);
            var midDelLen = midDel.get_Length();
            if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(del0, midDel) < 0 || Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(del1, midDel) < 0)
                return 1;
            if (midDelLen < minDelLength - eps)
                return 1;
            if (midDelLen > maxDelLen + eps)
                return -1;
            return 0;
        },
        BaseLength: function (seg){
            return (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(seg.get_Item$$Double(0), seg.get_Item$$Double(1))).get_LengthSquared();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$EdgeNudger);
var Microsoft$Msagl$Routing$Spline$Bundling$FlipCollapser = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.FlipCollapser",
    baseTypeName: "System.Object",
    staticDefinition: {
        OrderedPair$$PolylinePoint: function (pp){
            return Microsoft.Msagl.Routing.Spline.Bundling.FlipCollapser.OrderedPair$$PolylinePoint$$PolylinePoint(pp, pp.get_Next());
        },
        OrderedPair$$PolylinePoint$$PolylinePoint: function (p0, p1){
            return new Microsoft.Msagl.Core.Geometry.PointPair.ctor(p0.get_Point(), p1.get_Point());
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (metroGraphData, bundlingSettings, cdt){
            this.metroGraphData = null;
            this.bundlingSettings = null;
            this.cdt = null;
            this.randomWeights = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.PointPair.ctor, System.Double.ctor);
            this.polylineToEdgeGeom = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor);
            this.pathsThroughPoints = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.DataStructures.Set$1.ctor);
            this.random = new System.Random.ctor$$Int32(1);
            this.interestingPoints = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            this.siteHierarchy = null;
            this.triangleHierarchy = null;
            System.Object.ctor.call(this);
            this.metroGraphData = metroGraphData;
            this.bundlingSettings = bundlingSettings;
            this.cdt = cdt;
        },
        Polylines$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]",
        get_Polylines: function (){
            return this.polylineToEdgeGeom.get_Keys();
        },
        Run: function (){
            this.Init();
            this.RemoveFlips();
        },
        Init: function (){
            for (var $i465 = 0,$t465 = this.metroGraphData.get_Edges(),$l465 = $t465.length,e = $t465[$i465]; $i465 < $l465; $i465++, e = $t465[$i465]){
                this.polylineToEdgeGeom.set_Item$$TKey(Cast(e.get_Curve(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor), e);
            }
            var del = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon, Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon);
            if (this.cdt != null){
                this.siteHierarchy = Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnEnumeration(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.CdtSite.ctor, Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, this.cdt.PointsToSites.get_Values(), $CreateAnonymousDelegate(this, function (site){
                    return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(Microsoft.Msagl.Routing.CdtSite.ctor, site, new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Addition(site.Point, del), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(site.Point, del)));
                })));
                this.triangleHierarchy = Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnEnumeration(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle.ctor, Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, this.cdt.GetTriangles(), $CreateAnonymousDelegate(this, function (tr){
                    return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle.ctor, tr, this.TriangleRectangle(tr.Sites));
                })));
            }
            this.CreatePathsThroughPoints();
        },
        CreatePathsThroughPoints: function (){
            var $it465 = this.get_Polylines().GetEnumerator();
            while ($it465.MoveNext()){
                var poly = $it465.get_Current();
                this.CreatePathsThroughPointsForPolyline(poly);
            }
        },
        CreatePathsThroughPointsForPolyline: function (poly){
            var $it466 = poly.get_PolylinePoints().GetEnumerator();
            while ($it466.MoveNext()){
                var pp = $it466.get_Current();
                pp.set_Polyline(poly);
                this.RegisterPolylinePointInPathsThrough(pp);
            }
        },
        RegisterPolylinePointInPathsThrough: function (pp){
            var set = this.GetOrCreatePassingPathsSet(pp);
            set.Insert(pp);
        },
        GetOrCreatePassingPathsSet: function (pp){
            var set;
            if ((function (){
                var $1 = {
                    Value: set
                };
                var $res = this.pathsThroughPoints.TryGetValue(pp.get_Point(), $1);
                set = $1.Value;
                return $res;
            }).call(this))
                return set;
            this.pathsThroughPoints.set_Item$$TKey(pp.get_Point(), set = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor));
            return set;
        },
        RemoveFlips: function (){
            var queued = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, this.get_Polylines());
            var queue = new System.Collections.Generic.Queue$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            var $it467 = this.get_Polylines().GetEnumerator();
            while ($it467.MoveNext()){
                var e = $it467.get_Current();
                queue.Enqueue(e);
            }
            while (queue.get_Count() > 0){
                var initialPolyline = queue.Dequeue();
                queued.Remove(initialPolyline);
                var changedPolyline = this.ProcessPolyline(initialPolyline);
                if (changedPolyline != null)if (!queued.Contains$$T(changedPolyline)){
                    queued.Insert(changedPolyline);
                    queue.Enqueue(changedPolyline);
                }
            }
        },
        ProcessPolyline: function (polyline){
            var flipSide = this.FindFlip(polyline);
            if (flipSide != null){
                return this.CollapseFlip(flipSide, polyline);
            }
            return null;
        },
        FindFlip: function (poly){
            var departed = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor);
            for (var pp = poly.get_StartPoint().get_Next(); pp != null; pp = pp.get_Next()){
                this.FillDepartedOnPrev(departed, pp);
                var $it468 = this.pathsThroughPoints.get_Item$$TKey(pp.get_Point()).GetEnumerator();
                while ($it468.MoveNext()){
                    var polyPoint = $it468.get_Current();
                    var pointOfDeparture;
                    if ((function (){
                        var $1 = {
                            Value: pointOfDeparture
                        };
                        var $res = departed.TryGetValue(polyPoint.get_Polyline(), $1);
                        pointOfDeparture = $1.Value;
                        return $res;
                    }).call(this))
                        return pointOfDeparture.get_Polyline();
                }
            }
            return null;
        },
        FillDepartedOnPrev: function (departed, pp){
            var prevPoint = pp.get_Prev().get_Point();
            var $it469 = this.pathsThroughPoints.get_Item$$TKey(prevPoint).GetEnumerator();
            while ($it469.MoveNext()){
                var polyPoint = $it469.get_Current();
                if (!this.IsNeighbor(polyPoint, pp)){
                    System.Diagnostics.Debug.Assert$$Boolean(!departed.ContainsKey(polyPoint.get_Polyline()));
                    departed.set_Item$$TKey(polyPoint.get_Polyline(), polyPoint);
                }
            }
        },
        IsNeighbor: function (a, b){
            return a.get_Prev() != null && Microsoft.Msagl.Core.Geometry.Point.op_Equality(a.get_Prev().get_Point(), b.get_Point()) || a.get_Next() != null && Microsoft.Msagl.Core.Geometry.Point.op_Equality(a.get_Next().get_Point(), b.get_Point());
        },
        CollapseFlip: function (a, b){
            var aFirst;
            var bFirst;
            var aLast;
            var bLast;
            var aPointMap = this.GetPointMap(a);
            var bPointMap = this.GetPointMap(b);
            (function (){
                var $1 = {
                    Value: aFirst
                };
                var $2 = {
                    Value: aLast
                };
                var $res = this.FindFirstAndLast(a, $1, $2, bPointMap);
                aFirst = $1.Value;
                aLast = $2.Value;
                return $res;
            }).call(this);
            (function (){
                var $1 = {
                    Value: bFirst
                };
                var $2 = {
                    Value: bLast
                };
                var $res = this.FindFirstAndLast(b, $1, $2, aPointMap);
                bFirst = $1.Value;
                bLast = $2.Value;
                return $res;
            }).call(this);
            var baFirstP = bPointMap.get_Item$$TKey(aFirst);
            var baLastP = bPointMap.get_Item$$TKey(aLast);
            var aFirstBeforeALastOnB = this.PolylinePointsAreInCorrectOrder(baFirstP, baLastP);
            var abFirstP = aPointMap.get_Item$$TKey(bFirst);
            var abLastP = aPointMap.get_Item$$TKey(bLast);
            var bFirstBeforeBLastOnA = this.PolylinePointsAreInCorrectOrder(abFirstP, abLastP);
            var aChannel = this.GetCdtEdgesCrossedByPath(a);
            var bChannel = this.GetCdtEdgesCrossedByPath(b);
            var aCollapsedEdges = this.GetChannelEdgeOfCollapsedA(a, aPointMap.get_Item$$TKey(aFirst), baFirstP, aPointMap.get_Item$$TKey(aLast), baLastP, aFirstBeforeALastOnB);
            var bCollapsedEdges = this.GetChannelEdgeOfCollapsedA(b, bPointMap.get_Item$$TKey(bFirst), abFirstP, bPointMap.get_Item$$TKey(bLast), abLastP, bFirstBeforeBLastOnA);
            var edgesAbondonedByA = this.cdt == null ? null : Microsoft.Msagl.Core.DataStructures.Set$1.op_Subtraction(aChannel, aCollapsedEdges);
            var edgesEnteredByA = this.cdt == null ? null : Microsoft.Msagl.Core.DataStructures.Set$1.op_Subtraction(aCollapsedEdges, aChannel);
            var edgesAbondonedByB = this.cdt == null ? null : Microsoft.Msagl.Core.DataStructures.Set$1.op_Subtraction(bChannel, bCollapsedEdges);
            var edgesEnteredByB = this.cdt == null ? null : Microsoft.Msagl.Core.DataStructures.Set$1.op_Subtraction(bCollapsedEdges, bChannel);
            var aEdgeGeom = this.polylineToEdgeGeom.get_Item$$TKey(a);
            var bEdgeGeom = this.polylineToEdgeGeom.get_Item$$TKey(b);
            var deltaCostForCollapsingA = this.CostGrowth(aFirst, aLast, aPointMap, bPointMap, aFirstBeforeALastOnB, aEdgeGeom, edgesAbondonedByA, edgesEnteredByA);
            var deltaCostForCollapsingB = this.CostGrowth(bFirst, bLast, bPointMap, aPointMap, bFirstBeforeBLastOnA, bEdgeGeom, edgesAbondonedByB, edgesEnteredByB);
            if (deltaCostForCollapsingA >= 0 && deltaCostForCollapsingB >= 0){
                return null;
            }
            if (deltaCostForCollapsingA < deltaCostForCollapsingB){
                this.Collapse(aFirst, aLast, aPointMap, bPointMap, aFirstBeforeALastOnB, edgesAbondonedByA, edgesEnteredByA);
                return a;
            }
            if (deltaCostForCollapsingB < deltaCostForCollapsingA){
                this.Collapse(bFirst, bLast, bPointMap, aPointMap, bFirstBeforeBLastOnA, edgesEnteredByB, edgesEnteredByB);
                return b;
            }
            deltaCostForCollapsingA = this.DeltaRandomCost(aFirst, aLast, aPointMap, bPointMap, aFirstBeforeALastOnB);
            deltaCostForCollapsingB = this.DeltaRandomCost(bFirst, bLast, bPointMap, aPointMap, bFirstBeforeBLastOnA);
            if (deltaCostForCollapsingA < deltaCostForCollapsingB){
                this.Collapse(aFirst, aLast, aPointMap, bPointMap, aFirstBeforeALastOnB, edgesEnteredByA, edgesEnteredByB);
                return a;
            }
            else {
                this.Collapse(bFirst, bLast, bPointMap, aPointMap, bFirstBeforeBLastOnA, edgesAbondonedByB, edgesEnteredByB);
                return b;
            }
        },
        GetCdtEdgesCrossedByPath: function (polyline){
            if (this.cdt == null)
                return null;
            var ret = new Microsoft.Msagl.Routing.Spline.Bundling.CdtGeneralPolylineTracer.ctor(polyline.get_PolylinePoints(), this.siteHierarchy, this.triangleHierarchy).GetCrossedEdges();
            return ret;
        },
        CollapsedPolylinePolylinePoints: function (a, aFirstP, abFirstP, aLastP, abLastP, aFirstBeforeALastOnB){
            System.Diagnostics.Debug.Assert$$Boolean(abLastP.get_Polyline() != a);
            System.Diagnostics.Debug.Assert$$Boolean(abFirstP.get_Polyline() != a);
            var ret = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor);
            for (var p = a.get_StartPoint(); p != aFirstP; p = p.get_Next())
                ret.Add(p);
            if (aFirstBeforeALastOnB)
                for (var p = abFirstP; p != abLastP; p = p.get_Next())
                    ret.Add(p);
            else
                for (var p = abFirstP; p != abLastP; p = p.get_Prev())
                    ret.Add(p);
            for (var p = aLastP; p != null; p = p.get_Next())
                ret.Add(p);
            return ret;
        },
        GetChannelEdgeOfCollapsedA: function (a, aFirstP, abFirstP, aLastP, abLastP, aFirstBeforeALastOnB){
            if (this.cdt == null)
                return null;
            var tracer = new Microsoft.Msagl.Routing.Spline.Bundling.CdtGeneralPolylineTracer.ctor(this.CollapsedPolylinePolylinePoints(a, aFirstP, abFirstP, aLastP, abLastP, aFirstBeforeALastOnB), this.siteHierarchy, this.triangleHierarchy);
            return tracer.GetCrossedEdges();
        },
        GetPointMap: function (a){
            var aPointMap = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor);
            var $it470 = a.get_PolylinePoints().GetEnumerator();
            while ($it470.MoveNext()){
                var p = $it470.get_Current();
                aPointMap.set_Item$$TKey(p.get_Point(), p);
            }
            return aPointMap;
        },
        PolylinePointsAreInCorrectOrder: function (u, v){
            System.Diagnostics.Debug.Assert$$Boolean(u.get_Polyline() == v.get_Polyline());
            for (var p = u; p != null; p = p.get_Next())
                if (p == v)
                    return true;
            return false;
        },
        Collapse: function (aFirst, aLast, aPointMap, bPointMap, aFirstBeforeALastOnB, abondonedEdges, enteredEdges){
            var aFirstP = aPointMap.get_Item$$TKey(aFirst);
            var aLastP = aPointMap.get_Item$$TKey(aLast);
            this.UnregisterSegment(aFirstP, aLastP);
            var afb = bPointMap.get_Item$$TKey(aFirst);
            var alb = bPointMap.get_Item$$TKey(aLast);
            var nxt = aFirstBeforeALastOnB ? ($CreateAnonymousDelegate(this, function (p){
                return p.get_Next();
            })) : ($CreateAnonymousDelegate(this, function (p){
                return p.get_Prev();
            }));
            for (afb = nxt(afb); afb != alb; afb = nxt(afb)){
                var pp = (function (){
                    var $v74 = new Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor(afb.get_Point());
                    $v74.set_Prev(aFirstP);
                    $v74.set_Polyline(aFirstP.get_Polyline());
                    return $v74;
                }).call(this);
                aFirstP.set_Next(pp);
                aFirstP = pp;
                this.RegisterPolylinePointInPathsThrough(pp);
            }
            aFirstP.set_Next(aLastP);
            aLastP.set_Prev(aFirstP);
            if (this.cdt != null)
                this.UpdateResidualCapacities(aFirstP, abondonedEdges, enteredEdges);
        },
        UpdateResidualCapacities: function (aFirstP, abondonedEdges, enteredEdges){
            var width = this.polylineToEdgeGeom.get_Item$$TKey(aFirstP.get_Polyline()).get_LineWidth();
            var edgeSeparation = this.bundlingSettings.get_EdgeSeparation();
            var $it471 = abondonedEdges.GetEnumerator();
            while ($it471.MoveNext()){
                var edge = $it471.get_Current();
                edge.set_ResidualCapacity(edge.get_ResidualCapacity() + (edgeSeparation + width));
                if (edge.get_ResidualCapacity() > edge.Capacity)
                    edge.set_ResidualCapacity(edge.Capacity);
            }
            var $it472 = enteredEdges.GetEnumerator();
            while ($it472.MoveNext()){
                var edge = $it472.get_Current();
                if (edge.get_ResidualCapacity() == edge.Capacity)
                    edge.set_ResidualCapacity(edge.get_ResidualCapacity() - width);
                else
                    edge.set_ResidualCapacity(edge.get_ResidualCapacity() - width + edgeSeparation);
            }
        },
        CostGrowth: function (aFirst, aLast, aPointMap, bPointMap, aFirstBeforeALastOnB, edgeGeometry, edgesAbondonedByA, edgesEnteredByA){
            var savedCost = this.SavedCostBetween(aPointMap.get_Item$$TKey(aFirst), aPointMap.get_Item$$TKey(aLast), edgeGeometry, edgesAbondonedByA);
            var addedCost = this.AddedCostBetweenAfterCollapse(bPointMap.get_Item$$TKey(aFirst), bPointMap.get_Item$$TKey(aLast), aFirstBeforeALastOnB, edgeGeometry, edgesEnteredByA);
            return addedCost - savedCost;
        },
        SavedCostBetween: function (aFirst, aLast, edgeGeometry, edgesAbondonedByA){
            var savedCost = 0;
            savedCost += this.LengthBetween(aFirst, aLast);
            savedCost += this.SavedCapacityPenalty(edgeGeometry, edgesAbondonedByA);
            return savedCost;
        },
        SavedCapacityPenalty: function (edgeGeometry, abondonedEdges){
            if (abondonedEdges == null)
                return 0;
            return System.Linq.Enumerable.Sum$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.CdtEdge.ctor, abondonedEdges, $CreateAnonymousDelegate(this, function (cdtEdge){
                return this.SavedCapacityPenaltyOnCdtEdge(cdtEdge, edgeGeometry);
            }));
        },
        SavedCapacityPenaltyOnCdtEdge: function (cdtEdge, edgeGeometry){
            if (cdtEdge.get_ResidualCapacity() > 0)
                return 0;
            var savedDelta;
            var width = edgeGeometry.get_LineWidth();
            if (cdtEdge.get_ResidualCapacity() == cdtEdge.Capacity - width)
                savedDelta = width;
            else
                savedDelta = width + this.bundlingSettings.get_EdgeSeparation();
            if (savedDelta > -cdtEdge.get_ResidualCapacity())
                savedDelta = -cdtEdge.get_ResidualCapacity();
            return savedDelta * Microsoft.Msagl.Routing.Spline.Bundling.SdShortestPath.CapacityOverflowPenaltyMultiplier(this.bundlingSettings);
        },
        AddedCostBetweenAfterCollapse: function (aFirst, aLast, aFirstBeforeALastOnB, edgeGeometry, edgesEnteredByA){
            var addedCost = 0;
            addedCost += aFirstBeforeALastOnB ? this.LengthBetween(aFirst, aLast) : this.LengthBetween(aLast, aFirst);
            addedCost += this.AddedCapacityPenalty(edgeGeometry, edgesEnteredByA);
            return addedCost;
        },
        AddedCapacityPenalty: function (edgeGeometry, enteredCdtEdges){
            if (this.cdt == null)
                return 0;
            return System.Linq.Enumerable.Sum$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.CdtEdge.ctor, enteredCdtEdges, $CreateAnonymousDelegate(this, function (cdtEdge){
                return this.AddedCapacityPenaltyForCdtEdge(cdtEdge, edgeGeometry);
            }));
        },
        AddedCapacityPenaltyForCdtEdge: function (cdtEdge, edgeGeometry){
            var capacityOverflowMultiplier = Microsoft.Msagl.Routing.Spline.Bundling.SdShortestPath.CapacityOverflowPenaltyMultiplier(this.bundlingSettings);
            return Microsoft.Msagl.Routing.Spline.Bundling.SdShortestPath.CostOfCrossingCdtEdge(capacityOverflowMultiplier, this.bundlingSettings, edgeGeometry, cdtEdge);
        },
        DeltaRandomCost: function (aFirst, aLast, aPointMap, bPointMap, aFirstBeforeALastOnB){
            var aFirstPp = aPointMap.get_Item$$TKey(aFirst);
            var aLastPp = aPointMap.get_Item$$TKey(aLast);
            var oldCost = this.RandomCost(aFirstPp, aLastPp);
            var newCost = this.RandomCostBetweenAfterCollapse(bPointMap.get_Item$$TKey(aFirst), bPointMap.get_Item$$TKey(aLast), aFirstBeforeALastOnB);
            return newCost - oldCost;
        },
        RandomCostBetweenAfterCollapse: function (u, v, aFirstBeforeALastOnB){
            return aFirstBeforeALastOnB ? this.RandomCost(u, v) : this.RandomCost(v, u);
        },
        LengthBetween: function (aFirst, aLast){
            var r = 0;
            for (var p = aFirst; p != aLast; p = p.get_Next())
                r += (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(p.get_Point(), p.get_Next().get_Point())).get_Length();
            return r;
        },
        FindFirstAndLast: function (a, aFirst, aLast, bPoints){
            aFirst.Value = aLast.Value = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            for (var p = a.get_StartPoint(); p != null; p = p.get_Next()){
                if (bPoints.ContainsKey(p.get_Point())){
                    aFirst.Value = p.get_Point();
                    break;
                }
            }
            for (var p = a.get_EndPoint(); p != null; p = p.get_Prev()){
                if (bPoints.ContainsKey(p.get_Point())){
                    aLast.Value = p.get_Point();
                    return;
                }
            }
            throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
        },
        UnregisterSegment: function (b, bm){
            for (b = b.get_Next(); b != bm; b = b.get_Next())
                this.UnregisterPolypointFromPathsThrough(b);
        },
        UnregisterPolypointFromPathsThrough: function (b){
            var paths = this.pathsThroughPoints.get_Item$$TKey(b.get_Point());
            System.Diagnostics.Debug.Assert$$Boolean(paths.Contains$$T(b));
            paths.Remove(b);
        },
        RandomCost: function (p0, p1){
            var w = 0;
            for (; p0 != p1; p0 = p0.get_Next())
                w += this.GetRandomWeightOfPolylinePoint(p0);
            return w;
        },
        TriangleRectangle: function (sites){
            var rect = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point(sites.get_Item$$Int32(0).Point);
            rect.Add$$Point(sites.get_Item$$Int32(1).Point);
            rect.Add$$Point(sites.get_Item$$Int32(2).Point);
            return rect;
        },
        GetRandomWeightOfPolylinePoint: function (p){
            var pointPair = Microsoft.Msagl.Routing.Spline.Bundling.FlipCollapser.OrderedPair$$PolylinePoint(p);
            var weight;
            if ((function (){
                var $1 = {
                    Value: weight
                };
                var $res = this.randomWeights.TryGetValue(pointPair, $1);
                weight = $1.Value;
                return $res;
            }).call(this))
                return weight;
            this.randomWeights.set_Item$$TKey(pointPair, weight = this.random.NextDouble());
            return weight;
        },
        GetChangedCrossing: function (){
            return this.interestingPoints;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$FlipCollapser);
var Microsoft$Msagl$Routing$Spline$Bundling$FlipSwitcher = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.FlipSwitcher",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (metroGraphData){
            this.metroGraphData = null;
            this.polylineToEdgeGeom = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor);
            this.pathsThroughPoints = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.DataStructures.Set$1.ctor);
            this.interestingPoints = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            this.numberOfReducedCrossings = 0;
            System.Object.ctor.call(this);
            this.metroGraphData = metroGraphData;
        },
        Polylines$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]",
        get_Polylines: function (){
            return this.polylineToEdgeGeom.get_Keys();
        },
        Run: function (){
            this.Init();
            this.SwitchFlips();
        },
        Init: function (){
            for (var $i474 = 0,$t474 = this.metroGraphData.get_Edges(),$l474 = $t474.length,e = $t474[$i474]; $i474 < $l474; $i474++, e = $t474[$i474])
                this.polylineToEdgeGeom.set_Item$$TKey(Cast(e.get_Curve(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor), e);
            var $it474 = this.get_Polylines().GetEnumerator();
            while ($it474.MoveNext()){
                var poly = $it474.get_Current();
                this.RegisterPolylinePointInPathsThrough$$IEnumerable$1$PolylinePoint(poly.get_PolylinePoints());
            }
        },
        RegisterPolylinePointInPathsThrough$$IEnumerable$1$PolylinePoint: function (points){
            var $it475 = points.GetEnumerator();
            while ($it475.MoveNext()){
                var pp = $it475.get_Current();
                this.RegisterPolylinePointInPathsThrough$$PolylinePoint(pp);
            }
        },
        RegisterPolylinePointInPathsThrough$$PolylinePoint: function (pp){
            Microsoft.Msagl.Core.DataStructures.CollectionUtilities.AddToMap$3(Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.DataStructures.Set$1.ctor, this.pathsThroughPoints, pp.get_Point(), pp);
        },
        UnregisterPolylinePointInPathsThrough$$IEnumerable$1$PolylinePoint: function (points){
            var $it476 = points.GetEnumerator();
            while ($it476.MoveNext()){
                var pp = $it476.get_Current();
                this.UnregisterPolylinePointInPathsThrough$$PolylinePoint(pp);
            }
        },
        UnregisterPolylinePointInPathsThrough$$PolylinePoint: function (pp){
            Microsoft.Msagl.Core.DataStructures.CollectionUtilities.RemoveFromMap$3(Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.DataStructures.Set$1.ctor, this.pathsThroughPoints, pp.get_Point(), pp);
        },
        SwitchFlips: function (){
            var queued = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, this.get_Polylines());
            var queue = new System.Collections.Generic.Queue$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            var $it477 = this.get_Polylines().GetEnumerator();
            while ($it477.MoveNext()){
                var e = $it477.get_Current();
                queue.Enqueue(e);
            }
            while (queue.get_Count() > 0){
                var initialPolyline = queue.Dequeue();
                queued.Remove(initialPolyline);
                var changedPolyline = this.ProcessPolyline(initialPolyline);
                if (changedPolyline != null){
                    if (!queued.Contains$$T(initialPolyline)){
                        queued.Insert(initialPolyline);
                        queue.Enqueue(initialPolyline);
                    }
                    if (!queued.Contains$$T(changedPolyline)){
                        queued.Insert(changedPolyline);
                        queue.Enqueue(changedPolyline);
                    }
                }
            }
        },
        ProcessPolyline: function (polyline){
            var departed = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor);
            for (var pp = polyline.get_StartPoint().get_Next(); pp != null; pp = pp.get_Next()){
                this.FillDepartedPolylinePoints(pp, departed);
                var $it478 = this.pathsThroughPoints.get_Item$$TKey(pp.get_Point()).GetEnumerator();
                while ($it478.MoveNext()){
                    var polyPoint = $it478.get_Current();
                    if (departed.ContainsKey(polyPoint.get_Polyline())){
                        if (this.ProcessFlip(polyline, polyPoint.get_Polyline(), departed.get_Item$$TKey(polyPoint.get_Polyline()).get_Point(), pp.get_Point()))
                            return polyPoint.get_Polyline();
                        departed.Remove(polyPoint.get_Polyline());
                    }
                }
            }
            return null;
        },
        FillDepartedPolylinePoints: function (pp, departed){
            var prevPoint = pp.get_Prev().get_Point();
            var $it479 = this.pathsThroughPoints.get_Item$$TKey(prevPoint).GetEnumerator();
            while ($it479.MoveNext()){
                var polyPoint = $it479.get_Current();
                if (!this.IsNeighbor(polyPoint, pp)){
                    System.Diagnostics.Debug.Assert$$Boolean(!departed.ContainsKey(polyPoint.get_Polyline()));
                    departed.set_Item$$TKey(polyPoint.get_Polyline(), polyPoint);
                }
            }
        },
        ProcessFlip: function (polylineA, polylineB, flipStart, flipEnd){
            if (this.polylineToEdgeGeom.get_Item$$TKey(polylineA).get_LineWidth() != this.polylineToEdgeGeom.get_Item$$TKey(polylineB).get_LineWidth())
                return false;
            var aFirst,aLast,bFirst,bLast;
            var forwardOrderA,forwardOrderB;
            (function (){
                var $1 = {
                    Value: aFirst
                };
                var $2 = {
                    Value: aLast
                };
                var $3 = {
                    Value: forwardOrderA
                };
                var $res = this.FindPointsOnPolyline(polylineA, flipStart, flipEnd, $1, $2, $3);
                aFirst = $1.Value;
                aLast = $2.Value;
                forwardOrderA = $3.Value;
                return $res;
            }).call(this);
            (function (){
                var $1 = {
                    Value: bFirst
                };
                var $2 = {
                    Value: bLast
                };
                var $3 = {
                    Value: forwardOrderB
                };
                var $res = this.FindPointsOnPolyline(polylineB, flipStart, flipEnd, $1, $2, $3);
                bFirst = $1.Value;
                bLast = $2.Value;
                forwardOrderB = $3.Value;
                return $res;
            }).call(this);
            System.Diagnostics.Debug.Assert$$Boolean(this.PolylinePointsAreInForwardOrder(aFirst, aLast) == forwardOrderA);
            System.Diagnostics.Debug.Assert$$Boolean(this.PolylinePointsAreInForwardOrder(bFirst, bLast) == forwardOrderB);
            var rel1 = this.FindRelationOnFirstPoint(aFirst, bFirst, forwardOrderA, forwardOrderB);
            var rel2 = this.FindRelationOnLastPoint(aLast, bLast, forwardOrderA, forwardOrderB);
            if (rel1 != 2 && rel2 != 2)
                return false;
            if (rel1 == 1 || rel2 == 1)
                return false;
            this.UnregisterPolylinePointInPathsThrough$$IEnumerable$1$PolylinePoint(polylineA.get_PolylinePoints());
            this.UnregisterPolylinePointInPathsThrough$$IEnumerable$1$PolylinePoint(polylineB.get_PolylinePoints());
            this.Swap(aFirst, bFirst, aLast, bLast, forwardOrderA, forwardOrderB);
            this.RegisterPolylinePointInPathsThrough$$IEnumerable$1$PolylinePoint(polylineA.get_PolylinePoints());
            this.RegisterPolylinePointInPathsThrough$$IEnumerable$1$PolylinePoint(polylineB.get_PolylinePoints());
            this.RegisterInterestingPoint(aFirst.get_Point());
            this.RegisterInterestingPoint(aLast.get_Point());
            this.numberOfReducedCrossings++;
            return true;
        },
        FindPointsOnPolyline: function (polyline, first, last, ppFirst, ppLast, forwardOrder){
            ppFirst.Value = ppLast.Value = null;
            forwardOrder.Value = false;
            for (var pp = polyline.get_StartPoint(); pp != null; pp = pp.get_Next()){
                if (Microsoft.Msagl.Core.Geometry.Point.op_Equality(pp.get_Point(), first))
                    ppFirst.Value = pp;
                if (Microsoft.Msagl.Core.Geometry.Point.op_Equality(pp.get_Point(), last))
                    ppLast.Value = pp;
                if (ppFirst.Value != null && ppLast.Value == null)
                    forwardOrder.Value = true;
                if (ppFirst.Value == null && ppLast.Value != null)
                    forwardOrder.Value = false;
            }
            System.Diagnostics.Debug.Assert$$Boolean(ppFirst.Value != null && ppLast.Value != null);
        },
        PolylinePointsAreInForwardOrder: function (u, v){
            System.Diagnostics.Debug.Assert$$Boolean(u.get_Polyline() == v.get_Polyline());
            for (var p = u; p != null; p = p.get_Next())
                if (p == v)
                    return true;
            return false;
        },
        Next: function (p, forwardOrder){
            return forwardOrder ? p.get_Next() : p.get_Prev();
        },
        Prev: function (p, forwardOrder){
            return forwardOrder ? p.get_Prev() : p.get_Next();
        },
        FindRelationOnFirstPoint: function (aFirst, bFirst, forwardOrderA, forwardOrderB){
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.Point.op_Equality(aFirst.get_Point(), bFirst.get_Point()));
            var a0 = aFirst;
            var b0 = bFirst;
            while (true){
                var prevA = this.Prev(aFirst, forwardOrderA);
                var prevB = this.Prev(bFirst, forwardOrderB);
                if (prevA == null || prevB == null){
                    System.Diagnostics.Debug.Assert$$Boolean(prevA == null && prevB == null);
                    return 0;
                }
                if (Microsoft.Msagl.Core.Geometry.Point.op_Inequality(prevA.get_Point(), prevB.get_Point()))
                    break;
                aFirst = prevA;
                bFirst = prevB;
            }
            return this.PolylinesIntersect(a0, b0, aFirst, bFirst, forwardOrderA, forwardOrderB);
        },
        FindRelationOnLastPoint: function (aLast, bLast, forwardOrderA, forwardOrderB){
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.Point.op_Equality(aLast.get_Point(), bLast.get_Point()));
            var a0 = aLast;
            var b0 = bLast;
            while (true){
                var nextA = this.Next(aLast, forwardOrderA);
                var nextB = this.Next(bLast, forwardOrderB);
                if (nextA == null || nextB == null){
                    System.Diagnostics.Debug.Assert$$Boolean(nextA == null && nextB == null);
                    return 0;
                }
                if (Microsoft.Msagl.Core.Geometry.Point.op_Inequality(nextA.get_Point(), nextB.get_Point()))
                    break;
                aLast = nextA;
                bLast = nextB;
            }
            while (Microsoft.Msagl.Core.Geometry.Point.op_Equality(this.Next(aLast, forwardOrderA).get_Point(), this.Prev(bLast, forwardOrderB).get_Point())){
                aLast = this.Next(aLast, forwardOrderA);
                bLast = this.Prev(bLast, forwardOrderB);
            }
            return this.PolylinesIntersect(aLast, bLast, a0, b0, forwardOrderA, forwardOrderB);
        },
        PolylinesIntersect: function (a0, b0, a1, b1, forwardOrderA, forwardOrderB){
            var a0p = this.Prev(a0, forwardOrderA);
            var a0n = this.Next(a0, forwardOrderA);
            var a1n = this.Next(a1, forwardOrderA);
            var a1p = this.Prev(a1, forwardOrderA);
            var b0n = this.Next(b0, forwardOrderB);
            var b1p = this.Prev(b1, forwardOrderB);
            if (Microsoft.Msagl.Core.Geometry.Point.op_Equality(a0.get_Point(), a1.get_Point())){
                var bs = a0.get_Point();
                var left0 = Microsoft.Msagl.Core.Geometry.Point.GetOrientationOf3Vectors(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a1p.get_Point(), bs), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b1p.get_Point(), bs), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a0n.get_Point(), bs));
                var left1 = Microsoft.Msagl.Core.Geometry.Point.GetOrientationOf3Vectors(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a1p.get_Point(), bs), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b0n.get_Point(), bs), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a0n.get_Point(), bs));
                System.Diagnostics.Debug.Assert$$Boolean(left0 != 0 && left1 != 0);
                return left0 == left1 ? 1 : 2;
            }
            else {
                var left0 = Microsoft.Msagl.Core.Geometry.Point.GetOrientationOf3Vectors(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a0p.get_Point(), a0.get_Point()), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a0n.get_Point(), a0.get_Point()), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b0n.get_Point(), a0.get_Point()));
                var left1 = Microsoft.Msagl.Core.Geometry.Point.GetOrientationOf3Vectors(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a1n.get_Point(), a1.get_Point()), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b1p.get_Point(), a1.get_Point()), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a1p.get_Point(), a1.get_Point()));
                System.Diagnostics.Debug.Assert$$Boolean(left0 != 0 && left1 != 0);
                return left0 == left1 ? 1 : 2;
            }
        },
        Swap: function (aFirst, bFirst, aLast, bLast, forwardOrderA, forwardOrderB){
            var intermediateAPoints = this.GetRangeOnPolyline(this.Next(aFirst, forwardOrderA), aLast, forwardOrderA);
            var intermediateBPoints = this.GetRangeOnPolyline(this.Next(bFirst, forwardOrderB), bLast, forwardOrderB);
            this.ChangePolylineSegment(aFirst, aLast, forwardOrderA, intermediateBPoints);
            this.ChangePolylineSegment(bFirst, bLast, forwardOrderB, intermediateAPoints);
            Microsoft.Msagl.Routing.Spline.Bundling.PathFixer.RemoveSelfCyclesFromPolyline(aFirst.get_Polyline());
            System.Diagnostics.Debug.Assert$$Boolean(this.PolylineIsOK(aFirst.get_Polyline()));
            Microsoft.Msagl.Routing.Spline.Bundling.PathFixer.RemoveSelfCyclesFromPolyline(bFirst.get_Polyline());
            System.Diagnostics.Debug.Assert$$Boolean(this.PolylineIsOK(bFirst.get_Polyline()));
        },
        ChangePolylineSegment: function (aFirst, aLast, forwardOrderA, intermediateBPoints){
            var curA = aFirst;
            var $it480 = intermediateBPoints.GetEnumerator();
            while ($it480.MoveNext()){
                var b = $it480.get_Current();
                var newp = (function (){
                    var $v75 = new Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor(b.get_Point());
                    $v75.set_Polyline(curA.get_Polyline());
                    return $v75;
                }).call(this);
                if (forwardOrderA){
                    newp.set_Prev(curA);
                    curA.set_Next(newp);
                }
                else {
                    newp.set_Next(curA);
                    curA.set_Prev(newp);
                }
                curA = newp;
            }
            if (forwardOrderA){
                curA.set_Next(aLast);
                aLast.set_Prev(curA);
            }
            else {
                curA.set_Prev(aLast);
                aLast.set_Next(curA);
            }
        },
        GetRangeOnPolyline: function (start, end, forwardOrder){
            var res = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor);
            for (var pp = start; pp != end; pp = this.Next(pp, forwardOrder))
                res.Add(pp);
            return res;
        },
        FindFlip: function (poly){
            var departed = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor);
            for (var pp = poly.get_StartPoint().get_Next(); pp != null; pp = pp.get_Next()){
                this.FillDepartedOnPrev(departed, pp);
                var $it481 = this.pathsThroughPoints.get_Item$$TKey(pp.get_Point()).GetEnumerator();
                while ($it481.MoveNext()){
                    var polyPoint = $it481.get_Current();
                    var pointOfDeparture;
                    if ((function (){
                        var $1 = {
                            Value: pointOfDeparture
                        };
                        var $res = departed.TryGetValue(polyPoint.get_Polyline(), $1);
                        pointOfDeparture = $1.Value;
                        return $res;
                    }).call(this))
                        return pointOfDeparture.get_Polyline();
                }
            }
            return null;
        },
        FillDepartedOnPrev: function (departed, pp){
            var prevPoint = pp.get_Prev().get_Point();
            var $it482 = this.pathsThroughPoints.get_Item$$TKey(prevPoint).GetEnumerator();
            while ($it482.MoveNext()){
                var polyPoint = $it482.get_Current();
                if (!this.IsNeighbor(polyPoint, pp)){
                    System.Diagnostics.Debug.Assert$$Boolean(!departed.ContainsKey(polyPoint.get_Polyline()));
                    departed.set_Item$$TKey(polyPoint.get_Polyline(), polyPoint);
                }
            }
        },
        IsNeighbor: function (a, b){
            return a.get_Prev() != null && Microsoft.Msagl.Core.Geometry.Point.op_Equality(a.get_Prev().get_Point(), b.get_Point()) || a.get_Next() != null && Microsoft.Msagl.Core.Geometry.Point.op_Equality(a.get_Next().get_Point(), b.get_Point());
        },
        RegisterInterestingPoint: function (p){
            if (!this.interestingPoints.Contains$$T(p))
                this.interestingPoints.Insert(p);
        },
        GetChangedHubs: function (){
            return this.interestingPoints;
        },
        NumberOfReducedCrossings: function (){
            return this.numberOfReducedCrossings;
        },
        PolylineIsOK: function (poly){
            var pointsToPP = new System.Collections.Generic.HashSet$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            for (var pp = poly.get_StartPoint(); pp != null; pp = pp.get_Next()){
                if (pp == poly.get_StartPoint()){
                    if (pp.get_Prev() != null)
                        return false;
                }
                else {
                    if (pp.get_Prev().get_Next() != pp)
                        return false;
                }
                if (pp == poly.get_EndPoint()){
                    if (pp.get_Next() != null)
                        return false;
                }
                else {
                    if (pp.get_Next().get_Prev() != pp)
                        return false;
                }
                if (pointsToPP.Contains(pp.get_Point()))
                    return false;
                pointsToPP.Add(pp.get_Point());
            }
            if (poly.get_StartPoint().get_Prev() != null)
                return false;
            if (poly.get_EndPoint().get_Next() != null)
                return false;
            return true;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$FlipSwitcher);
var Microsoft$Msagl$Routing$Spline$Bundling$GeneralMetroMapOrdering = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.GeneralMetroMapOrdering",
    baseTypeName: "System.Object",
    staticDefinition: {
        Next: function (p){
            return p.get_Next();
        },
        Prev: function (p){
            return p.get_Prev();
        },
        IsLeft: function (v0, v1, v2){
            return Microsoft.Msagl.Core.Geometry.Point.GetOrientationOf3Vectors(v0, v1, v2);
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Routing.Spline.Bundling.IMetroMapOrderingAlgorithm"],
    Kind: "Class",
    definition: {
        ctor: function (Metrolines){
            this.Metrolines = null;
            this.bundles = null;
            System.Object.ctor.call(this);
            this.Metrolines = Metrolines;
            this.BuildOrder();
        },
        GetMetroline: function (metroEdgeIndex){
            return this.Metrolines.get_Item$$Int32(metroEdgeIndex);
        },
        GetOrder: function (u, v){
            var $yield = [];
            var pointPair = new Microsoft.Msagl.Core.Geometry.PointPair.ctor(u.Position, v.Position);
            var orderedMetrolineListForUv = this.bundles.get_Item$$TKey(pointPair).Metrolines;
            if (Microsoft.Msagl.Core.Geometry.Point.op_Equality(u.Position, pointPair.get_First())){
                var $it483 = orderedMetrolineListForUv.GetEnumerator();
                while ($it483.MoveNext()){
                    var Metroline = $it483.get_Current();
                    $yield.push(Metroline);
                }
            }
            else {
                for (var i = orderedMetrolineListForUv.get_Count() - 1; i >= 0; i--)
                    $yield.push(orderedMetrolineListForUv.get_Item$$Int32(i));
            }
            return $yield;
        },
        GetLineCount: function (u, v){
            return this.bundles.get_Item$$TKey(new Microsoft.Msagl.Core.Geometry.PointPair.ctor(u, v)).get_Count();
        },
        GetLineIndexInOrder: function (u, v, Metroline){
            var edge = new Microsoft.Msagl.Core.Geometry.PointPair.ctor(u.Position, v.Position);
            var reversed = Microsoft.Msagl.Core.Geometry.Point.op_Inequality(u.Position, edge.get_First());
            var d = this.bundles.get_Item$$TKey(edge).LineIndexInOrder;
            return !reversed ? d.get_Item$$TKey(Metroline) : d.get_Count() - 1 - d.get_Item$$TKey(Metroline);
        },
        BuildOrder: function (){
            this.bundles = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.PointPair.ctor, Microsoft.Msagl.Routing.Spline.Bundling.PointPairOrder.ctor);
            var $it484 = this.Metrolines.GetEnumerator();
            while ($it484.MoveNext()){
                var Metroline = $it484.get_Current();
                for (var p = Metroline.get_Polyline().get_StartPoint(); p.get_Next() != null; p = p.get_Next()){
                    var e = new Microsoft.Msagl.Core.Geometry.PointPair.ctor(p.get_Point(), p.get_Next().get_Point());
                    var li;
                    if (!(function (){
                        var $1 = {
                            Value: li
                        };
                        var $res = this.bundles.TryGetValue(e, $1);
                        li = $1.Value;
                        return $res;
                    }).call(this))
                        this.bundles.set_Item$$TKey(e, li = new Microsoft.Msagl.Routing.Spline.Bundling.PointPairOrder.ctor());
                    li.Add(Metroline);
                }
            }
            var $it485 = this.bundles.GetEnumerator();
            while ($it485.MoveNext()){
                var edge = $it485.get_Current();
                this.BuildOrder$$PointPair$$PointPairOrder(edge.get_Key(), edge.get_Value());
            }
        },
        BuildOrder$$PointPair$$PointPairOrder: function (pair, order){
            if (order.orderFixed)
                return;
            order.Metrolines.Sort$$Comparison$1($CreateAnonymousDelegate(this, function (line0, line1){
                return this.CompareLines(line0, line1, pair.get_First(), pair.get_Second());
            }));
            order.orderFixed = true;
            order.LineIndexInOrder = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Metroline.ctor, System.Int32.ctor);
            for (var i = 0; i < order.Metrolines.get_Count(); i++)
                order.LineIndexInOrder.set_Item$$TKey(order.Metrolines.get_Item$$Int32(i), i);
        },
        CompareLines: function (ml0, ml1, u, v){
            var polylinePoint0;
            var next0;
            var prev0;
            (function (){
                var $1 = {
                    Value: polylinePoint0
                };
                var $2 = {
                    Value: next0
                };
                var $3 = {
                    Value: prev0
                };
                var $res = this.FindStationOnLine(u, v, ml0, $1, $2, $3);
                polylinePoint0 = $1.Value;
                next0 = $2.Value;
                prev0 = $3.Value;
                return $res;
            }).call(this);
            var polylinePoint1;
            var next1;
            var prev1;
            (function (){
                var $1 = {
                    Value: polylinePoint1
                };
                var $2 = {
                    Value: next1
                };
                var $3 = {
                    Value: prev1
                };
                var $res = this.FindStationOnLine(u, v, ml1, $1, $2, $3);
                polylinePoint1 = $1.Value;
                next1 = $2.Value;
                prev1 = $3.Value;
                return $res;
            }).call(this);
            var p0 = polylinePoint0;
            var p1 = polylinePoint1;
            var p00,p11 = null;
            while ((p00 = prev0(p0)) != null && (p11 = prev1(p1)) != null && Microsoft.Msagl.Core.Geometry.Point.op_Equality(p00.get_Point(), p11.get_Point())){
                var edge = new Microsoft.Msagl.Core.Geometry.PointPair.ctor(p00.get_Point(), p0.get_Point());
                if (this.bundles.get_Item$$TKey(edge).orderFixed){
                    return this.CompareOnFixedOrder(edge, ml0, ml1, Microsoft.Msagl.Core.Geometry.Point.op_Inequality(p00.get_Point(), edge.get_First()));
                }
                p0 = p00;
                p1 = p11;
            }
            if (p00 != null && p11 != null){
                var forkBase = p0.get_Point();
                return Microsoft.Msagl.Routing.Spline.Bundling.GeneralMetroMapOrdering.IsLeft(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(next0(p0).get_Point(), forkBase), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(p00.get_Point(), forkBase), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(p11.get_Point(), forkBase));
            }
            p0 = polylinePoint0;
            p1 = polylinePoint1;
            while ((p00 = next0(p0)) != null && (p11 = next1(p1)) != null && Microsoft.Msagl.Core.Geometry.Point.op_Equality(p00.get_Point(), p11.get_Point())){
                var edge = new Microsoft.Msagl.Core.Geometry.PointPair.ctor(p00.get_Point(), p0.get_Point());
                if (this.bundles.get_Item$$TKey(edge).orderFixed)
                    return this.CompareOnFixedOrder(edge, ml0, ml1, Microsoft.Msagl.Core.Geometry.Point.op_Inequality(p0.get_Point(), edge.get_First()));
                p0 = p00;
                p1 = p11;
            }
            if (p00 != null && p11 != null){
                var forkBase = p0.get_Point();
                return -Microsoft.Msagl.Routing.Spline.Bundling.GeneralMetroMapOrdering.IsLeft(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(prev0(p0).get_Point(), forkBase), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(p00.get_Point(), forkBase), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(p11.get_Point(), forkBase));
            }
            return ml0.get_Index().CompareTo$$Int32(ml1.get_Index());
        },
        CompareOnFixedOrder: function (edge, ml0, ml1, reverse){
            var mlToIndex = this.bundles.get_Item$$TKey(edge).LineIndexInOrder;
            var r = reverse ? -1 : 1;
            return r * mlToIndex.get_Item$$TKey(ml0).CompareTo$$Int32(mlToIndex.get_Item$$TKey(ml1));
        },
        FindStationOnLine: function (u, v, Metroline, polyPoint, next, prev){
            for (var p = Metroline.get_Polyline().get_StartPoint(); p.get_Next() != null; p = p.get_Next()){
                if (Microsoft.Msagl.Core.Geometry.Point.op_Equality(p.get_Point(), u) && Microsoft.Msagl.Core.Geometry.Point.op_Equality(p.get_Next().get_Point(), v)){
                    next.Value = Microsoft.Msagl.Routing.Spline.Bundling.GeneralMetroMapOrdering.Next;
                    prev.Value = Microsoft.Msagl.Routing.Spline.Bundling.GeneralMetroMapOrdering.Prev;
                    polyPoint.Value = p;
                    return;
                }
                if (Microsoft.Msagl.Core.Geometry.Point.op_Equality(p.get_Point(), v) && Microsoft.Msagl.Core.Geometry.Point.op_Equality(p.get_Next().get_Point(), u)){
                    prev.Value = Microsoft.Msagl.Routing.Spline.Bundling.GeneralMetroMapOrdering.Next;
                    next.Value = Microsoft.Msagl.Routing.Spline.Bundling.GeneralMetroMapOrdering.Prev;
                    polyPoint.Value = p.get_Next();
                    return;
                }
            }
            throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$GeneralMetroMapOrdering);
var Microsoft$Msagl$Routing$Spline$Bundling$HubDebugger = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.HubDebugger",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$HubDebugger);
var Microsoft$Msagl$Routing$Spline$Bundling$HubRadiiCalculator = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.MaxIterations = 100;
        },
        CalculateIdealHubRadius: function (metroGraphData, bundlingSettings, node){
            var r = 1;
            for (var $i492 = 0,$t492 = node.Neighbors,$l492 = $t492.length,adj = $t492[$i492]; $i492 < $l492; $i492++, adj = $t492[$i492]){
                var width = metroGraphData.GetWidth$$Station$$Station$$Double(adj, node, bundlingSettings.get_EdgeSeparation());
                var nr = width / 2 + bundlingSettings.get_EdgeSeparation();
                r = System.Math.Max$$Double$$Double(r, nr);
            }
            r = System.Math.Min$$Double$$Double(r, 2 * bundlingSettings.MaxHubRadius);
            return r;
        },
        CalculateIdealHubRadiusWithNeighbors$$MetroGraphData$$BundlingSettings$$Station: function (metroGraphData, bundlingSettings, node){
            return Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.CalculateIdealHubRadiusWithNeighbors$$MetroGraphData$$BundlingSettings$$Station$$Point(metroGraphData, bundlingSettings, node, node.Position);
        },
        CalculateIdealHubRadiusWithNeighbors$$MetroGraphData$$BundlingSettings$$Station$$Point: function (metroGraphData, bundlingSettings, node, newPosition){
            var r = Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.CalculateIdealHubRadius(metroGraphData, bundlingSettings, node);
            if (System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, node.Neighbors) > 1){
                var adjNodes = node.Neighbors;
                for (var i = 0; i < adjNodes.length; i++){
                    var adj = adjNodes[i];
                    var nextAdj = adjNodes[(i + 1) % adjNodes.length];
                    r = System.Math.Max$$Double$$Double(r, Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.GetMinRadiusForTwoAdjacentBundles$$Double$$Station$$Point$$Station$$Station$$MetroGraphData$$BundlingSettings(r, node, newPosition, adj, nextAdj, metroGraphData, bundlingSettings));
                }
            }
            r = System.Math.Min$$Double$$Double(r, 2 * bundlingSettings.MaxHubRadius);
            return r;
        },
        CalculateIdealHubRadiusWithAdjacentEdges: function (metroGraphData, bundlingSettings, node){
            var r = bundlingSettings.MaxHubRadius;
            for (var $i493 = 0,$t493 = node.Neighbors,$l493 = $t493.length,adj = $t493[$i493]; $i493 < $l493; $i493++, adj = $t493[$i493]){
                r = System.Math.Min$$Double$$Double(r, (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(node.Position, adj.Position)).get_Length() / 2);
            }
            return r;
        },
        GetMinRadiusForTwoAdjacentBundles$$Double$$Station$$Point$$Station$$Station$$MetroGraphData$$BundlingSettings: function (r, node, nodePosition, adj0, adj1, metroGraphData, bundlingSettings){
            var w0 = metroGraphData.GetWidth$$Station$$Station$$Double(node, adj0, bundlingSettings.get_EdgeSeparation());
            var w1 = metroGraphData.GetWidth$$Station$$Station$$Double(node, adj1, bundlingSettings.get_EdgeSeparation());
            return Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.GetMinRadiusForTwoAdjacentBundles$$Double$$Point$$Point$$Point$$Double$$Double$$MetroGraphData$$BundlingSettings(r, nodePosition, adj0.Position, adj1.Position, w0, w1, metroGraphData, bundlingSettings);
        },
        GetMinRadiusForTwoAdjacentBundles$$Double$$Point$$Point$$Point$$Double$$Double$$MetroGraphData$$BundlingSettings: function (r, a, b, c, widthAB, widthAC, metroGraphData, bundlingSettings){
            if (widthAB < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon || widthAC < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return r;
            var angle = Microsoft.Msagl.Core.Geometry.Point.Angle$$Point$$Point$$Point(b, a, c);
            angle = System.Math.Min$$Double$$Double(angle, 6.28318530717959 - angle);
            if (angle < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return 2 * bundlingSettings.MaxHubRadius;
            if (angle >= 1.5707963267949)
                return r * 1.05;
            var sina = System.Math.Sin(angle);
            var cosa = System.Math.Cos(angle);
            var aa = widthAB / (4 * sina);
            var bb = widthAC / (4 * sina);
            var d = 2 * System.Math.Sqrt(aa * aa + bb * bb + 2 * aa * bb * cosa);
            d = System.Math.Min$$Double$$Double(d, 2 * bundlingSettings.MaxHubRadius);
            d = System.Math.Max$$Double$$Double(d, r);
            return d;
        },
        GetMinRadiusForTwoAdjacentBundlesOld$$Double$$Station$$Point$$Station$$Station$$MetroGraphData$$BundlingSettings: function (r, node, nodePosition, adj0, adj1, metroGraphData, bundlingSettings){
            var w0 = metroGraphData.GetWidth$$Station$$Station$$Double(node, adj0, bundlingSettings.get_EdgeSeparation());
            var w1 = metroGraphData.GetWidth$$Station$$Station$$Double(node, adj1, bundlingSettings.get_EdgeSeparation());
            return Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.GetMinRadiusForTwoAdjacentBundlesOld$$Double$$Point$$Point$$Point$$Double$$Double$$MetroGraphData$$BundlingSettings(r, nodePosition, adj0.Position, adj1.Position, w0, w1, metroGraphData, bundlingSettings);
        },
        GetMinRadiusForTwoAdjacentBundlesOld$$Double$$Point$$Point$$Point$$Double$$Double$$MetroGraphData$$BundlingSettings: function (r, a, b, c, widthAB, widthAC, metroGraphData, bundlingSettings){
            if (widthAB < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon || widthAC < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return r;
            var angle = Microsoft.Msagl.Core.Geometry.Point.Angle$$Point$$Point$$Point(b, a, c);
            angle = System.Math.Min$$Double$$Double(angle, 6.28318530717959 - angle);
            if (angle < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return 2 * bundlingSettings.MaxHubRadius;
            var L = r;
            var R = 2 * bundlingSettings.MaxHubRadius;
            while (System.Math.Abs$$Double(R - L) > 0.1){
                var C = (L + R) / 2;
                var alpha0 = System.Math.Asin(widthAB / (2 * C));
                var alpha1 = System.Math.Asin(widthAC / (2 * C));
                if (alpha0 + alpha1 <= angle)
                    R = C;
                else
                    L = C;
            }
            return L;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (metroGraphData, bundlingSettings){
            this.metroGraphData = null;
            this.bundlingSettings = null;
            System.Object.ctor.call(this);
            this.metroGraphData = metroGraphData;
            this.bundlingSettings = bundlingSettings;
        },
        CreateNodeRadii: function (){
            var $it486 = this.metroGraphData.VirtualNodes().GetEnumerator();
            while ($it486.MoveNext()){
                var v = $it486.get_Current();
                v.Radius = 0;
                v.cachedIdealRadius = Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.CalculateIdealHubRadiusWithNeighbors$$MetroGraphData$$BundlingSettings$$Station(this.metroGraphData, this.bundlingSettings, v);
            }
            this.GrowHubs(false);
            this.GrowHubs(true);
            var $it487 = this.metroGraphData.VirtualNodes().GetEnumerator();
            while ($it487.MoveNext()){
                var v = $it487.get_Current();
                v.Radius = System.Math.Max$$Double$$Double(v.Radius, this.bundlingSettings.MinHubRadius);
            }
        },
        GrowHubs: function (useHalfEdgesAsIdealR){
            var queue = new Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueue$1.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor);
            var $it488 = this.metroGraphData.VirtualNodes().GetEnumerator();
            while ($it488.MoveNext()){
                var v = $it488.get_Current();
                queue.Enqueue(v, -this.CalculatePotential(v, useHalfEdgesAsIdealR));
            }
            var progress = false;
            while (!queue.IsEmpty()){
                var hu;
                var v = (function (){
                    var $1 = {
                        Value: hu
                    };
                    var $res = queue.Dequeue$$Double($1);
                    hu = $1.Value;
                    return $res;
                }).call(this);
                if (hu >= 0)
                    break;
                if (this.TryGrowHub(v, useHalfEdgesAsIdealR)){
                    queue.Enqueue(v, -this.CalculatePotential(v, useHalfEdgesAsIdealR));
                    progress = true;
                }
            }
            return progress;
        },
        TryGrowHub: function (v, useHalfEdgesAsIdealR){
            var oldR = v.Radius;
            var allowedRadius = this.CalculateAllowedHubRadius(v);
            System.Diagnostics.Debug.Assert$$Boolean(allowedRadius > 0);
            if (v.Radius >= allowedRadius)
                return false;
            var idealR = useHalfEdgesAsIdealR ? Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.CalculateIdealHubRadiusWithAdjacentEdges(this.metroGraphData, this.bundlingSettings, v) : v.cachedIdealRadius;
            System.Diagnostics.Debug.Assert$$Boolean(idealR > 0);
            if (v.Radius >= idealR)
                return false;
            var step = 0.05;
            var delta = step * (idealR - v.Radius);
            if (delta < 1)
                delta = 1;
            var newR = System.Math.Min$$Double$$Double(v.Radius + delta, allowedRadius);
            if (newR <= v.Radius)
                return false;
            v.Radius = newR;
            return true;
        },
        CalculatePotential: function (v, useHalfEdgesAsIdealR){
            var idealR = useHalfEdgesAsIdealR ? Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.CalculateIdealHubRadiusWithAdjacentEdges(this.metroGraphData, this.bundlingSettings, v) : v.cachedIdealRadius;
            if (idealR <= v.Radius)
                return 0;
            return (idealR - v.Radius) / idealR;
        },
        Cost: function (){
            var cost = 0;
            var $it489 = this.metroGraphData.VirtualNodes().GetEnumerator();
            while ($it489.MoveNext()){
                var v = $it489.get_Current();
                var idealR = v.cachedIdealRadius;
                cost += Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.RError(idealR, v.Radius, this.bundlingSettings);
            }
            return cost;
        },
        CalculateAllowedHubRadius: function (node){
            var r = this.bundlingSettings.MaxHubRadius;
            for (var $i491 = 0,$t491 = node.Neighbors,$l491 = $t491.length,adj = $t491[$i491]; $i491 < $l491; $i491++, adj = $t491[$i491]){
                var dist = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(adj.Position, node.Position)).get_Length();
                System.Diagnostics.Debug.Assert$$Boolean(dist - 0.05 * (node.Radius + adj.Radius) + 1 >= node.Radius + adj.Radius);
                r = System.Math.Min$$Double$$Double(r, dist / 1.05 - adj.Radius);
            }
            var minimalDistance = this.metroGraphData.tightIntersections.GetMinimalDistanceToObstacles(node, node.Position, r);
            if (minimalDistance < r)
                r = minimalDistance - 0.001;
            return System.Math.Max$$Double$$Double(r, 0.1);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$HubRadiiCalculator);
var Microsoft$Msagl$Routing$Spline$Bundling$IMetroMapOrderingAlgorithm = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.IMetroMapOrderingAlgorithm",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Interface"
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$IMetroMapOrderingAlgorithm);
var Microsoft$Msagl$Routing$Spline$Bundling$CostCalculator = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.Inf = 1000000000;
        },
        InkError: function (oldInk, newInk, bundlingSettings){
            return (oldInk - newInk) * bundlingSettings.get_InkImportance();
        },
        PathLengthsError: function (oldLength, newLength, idealLength, bundlingSettings){
            return (oldLength - newLength) * (bundlingSettings.get_PathLengthImportance() / idealLength);
        },
        RError: function (idealR, nowR, bundlingSettings){
            if (idealR <= nowR)
                return 0;
            var res = bundlingSettings.get_HubRepulsionImportance() * (1 - nowR / idealR) * (idealR - nowR);
            return res;
        },
        BundleError: function (idealWidth, nowWidth, bundlingSettings){
            if (idealWidth <= nowWidth)
                return 0;
            var res = bundlingSettings.get_BundleRepulsionImportance() * (1 - nowWidth / idealWidth) * (idealWidth - nowWidth);
            return res;
        },
        Cost: function (metroGraphData, bundlingSettings){
            var cost = 0;
            cost += bundlingSettings.get_InkImportance() * metroGraphData.get_Ink();
            var $it493 = metroGraphData.get_Metrolines().GetEnumerator();
            while ($it493.MoveNext()){
                var metroline = $it493.get_Current();
                cost += bundlingSettings.get_PathLengthImportance() * metroline.get_Length() / metroline.get_IdealLength();
            }
            cost += Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.CostOfForces(metroGraphData, bundlingSettings);
            return cost;
        },
        CostOfForces: function (metroGraphData, bundlingSettings){
            var cost = 0;
            var $it494 = metroGraphData.VirtualNodes().GetEnumerator();
            while ($it494.MoveNext()){
                var v = $it494.get_Current();
                cost += v.cachedRadiusCost;
            }
            var $it495 = metroGraphData.VirtualEdges().GetEnumerator();
            while ($it495.MoveNext()){
                var edge = $it495.get_Current();
                var v = edge.get_Item1();
                var u = edge.get_Item2();
                cost += metroGraphData.GetIjInfo(v, u).cachedBundleCost;
            }
            return cost;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (metroGraphData, bundlingSettings){
            this.metroGraphData = null;
            this.bundlingSettings = null;
            System.Object.ctor.call(this);
            this.metroGraphData = metroGraphData;
            this.bundlingSettings = bundlingSettings;
        },
        QGain: function (node, newPosition){
            return this.InkGain(node, newPosition) + this.PathLengthsGain(node, newPosition);
        },
        InkGain: function (node, newPosition){
            var oldInk = this.metroGraphData.get_Ink();
            var newInk = this.metroGraphData.get_Ink();
            for (var $i497 = 0,$t497 = node.Neighbors,$l497 = $t497.length,adj = $t497[$i497]; $i497 < $l497; $i497++, adj = $t497[$i497]){
                var adjPosition = adj.Position;
                newInk -= (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(adjPosition, node.Position)).get_Length();
                newInk += (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(adjPosition, newPosition)).get_Length();
            }
            return Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.InkError(oldInk, newInk, this.bundlingSettings);
        },
        PathLengthsGain: function (node, newPosition){
            var gain = 0;
            var $it497 = this.metroGraphData.MetroNodeInfosOfNode(node).GetEnumerator();
            while ($it497.MoveNext()){
                var e = $it497.get_Current();
                var oldLength = e.get_Metroline().get_Length();
                var newLength = e.get_Metroline().get_Length();
                var prev = e.get_PolyPoint().get_Prev().get_Point();
                var next = e.get_PolyPoint().get_Next().get_Point();
                newLength += (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(next, newPosition)).get_Length() + (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(prev, newPosition)).get_Length() - (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(next, node.Position)).get_Length() - (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(prev, node.Position)).get_Length();
                gain += Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.PathLengthsError(oldLength, newLength, e.get_Metroline().get_IdealLength(), this.bundlingSettings);
            }
            return gain;
        },
        RadiusGain: function (node, newPosition){
            var gain = 0;
            gain += node.cachedRadiusCost;
            gain -= this.RadiusCost(node, newPosition);
            return gain;
        },
        RadiusCost: function (node, newPosition){
            var idealR;
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(node.Position, newPosition))
                idealR = node.cachedIdealRadius;
            else
                idealR = Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.CalculateIdealHubRadiusWithNeighbors$$MetroGraphData$$BundlingSettings$$Station$$Point(this.metroGraphData, this.bundlingSettings, node, newPosition);
            var touchedObstacles;
            if (!(function (){
                var $1 = {
                    Value: touchedObstacles
                };
                var $res = this.metroGraphData.looseIntersections.HubAvoidsObstacles$$Station$$Point$$Double$$List$1(node, newPosition, idealR, $1);
                touchedObstacles = $1.Value;
                return $res;
            }).call(this)){
                return 1000000000;
            }
            var cost = 0;
            var $it498 = touchedObstacles.GetEnumerator();
            while ($it498.MoveNext()){
                var d = $it498.get_Current();
                var dist = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(d.get_Item2(), newPosition)).get_Length();
                cost += Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.RError(idealR, dist, this.bundlingSettings);
            }
            return cost;
        },
        BundleGain: function (node, newPosition){
            var gain = 0;
            gain += node.cachedBundleCost;
            for (var $i500 = 0,$t500 = node.Neighbors,$l500 = $t500.length,adj = $t500[$i500]; $i500 < $l500; $i500++, adj = $t500[$i500]){
                var lgain = this.BundleCost(node, adj, newPosition);
                if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.GreaterOrEqual(lgain, 1000000000))
                    return -1000000000;
                gain -= lgain;
            }
            return gain;
        },
        BundleCost: function (node, adj, newPosition){
            var idealWidth = this.metroGraphData.GetWidth$$Station$$Station$$Double(node, adj, this.bundlingSettings.get_EdgeSeparation());
            var closestDist;
            var cost = 0;
            if (!(function (){
                var $1 = {
                    Value: closestDist
                };
                var $res = this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(node, adj, newPosition, adj.Position, idealWidth, $1);
                closestDist = $1.Value;
                return $res;
            }).call(this)){
                return 1000000000;
            }
            var $it500 = closestDist.GetEnumerator();
            while ($it500.MoveNext()){
                var pair = $it500.get_Current();
                var dist = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(pair.get_Item1(), pair.get_Item2())).get_Length();
                cost += Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.BundleError(idealWidth / 2, dist, this.bundlingSettings);
            }
            return cost;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$CostCalculator);
var Microsoft$Msagl$Routing$Spline$Bundling$IntersectionCache = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.IntersectionCache",
    baseTypeName: "System.Object",
    staticDefinition: {
        Test: function (pnt, t){
            return Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.PointIsInsideOfTriangle(pnt, t) ? Microsoft.Msagl.Core.Geometry.HitTestBehavior.Stop : Microsoft.Msagl.Core.Geometry.HitTestBehavior.Continue;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (metroGraphData, bundlingSettings, costCalculator, cdt){
            this.metroGraphData = null;
            this.bundlingSettings = null;
            this.costCalculator = null;
            this.cdt = null;
            System.Object.ctor.call(this);
            System.Diagnostics.Debug.Assert$$Boolean(cdt != null);
            this.metroGraphData = metroGraphData;
            this.bundlingSettings = bundlingSettings;
            this.costCalculator = costCalculator;
            this.cdt = cdt;
        },
        InitializeCostCache: function (){
            var $it501 = this.metroGraphData.VirtualNodes().GetEnumerator();
            while ($it501.MoveNext()){
                var v = $it501.get_Current();
                v.cachedIdealRadius = Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.CalculateIdealHubRadiusWithNeighbors$$MetroGraphData$$BundlingSettings$$Station(this.metroGraphData, this.bundlingSettings, v);
                v.cachedRadiusCost = this.costCalculator.RadiusCost(v, v.Position);
                v.cachedBundleCost = 0;
            }
            var $it502 = this.metroGraphData.VirtualEdges().GetEnumerator();
            while ($it502.MoveNext()){
                var edge = $it502.get_Current();
                var v = edge.get_Item1();
                var u = edge.get_Item2();
                var edgeInfo = this.metroGraphData.GetIjInfo(v, u);
                edgeInfo.cachedBundleCost = this.costCalculator.BundleCost(v, u, v.Position);
                v.cachedBundleCost += edgeInfo.cachedBundleCost;
                u.cachedBundleCost += edgeInfo.cachedBundleCost;
            }
        },
        UpdateCostCache: function (node){
            var cdtTree = this.cdt.GetCdtTree();
            node.CdtTriangle = cdtTree.FirstHitNode$$Point$$Func$3(node.Position, Microsoft.Msagl.Routing.Spline.Bundling.IntersectionCache.Test).get_UserData();
            node.cachedIdealRadius = Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.CalculateIdealHubRadiusWithNeighbors$$MetroGraphData$$BundlingSettings$$Station(this.metroGraphData, this.bundlingSettings, node);
            node.cachedRadiusCost = this.costCalculator.RadiusCost(node, node.Position);
            node.cachedBundleCost = 0;
            for (var $i504 = 0,$t504 = node.Neighbors,$l504 = $t504.length,adj = $t504[$i504]; $i504 < $l504; $i504++, adj = $t504[$i504]){
                if (!adj.IsRealNode){
                    adj.cachedIdealRadius = Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.CalculateIdealHubRadiusWithNeighbors$$MetroGraphData$$BundlingSettings$$Station(this.metroGraphData, this.bundlingSettings, adj);
                    adj.cachedRadiusCost = this.costCalculator.RadiusCost(adj, adj.Position);
                }
                var edgeInfo = this.metroGraphData.GetIjInfo(node, adj);
                adj.cachedBundleCost -= edgeInfo.cachedBundleCost;
                edgeInfo.cachedBundleCost = this.costCalculator.BundleCost(node, adj, node.Position);
                node.cachedBundleCost += edgeInfo.cachedBundleCost;
                adj.cachedBundleCost += edgeInfo.cachedBundleCost;
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$IntersectionCache);
var Microsoft$Msagl$Routing$Spline$Bundling$Intersections = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.Intersections",
    baseTypeName: "System.Object",
    staticDefinition: {
        IntersectCircleWithTree: function (node, center, radius, obstaclesToIgnore, touchedObstacles, minimalDistance){
            if (!node.get_Rectangle().Contains$$Point$$Double(center, radius))
                return true;
            if (node.get_UserData() == null){
                var res = Microsoft.Msagl.Routing.Spline.Bundling.Intersections.IntersectCircleWithTree(node.get_Left(), center, radius, obstaclesToIgnore, touchedObstacles, minimalDistance);
                if (!res)
                    return false;
                res = Microsoft.Msagl.Routing.Spline.Bundling.Intersections.IntersectCircleWithTree(node.get_Right(), center, radius, obstaclesToIgnore, touchedObstacles, minimalDistance);
                if (!res)
                    return false;
            }
            else {
                var obstacle = node.get_UserData();
                if (obstaclesToIgnore.Contains$$T(obstacle))
                    return true;
                var pl = Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(center, obstacle);
                if (pl != Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside)
                    return false;
                var touchPoint = obstacle.get_Item$$Double(obstacle.ClosestParameter(center));
                var dist = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(touchPoint, center)).get_Length();
                if (dist <= radius)
                    touchedObstacles.Add(new System.Tuple$2.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, obstacle, touchPoint));
                minimalDistance.Value = System.Math.Min$$Double$$Double(dist, minimalDistance.Value);
            }
            return true;
        },
        LineSegmentIntersectPolyline: function (start, end, poly){
            var segDirection = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(end, start);
            System.Diagnostics.Debug.Assert$$Boolean(segDirection.get_Length() > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon);
            var tStart = 0;
            var tEnd = 1;
            var $it504 = poly.get_PolylinePoints().GetEnumerator();
            while ($it504.MoveNext()){
                var p = $it504.get_Current();
                var prev = p.get_PrevOnPolyline();
                var e = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(prev.get_Point(), p.get_Point());
                var num = Microsoft.Msagl.Core.Geometry.Point.CrossProduct(e, Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(start, p.get_Point()));
                var den = -Microsoft.Msagl.Core.Geometry.Point.CrossProduct(e, segDirection);
                if (System.Math.Abs$$Double(den) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance()){
                    if (num < 0)
                        return false;
                    continue;
                }
                var t = num / den;
                if (den < 0){
                    tStart = System.Math.Max$$Double$$Double(tStart, t);
                    if (tStart > tEnd)
                        return false;
                }
                else {
                    tEnd = System.Math.Min$$Double$$Double(tEnd, t);
                    if (tStart > tEnd)
                        return false;
                }
            }
            return true;
        },
        Create4gon: function (apex, baseCenter, width1, width2){
            var norm = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(baseCenter, apex)).Normalize();
            norm = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(norm.get_Y(), -norm.get_X());
            return (function (){
                var $v76 = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor$$Point$Array([Microsoft.Msagl.Core.Geometry.Point.op_Addition(apex, Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(norm, width1), 2)), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(apex, Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(norm, width1), 2)), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(baseCenter, Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(norm, width2), 2)), Microsoft.Msagl.Core.Geometry.Point.op_Addition(baseCenter, Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(norm, width2), 2))]);
                $v76.set_Closed(true);
                return $v76;
            })();
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (metroGraphData, bundlingSettings, obstacleTree, obstaclesToIgnore){
            this.metroGraphData = null;
            this.bundlingSettings = null;
            this.obstaclesToIgnore = null;
            this._obstacleTree = null;
            System.Object.ctor.call(this);
            this.metroGraphData = metroGraphData;
            this.obstaclesToIgnore = obstaclesToIgnore;
            this.bundlingSettings = bundlingSettings;
            this.set_obstacleTree(obstacleTree);
        },
        obstacleTree$$: "Microsoft.Msagl.Core.Geometry.RectangleNode`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]",
        get_obstacleTree: function (){
            return this._obstacleTree;
        },
        set_obstacleTree: function (value){
            this._obstacleTree = value;
        },
        ObstaclesToIgnoreForHub: function (node){
            return (node != null ? this.obstaclesToIgnore(node) : new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor));
        },
        ObstaclesToIgnoreForBundle: function (node, adj){
            if (node != null && adj != null)
                return Microsoft.Msagl.Core.DataStructures.Set$1.op_Addition(this.obstaclesToIgnore(node), this.obstaclesToIgnore(adj));
            if (node == null && adj == null)
                return new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            if (node != null)
                return this.obstaclesToIgnore(node);
            else
                return this.obstaclesToIgnore(adj);
        },
        HubAvoidsObstacles$$Station$$Point$$Double$$List$1: function (node, center, upperBound, touchedObstacles){
            touchedObstacles.Value = new System.Collections.Generic.List$1.ctor(System.Tuple$2.ctor);
            var minimalDistance = upperBound;
            return (function (){
                var $1 = {
                    Value: minimalDistance
                };
                var $res = Microsoft.Msagl.Routing.Spline.Bundling.Intersections.IntersectCircleWithTree(this.get_obstacleTree(), center, upperBound, this.obstaclesToIgnore(node), touchedObstacles.Value, $1);
                minimalDistance = $1.Value;
                return $res;
            }).call(this);
        },
        HubAvoidsObstacles$$Point$$Double$$Set$1$Polyline: function (center, upperBound, obstaclesToIgnore){
            var touchedObstacles;
            var minimalDistance;
            return (function (){
                var $1 = {
                    Value: touchedObstacles
                };
                var $2 = {
                    Value: minimalDistance
                };
                var $res = this.HubAvoidsObstacles$$Point$$Double$$Set$1$Polyline$$List$1$$Double(center, upperBound, obstaclesToIgnore, $1, $2);
                touchedObstacles = $1.Value;
                minimalDistance = $2.Value;
                return $res;
            }).call(this);
        },
        GetMinimalDistanceToObstacles: function (node, nodePosition, upperBound){
            var touchedObstacles = new System.Collections.Generic.List$1.ctor(System.Tuple$2.ctor);
            var minimalDistance = upperBound;
            if (!(function (){
                var $1 = {
                    Value: minimalDistance
                };
                var $res = Microsoft.Msagl.Routing.Spline.Bundling.Intersections.IntersectCircleWithTree(this.get_obstacleTree(), nodePosition, upperBound, this.obstaclesToIgnore(node), touchedObstacles, $1);
                minimalDistance = $1.Value;
                return $res;
            }).call(this))
                return 0;
            return minimalDistance;
        },
        HubAvoidsObstacles$$Point$$Double$$Set$1$Polyline$$List$1$$Double: function (center, upperBound, obstaclesToIgnore, touchedObstacles, minimalDistance){
            touchedObstacles.Value = new System.Collections.Generic.List$1.ctor(System.Tuple$2.ctor);
            minimalDistance.Value = upperBound;
            return Microsoft.Msagl.Routing.Spline.Bundling.Intersections.IntersectCircleWithTree(this.get_obstacleTree(), center, upperBound, obstaclesToIgnore, touchedObstacles.Value, minimalDistance);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$Intersections);
var Microsoft$Msagl$Routing$Spline$Bundling$LinearMetroMapOrdering = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Routing.Spline.Bundling.IMetroMapOrderingAlgorithm"],
    Kind: "Class",
    definition: {
        ctor: function (MetrolinesGlobal, pointToIndex){
            this.MetrolinesGlobal = null;
            this.Metrolines = null;
            this.positions = null;
            this.order = null;
            this.lineIndexInOrder = null;
            this.nonTerminals = null;
            this.initialEdges = null;
            this.orderedAdjacent = null;
            this.adjacencyIndex = null;
            this.e2p = null;
            this.paths = null;
            System.Object.ctor.call(this);
            this.MetrolinesGlobal = MetrolinesGlobal;
            this.ConvertParameters(pointToIndex);
            this.BuildOrder();
        },
        ConvertParameters: function (pointToIndex){
            this.Metrolines = new System.Collections.Generic.List$1.ctor(Int32Array);
            this.positions = new Array(pointToIndex.get_Count());
            var $it505 = this.MetrolinesGlobal.GetEnumerator();
            while ($it505.MoveNext()){
                var gline = $it505.get_Current();
                var line = new System.Collections.Generic.List$1.ctor(System.Int32.ctor);
                var $it506 = gline.get_Polyline().GetEnumerator();
                while ($it506.MoveNext()){
                    var p = $it506.get_Current();
                    line.Add(pointToIndex.get_Item$$TKey(p).SerialNumber);
                    this.positions[pointToIndex.get_Item$$TKey(p).SerialNumber] = p;
                }
                this.Metrolines.Add(line.ToArray());
            }
        },
        BuildOrder: function (){
            this.Initialize();
            var $it507 = this.nonTerminals.GetEnumerator();
            while ($it507.MoveNext()){
                var v = $it507.get_Current();
                this.ProcessNonTerminal(v);
            }
            this.RestoreResult();
        },
        Initialize: function (){
            this.nonTerminals = new System.Collections.Generic.HashSet$1.ctor(System.Int32.ctor);
            this.initialEdges = new System.Collections.Generic.HashSet$1.ctor(Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.ctor);
            var adjacent = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, System.Collections.Generic.HashSet$1.ctor);
            for (var mi = 0; mi < this.Metrolines.get_Count(); mi++){
                var Metroline = this.Metrolines.get_Item$$Int32(mi);
                for (var i = 0; i + 1 < Metroline.length; i++){
                    var me = Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.CreateFromTwoNodes(Metroline[i], Metroline[i + 1]);
                    if (!this.initialEdges.Contains(me))
                        this.initialEdges.Add(me);
                    if (i + 2 < Metroline.length)
                        this.nonTerminals.Add(Metroline[i + 1]);
                    Microsoft.Msagl.Core.DataStructures.CollectionUtilities.AddToMap$3(Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.ctor, System.Int32.ctor, System.Collections.Generic.HashSet$1.ctor, adjacent, Metroline[i], me);
                    Microsoft.Msagl.Core.DataStructures.CollectionUtilities.AddToMap$3(Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.ctor, System.Int32.ctor, System.Collections.Generic.HashSet$1.ctor, adjacent, Metroline[i + 1], me);
                }
            }
            this.InitAdjacencyData(adjacent);
            this.InitPathData();
        },
        InitPathData: function (){
            this.paths = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, System.Collections.Generic.LinkedList$1.ctor);
            this.e2p = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.ctor, Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.PathList.ctor);
            for (var mi = 0; mi < this.Metrolines.get_Count(); mi++){
                var Metroline = this.Metrolines.get_Item$$Int32(mi);
                this.paths.Add(mi, new System.Collections.Generic.LinkedList$1.ctor(Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.ctor));
                for (var i = 0; i + 1 < Metroline.length; i++){
                    var me = Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.CreateFromTwoNodes(Metroline[i], Metroline[i + 1]);
                    if (!this.e2p.ContainsKey(me)){
                        var pl = new Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.PathList.ctor();
                        pl.edge = me;
                        pl.paths = new System.Collections.Generic.HashSet$1.ctor(Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.PathOnEdge.ctor);
                        this.e2p.Add(me, pl);
                    }
                    var pathOnEdge = new Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.PathOnEdge.ctor();
                    pathOnEdge.index = mi;
                    pathOnEdge.node = this.paths.get_Item$$TKey(mi).AddLast$$T(me);
                    this.e2p.get_Item$$TKey(me).paths.Add(pathOnEdge);
                }
            }
        },
        InitAdjacencyData: function (adjacent){
            this.orderedAdjacent = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, System.Collections.Generic.LinkedList$1.ctor);
            this.adjacencyIndex = new System.Collections.Generic.Dictionary$2.ctor(System.Tuple$2.ctor, System.Collections.Generic.LinkedListNode$1.ctor);
            var $it508 = adjacent.get_Keys().GetEnumerator();
            while ($it508.MoveNext()){
                var v = $it508.get_Current();
                var adj = new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.ctor, adjacent.get_Item$$TKey(v));
                this.orderedAdjacent.Add(v, this.SortAdjacentEdges(v, adj));
            }
        },
        SortAdjacentEdges: function (v, adjacent){
            var mn = System.Linq.Enumerable.First$1$$IEnumerable$1(Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.ctor, adjacent);
            var mnv = this.OppositeNode(mn, v);
            adjacent.Sort$$Comparison$1($CreateAnonymousDelegate(this, function (edge1, edge2){
                var a = this.OppositeNode(edge1, v);
                var b = this.OppositeNode(edge2, v);
                var angA = Microsoft.Msagl.Core.Geometry.Point.Angle$$Point$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.positions[a], this.positions[v]), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.positions[mnv], this.positions[v]));
                var angB = Microsoft.Msagl.Core.Geometry.Point.Angle$$Point$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.positions[b], this.positions[v]), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.positions[mnv], this.positions[v]));
                return angA.CompareTo$$Double(angB);
            }));
            var res = new System.Collections.Generic.LinkedList$1.ctor(Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.ctor);
            var $it509 = adjacent.GetEnumerator();
            while ($it509.MoveNext()){
                var edge = $it509.get_Current();
                var node = res.AddLast$$T(edge);
                this.adjacencyIndex.Add(new System.Tuple$2.ctor(System.Int32.ctor, Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.ctor, v, edge), node);
            }
            return res;
        },
        UpdateAdjacencyData: function (a, oldEdge, newSubList){
            var node = this.adjacencyIndex.get_Item$$TKey(new System.Tuple$2.ctor(System.Int32.ctor, Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.ctor, a, oldEdge));
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.op_Equality(node.get_Value(), oldEdge));
            var inode = node;
            var $it510 = newSubList.GetEnumerator();
            while ($it510.MoveNext()){
                var pl = $it510.get_Current();
                var newEdge = pl.edge;
                if (oldEdge.Source() == a)
                    node = node.get_List().AddAfter$$LinkedListNode$1$$T(node, newEdge);
                else
                    node = node.get_List().AddBefore$$LinkedListNode$1$$T(node, newEdge);
                this.adjacencyIndex.Add(new System.Tuple$2.ctor(System.Int32.ctor, Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.ctor, a, newEdge), node);
            }
            this.adjacencyIndex.Remove(new System.Tuple$2.ctor(System.Int32.ctor, Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.ctor, a, oldEdge));
            inode.get_List().Remove$$LinkedListNode$1(inode);
        },
        RestoreResult$$MetroEdge: function (edge){
            var res = new System.Collections.Generic.List$1.ctor(System.Int32.ctor);
            var pl = this.e2p.get_Item$$TKey(edge);
            if (pl.subLists == null){
                var $it511 = pl.paths.GetEnumerator();
                while ($it511.MoveNext()){
                    var path = $it511.get_Current();
                    res.Add(path.index);
                }
            }
            else {
                var $it512 = pl.subLists.GetEnumerator();
                while ($it512.MoveNext()){
                    var subList = $it512.get_Current();
                    var subResult = this.RestoreResult$$MetroEdge(subList.edge);
                    if (!(edge.Source() == subList.edge.Source() || edge.Target() == subList.edge.Target()))
                        subResult.Reverse();
                    res.AddRange(subResult);
                }
            }
            return res;
        },
        RestoreResult: function (){
            this.order = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.ctor, System.Collections.Generic.List$1.ctor);
            this.lineIndexInOrder = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.ctor, System.Collections.Generic.Dictionary$2.ctor);
            var $it513 = this.initialEdges.GetEnumerator();
            while ($it513.MoveNext()){
                var me = $it513.get_Current();
                this.order.Add(me, this.RestoreResult$$MetroEdge(me));
                var d = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Metroline.ctor, System.Int32.ctor);
                var index = 0;
                var $it514 = this.order.get_Item$$TKey(me).GetEnumerator();
                while ($it514.MoveNext()){
                    var v = $it514.get_Current();
                    d.set_Item$$TKey(this.MetrolinesGlobal.get_Item$$Int32(v), index++);
                }
                this.lineIndexInOrder.Add(me, d);
            }
        },
        ProcessNonTerminal: function (v){
            var newSubLists = this.RadixSort(v);
            var $it515 = this.orderedAdjacent.get_Item$$TKey(v).GetEnumerator();
            while ($it515.MoveNext()){
                var oldEdge = $it515.get_Current();
                System.Diagnostics.Debug.Assert$$Boolean(this.e2p.ContainsKey(oldEdge));
                var newSubList = newSubLists.get_Item$$TKey(oldEdge);
                this.e2p.get_Item$$TKey(oldEdge).paths = null;
                this.e2p.get_Item$$TKey(oldEdge).subLists = newSubList;
                this.UpdateAdjacencyData(this.OppositeNode(oldEdge, v), oldEdge, newSubList);
                var $it516 = newSubList.GetEnumerator();
                while ($it516.MoveNext()){
                    var pl = $it516.get_Current();
                    var newEdge = pl.edge;
                    if (this.e2p.ContainsKey(newEdge))
                        continue;
                    this.e2p.Add(newEdge, pl);
                    var $it517 = pl.paths.GetEnumerator();
                    while ($it517.MoveNext()){
                        var path = $it517.get_Current();
                        this.UpdatePath(path, v, newEdge);
                    }
                }
            }
        },
        RadixSort: function (v){
            var r = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.ctor, System.Collections.Generic.List$1.ctor);
            var firstIndex = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.ctor, System.Int32.ctor);
            var $it518 = this.orderedAdjacent.get_Item$$TKey(v).GetEnumerator();
            while ($it518.MoveNext()){
                var oldEdge = $it518.get_Current();
                var pathList = this.e2p.get_Item$$TKey(oldEdge);
                var $it519 = pathList.paths.GetEnumerator();
                while ($it519.MoveNext()){
                    var path = $it519.get_Current();
                    var ej = this.FindNextEdgeOnPath(v, path);
                    Microsoft.Msagl.Core.DataStructures.CollectionUtilities.AddToMap$3(Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.PathOnEdge.ctor, Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.ctor, System.Collections.Generic.List$1.ctor, r, ej, path);
                }
                firstIndex.Add(oldEdge, (r.ContainsKey(oldEdge) ? r.get_Item$$TKey(oldEdge).get_Count() : 0));
            }
            var res = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.ctor, System.Collections.Generic.List$1.ctor);
            var $it520 = this.orderedAdjacent.get_Item$$TKey(v).GetEnumerator();
            while ($it520.MoveNext()){
                var oldEdge = $it520.get_Current();
                var paths = r.get_Item$$TKey(oldEdge);
                System.Diagnostics.Debug.Assert$$Boolean(paths.get_Count() > 0);
                var subLists = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.PathList.ctor);
                var curPathSet = new System.Collections.Generic.HashSet$1.ctor(Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.PathOnEdge.ctor);
                for (var j = 0; j < paths.get_Count(); j++){
                    var i = (j + firstIndex.get_Item$$TKey(oldEdge)) % paths.get_Count();
                    var nowEdge = paths.get_Item$$Int32(i).node.get_Value();
                    var nextEdge = paths.get_Item$$Int32((i + 1) % paths.get_Count()).node.get_Value();
                    curPathSet.Add(paths.get_Item$$Int32(i));
                    if (j == paths.get_Count() - 1 || Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.op_Inequality(nowEdge, nextEdge)){
                        var newEdge = Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.CreateFromTwoEdges$$Int32$$MetroEdge$$MetroEdge(v, oldEdge, nowEdge);
                        var pl = new Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.PathList.ctor();
                        pl.edge = newEdge;
                        pl.paths = curPathSet;
                        subLists.Add(pl);
                        curPathSet = new System.Collections.Generic.HashSet$1.ctor(Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.PathOnEdge.ctor);
                    }
                }
                if (oldEdge.Source() == v)
                    subLists.Reverse();
                res.Add(oldEdge, subLists);
            }
            return res;
        },
        FindNextEdgeOnPath: function (v, pathOnEdge){
            if (pathOnEdge.node.get_Next() != null){
                var o = this.OppositeNode(pathOnEdge.node.get_Next().get_Value(), v);
                if (o != -1)
                    return pathOnEdge.node.get_Next().get_Value();
            }
            if (pathOnEdge.node.get_Previous() != null){
                var o = this.OppositeNode(pathOnEdge.node.get_Previous().get_Value(), v);
                if (o != -1)
                    return pathOnEdge.node.get_Previous().get_Value();
            }
            throw $CreateException(new System.NotSupportedException.ctor(), new Error());
        },
        OppositeNode: function (edge, v){
            if (edge.Source() == v)
                return edge.Target();
            if (edge.Target() == v)
                return edge.Source();
            return -1;
        },
        UpdatePath: function (pathOnEdge, v, newEdge){
            var f = pathOnEdge.node;
            System.Diagnostics.Debug.Assert$$Boolean(f.get_Value().Source() == v || f.get_Value().Target() == v);
            var a,b;
            a = this.OppositeNode(f.get_Value(), v);
            if (f.get_Next() != null && (b = this.OppositeNode(f.get_Next().get_Value(), v)) != -1){
                System.Diagnostics.Debug.Assert$$Boolean((a == newEdge.Source() || a == newEdge.Target()));
                System.Diagnostics.Debug.Assert$$Boolean((b == newEdge.Source() || b == newEdge.Target()));
                f.set_Value(newEdge);
                f.get_List().Remove$$LinkedListNode$1(f.get_Next());
            }
            else if (f.get_Previous() != null && (b = this.OppositeNode(f.get_Previous().get_Value(), v)) != -1){
                System.Diagnostics.Debug.Assert$$Boolean((a == newEdge.Source() || a == newEdge.Target()));
                System.Diagnostics.Debug.Assert$$Boolean((b == newEdge.Source() || b == newEdge.Target()));
                f.set_Value(newEdge);
                f.get_List().Remove$$LinkedListNode$1(f.get_Previous());
            }
            else
                throw $CreateException(new System.NotSupportedException.ctor(), new Error());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$LinearMetroMapOrdering);
var Microsoft$Msagl$Routing$Spline$Bundling$LinearMetroMapOrdering$MetroEdge = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge",
    baseTypeName: "System.Object",
    staticDefinition: {
        CreateFromTwoNodes: function (u, v){
            var res = new Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.ctor();
            res.nodes = new System.Collections.Generic.List$1.ctor(System.Int32.ctor);
            res.nodes.Add(System.Math.Min$$Int32$$Int32(u, v));
            res.nodes.Add(System.Math.Max$$Int32$$Int32(u, v));
            res.UpdateHashKey();
            return res;
        },
        CreateFromTwoEdges$$Int32$$MetroEdge$$MetroEdge: function (v, e1, e2){
            var s = e1.Source() == v ? e1.Target() : e1.Source();
            var t = e2.Source() == v ? e2.Target() : e2.Source();
            if (s < t)
                return Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.CreateFromTwoEdges$$Int32$$List$1$Int32$$List$1$Int32(v, e1.nodes, e2.nodes);
            else
                return Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.CreateFromTwoEdges$$Int32$$List$1$Int32$$List$1$Int32(v, e2.nodes, e1.nodes);
        },
        CreateFromTwoEdges$$Int32$$List$1$Int32$$List$1$Int32: function (v, e1, e2){
            var nodes = new System.Collections.Generic.List$1.ctor$$Int32(System.Int32.ctor, e1.get_Count() + e2.get_Count() - 1);
            if (e1.get_Item$$Int32(0) != v){
                for (var i = 0; i < e1.get_Count(); i++)
                    nodes.Add(e1.get_Item$$Int32(i));
            }
            else {
                for (var i = e1.get_Count() - 1; i >= 0; i--)
                    nodes.Add(e1.get_Item$$Int32(i));
            }
            if (e2.get_Item$$Int32(0) == v){
                for (var i = 1; i < e2.get_Count(); i++)
                    nodes.Add(e2.get_Item$$Int32(i));
            }
            else {
                for (var i = e2.get_Count() - 2; i >= 0; i--)
                    nodes.Add(e2.get_Item$$Int32(i));
            }
            var res = new Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.ctor();
            res.nodes = nodes;
            res.UpdateHashKey();
            return res;
        },
        op_Equality: function (pair0, pair1){
            if (pair0.GetHashCode() != pair1.GetHashCode())
                return false;
            return true;
        },
        op_Inequality: function (pair0, pair1){
            return !(Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.op_Equality(pair0, pair1));
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.nodes = null;
            this.label = 0;
            this.labelCached = false;
            this._hashKey = null;
            System.Object.ctor.call(this);
        },
        Source: function (){
            return this.nodes.get_Item$$Int32(0);
        },
        Target: function (){
            return this.nodes.get_Item$$Int32(this.nodes.get_Count() - 1);
        },
        toString: function (){
            var s = "(";
            var $it521 = this.nodes.GetEnumerator();
            while ($it521.MoveNext()){
                var i = $it521.get_Current();
                s += i + " ";
            }
            s += ")";
            return s;
        },
        UpdateHashKey: function (){
            this._hashKey = this.GetHashCode().toString();
        },
        GetHashCode: function (){
            if (!this.labelCached){
                var hc = (this.nodes.get_Count()) | 0;
                for (var i = 0; i < this.nodes.get_Count(); i++){
                    hc = hc * 314159 + (this.nodes.get_Item$$Int32(i)) | 0;
                }
                this.label = hc | 0;
                this.labelCached = true;
            }
            return this.label;
        },
        Equals$$Object: function (obj){
            if (!(Is(obj, Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.ctor)))
                return false;
            return Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.op_Equality(Cast(obj, Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.ctor), this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$LinearMetroMapOrdering$MetroEdge);
var Microsoft$Msagl$Routing$Spline$Bundling$LinearMetroMapOrdering$PathList = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.PathList",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.edge = null;
            this.paths = null;
            this.subLists = null;
            System.Object.ctor.call(this);
        },
        toString: function (){
            return this.edge.toString() + " (" + this.paths.get_Count() + ")";
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$LinearMetroMapOrdering$PathList);
var Microsoft$Msagl$Routing$Spline$Bundling$LinearMetroMapOrdering$PathOnEdge = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.PathOnEdge",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.index = 0;
            this.node = null;
            System.Object.ctor.call(this);
        },
        toString: function (){
            var s = "(index = " + this.index + ")";
            return s;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$LinearMetroMapOrdering$PathOnEdge);
var Microsoft$Msagl$Routing$Spline$Bundling$MetroGraphData = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (regularEdges, looseTree, tightTree, bundlingSettings, cdt, edgeLooseEnterable, edgeTightEnterable, loosePolylineOfPort){
            this.Stations = null;
            this.edgeInfoDictionary = null;
            this.ink = 0;
            this.metrolines = null;
            this.PointToStations = null;
            this.regularEdges = null;
            this.looseIntersections = null;
            this.tightIntersections = null;
            this.cdtIntersections = null;
            this.LoosePolylineOfPort = null;
            this.Cdt = null;
            this.cachedEnterableLooseForEnd = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.DataStructures.Set$1.ctor);
            this._EdgeLooseEnterable = null;
            this._EdgeTightEnterable = null;
            System.Object.ctor.call(this);
            this.regularEdges = regularEdges;
            if (cdt != null)
                this.Cdt = cdt;
            else
                this.Cdt = Microsoft.Msagl.Routing.Spline.Bundling.BundleRouter.CreateConstrainedDelaunayTriangulation(looseTree);
            this.set_EdgeLooseEnterable(edgeLooseEnterable);
            this.set_EdgeTightEnterable(edgeTightEnterable);
            this.LoosePolylineOfPort = loosePolylineOfPort;
            this.looseIntersections = new Microsoft.Msagl.Routing.Spline.Bundling.Intersections.ctor(this, bundlingSettings, looseTree, $CreateAnonymousDelegate(this, function (station){
                return station.EnterableLoosePolylines;
            }));
            this.tightIntersections = new Microsoft.Msagl.Routing.Spline.Bundling.Intersections.ctor(this, bundlingSettings, tightTree, $CreateAnonymousDelegate(this, function (station){
                return station.EnterableTightPolylines;
            }));
            this.cdtIntersections = new Microsoft.Msagl.Routing.Spline.Bundling.CdtIntersections.ctor(this, bundlingSettings);
            this.Initialize$$Boolean(false);
        },
        EdgeLooseEnterable$$: "System.Collections.Generic.Dictionary`2[[Microsoft.Msagl.Core.Layout.EdgeGeometry],[Microsoft.Msagl.Core.DataStructures.Set`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]]]",
        get_EdgeLooseEnterable: function (){
            return this._EdgeLooseEnterable;
        },
        set_EdgeLooseEnterable: function (value){
            this._EdgeLooseEnterable = value;
        },
        EdgeTightEnterable$$: "System.Collections.Generic.Dictionary`2[[Microsoft.Msagl.Core.Layout.EdgeGeometry],[Microsoft.Msagl.Core.DataStructures.Set`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]]]",
        get_EdgeTightEnterable: function (){
            return this._EdgeTightEnterable;
        },
        set_EdgeTightEnterable: function (value){
            this._EdgeTightEnterable = value;
        },
        Ink$$: "System.Double",
        get_Ink: function (){
            return this.ink;
        },
        Edges$$: "Microsoft.Msagl.Core.Layout.EdgeGeometry[]",
        get_Edges: function (){
            return this.regularEdges;
        },
        VirtualNodes: function (){
            return System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, this.Stations, $CreateAnonymousDelegate(this, function (s){
                return !s.IsRealNode;
            }));
        },
        Metrolines$$: "System.Collections.Generic.List`1[[Microsoft.Msagl.Routing.Spline.Bundling.Metroline]]",
        get_Metrolines: function (){
            return this.metrolines;
        },
        LooseTree$$: "Microsoft.Msagl.Core.Geometry.RectangleNode`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]",
        get_LooseTree: function (){
            return this.looseIntersections.get_obstacleTree();
        },
        TightTree$$: "Microsoft.Msagl.Core.Geometry.RectangleNode`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]",
        get_TightTree: function (){
            return this.tightIntersections.get_obstacleTree();
        },
        VirtualEdges: function (){
            return this.edgeInfoDictionary.get_Keys();
        },
        RealEdgeCount$$Station: function (node){
            return node.MetroNodeInfos.get_Count();
        },
        RealEdgeCount$$Station$$Station: function (u, v){
            var couple = Microsoft.Msagl.Routing.Spline.Bundling.Station.op_LessThan(u, v) ? new System.Tuple$2.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, u, v) : new System.Tuple$2.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, v, u);
            var cw;
            if ((function (){
                var $1 = {
                    Value: cw
                };
                var $res = this.edgeInfoDictionary.TryGetValue(couple, $1);
                cw = $1.Value;
                return $res;
            }).call(this))
                return cw.Count;
            return 0;
        },
        MetroNodeInfosOfNode: function (node){
            return node.MetroNodeInfos;
        },
        GetIjInfo: function (u, v){
            var couple = Microsoft.Msagl.Routing.Spline.Bundling.Station.op_LessThan(u, v) ? new System.Tuple$2.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, u, v) : new System.Tuple$2.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, v, u);
            return this.edgeInfoDictionary.get_Item$$TKey(couple);
        },
        MoveNode: function (node, newPosition){
            var oldPosition = node.Position;
            this.PointToStations.Remove(oldPosition);
            this.PointToStations.Add(newPosition, node);
            node.Position = newPosition;
            var $it522 = this.MetroNodeInfosOfNode(node).GetEnumerator();
            while ($it522.MoveNext()){
                var metroNodeInfo = $it522.get_Current();
                metroNodeInfo.get_PolyPoint().set_Point(newPosition);
            }
            var $it523 = this.MetroNodeInfosOfNode(node).GetEnumerator();
            while ($it523.MoveNext()){
                var e = $it523.get_Current();
                var metroLine = e.get_Metroline();
                var prev = e.get_PolyPoint().get_Prev().get_Point();
                var succ = e.get_PolyPoint().get_Next().get_Point();
                metroLine.set_Length(metroLine.get_Length() + (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(succ, newPosition)).get_Length() + (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(prev, newPosition)).get_Length() - (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(succ, oldPosition)).get_Length() - (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(prev, oldPosition)).get_Length());
            }
            for (var $i525 = 0,$t525 = node.Neighbors,$l525 = $t525.length,adj = $t525[$i525]; $i525 < $l525; $i525++, adj = $t525[$i525]){
                this.ink += (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(newPosition, adj.Position)).get_Length() - (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(oldPosition, adj.Position)).get_Length();
            }
            this.SortNeighbors$$Station(node);
            for (var $i526 = 0,$t526 = node.Neighbors,$l526 = $t526.length,adj = $t526[$i526]; $i526 < $l526; $i526++, adj = $t526[$i526])
                this.SortNeighbors$$Station(adj);
        },
        GetWidth$$Station$$Station$$Double: function (u, v, edgeSeparation){
            var couple = Microsoft.Msagl.Routing.Spline.Bundling.Station.op_LessThan(u, v) ? new System.Tuple$2.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, u, v) : new System.Tuple$2.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, v, u);
            var cw;
            if ((function (){
                var $1 = {
                    Value: cw
                };
                var $res = this.edgeInfoDictionary.TryGetValue(couple, $1);
                cw = $1.Value;
                return $res;
            }).call(this))
                return cw.Width + (cw.Count - 1) * edgeSeparation;
            return 0;
        },
        GetWidth$$IEnumerable$1$Metroline$$Double: function (metrolines, edgeSeparation){
            var width = 0;
            var $it526 = metrolines.GetEnumerator();
            while ($it526.MoveNext()){
                var metroline = $it526.get_Current();
                width += metroline.Width;
            }
            var count = System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Routing.Spline.Bundling.Metroline.ctor, metrolines);
            width += count > 0 ? (count - 1) * edgeSeparation : 0;
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.ApproximateComparer.GreaterOrEqual(width, 0));
            return width;
        },
        Initialize: function (){
            this.Initialize$$Boolean(true);
        },
        Initialize$$Boolean: function (initTightTree){
            this.SimplifyRegularEdges();
            this.InitializeNodeData();
            this.InitializeEdgeData();
            this.InitializeVirtualGraph();
            this.InitializeEdgeNodeInfo(initTightTree);
            this.InitializeCdtInfo();
        },
        SimplifyRegularEdges: function (){
            for (var $i528 = 0,$t528 = this.regularEdges,$l528 = $t528.length,edge = $t528[$i528]; $i528 < $l528; $i528++, edge = $t528[$i528])
                this.SimplifyRegularEdge(edge);
        },
        SimplifyRegularEdge: function (edge){
            var polyline = Cast(edge.get_Curve(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            var stack = new System.Collections.Generic.Stack$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            var seen = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            for (var p = polyline.get_EndPoint(); p != null; p = p.get_Prev()){
                var v = p.get_Point();
                if (seen.Contains$$T(p.get_Point())){
                    var pp = p.get_Next();
                    do{
                        var u = stack.Peek();
                        if (Microsoft.Msagl.Core.Geometry.Point.op_Inequality(u, v)){
                            seen.Remove(u);
                            stack.Pop();
                            pp = pp.get_Next();
                        }
                        else
                            break;
                    }
                    while (true)
                    pp.set_Prev(p.get_Prev());
                    pp.get_Prev().set_Next(pp);
                }
                else {
                    stack.Push(v);
                    seen.Insert(v);
                }
            }
        },
        InitializeNodeData: function (){
            this.Stations = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor);
            this.PointToStations = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor);
            var i = 0;
            for (var $i529 = 0,$t529 = this.regularEdges,$l529 = $t529.length,edge = $t529[$i529]; $i529 < $l529; $i529++, edge = $t529[$i529]){
                var poly = Cast(edge.get_Curve(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
                i = this.ProcessPolylinePoints(i, poly);
            }
        },
        ProcessPolylinePoints: function (i, poly){
            var pp = poly.get_StartPoint();
            i = this.RegisterStation(i, pp, true);
            for (pp = pp.get_Next(); pp != poly.get_EndPoint(); pp = pp.get_Next())
                i = this.RegisterStation(i, pp, false);
            i = this.RegisterStation(i, pp, true);
            return i;
        },
        RegisterStation: function (i, pp, isRealNode){
            if (!this.PointToStations.ContainsKey(pp.get_Point())){
                var station;
                this.PointToStations.set_Item$$TKey(pp.get_Point(), station = new Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor(i++, isRealNode, pp.get_Point()));
                this.Stations.Insert(station);
            }
            else {
            }
            return i;
        },
        InitializeEdgeData: function (){
            this.metrolines = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Metroline.ctor);
            for (var i = 0; i < this.regularEdges.length; i++){
                var geomEdge = this.regularEdges[i];
                this.InitEdgeData(geomEdge, i);
            }
        },
        InitEdgeData: function (geomEdge, index){
            var metroEdge = new Microsoft.Msagl.Routing.Spline.Bundling.Metroline.ctor(Cast(geomEdge.get_Curve(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor), geomEdge.get_LineWidth(), this.EdgeSourceAndTargetFunc(geomEdge), index);
            this.metrolines.Add(metroEdge);
            this.PointToStations.get_Item$$TKey(metroEdge.get_Polyline().get_Start()).BoundaryCurve = geomEdge.get_SourcePort().get_Curve();
            this.PointToStations.get_Item$$TKey(metroEdge.get_Polyline().get_End()).BoundaryCurve = geomEdge.get_TargetPort().get_Curve();
        },
        EdgeSourceAndTargetFunc: function (geomEdge){
            return $CreateAnonymousDelegate(this, function (){
                return new System.Tuple$2.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, this.LoosePolylineOfPort(geomEdge.get_SourcePort()), this.LoosePolylineOfPort(geomEdge.get_TargetPort()));
            });
        },
        InitializeVirtualGraph: function (){
            var neighbors = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, Microsoft.Msagl.Core.DataStructures.Set$1.ctor);
            var $it529 = this.metrolines.GetEnumerator();
            while ($it529.MoveNext()){
                var metroline = $it529.get_Current();
                var u = this.PointToStations.get_Item$$TKey(metroline.get_Polyline().get_Start());
                var v;
                for (var p = metroline.get_Polyline().get_StartPoint(); p.get_Next() != null; p = p.get_Next(), u = v){
                    v = this.PointToStations.get_Item$$TKey(p.get_Next().get_Point());
                    Microsoft.Msagl.Core.DataStructures.CollectionUtilities.AddToMap$3(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, Microsoft.Msagl.Core.DataStructures.Set$1.ctor, neighbors, u, v);
                    Microsoft.Msagl.Core.DataStructures.CollectionUtilities.AddToMap$3(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, Microsoft.Msagl.Core.DataStructures.Set$1.ctor, neighbors, v, u);
                }
            }
            var $it530 = this.Stations.GetEnumerator();
            while ($it530.MoveNext()){
                var s = $it530.get_Current();
                s.Neighbors = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, neighbors.get_Item$$TKey(s));
            }
        },
        GetUnorderedIjInfo: function (i, j){
            System.Diagnostics.Debug.Assert$$Boolean(i != j);
            return (Microsoft.Msagl.Routing.Spline.Bundling.Station.op_LessThan(i, j) ? this.GetOrderedIjInfo(i, j) : this.GetOrderedIjInfo(j, i));
        },
        GetOrderedIjInfo: function (i, j){
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Routing.Spline.Bundling.Station.op_LessThan(i, j));
            var couple = new System.Tuple$2.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, i, j);
            var cw;
            if ((function (){
                var $1 = {
                    Value: cw
                };
                var $res = this.edgeInfoDictionary.TryGetValue(couple, $1);
                cw = $1.Value;
                return $res;
            }).call(this))
                return cw;
            this.edgeInfoDictionary.set_Item$$TKey(couple, cw = new Microsoft.Msagl.Routing.Spline.Bundling.StationEdgeInfo.ctor(i.Position, j.Position));
            return cw;
        },
        InitializeEdgeNodeInfo: function (initTightTree){
            this.edgeInfoDictionary = new System.Collections.Generic.Dictionary$2.ctor(System.Tuple$2.ctor, Microsoft.Msagl.Routing.Spline.Bundling.StationEdgeInfo.ctor);
            this.InitMetroNodeInfos$$Boolean(initTightTree);
            this.SortNeighbors();
            this.InitEdgeIjInfos();
            this.ink = 0;
            var $it531 = this.VirtualEdges().GetEnumerator();
            while ($it531.MoveNext()){
                var edge = $it531.get_Current();
                this.ink += (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(edge.get_Item1().Position, edge.get_Item2().Position)).get_Length();
            }
        },
        InitMetroNodeInfos$$Boolean: function (initTightTree){
            for (var i = 0; i < this.metrolines.get_Count(); i++){
                var metroline = this.metrolines.get_Item$$Int32(i);
                this.InitMetroNodeInfos$$Metroline(metroline);
                this.InitNodeEnterableLoosePolylines(metroline, this.regularEdges[i]);
                if (initTightTree)
                    this.InitNodeEnterableTightPolylines(metroline, this.regularEdges[i]);
                metroline.UpdateLengths();
            }
        },
        InitMetroNodeInfos$$Metroline: function (metroline){
            for (var pp = metroline.get_Polyline().get_StartPoint(); pp != null; pp = pp.get_Next()){
                var station = this.PointToStations.get_Item$$TKey(pp.get_Point());
                station.MetroNodeInfos.Add(new Microsoft.Msagl.Routing.Spline.Bundling.MetroNodeInfo.ctor(metroline, station, pp));
            }
        },
        InitNodeEnterableLoosePolylines: function (metroline, regularEdge){
            var metrolineEnterable = this.get_EdgeLooseEnterable() != null ? this.get_EdgeLooseEnterable().get_Item$$TKey(regularEdge) : new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            for (var p = metroline.get_Polyline().get_StartPoint().get_Next(); p != null && p.get_Next() != null; p = p.get_Next()){
                var v = this.PointToStations.get_Item$$TKey(p.get_Point());
                if (Microsoft.Msagl.Core.DataStructures.Set$1.op_Inequality(v.EnterableLoosePolylines, null))
                    v.EnterableLoosePolylines = Microsoft.Msagl.Core.DataStructures.Set$1.op_Multiply(v.EnterableLoosePolylines, metrolineEnterable);
                else
                    v.EnterableLoosePolylines = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, metrolineEnterable);
            }
            this.AddLooseEnterableForMetrolineStartEndPoints(metroline);
        },
        AddLooseEnterableForMetrolineStartEndPoints: function (metroline){
            this.AddLooseEnterableForEnd(metroline.get_Polyline().get_Start());
            this.AddLooseEnterableForEnd(metroline.get_Polyline().get_End());
        },
        AddTightEnterableForMetrolineStartEndPoints: function (metroline){
            this.AddTightEnterableForEnd(metroline.get_Polyline().get_Start());
            this.AddTightEnterableForEnd(metroline.get_Polyline().get_End());
        },
        AddLooseEnterableForEnd: function (point){
            var station = this.PointToStations.get_Item$$TKey(point);
            if (!this.cachedEnterableLooseForEnd.ContainsKey(point)){
                var $it532 = this.get_LooseTree().AllHitItems$$Point(point).GetEnumerator();
                while ($it532.MoveNext()){
                    var poly = $it532.get_Current();
                    if (Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(point, poly) == Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Inside)
                        station.AddEnterableLoosePolyline(poly);
                }
                this.cachedEnterableLooseForEnd.Add(point, station.EnterableLoosePolylines);
            }
            else {
                station.EnterableLoosePolylines = this.cachedEnterableLooseForEnd.get_Item$$TKey(point);
            }
        },
        AddTightEnterableForEnd: function (point){
            var station = this.PointToStations.get_Item$$TKey(point);
            var $it533 = this.get_TightTree().AllHitItems$$Point(point).GetEnumerator();
            while ($it533.MoveNext()){
                var poly = $it533.get_Current();
                if (Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(point, poly) == Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Inside)
                    station.AddEnterableTightPolyline(poly);
            }
        },
        InitNodeEnterableTightPolylines: function (metroline, regularEdge){
            var metrolineEnterable = this.get_EdgeTightEnterable() != null ? this.get_EdgeTightEnterable().get_Item$$TKey(regularEdge) : new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            for (var p = metroline.get_Polyline().get_StartPoint().get_Next(); p != null && p.get_Next() != null; p = p.get_Next()){
                var v = this.PointToStations.get_Item$$TKey(p.get_Point());
                var nodeEnterable = v.EnterableTightPolylines;
                if (Microsoft.Msagl.Core.DataStructures.Set$1.op_Inequality(nodeEnterable, null))
                    v.EnterableTightPolylines = Microsoft.Msagl.Core.DataStructures.Set$1.op_Multiply(nodeEnterable, metrolineEnterable);
                else
                    v.EnterableTightPolylines = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, metrolineEnterable);
            }
            this.AddTightEnterableForMetrolineStartEndPoints(metroline);
        },
        SortNeighbors: function (){
            var $it534 = this.Stations.GetEnumerator();
            while ($it534.MoveNext()){
                var station = $it534.get_Current();
                this.SortNeighbors$$Station(station);
            }
        },
        SortNeighbors$$Station: function (station){
            if (station.Neighbors.length <= 2)
                return;
            var pivot = station.Neighbors[0].Position;
            var center = station.Position;
            System.Array.Sort$1$$T$Array$$Comparison$1(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, station.Neighbors, $CreateAnonymousDelegate(this, function (u, v){
                return Microsoft.Msagl.Core.Geometry.Point.GetOrientationOf3Vectors(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(pivot, center), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(u.Position, center), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v.Position, center));
            }));
        },
        InitEdgeIjInfos: function (){
            var $it535 = this.metrolines.GetEnumerator();
            while ($it535.MoveNext()){
                var metroLine = $it535.get_Current();
                var poly = metroLine.get_Polyline();
                var u = this.PointToStations.get_Item$$TKey(poly.get_Start());
                var v;
                for (var p = metroLine.get_Polyline().get_StartPoint(); p.get_Next() != null; p = p.get_Next(), u = v){
                    v = this.PointToStations.get_Item$$TKey(p.get_Next().get_Point());
                    var info = this.GetUnorderedIjInfo(u, v);
                    info.Count++;
                    info.Width += metroLine.Width;
                    info.Metrolines.Add(metroLine);
                }
            }
        },
        InitializeCdtInfo: function (){
            var cdtTree = this.Cdt.GetCdtTree();
            var $it536 = this.Stations.GetEnumerator();
            while ($it536.MoveNext()){
                var station = $it536.get_Current();
                station.CdtTriangle = cdtTree.FirstHitNode$$Point$$Func$3(station.Position, Microsoft.Msagl.Routing.Spline.Bundling.IntersectionCache.Test).get_UserData();
                System.Diagnostics.Debug.Assert$$Boolean(station.CdtTriangle != null);
            }
        },
        PointIsAcceptableForEdge: function (metroline, point){
            if (this.LoosePolylineOfPort == null)
                return true;
            var polys = metroline.sourceAndTargetLoosePolylines();
            return Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(point, polys.get_Item1()) == Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside && Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(point, polys.get_Item2()) == Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$MetroGraphData);
var Microsoft$Msagl$Routing$Spline$Bundling$Metroline = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.Metroline",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (polyline, width, sourceAndTargetLoosePolys, index){
            this.Width = 0;
            this.sourceAndTargetLoosePolylines = null;
            this._Length = 0;
            this._IdealLength = 0;
            this._Polyline = null;
            this._Index = 0;
            System.Object.ctor.call(this);
            this.Width = width;
            this.set_Polyline(polyline);
            this.sourceAndTargetLoosePolylines = sourceAndTargetLoosePolys;
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this.get_Polyline().get_Count();
        },
        Length$$: "System.Double",
        get_Length: function (){
            return this._Length;
        },
        set_Length: function (value){
            this._Length = value;
        },
        IdealLength$$: "System.Double",
        get_IdealLength: function (){
            return this._IdealLength;
        },
        set_IdealLength: function (value){
            this._IdealLength = value;
        },
        Polyline$$: "Microsoft.Msagl.Core.Geometry.Curves.Polyline",
        get_Polyline: function (){
            return this._Polyline;
        },
        set_Polyline: function (value){
            this._Polyline = value;
        },
        Index$$: "System.Int32",
        get_Index: function (){
            return this._Index;
        },
        set_Index: function (value){
            this._Index = value;
        },
        UpdateLengths: function (){
            var l = 0;
            for (var p = this.get_Polyline().get_StartPoint(); p.get_Next() != null; p = p.get_Next()){
                l += (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(p.get_Next().get_Point(), p.get_Point())).get_Length();
            }
            this.set_Length(l);
            this.set_IdealLength((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.get_Polyline().get_End(), this.get_Polyline().get_Start())).get_Length());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$Metroline);
var Microsoft$Msagl$Routing$Spline$Bundling$MetroNodeInfo = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.MetroNodeInfo",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (metroline, station, polyPoint){
            this.metroline = null;
            this.station = null;
            this.polyPoint = null;
            System.Object.ctor.call(this);
            this.metroline = metroline;
            this.station = station;
            this.polyPoint = polyPoint;
        },
        Metroline$$: "Microsoft.Msagl.Routing.Spline.Bundling.Metroline",
        get_Metroline: function (){
            return this.metroline;
        },
        PolyPoint$$: "Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint",
        get_PolyPoint: function (){
            return this.polyPoint;
        },
        Station$$: "Microsoft.Msagl.Routing.Spline.Bundling.Station",
        get_Station: function (){
            return this.station;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$MetroNodeInfo);
var Microsoft$Msagl$Routing$Spline$Bundling$NodePositionsAdjuster = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.NodePositionsAdjuster",
    baseTypeName: "System.Object",
    staticDefinition: {
        FixRouting: function (metroGraphData, bundlingSettings){
            var adjuster = new Microsoft.Msagl.Routing.Spline.Bundling.NodePositionsAdjuster.ctor(metroGraphData, bundlingSettings);
            adjuster.GlueConflictingNodes();
            adjuster.UnglueEdgesFromBundleToSaveInk(true);
            var step = 0;
            var MaxSteps = 10;
            while (++step < MaxSteps){
                var progress = adjuster.GlueConflictingNodes();
                progress |= adjuster.RelaxConstrainedEdges();
                progress |= (step <= 3 && adjuster.UnglueEdgesFromBundleToSaveInk(false));
                progress |= adjuster.GlueCollinearNeighbors$$Int32(step);
                progress |= (step == 3 && adjuster.RemoveDoublePathCrossings());
                if (!progress)
                    break;
            }
            metroGraphData.cdtIntersections.ComputeForcesForBundles = true;
            adjuster.RemoveDoublePathCrossings();
            adjuster.UnglueEdgesFromBundleToSaveInk(true);
            while (adjuster.GlueConflictingNodes()){
            }
            metroGraphData.Initialize$$Boolean(true);
        },
        GluedPolyline: function (metroline, gluedMap){
            var i;
            var ret = new System.Collections.Generic.Stack$1.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor);
            ret.Push(metroline[0]);
            var seenStations = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor);
            for (i = 1; i < metroline.length - 1; i++){
                var station = Microsoft.Msagl.Routing.Spline.Bundling.NodePositionsAdjuster.Glued(metroline[i], gluedMap);
                if (seenStations.Contains$$T(station)){
                    while (ret.Peek() != station)
                        seenStations.Delete(ret.Pop());
                    continue;
                }
                if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(station.Position, ret.Peek().Position))
                    continue;
                seenStations.Insert(station);
                ret.Push(station);
            }
            ret.Push(metroline[i]);
            return System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, System.Linq.Enumerable.Reverse$1(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, ret), function (n){
                return n.Position;
            });
        },
        Glued: function (i, gluedMap){
            var j;
            return (function (){
                var $1 = {
                    Value: j
                };
                var $res = gluedMap.TryGetValue(i, $1);
                j = $1.Value;
                return $res;
            })() ? j : i;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (metroGraphData, bundlingSettings){
            this.bundlingSettings = null;
            this.metroGraphData = null;
            this.ink = 0;
            this.polylineLength = null;
            System.Object.ctor.call(this);
            this.metroGraphData = metroGraphData;
            this.bundlingSettings = bundlingSettings;
        },
        GlueConflictingNodes: function (){
            var circlesHierarchy = this.GetCirclesHierarchy();
            if (circlesHierarchy == null)
                return false;
            var gluingMap = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor);
            var gluedDomain = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor);
            Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$1$$RectangleNode$1$$RectangleNode$1$$Action$2(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, circlesHierarchy, circlesHierarchy, $CreateAnonymousDelegate(this, function (i, j){
                this.TryToGlueNodes(i, j, gluingMap, gluedDomain);
            }));
            if (gluingMap.get_Count() == 0)
                return false;
            for (var i = 0; i < this.metroGraphData.get_Edges().length; i++)
                this.RegenerateEdge(gluingMap, i);
            var affectedPoints = new System.Collections.Generic.HashSet$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            var $it537 = gluedDomain.GetEnumerator();
            while ($it537.MoveNext()){
                var s = $it537.get_Current();
                affectedPoints.Add(s.Position);
                for (var $i539 = 0,$t539 = s.Neighbors,$l539 = $t539.length,neig = $t539[$i539]; $i539 < $l539; $i539++, neig = $t539[$i539])
                    if (!neig.IsRealNode)
                        affectedPoints.Add(neig.Position);
            }
            this.metroGraphData.Initialize$$Boolean(false);
            Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing.FixRouting$$MetroGraphData$$BundlingSettings$$HashSet$1$Point(this.metroGraphData, this.bundlingSettings, affectedPoints);
            return true;
        },
        GetCirclesHierarchy: function (){
            var $it539 = this.metroGraphData.VirtualNodes().GetEnumerator();
            while ($it539.MoveNext()){
                var v = $it539.get_Current();
                v.Radius = this.GetCurrentHubRadius(v);
            }
            return Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnEnumeration(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(null, Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(null, null, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(null, null, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(null, null, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, null, this.metroGraphData.VirtualNodes(), $CreateAnonymousDelegate(this, function (i){
                return $CreateAnonymousObject({
                    i: i,
                    p: i.Position
                });
            })), $CreateAnonymousDelegate(this, function ($$x0){
                return $CreateAnonymousObject({
                    $$x0: $$x0,
                    r: System.Math.Max$$Double$$Double($$x0.get_i().Radius, 5)
                });
            })), $CreateAnonymousDelegate(this, function ($$x1){
                return $CreateAnonymousObject({
                    $$x1: $$x1,
                    del: new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double($$x1.get_r(), $$x1.get_r())
                });
            })), $CreateAnonymousDelegate(this, function ($$x2){
                return $CreateAnonymousObject({
                    $$x2: $$x2,
                    b: new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Addition($$x2.get_$$x1().get_$$x0().get_p(), $$x2.get_del()), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction($$x2.get_$$x1().get_$$x0().get_p(), $$x2.get_del()))
                });
            })), $CreateAnonymousDelegate(this, function ($$x3){
                return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, $$x3.get_$$x2().get_$$x1().get_$$x0().get_i(), $$x3.get_b());
            })));
        },
        GetCurrentHubRadius: function (node){
            if (node.IsRealNode){
                return node.BoundaryCurve.get_BoundingBox().get_Diagonal() / 2;
            }
            else {
                var idealR = node.cachedIdealRadius;
                var r = this.metroGraphData.looseIntersections.GetMinimalDistanceToObstacles(node, node.Position, idealR);
                System.Diagnostics.Debug.Assert$$Boolean(r <= idealR);
                for (var $i541 = 0,$t541 = node.Neighbors,$l541 = $t541.length,adj = $t541[$i541]; $i541 < $l541; $i541++, adj = $t541[$i541])
                    r = System.Math.Min$$Double$$Double(r, (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(node.Position, adj.Position)).get_Length());
                return r;
            }
        },
        TryToGlueNodes: function (i, j, gluingMap, gluedDomain){
            System.Diagnostics.Debug.Assert$$Boolean(i != j);
            var d = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(i.Position, j.Position)).get_Length();
            var r1 = System.Math.Max$$Double$$Double(i.Radius, 5);
            var r2 = System.Math.Max$$Double$$Double(j.Radius, 5);
            if (d >= r1 + r2)
                return;
            if (!this.TryGlueOrdered(i, j, gluedDomain, gluingMap))
                this.TryGlueOrdered(j, i, gluedDomain, gluingMap);
        },
        TryGlueOrdered: function (i, j, gluedDomain, gluingMap){
            if (!gluingMap.ContainsKey(i) && !gluedDomain.Contains$$T(i) && this.NodeGluingIsAllowed(i, j, gluingMap)){
                this.Map(i, j, gluedDomain, gluingMap);
                return true;
            }
            return false;
        },
        Map: function (i, j, gluedDomain, gluingMap){
            gluingMap.set_Item$$TKey(i, j);
            gluedDomain.Insert(j);
        },
        NodeGluingIsAllowed: function (i, j, gluingMap){
            for (var $i542 = 0,$t542 = i.Neighbors,$l542 = $t542.length,adj = $t542[$i542]; $i542 < $l542; $i542++, adj = $t542[$i542]){
                var k = Microsoft.Msagl.Routing.Spline.Bundling.NodePositionsAdjuster.Glued(adj, gluingMap);
                var obstaclesToIgnore = this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(k, i);
                if (!this.metroGraphData.cdtIntersections.EdgeIsLegal$$Station$$Station$$Point$$Point$$Set$1$Polyline(k, j, k.Position, j.Position, obstaclesToIgnore))
                    return false;
            }
            var delta = this.ComputeCostDeltaAfterNodeGluing(i, j, gluingMap);
            if (delta < 0)
                return false;
            return true;
        },
        ComputeCostDeltaAfterNodeGluing: function (i, j, gluingMap){
            var d = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(i.Position, j.Position)).get_Length();
            if (i.Radius >= d || j.Radius >= d)
                return 1;
            var gain = 0;
            var oldInk = this.metroGraphData.get_Ink();
            var newInk = this.metroGraphData.get_Ink() - (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(j.Position, i.Position)).get_Length();
            for (var $i543 = 0,$t543 = i.Neighbors,$l543 = $t543.length,adj = $t543[$i543]; $i543 < $l543; $i543++, adj = $t543[$i543]){
                var k = Microsoft.Msagl.Routing.Spline.Bundling.NodePositionsAdjuster.Glued(adj, gluingMap);
                newInk -= (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(k.Position, i.Position)).get_Length();
                newInk += (this.metroGraphData.RealEdgeCount$$Station$$Station(k, j) == 0 ? (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(k.Position, j.Position)).get_Length() : 0);
            }
            gain += Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.InkError(oldInk, newInk, this.bundlingSettings);
            var $it543 = this.metroGraphData.MetroNodeInfosOfNode(i).GetEnumerator();
            while ($it543.MoveNext()){
                var metroInfo = $it543.get_Current();
                var oldLength = metroInfo.get_Metroline().get_Length();
                var newLength = metroInfo.get_Metroline().get_Length();
                var pi = metroInfo.get_PolyPoint();
                var pa = pi.get_Prev();
                var pb = pi.get_Next();
                newLength -= (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(pa.get_Point(), i.Position)).get_Length() + (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(pb.get_Point(), i.Position)).get_Length();
                newLength += (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(pa.get_Point(), j.Position)).get_Length() + (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(pb.get_Point(), j.Position)).get_Length();
                gain += Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.PathLengthsError(oldLength, newLength, metroInfo.get_Metroline().get_IdealLength(), this.bundlingSettings);
            }
            return gain;
        },
        RegenerateEdge: function (gluingMap, edgeIndex){
            var poly = this.metroGraphData.get_Metrolines().get_Item$$Int32(edgeIndex).get_Polyline();
            if (!System.Linq.Enumerable.Any$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Point.ctor, poly, $CreateAnonymousDelegate(this, function (p){
                return gluingMap.ContainsKey(this.metroGraphData.PointToStations.get_Item$$TKey(p));
            })))
                return;
            this.metroGraphData.get_Edges()[edgeIndex].set_Curve(new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor$$IEnumerable$1$Point(Microsoft.Msagl.Routing.Spline.Bundling.NodePositionsAdjuster.GluedPolyline(System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, poly, $CreateAnonymousDelegate(this, function (p){
                return this.metroGraphData.PointToStations.get_Item$$TKey(p);
            }))), gluingMap)));
        },
        UnglueEdgesFromBundleToSaveInk: function (alwaysExecuteSA){
            var segsToPolylines = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.PointPair.ctor, Microsoft.Msagl.Core.DataStructures.Set$1.ctor);
            this.ink = this.metroGraphData.get_Ink();
            this.polylineLength = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Metroline.ctor, System.Double.ctor);
            var $it544 = this.metroGraphData.get_Metrolines().GetEnumerator();
            while ($it544.MoveNext()){
                var metroline = $it544.get_Current();
                this.polylineLength.set_Item$$TKey(metroline, metroline.get_Length());
                for (var pp = metroline.get_Polyline().get_StartPoint(); pp.get_Next() != null; pp = pp.get_Next()){
                    var segment = new Microsoft.Msagl.Core.Geometry.PointPair.ctor(pp.get_Point(), pp.get_Next().get_Point());
                    Microsoft.Msagl.Core.DataStructures.CollectionUtilities.AddToMap$3(Microsoft.Msagl.Routing.Spline.Bundling.Metroline.ctor, Microsoft.Msagl.Core.Geometry.PointPair.ctor, Microsoft.Msagl.Core.DataStructures.Set$1.ctor, segsToPolylines, segment, metroline);
                }
            }
            var affectedPoints = new System.Collections.Generic.HashSet$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            var progress = false;
            var $it545 = this.metroGraphData.get_Metrolines().GetEnumerator();
            while ($it545.MoveNext()){
                var metroline = $it545.get_Current();
                var obstaclesAllowedToIntersect = Microsoft.Msagl.Core.DataStructures.Set$1.op_Multiply(this.metroGraphData.PointToStations.get_Item$$TKey(metroline.get_Polyline().get_Start()).EnterableLoosePolylines, this.metroGraphData.PointToStations.get_Item$$TKey(metroline.get_Polyline().get_End()).EnterableLoosePolylines);
                if (this.TrySeparateOnPolyline(metroline, segsToPolylines, affectedPoints, obstaclesAllowedToIntersect))
                    progress = true;
            }
            if (progress)
                this.metroGraphData.Initialize$$Boolean(false);
            if (alwaysExecuteSA || progress)
                Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing.FixRouting$$MetroGraphData$$BundlingSettings$$HashSet$1$Point(this.metroGraphData, this.bundlingSettings, alwaysExecuteSA ? null : affectedPoints);
            return progress;
        },
        TrySeparateOnPolyline: function (metroline, segsToPolylines, affectedPoints, obstaclesAllowedToIntersect){
            var progress = false;
            var relaxing = true;
            while (relaxing){
                relaxing = false;
                for (var p = metroline.get_Polyline().get_StartPoint(); p.get_Next() != null && p.get_Next().get_Next() != null; p = p.get_Next())
                    if (this.TryShortcutPolypoint(p, segsToPolylines, affectedPoints, obstaclesAllowedToIntersect))
                        relaxing = true;
                if (relaxing)
                    progress = true;
            }
            return progress;
        },
        TryShortcutPolypoint: function (pp, segsToPolylines, affectedPoints, obstaclesAllowedToIntersect){
            if (this.SeparationShortcutAllowed(pp, segsToPolylines, obstaclesAllowedToIntersect)){
                affectedPoints.Add(pp.get_Point());
                affectedPoints.Add(pp.get_Next().get_Point());
                affectedPoints.Add(pp.get_Next().get_Next().get_Point());
                this.RemoveShortcuttedPolypoint(pp, segsToPolylines);
                return true;
            }
            return false;
        },
        SeparationShortcutAllowed: function (pp, segsToPolylines, obstaclesAllowedToIntersect){
            var a = pp.get_Point();
            var b = pp.get_Next().get_Point();
            var c = pp.get_Next().get_Next().get_Point();
            var aStation = this.metroGraphData.PointToStations.get_Item$$TKey(a);
            var bStation = this.metroGraphData.PointToStations.get_Item$$TKey(b);
            var cStation = this.metroGraphData.PointToStations.get_Item$$TKey(c);
            if (!this.metroGraphData.cdtIntersections.EdgeIsLegal$$Station$$Station$$Point$$Point$$Set$1$Polyline(aStation, cStation, a, c, Microsoft.Msagl.Core.DataStructures.Set$1.op_Multiply(Microsoft.Msagl.Core.DataStructures.Set$1.op_Multiply(obstaclesAllowedToIntersect, bStation.EnterableLoosePolylines), (Microsoft.Msagl.Core.DataStructures.Set$1.op_Addition(aStation.EnterableLoosePolylines, cStation.EnterableLoosePolylines)))))
                return false;
            var inkgain = this.GetInkgain(pp, segsToPolylines, a, b, c);
            if (inkgain < 0)
                return false;
            return true;
        },
        GetInkgain: function (pp, segsToPolylines, a, b, c){
            var abPolylines,bcPolylines,abcPolylines;
            (function (){
                var $1 = {
                    Value: abPolylines
                };
                var $2 = {
                    Value: bcPolylines
                };
                var $3 = {
                    Value: abcPolylines
                };
                var $res = this.FindPolylines(pp, segsToPolylines, $1, $2, $3);
                abPolylines = $1.Value;
                bcPolylines = $2.Value;
                abcPolylines = $3.Value;
                return $res;
            }).call(this);
            var gain = 0;
            var oldInk = this.ink;
            var newInk = this.ink;
            var ab = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a, b)).get_Length();
            var bc = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b, c)).get_Length();
            var ac = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a, c)).get_Length();
            if (abPolylines.get_Count() == abcPolylines.get_Count())
                newInk -= ab;
            if (bcPolylines.get_Count() == abcPolylines.get_Count())
                newInk -= bc;
            if (!segsToPolylines.ContainsKey(new Microsoft.Msagl.Core.Geometry.PointPair.ctor(a, c)) || segsToPolylines.get_Item$$TKey(new Microsoft.Msagl.Core.Geometry.PointPair.ctor(a, c)).get_Count() == 0)
                newInk += ac;
            gain += Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.InkError(oldInk, newInk, this.bundlingSettings);
            var $it546 = abcPolylines.GetEnumerator();
            while ($it546.MoveNext()){
                var metroline = $it546.get_Current();
                var oldLength = this.polylineLength.get_Item$$TKey(metroline);
                var newLength = this.polylineLength.get_Item$$TKey(metroline);
                newLength -= ab + bc - ac;
                gain += Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.PathLengthsError(oldLength, newLength, metroline.get_IdealLength(), this.bundlingSettings);
            }
            var nowR = this.GetCurrentHubRadius(this.metroGraphData.PointToStations.get_Item$$TKey(a));
            var widthABC = this.metroGraphData.GetWidth$$IEnumerable$1$Metroline$$Double(abcPolylines, this.bundlingSettings.get_EdgeSeparation());
            var widthABD = this.metroGraphData.GetWidth$$IEnumerable$1$Metroline$$Double(Microsoft.Msagl.Core.DataStructures.Set$1.op_Subtraction(abPolylines, abcPolylines), this.bundlingSettings.get_EdgeSeparation());
            var idealR = Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.GetMinRadiusForTwoAdjacentBundles$$Double$$Point$$Point$$Point$$Double$$Double$$MetroGraphData$$BundlingSettings(nowR, a, c, b, widthABC, widthABD, this.metroGraphData, this.bundlingSettings);
            if (idealR > nowR){
                gain -= Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.RError(idealR, nowR, this.bundlingSettings);
            }
            nowR = this.GetCurrentHubRadius(this.metroGraphData.PointToStations.get_Item$$TKey(c));
            var widthCBD = this.metroGraphData.GetWidth$$IEnumerable$1$Metroline$$Double(Microsoft.Msagl.Core.DataStructures.Set$1.op_Subtraction(bcPolylines, abcPolylines), this.bundlingSettings.get_EdgeSeparation());
            idealR = Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.GetMinRadiusForTwoAdjacentBundles$$Double$$Point$$Point$$Point$$Double$$Double$$MetroGraphData$$BundlingSettings(nowR, c, b, a, widthCBD, widthABC, this.metroGraphData, this.bundlingSettings);
            if (idealR > nowR){
                gain -= Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.RError(idealR, nowR, this.bundlingSettings);
            }
            return gain;
        },
        RemoveShortcuttedPolypoint: function (pp, segsToPolylines){
            var a = pp.get_Point();
            var b = pp.get_Next().get_Point();
            var c = pp.get_Next().get_Next().get_Point();
            var abPolylines,bcPolylines,abcPolylines;
            (function (){
                var $1 = {
                    Value: abPolylines
                };
                var $2 = {
                    Value: bcPolylines
                };
                var $3 = {
                    Value: abcPolylines
                };
                var $res = this.FindPolylines(pp, segsToPolylines, $1, $2, $3);
                abPolylines = $1.Value;
                bcPolylines = $2.Value;
                abcPolylines = $3.Value;
                return $res;
            }).call(this);
            var ab = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a, b)).get_Length();
            var bc = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b, c)).get_Length();
            var ac = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a, c)).get_Length();
            if (abPolylines.get_Count() == abcPolylines.get_Count())
                this.ink -= ab;
            if (bcPolylines.get_Count() == abcPolylines.get_Count())
                this.ink -= bc;
            if (!segsToPolylines.ContainsKey(new Microsoft.Msagl.Core.Geometry.PointPair.ctor(a, c)) || segsToPolylines.get_Item$$TKey(new Microsoft.Msagl.Core.Geometry.PointPair.ctor(a, c)).get_Count() == 0)
                this.ink += ac;
            var $it547 = abcPolylines.GetEnumerator();
            while ($it547.MoveNext()){
                var metroline = $it547.get_Current();
                this.polylineLength.set_Item$$TKey(metroline, this.polylineLength.get_Item$$TKey(metroline) - ab + bc - ac);
            }
            var $it548 = abcPolylines.GetEnumerator();
            while ($it548.MoveNext()){
                var metroline = $it548.get_Current();
                this.RemovePolypoint(System.Linq.Enumerable.First$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor, metroline.get_Polyline().get_PolylinePoints(), $CreateAnonymousDelegate(this, function (p){
                    return Microsoft.Msagl.Core.Geometry.Point.op_Equality(p.get_Point(), b);
                })));
                Microsoft.Msagl.Core.DataStructures.CollectionUtilities.RemoveFromMap$3(Microsoft.Msagl.Routing.Spline.Bundling.Metroline.ctor, Microsoft.Msagl.Core.Geometry.PointPair.ctor, Microsoft.Msagl.Core.DataStructures.Set$1.ctor, segsToPolylines, new Microsoft.Msagl.Core.Geometry.PointPair.ctor(a, b), metroline);
                Microsoft.Msagl.Core.DataStructures.CollectionUtilities.RemoveFromMap$3(Microsoft.Msagl.Routing.Spline.Bundling.Metroline.ctor, Microsoft.Msagl.Core.Geometry.PointPair.ctor, Microsoft.Msagl.Core.DataStructures.Set$1.ctor, segsToPolylines, new Microsoft.Msagl.Core.Geometry.PointPair.ctor(b, c), metroline);
                Microsoft.Msagl.Core.DataStructures.CollectionUtilities.AddToMap$3(Microsoft.Msagl.Routing.Spline.Bundling.Metroline.ctor, Microsoft.Msagl.Core.Geometry.PointPair.ctor, Microsoft.Msagl.Core.DataStructures.Set$1.ctor, segsToPolylines, new Microsoft.Msagl.Core.Geometry.PointPair.ctor(a, c), metroline);
            }
        },
        FindPolylines: function (pp, segsToPolylines, abPolylines, bcPolylines, abcPolylines){
            var a = pp.get_Point();
            var b = pp.get_Next().get_Point();
            var c = pp.get_Next().get_Next().get_Point();
            abPolylines.Value = segsToPolylines.get_Item$$TKey(new Microsoft.Msagl.Core.Geometry.PointPair.ctor(a, b));
            bcPolylines.Value = segsToPolylines.get_Item$$TKey(new Microsoft.Msagl.Core.Geometry.PointPair.ctor(b, c));
            abcPolylines.Value = Microsoft.Msagl.Core.DataStructures.Set$1.op_Multiply(abPolylines.Value, bcPolylines.Value);
        },
        RemovePolypoint: function (p){
            var prev = p.get_Prev();
            var next = p.get_Next();
            prev.set_Next(next);
            next.set_Prev(prev);
        },
        GlueCollinearNeighbors$$Int32: function (step){
            var affectedPoints = new System.Collections.Generic.HashSet$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            var progress = false;
            var $it549 = this.metroGraphData.Stations.GetEnumerator();
            while ($it549.MoveNext()){
                var node = $it549.get_Current();
                if (this.GlueCollinearNeighbors$$Station$$HashSet$1$Point$$Int32(node, affectedPoints, step))
                    progress = true;
            }
            if (progress){
                this.metroGraphData.Initialize$$Boolean(false);
                Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing.FixRouting$$MetroGraphData$$BundlingSettings$$HashSet$1$Point(this.metroGraphData, this.bundlingSettings, affectedPoints);
            }
            return progress;
        },
        GlueCollinearNeighbors$$Station$$HashSet$1$Point$$Int32: function (node, affectedPoints, step){
            if (node.Neighbors.length <= 1)
                return false;
            var gluedEdges = new System.Collections.Generic.Dictionary$2.ctor(System.Tuple$2.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor);
            var neighbors = node.Neighbors;
            for (var i = 0; i < neighbors.length; i++)
                this.TryToGlueEdges(node, neighbors[i], neighbors[(i + 1) % neighbors.length], gluedEdges, step);
            if (gluedEdges.get_Count() == 0)
                return false;
            var $it550 = gluedEdges.GetEnumerator();
            while ($it550.MoveNext()){
                var keyValuePair = $it550.get_Current();
                this.GlueEdge(keyValuePair);
                affectedPoints.Add(keyValuePair.get_Key().get_Item1().Position);
                affectedPoints.Add(keyValuePair.get_Key().get_Item2().Position);
                affectedPoints.Add(keyValuePair.get_Value());
            }
            return true;
        },
        TryToGlueEdges: function (node, a, b, gluedEdges, step){
            System.Diagnostics.Debug.Assert$$Boolean(a != b);
            var angle = Microsoft.Msagl.Core.Geometry.Point.Angle$$Point$$Point$$Point(a.Position, node.Position, b.Position);
            if (angle < this.bundlingSettings.get_AngleThreshold()){
                var la = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a.Position, node.Position)).get_Length();
                var lb = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b.Position, node.Position)).get_Length();
                var ratio = System.Math.Min$$Double$$Double(la, lb) / System.Math.Max$$Double$$Double(la, lb);
                if (ratio < 0.05)
                    return;
                if (la < lb){
                    if (this.EdgeGluingIsAllowed$$Station$$Station$$Station(node, a, b)){
                        this.AddEdgeToGlue(node, b, a, a.Position, gluedEdges);
                        return;
                    }
                }
                else {
                    if (this.EdgeGluingIsAllowed$$Station$$Station$$Station(node, b, a)){
                        this.AddEdgeToGlue(node, a, b, b.Position, gluedEdges);
                        return;
                    }
                }
                if (step < 5 && ratio > 0.5){
                    var newPosition = this.ConstructGluingPoint(node, a, b);
                    if (this.EdgeGluingIsAllowed$$Station$$Station$$Station$$Point(node, a, b, newPosition)){
                        this.AddEdgeToGlue(node, b, a, newPosition, gluedEdges);
                    }
                }
            }
        },
        ConstructGluingPoint: function (node, a, b){
            var len = System.Math.Min$$Double$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a.Position, node.Position)).get_Length(), (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b.Position, node.Position)).get_Length()) / 2;
            var dir = Microsoft.Msagl.Core.Geometry.Point.op_Addition((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a.Position, node.Position)).Normalize(), (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b.Position, node.Position)).Normalize());
            return Microsoft.Msagl.Core.Geometry.Point.op_Addition(node.Position, Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(dir, len), 2));
        },
        EdgeGluingIsAllowed$$Station$$Station$$Station: function (node, a, b){
            if (a.IsRealNode || b.IsRealNode)
                return false;
            if (!this.metroGraphData.cdtIntersections.EdgeIsLegal$$Station$$Station$$Point$$Point(a, b, a.Position, b.Position))
                return false;
            var enterableForEdgeNodeB = this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(node, b);
            var crossingsOfEdgeNodeA = Microsoft.Msagl.Routing.InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolyline$$LineSegment$$RectangleNode$1$Polyline(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(node.Position, a.Position), this.metroGraphData.get_LooseTree());
            if (!System.Linq.Enumerable.All$1(Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.ctor, crossingsOfEdgeNodeA, $CreateAnonymousDelegate(this, function (ii){
                return System.Linq.Enumerable.Contains$1$$IEnumerable$1$$TSource(Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor, enterableForEdgeNodeB, ii.get_Segment1());
            })))
                return false;
            var crossingsOfEdgeab = Microsoft.Msagl.Routing.InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolyline$$LineSegment$$RectangleNode$1$Polyline(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(a.Position, b.Position), this.metroGraphData.get_LooseTree());
            if (!System.Linq.Enumerable.All$1(Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.ctor, crossingsOfEdgeab, $CreateAnonymousDelegate(this, function (ii){
                return System.Linq.Enumerable.Contains$1$$IEnumerable$1$$TSource(Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor, enterableForEdgeNodeB, ii.get_Segment1());
            })))
                return false;
            var delta = this.ComputeCostDeltaAfterEdgeGluing(node, a, b, a.Position);
            if (delta < 0)
                return false;
            return true;
        },
        EdgeGluingIsAllowed$$Station$$Station$$Station$$Point: function (node, a, b, gluingPoint){
            if (!this.metroGraphData.looseIntersections.HubAvoidsObstacles$$Point$$Double$$Set$1$Polyline(gluingPoint, 0, Microsoft.Msagl.Core.DataStructures.Set$1.op_Multiply(a.EnterableLoosePolylines, b.EnterableLoosePolylines)))
                return false;
            if (!this.metroGraphData.cdtIntersections.EdgeIsLegal$$Station$$Station$$Point$$Point(node, null, node.Position, gluingPoint))
                return false;
            if (!this.metroGraphData.cdtIntersections.EdgeIsLegal$$Station$$Station$$Point$$Point(a, null, a.Position, gluingPoint))
                return false;
            if (!this.metroGraphData.cdtIntersections.EdgeIsLegal$$Station$$Station$$Point$$Point(b, null, b.Position, gluingPoint))
                return false;
            var delta = this.ComputeCostDeltaAfterEdgeGluing(node, a, b, gluingPoint);
            if (delta < 0)
                return false;
            return true;
        },
        ComputeCostDeltaAfterEdgeGluing: function (node, a, b, newp){
            var gain = 0;
            var oldInk = this.metroGraphData.get_Ink();
            var newInk = this.metroGraphData.get_Ink() - (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(node.Position, b.Position)).get_Length() - (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(node.Position, a.Position)).get_Length() + (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(node.Position, newp)).get_Length() + (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(newp, a.Position)).get_Length() + (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(newp, b.Position)).get_Length();
            gain += Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.InkError(oldInk, newInk, this.bundlingSettings);
            var $it551 = this.metroGraphData.GetIjInfo(node, b).Metrolines.GetEnumerator();
            while ($it551.MoveNext()){
                var metroline = $it551.get_Current();
                var oldLength = metroline.get_Length();
                var newLength = metroline.get_Length() - (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(node.Position, b.Position)).get_Length() + (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(node.Position, newp)).get_Length() + (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(newp, b.Position)).get_Length();
                gain += Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.PathLengthsError(oldLength, newLength, metroline.get_IdealLength(), this.bundlingSettings);
            }
            var $it552 = this.metroGraphData.GetIjInfo(node, a).Metrolines.GetEnumerator();
            while ($it552.MoveNext()){
                var metroline = $it552.get_Current();
                var oldLength = metroline.get_Length();
                var newLength = metroline.get_Length() - (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(node.Position, a.Position)).get_Length() + (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(node.Position, newp)).get_Length() + (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(newp, a.Position)).get_Length();
                gain += Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.PathLengthsError(oldLength, newLength, metroline.get_IdealLength(), this.bundlingSettings);
            }
            var id2 = node.cachedIdealRadius;
            var nowR = this.GetCurrentHubRadius(node);
            var idealR = Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.GetMinRadiusForTwoAdjacentBundles$$Double$$Station$$Point$$Station$$Station$$MetroGraphData$$BundlingSettings(nowR, node, node.Position, a, b, this.metroGraphData, this.bundlingSettings);
            if (idealR > nowR){
                gain += Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.RError(idealR, nowR, this.bundlingSettings);
            }
            if (id2 > (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(node.Position, newp)).get_Length() && !node.IsRealNode){
                gain -= Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.RError(id2, (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(node.Position, newp)).get_Length(), this.bundlingSettings);
            }
            return gain;
        },
        AddEdgeToGlue: function (node, b, a, newp, gluedEdges){
            if (gluedEdges.ContainsKey(new System.Tuple$2.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, a, node)))
                return;
            if (gluedEdges.ContainsKey(new System.Tuple$2.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, b, node)))
                return;
            if (gluedEdges.ContainsKey(new System.Tuple$2.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, node, a)))
                return;
            if (gluedEdges.ContainsKey(new System.Tuple$2.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, node, b)))
                return;
            gluedEdges.set_Item$$TKey(new System.Tuple$2.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, node, a), newp);
            gluedEdges.set_Item$$TKey(new System.Tuple$2.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, node, b), newp);
        },
        GlueEdge: function (keyValuePair){
            var node = keyValuePair.get_Key().get_Item1();
            var a = keyValuePair.get_Key().get_Item2();
            var newp = keyValuePair.get_Value();
            var $it553 = System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Spline.Bundling.MetroNodeInfo.ctor, Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor, node.MetroNodeInfos, $CreateAnonymousDelegate(this, function (i){
                return i.get_PolyPoint();
            })).GetEnumerator();
            while ($it553.MoveNext()){
                var polylinePoint = $it553.get_Current();
                if (polylinePoint.get_Next() != null && Microsoft.Msagl.Core.Geometry.Point.op_Equality(polylinePoint.get_Next().get_Point(), a.Position))
                    this.SplitPolylinePoint(polylinePoint, newp);
                else if (polylinePoint.get_Prev() != null && Microsoft.Msagl.Core.Geometry.Point.op_Equality(polylinePoint.get_Prev().get_Point(), a.Position))
                    this.SplitPolylinePoint(polylinePoint.get_Prev(), newp);
            }
        },
        SplitPolylinePoint: function (node, pointToInsert){
            if (Microsoft.Msagl.Core.Geometry.Point.op_Equality(node.get_Point(), pointToInsert) || Microsoft.Msagl.Core.Geometry.Point.op_Equality(node.get_Next().get_Point(), pointToInsert))
                return;
            var p = (function (){
                var $v77 = new Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor(pointToInsert);
                $v77.set_Polyline(node.get_Polyline());
                $v77.set_Next(node.get_Next());
                $v77.set_Prev(node);
                return $v77;
            }).call(this);
            p.get_Next().set_Prev(p);
            p.get_Prev().set_Next(p);
        },
        RelaxConstrainedEdges: function (){
            var affectedPoints = new System.Collections.Generic.HashSet$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            var progress = false;
            var $it554 = this.metroGraphData.VirtualEdges().GetEnumerator();
            while ($it554.MoveNext()){
                var edge = $it554.get_Current();
                if (this.RelaxConstrainedEdge(edge.get_Item1(), edge.get_Item2(), affectedPoints))
                    progress = true;
            }
            if (progress){
                this.metroGraphData.Initialize$$Boolean(false);
                Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing.FixRouting$$MetroGraphData$$BundlingSettings$$HashSet$1$Point(this.metroGraphData, this.bundlingSettings, affectedPoints);
            }
            return progress;
        },
        RelaxConstrainedEdge: function (a, b, affectedPoints){
            var idealWidth = this.metroGraphData.GetWidth$$Station$$Station$$Double(a, b, this.bundlingSettings.get_EdgeSeparation());
            var closestPoints;
            (function (){
                var $1 = {
                    Value: closestPoints
                };
                var $res = this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(a, b, a.Position, b.Position, 0.99 * idealWidth / 2, $1);
                closestPoints = $1.Value;
                return $res;
            }).call(this);
            if (closestPoints.get_Count() > 0){
                var bestDist = -1;
                var bestPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
                var $it555 = closestPoints.GetEnumerator();
                while ($it555.MoveNext()){
                    var d = $it555.get_Current();
                    var distToSegmentEnd = System.Math.Min$$Double$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a.Position, d.get_Item2())).get_Length(), (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b.Position, d.get_Item2())).get_Length());
                    var distAB = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a.Position, b.Position)).get_Length();
                    var ratio = distToSegmentEnd / distAB;
                    if (ratio < 0.1)
                        continue;
                    var dist = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(d.get_Item1(), d.get_Item2())).get_Length();
                    if (bestDist == -1 || dist < bestDist){
                        bestDist = dist;
                        bestPoint = d.get_Item2();
                    }
                }
                if (bestDist == -1)
                    return false;
                if (!this.metroGraphData.looseIntersections.HubAvoidsObstacles$$Point$$Double$$Set$1$Polyline(bestPoint, 0, Microsoft.Msagl.Core.DataStructures.Set$1.op_Multiply(a.EnterableLoosePolylines, b.EnterableLoosePolylines)))
                    return false;
                affectedPoints.Add(bestPoint);
                affectedPoints.Add(a.Position);
                affectedPoints.Add(b.Position);
                var $it556 = this.metroGraphData.GetIjInfo(a, b).Metrolines.GetEnumerator();
                while ($it556.MoveNext()){
                    var metroline = $it556.get_Current();
                    var pp = null;
                    var $it557 = metroline.get_Polyline().get_PolylinePoints().GetEnumerator();
                    while ($it557.MoveNext()){
                        var ppp = $it557.get_Current();
                        if (Microsoft.Msagl.Core.Geometry.Point.op_Equality(ppp.get_Point(), a.Position)){
                            pp = ppp;
                            break;
                        }
                    }
                    System.Diagnostics.Debug.Assert$$Boolean(pp != null);
                    if (pp.get_Next() != null && Microsoft.Msagl.Core.Geometry.Point.op_Equality(pp.get_Next().get_Point(), b.Position))
                        this.SplitPolylinePoint(pp, bestPoint);
                    else
                        this.SplitPolylinePoint(pp.get_Prev(), bestPoint);
                }
                return true;
            }
            return false;
        },
        RemoveDoublePathCrossings: function (){
            var progress = new Microsoft.Msagl.Routing.Spline.Bundling.PathFixer.ctor(this.metroGraphData, $CreateDelegate(this.metroGraphData, this.metroGraphData.PointIsAcceptableForEdge)).Run();
            if (progress){
                this.metroGraphData.Initialize$$Boolean(false);
                Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing.FixRouting$$MetroGraphData$$BundlingSettings(this.metroGraphData, this.bundlingSettings);
            }
            return progress;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$NodePositionsAdjuster);
var Microsoft$Msagl$Routing$Spline$Bundling$OrientedHubSegment = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.OrientedHubSegment",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (seg, reversed, index, bundleBase){
            this.Segment = null;
            this.Reversed = false;
            this.Index = 0;
            this.BundleBase = null;
            this._Other = null;
            System.Object.ctor.call(this);
            this.Segment = seg;
            this.Reversed = reversed;
            this.Index = index;
            this.BundleBase = bundleBase;
        },
        Item$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Item$$Double: function (t){
            return this.Reversed ? this.Segment.get_Item$$Double(this.Segment.get_ParEnd() - t) : this.Segment.get_Item$$Double(t);
        },
        Start$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Start: function (){
            return !this.Reversed ? this.Segment.get_Start() : this.Segment.get_End();
        },
        End$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_End: function (){
            return this.Reversed ? this.Segment.get_Start() : this.Segment.get_End();
        },
        Other$$: "Microsoft.Msagl.Routing.Spline.Bundling.OrientedHubSegment",
        get_Other: function (){
            return this._Other;
        },
        set_Other: function (value){
            this._Other = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$OrientedHubSegment);
var Microsoft$Msagl$Routing$Spline$Bundling$PathFixer = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.PathFixer",
    baseTypeName: "System.Object",
    staticDefinition: {
        RemoveSelfCyclesFromPolyline: function (poly){
            var progress = false;
            var pointsToPp = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor);
            for (var pp = poly.get_StartPoint(); pp != null; pp = pp.get_Next()){
                var point = pp.get_Point();
                var previous;
                if ((function (){
                    var $1 = {
                        Value: previous
                    };
                    var $res = pointsToPp.TryGetValue(point, $1);
                    previous = $1.Value;
                    return $res;
                })()){
                    for (var px = previous.get_Next(); px != pp.get_Next(); px = px.get_Next()){
                        pointsToPp.Remove(px.get_Point());
                    }
                    previous.set_Next(pp.get_Next());
                    pp.get_Next().set_Prev(previous);
                    progress = true;
                }
                else
                    pointsToPp.set_Item$$TKey(pp.get_Point(), pp);
            }
            return progress;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (metroGraphData, polylineAcceptsPoint){
            this.metroGraphData = null;
            this.polylineAcceptsPoint = null;
            this.foundCrossings = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            this.crossingsThatShouldBecomeHubs = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            this.pointsToDelete = null;
            System.Object.ctor.call(this);
            this.metroGraphData = metroGraphData;
            this.polylineAcceptsPoint = polylineAcceptsPoint;
        },
        Vertices: function (){
            return System.Linq.Enumerable.SelectMany$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, this.metroGraphData.get_Edges(), $CreateAnonymousDelegate(this, function (e){
                return Cast(e.get_Curve(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            })), $CreateAnonymousDelegate(this, function (p){
                return p.get_PolylinePoints();
            }));
        },
        Polylines$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]",
        get_Polylines: function (){
            return System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, this.metroGraphData.get_Edges(), $CreateAnonymousDelegate(this, function (e){
                return Cast(e.get_Curve(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            }));
        },
        Edges: function (){
            var set = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.PointPair.ctor);
            var $it558 = this.get_Polylines().GetEnumerator();
            while ($it558.MoveNext()){
                var poly = $it558.get_Current();
                for (var pp = poly.get_StartPoint(); pp.get_Next() != null; pp = pp.get_Next())
                    set.Insert(Microsoft.Msagl.Routing.Spline.Bundling.FlipCollapser.OrderedPair$$PolylinePoint(pp));
            }
            return set;
        },
        Run: function (){
            if (System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, this.metroGraphData.get_Edges()) == 0)
                return false;
            var splittingPoints = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.PointPair.ctor, System.Collections.Generic.List$1.ctor);
            var treeOfVertices = new Microsoft.Msagl.Core.Geometry.RTree$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            var $it559 = this.Vertices().GetEnumerator();
            while ($it559.MoveNext()){
                var vertex = $it559.get_Current();
                var r = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point(vertex.get_Point());
                r.Pad$$Double(Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_IntersectionEpsilon());
                treeOfVertices.Add$$Rectangle$$TData(r, vertex.get_Point());
            }
            var treeOfEdges = Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnData(this.Edges(), $CreateAnonymousDelegate(this, function (e){
                return new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(e.get_First(), e.get_Second());
            }));
            Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$1$$RectangleNode$1$$RectangleNode$1$$Action$2(Microsoft.Msagl.Core.Geometry.PointPair.ctor, treeOfEdges, treeOfEdges, $CreateAnonymousDelegate(this, function (a, b){
                this.IntersectTwoEdges(a, b, splittingPoints, treeOfVertices);
            }));
            this.SortInsertedPoints(splittingPoints);
            var pointsInserted = this.InsertPointsIntoPolylines(splittingPoints);
            var progress = this.FixPaths();
            var pointsRemoved = this.RemoveUnimportantCrossings();
            return progress || pointsInserted || pointsRemoved;
        },
        FixPaths: function (){
            var progress = false;
            if (this.RemoveSelfCycles())
                progress = true;
            if (this.ReduceEdgeCrossings())
                progress = true;
            return progress;
        },
        SortInsertedPoints: function (splittingPoints){
            var $it560 = splittingPoints.GetEnumerator();
            while ($it560.MoveNext()){
                var pair = $it560.get_Current();
                this.SortInsideSegment(pair.get_Key(), pair.get_Value());
            }
        },
        SortInsideSegment: function (edge, list){
            System.Diagnostics.Debug.Assert$$Boolean$$String(list.get_Count() > 0, "an edge should not be present with an empty list");
            list.Sort$$Comparison$1($CreateAnonymousDelegate(this, function (a, b){
                return (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a, edge.get_First())).get_Length().CompareTo$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b, edge.get_First())).get_Length());
            }));
        },
        InsertPointsIntoPolylines: function (splittingPoints){
            var inserted = false;
            var $it561 = this.metroGraphData.get_Metrolines().GetEnumerator();
            while ($it561.MoveNext()){
                var metroline = $it561.get_Current();
                if (this.InsertPointsIntoPolyline(metroline, splittingPoints))
                    inserted = true;
            }
            return inserted;
        },
        InsertPointsIntoPolyline: function (metroline, splittingPoints){
            var inserted = false;
            for (var pp = metroline.get_Polyline().get_StartPoint(); pp.get_Next() != null; pp = pp.get_Next())
                if (this.InsertPointsOnPolypoint(pp, splittingPoints, metroline))
                    inserted = true;
            return inserted;
        },
        InsertPointsOnPolypoint: function (pp, splittingPoints, metroline){
            var pointPair = Microsoft.Msagl.Routing.Spline.Bundling.FlipCollapser.OrderedPair$$PolylinePoint(pp);
            var reversed = Microsoft.Msagl.Core.Geometry.Point.op_Inequality(pp.get_Point(), pointPair.get_First());
            var list;
            if (!(function (){
                var $1 = {
                    Value: list
                };
                var $res = splittingPoints.TryGetValue(pointPair, $1);
                list = $1.Value;
                return $res;
            }).call(this))
                return false;
            var endPolyPoint = pp.get_Next();
            var poly = pp.get_Polyline();
            if (reversed)
                for (var i = list.get_Count() - 1; i >= 0; i--){
                    if (this.polylineAcceptsPoint != null && !this.polylineAcceptsPoint(metroline, list.get_Item$$Int32(i)))
                        continue;
                    var p = (function (){
                        var $v78 = new Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor(list.get_Item$$Int32(i));
                        $v78.set_Prev(pp);
                        $v78.set_Polyline(poly);
                        return $v78;
                    }).call(this);
                    pp.set_Next(p);
                    pp = p;
                }
            else
                for (var i = 0; i < list.get_Count(); i++){
                    if (this.polylineAcceptsPoint != null && !this.polylineAcceptsPoint(metroline, list.get_Item$$Int32(i)))
                        continue;
                    var p = (function (){
                        var $v79 = new Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor(list.get_Item$$Int32(i));
                        $v79.set_Prev(pp);
                        $v79.set_Polyline(poly);
                        return $v79;
                    }).call(this);
                    pp.set_Next(p);
                    pp = p;
                }
            pp.set_Next(endPolyPoint);
            endPolyPoint.set_Prev(pp);
            return true;
        },
        RemoveSelfCycles: function (){
            var progress = false;
            var $it562 = this.get_Polylines().GetEnumerator();
            while ($it562.MoveNext()){
                var poly = $it562.get_Current();
                if (Microsoft.Msagl.Routing.Spline.Bundling.PathFixer.RemoveSelfCyclesFromPolyline(poly))
                    progress = true;
            }
            return progress;
        },
        ReduceEdgeCrossings: function (){
            var cycleCollapser = new Microsoft.Msagl.Routing.Spline.Bundling.FlipSwitcher.ctor(this.metroGraphData);
            cycleCollapser.Run();
            this.crossingsThatShouldBecomeHubs.InsertRange(cycleCollapser.GetChangedHubs());
            return cycleCollapser.NumberOfReducedCrossings() > 0;
        },
        RemoveUnimportantCrossings: function (){
            var removed = false;
            this.pointsToDelete = Microsoft.Msagl.Core.DataStructures.Set$1.op_Subtraction(this.foundCrossings, this.crossingsThatShouldBecomeHubs);
            var $it563 = this.get_Polylines().GetEnumerator();
            while ($it563.MoveNext()){
                var polyline = $it563.get_Current();
                if (this.RemoveUnimportantCrossingsFromPolyline(polyline))
                    removed = true;
            }
            return removed;
        },
        RemoveUnimportantCrossingsFromPolyline: function (polyline){
            var removed = false;
            for (var p = polyline.get_StartPoint().get_Next(); p != null && p.get_Next() != null; p = p.get_Next())
                if (this.pointsToDelete.Contains$$T(p.get_Point()) && Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(p.get_Prev().get_Point(), p.get_Point(), p.get_Next().get_Point()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Collinear){
                    var pp = p.get_Prev();
                    var pn = p.get_Next();
                    pp.set_Next(pn);
                    pn.set_Prev(pp);
                    p = pp;
                    removed = true;
                }
            return removed;
        },
        IntersectTwoEdges: function (a, b, splittingPoints, tree){
            var x;
            if ((function (){
                var $1 = {
                    Value: x
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.LineSegment.Intersect(a.get_First(), a.get_Second(), b.get_First(), b.get_Second(), $1);
                x = $1.Value;
                return $res;
            }).call(this)){
                var vertex = this.FindExistingVertexOrCreateNew(tree, x);
                if (this.AddVertexToSplittingList(a, splittingPoints, vertex) | this.AddVertexToSplittingList(b, splittingPoints, vertex))
                    this.foundCrossings.Insert(vertex);
            }
        },
        FindExistingVertexOrCreateNew: function (tree, x){
            var p = tree.get_RootNode().FirstHitNode$$Point(x);
            if (p != null)
                return p.get_UserData();
            var rect = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point(x);
            rect.Pad$$Double(Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_IntersectionEpsilon());
            tree.Add$$Rectangle$$TData(rect, x);
            return x;
        },
        AddVertexToSplittingList: function (a, splittingPoints, intersectionPoint){
            if (!Microsoft.Msagl.Core.Geometry.ApproximateComparer.CloseIntersections(intersectionPoint, a.get_First()) && !Microsoft.Msagl.Core.Geometry.ApproximateComparer.CloseIntersections(intersectionPoint, a.get_Second())){
                var list;
                if (!(function (){
                    var $1 = {
                        Value: list
                    };
                    var $res = splittingPoints.TryGetValue(a, $1);
                    list = $1.Value;
                    return $res;
                }).call(this))
                    splittingPoints.set_Item$$TKey(a, list = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor));
                if (!list.Contains(intersectionPoint)){
                    list.Add(intersectionPoint);
                    return true;
                }
            }
            return false;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$PathFixer);
var Microsoft$Msagl$Routing$Spline$Bundling$PointPairOrder = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.PointPairOrder",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.Metrolines = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Metroline.ctor);
            this.orderFixed = false;
            this.LineIndexInOrder = null;
            System.Object.ctor.call(this);
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this.Metrolines.get_Count();
        },
        Add: function (metroline){
            this.Metrolines.Add(metroline);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$PointPairOrder);
var Microsoft$Msagl$Routing$Spline$Bundling$SimulatedAnnealing = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing.MaxIterations = 100;
            Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing.MaxStep = 50;
            Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing.MinStep = 1;
            Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing.MinRelativeChange = 0.0005;
        },
        FixRouting$$MetroGraphData$$BundlingSettings: function (metroGraphData, bundlingSettings){
            return Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing.FixRouting$$MetroGraphData$$BundlingSettings$$HashSet$1$Point(metroGraphData, bundlingSettings, null);
        },
        FixRouting$$MetroGraphData$$BundlingSettings$$HashSet$1$Point: function (metroGraphData, bundlingSettings, changedPoints){
            return new Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing.ctor(metroGraphData, bundlingSettings).FixRouting$$HashSet$1$Point(changedPoints);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (metroGraphData, bundlingSettings){
            this.metroGraphData = null;
            this.bundlingSettings = null;
            this.costCalculator = null;
            this.cache = null;
            this.stationsForOptimizations = null;
            this.stepsWithProgress = 0;
            System.Object.ctor.call(this);
            this.metroGraphData = metroGraphData;
            this.bundlingSettings = bundlingSettings;
            this.costCalculator = new Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.ctor(metroGraphData, bundlingSettings);
            this.cache = new Microsoft.Msagl.Routing.Spline.Bundling.IntersectionCache.ctor(metroGraphData, bundlingSettings, this.costCalculator, metroGraphData.Cdt);
        },
        FixRouting$$HashSet$1$Point: function (changedPoints){
            this.stationsForOptimizations = this.GetStationsForOptimizations(changedPoints);
            this.cache.InitializeCostCache();
            var step = 50;
            var energy = Infinity;
            var x = new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, this.metroGraphData.VirtualNodes(), $CreateAnonymousDelegate(this, function (v){
                return v.Position;
            })));
            var iteration = 0;
            while (iteration++ < 100){
                var coordinatesChanged = this.TryMoveNodes();
                if (iteration <= 1 && !coordinatesChanged)
                    return false;
                if (!coordinatesChanged)
                    break;
                var oldEnergy = energy;
                energy = Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.Cost(this.metroGraphData, this.bundlingSettings);
                step = this.UpdateMaxStep(step, oldEnergy, energy);
                var oldX = x;
                x = new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, this.metroGraphData.VirtualNodes(), $CreateAnonymousDelegate(this, function (v){
                    return v.Position;
                })));
                if (step < 1 || this.Converged(step, oldX, x))
                    break;
            }
            return true;
        },
        GetStationsForOptimizations: function (changedPoints){
            if (changedPoints == null){
                return new System.Collections.Generic.HashSet$1.ctor$$IEnumerable$1(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, this.metroGraphData.VirtualNodes());
            }
            else {
                var result = new System.Collections.Generic.HashSet$1.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor);
                var $it564 = changedPoints.GetEnumerator();
                while ($it564.MoveNext()){
                    var p = $it564.get_Current();
                    if (this.metroGraphData.PointToStations.ContainsKey(p)){
                        var s = this.metroGraphData.PointToStations.get_Item$$TKey(p);
                        if (!s.IsRealNode)
                            result.Add(s);
                    }
                }
                return result;
            }
        },
        Converged: function (step, oldx, newx){
            var num = 0,den = 0;
            for (var i = 0; i < oldx.get_Count(); i++){
                num += (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(oldx.get_Item$$Int32(i), newx.get_Item$$Int32(i))).get_LengthSquared();
                den += oldx.get_Item$$Int32(i).get_LengthSquared();
            }
            var res = System.Math.Sqrt(num / den);
            return (res < 0.0005);
        },
        UpdateMaxStep: function (step, oldEnergy, newEnergy){
            var T = 0.8;
            if (newEnergy + 1 < oldEnergy){
                this.stepsWithProgress++;
                if (this.stepsWithProgress >= 5){
                    this.stepsWithProgress = 0;
                    step = System.Math.Min$$Double$$Double(50, step / T);
                }
            }
            else {
                this.stepsWithProgress = 0;
                step *= T;
            }
            return step;
        },
        TryMoveNodes: function (){
            var coordinatesChanged = false;
            var movedStations = new System.Collections.Generic.HashSet$1.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor);
            var $it565 = this.stationsForOptimizations.GetEnumerator();
            while ($it565.MoveNext()){
                var node = $it565.get_Current();
                if (this.TryMoveNode(node)){
                    System.Diagnostics.Debug.Assert$$Boolean(this.stationsForOptimizations.Contains(node));
                    coordinatesChanged = true;
                    movedStations.Add(node);
                    for (var $i567 = 0,$t567 = node.Neighbors,$l567 = $t567.length,adj = $t567[$i567]; $i567 < $l567; $i567++, adj = $t567[$i567])
                        if (!adj.IsRealNode)
                            movedStations.Add(adj);
                }
            }
            this.stationsForOptimizations = movedStations;
            return coordinatesChanged;
        },
        TryMoveNode: function (node){
            var direction = this.BuildDirection(node);
            if (direction.get_Length() == 0)
                return false;
            var stepLength = this.BuildStepLength(node, direction);
            if (stepLength < 1){
                direction = Microsoft.Msagl.Core.Geometry.Point.RandomPoint();
                stepLength = this.BuildStepLength(node, direction);
                if (stepLength < 1)
                    return false;
            }
            var step = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(direction, stepLength);
            var newPosition = Microsoft.Msagl.Core.Geometry.Point.op_Addition(node.Position, step);
            if (this.metroGraphData.PointToStations.ContainsKey(newPosition))
                return false;
            this.metroGraphData.MoveNode(node, newPosition);
            this.cache.UpdateCostCache(node);
            return true;
        },
        BuildDirection: function (node){
            var forceInk = this.BuildForceForInk(node);
            var forcePL = this.BuildForceForPathLengths(node);
            var forceR = this.BuildForceForRadius(node);
            var forceBundle = this.BuildForceForBundle(node);
            var force = Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Addition(forceInk, forcePL), forceR), forceBundle);
            if (force.get_Length() < 0.1)
                return new Microsoft.Msagl.Core.Geometry.Point.ctor();
            force = force.Normalize();
            return force;
        },
        BuildStepLength: function (node, direction){
            var stepLength = 1;
            var costGain = this.CostGain(node, Microsoft.Msagl.Core.Geometry.Point.op_Addition(node.Position, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(direction, stepLength)));
            if (costGain < 0.01)
                return 0;
            while (2 * stepLength <= 50){
                var newCostGain = this.CostGain(node, Microsoft.Msagl.Core.Geometry.Point.op_Addition(node.Position, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(direction, stepLength), 2)));
                if (newCostGain <= costGain)
                    break;
                stepLength *= 2;
                costGain = newCostGain;
            }
            return stepLength;
        },
        CostGain: function (node, newPosition){
            var MInf = -12345678;
            var rGain = this.costCalculator.RadiusGain(node, newPosition);
            if (rGain < MInf)
                return MInf;
            var bundleGain = this.costCalculator.BundleGain(node, newPosition);
            if (bundleGain < MInf)
                return MInf;
            var inkGain = this.costCalculator.InkGain(node, newPosition);
            var plGain = this.costCalculator.PathLengthsGain(node, newPosition);
            return rGain + inkGain + plGain + bundleGain;
        },
        BuildForceForInk: function (node){
            var direction = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            for (var $i568 = 0,$t568 = node.Neighbors,$l568 = $t568.length,adj = $t568[$i568]; $i568 < $l568; $i568++, adj = $t568[$i568]){
                var p = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(adj.Position, node.Position));
                direction = Microsoft.Msagl.Core.Geometry.Point.op_Addition(direction, Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(p, p.get_Length()));
            }
            var force = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(direction, this.bundlingSettings.get_InkImportance());
            return force;
        },
        BuildForceForPathLengths: function (node){
            var direction = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            var $it568 = this.metroGraphData.MetroNodeInfosOfNode(node).GetEnumerator();
            while ($it568.MoveNext()){
                var mni = $it568.get_Current();
                var metroline = mni.get_Metroline();
                var u = mni.get_PolyPoint().get_Next().get_Point();
                var v = mni.get_PolyPoint().get_Prev().get_Point();
                var p1 = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(u, node.Position);
                var p2 = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v, node.Position);
                direction = Microsoft.Msagl.Core.Geometry.Point.op_Addition(direction, Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(p1, (p1.get_Length() * metroline.get_IdealLength())));
                direction = Microsoft.Msagl.Core.Geometry.Point.op_Addition(direction, Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(p2, (p2.get_Length() * metroline.get_IdealLength())));
            }
            var force = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(direction, this.bundlingSettings.get_PathLengthImportance());
            return force;
        },
        BuildForceForRadius: function (node){
            var direction = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            var idealR = node.cachedIdealRadius;
            var touchedObstacles;
            var res = (function (){
                var $1 = {
                    Value: touchedObstacles
                };
                var $res = this.metroGraphData.looseIntersections.HubAvoidsObstacles$$Station$$Point$$Double$$List$1(node, node.Position, idealR, $1);
                touchedObstacles = $1.Value;
                return $res;
            }).call(this);
            System.Diagnostics.Debug.Assert$$Boolean(res);
            var $it569 = touchedObstacles.GetEnumerator();
            while ($it569.MoveNext()){
                var d = $it569.get_Current();
                var dist = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(d.get_Item2(), node.Position)).get_Length();
                System.Diagnostics.Debug.Assert$$Boolean(dist <= idealR);
                var lforce = 2 * (1 - dist / idealR);
                var dir = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(node.Position, d.get_Item2())).Normalize();
                direction = Microsoft.Msagl.Core.Geometry.Point.op_Addition(direction, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(dir, lforce));
            }
            var force = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(direction, this.bundlingSettings.get_HubRepulsionImportance());
            return force;
        },
        BuildForceForBundle: function (node){
            var direction = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            for (var $i571 = 0,$t571 = node.Neighbors,$l571 = $t571.length,adj = $t571[$i571]; $i571 < $l571; $i571++, adj = $t571[$i571]){
                var idealWidth = this.metroGraphData.GetWidth$$Station$$Station$$Double(node, adj, this.bundlingSettings.get_EdgeSeparation());
                var closestPoints;
                var res = (function (){
                    var $1 = {
                        Value: closestPoints
                    };
                    var $res = this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(node, adj, node.Position, adj.Position, idealWidth / 2, $1);
                    closestPoints = $1.Value;
                    return $res;
                }).call(this);
                if (!res){
                }
                var $it571 = closestPoints.GetEnumerator();
                while ($it571.MoveNext()){
                    var d = $it571.get_Current();
                    var dist = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(d.get_Item1(), d.get_Item2())).get_Length();
                    System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.ApproximateComparer.LessOrEqual(dist, idealWidth / 2));
                    var lforce = 2 * (1 - dist / (idealWidth / 2));
                    var dir = Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(d.get_Item1(), d.get_Item2())).Normalize());
                    direction = Microsoft.Msagl.Core.Geometry.Point.op_Addition(direction, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(dir, lforce));
                }
            }
            var force = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(direction, this.bundlingSettings.get_BundleRepulsionImportance());
            return force;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$SimulatedAnnealing);
var Microsoft$Msagl$Routing$Spline$Bundling$Station = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.Station",
    baseTypeName: "System.Object",
    staticDefinition: {
        op_LessThan: function (a, b){
            System.Diagnostics.Debug.Assert$$Boolean(a == b || a.SerialNumber != b.SerialNumber);
            return a.SerialNumber < b.SerialNumber;
        },
        op_GreaterThan: function (a, b){
            System.Diagnostics.Debug.Assert$$Boolean(a == b || a.SerialNumber != b.SerialNumber);
            return a.SerialNumber > b.SerialNumber;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (serialNumber, isRealNode, position){
            this.SerialNumber = 0;
            this.IsRealNode = false;
            this.Radius = 0;
            this.Position = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.Neighbors = null;
            this.BundleBases = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Station.ctor, Microsoft.Msagl.Routing.Spline.Bundling.BundleBase.ctor);
            this.EnterableTightPolylines = null;
            this.EnterableLoosePolylines = null;
            this.MetroNodeInfos = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Spline.Bundling.MetroNodeInfo.ctor);
            this.BoundaryCurve = null;
            this.CdtTriangle = null;
            this.cachedRadiusCost = 0;
            this.cachedBundleCost = 0;
            this.cachedIdealRadius = 0;
            System.Object.ctor.call(this);
            this.SerialNumber = serialNumber;
            this.IsRealNode = isRealNode;
            this.Position = position;
        },
        AddEnterableLoosePolyline: function (poly){
            if (Microsoft.Msagl.Core.DataStructures.Set$1.op_Equality(this.EnterableLoosePolylines, null))
                this.EnterableLoosePolylines = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            this.EnterableLoosePolylines.Insert(poly);
        },
        AddEnterableTightPolyline: function (poly){
            if (Microsoft.Msagl.Core.DataStructures.Set$1.op_Equality(this.EnterableTightPolylines, null))
                this.EnterableTightPolylines = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            this.EnterableTightPolylines.Insert(poly);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$Station);
var Microsoft$Msagl$Routing$Spline$Bundling$StationEdgeInfo = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.StationEdgeInfo",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (iPos, jPos){
            this.Count = 0;
            this.Width = 0;
            this.Metrolines = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Spline.Bundling.Metroline.ctor);
            this.cachedBundleCost = 0;
            System.Object.ctor.call(this);
            var dir = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(jPos, iPos);
            var length = dir.get_Length();
            if (length > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                dir = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(dir, length);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$StationEdgeInfo);
var Microsoft$Msagl$Routing$Spline$Bundling$TimeMeasurer = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.TimeMeasurer",
    baseTypeName: "System.Object",
    staticDefinition: {
        Run$$Task: function (task){
            Microsoft.Msagl.Routing.Spline.Bundling.TimeMeasurer.Run$$String$$Task(Microsoft.Msagl.Routing.Spline.Bundling.TimeMeasurer.MethodName(task), task);
        },
        Run$$String$$Task: function (description, task){
        },
        MethodName: function (task){
            var tp = task.get_Target().GetType().get_DeclaringType();
            var cls = (tp != null ? tp.get_Name() : "");
            var method = task.get_Method().get_Name();
            if (method.length >= 4)
                method = method.substr(0, method.length - 4);
            if (cls.length > 0)
                return cls + "." + method;
            return method;
        },
        DebugOutput: function (str){
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$TimeMeasurer);
var Microsoft$Msagl$Routing$Spline$Bundling$TimeMeasurer$Task = {
    fullname: "Microsoft.Msagl.Routing.Spline.Bundling.TimeMeasurer.Task",
    Kind: "Delegate",
    definition: {
        ctor: function (obj, func){
            System.MulticastDelegate.ctor.call(this, obj, func);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$Bundling$TimeMeasurer$Task);
var Microsoft$Msagl$Routing$TightLooseCouple = {
    fullname: "Microsoft.Msagl.Routing.TightLooseCouple",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (tightPolyline, looseShape, distance){
            this._TightPolyline = null;
            this._LooseShape = null;
            this._Distance = 0;
            System.Object.ctor.call(this);
            this.set_TightPolyline(tightPolyline);
            this.set_LooseShape(looseShape);
            this.set_Distance(distance);
        },
        TightPolyline$$: "Microsoft.Msagl.Core.Geometry.Curves.Polyline",
        get_TightPolyline: function (){
            return this._TightPolyline;
        },
        set_TightPolyline: function (value){
            this._TightPolyline = value;
        },
        LooseShape$$: "Microsoft.Msagl.Routing.Shape",
        get_LooseShape: function (){
            return this._LooseShape;
        },
        set_LooseShape: function (value){
            this._LooseShape = value;
        },
        Distance$$: "System.Double",
        get_Distance: function (){
            return this._Distance;
        },
        set_Distance: function (value){
            this._Distance = value;
        },
        GetHashCode: function (){
            if (this.get_TightPolyline() == null)
                throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            return this.get_TightPolyline().GetHashCode();
        },
        Equals$$Object: function (obj){
            var couple = As(obj, Microsoft.Msagl.Routing.TightLooseCouple.ctor);
            if (couple == null)
                return false;
            return this.get_TightPolyline() == couple.get_TightPolyline();
        },
        toString: function (){
            return (this.get_TightPolyline() == null ? "null" : this.get_TightPolyline().toString().substr(0, 5)) + "," + (this.get_LooseShape() == null ? "null" : this.get_LooseShape().toString().substr(0, 5));
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$TightLooseCouple);
var Microsoft$Msagl$Routing$StraightLineEdges = {
    fullname: "Microsoft.Msagl.Routing.StraightLineEdges",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        },
        RouteEdge: function (edge, padding){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(edge, "edge");
            var eg = edge.get_EdgeGeometry();
            if (eg.get_SourcePort() == null){
                eg.set_SourcePort((function (ed){
                    return new Microsoft.Msagl.Core.Layout.RelativeFloatingPort.ctor$$Func$1$ICurve$$Func$1$Point(function (){
                        return ed.get_Source().get_BoundaryCurve();
                    }, function (){
                        return ed.get_Source().get_Center();
                    });
                })(edge));
            }
            if (eg.get_TargetPort() == null){
                eg.set_TargetPort((function (ed){
                    return new Microsoft.Msagl.Core.Layout.RelativeFloatingPort.ctor$$Func$1$ICurve$$Func$1$Point(function (){
                        return ed.get_Target().get_BoundaryCurve();
                    }, function (){
                        return ed.get_Target().get_Center();
                    });
                })(edge));
            }
            if (!Microsoft.Msagl.Routing.StraightLineEdges.ContainmentLoop(eg, padding)){
                eg.set_Curve(Microsoft.Msagl.Routing.StraightLineEdges.GetEdgeLine(edge));
            }
            Microsoft.Msagl.Core.Layout.Arrowheads.TrimSplineAndCalculateArrowheads$$EdgeGeometry$$ICurve$$ICurve$$ICurve$$Boolean$$Boolean(eg, eg.get_SourcePort().get_Curve(), eg.get_TargetPort().get_Curve(), edge.get_Curve(), false, false);
        },
        ContainmentLoop: function (eg, padding){
            var sourceCurve = eg.get_SourcePort().get_Curve();
            var targetCurve = eg.get_TargetPort().get_Curve();
            if (sourceCurve == null || targetCurve == null)
                return false;
            var targetBox = sourceCurve.get_BoundingBox();
            var sourceBox = targetCurve.get_BoundingBox();
            var targetInSource = targetBox.Contains$$Rectangle(sourceBox);
            var sourceInTarget = (!targetInSource) && sourceBox.Contains$$Rectangle(targetBox);
            if (targetInSource || sourceInTarget){
                eg.set_Curve(Microsoft.Msagl.Routing.StraightLineEdges.CreateLoop$$Rectangle$$Rectangle$$Boolean$$Double(targetBox, sourceBox, sourceInTarget, padding));
                return true;
            }
            return false;
        },
        CreateLoop$$Rectangle$$Rectangle$$Boolean$$Double: function (targetBox, sourceBox, sourceContainsTarget, padding){
            return sourceContainsTarget ? Microsoft.Msagl.Routing.StraightLineEdges.CreateLoop$$Rectangle$$Rectangle$$Double$$Boolean(targetBox, sourceBox, padding, false) : Microsoft.Msagl.Routing.StraightLineEdges.CreateLoop$$Rectangle$$Rectangle$$Double$$Boolean(sourceBox, targetBox, padding, true);
        },
        CreateLoop$$Rectangle$$Rectangle$$Double$$Boolean: function (sourceBox, targetBox, howMuchToStickOut, reverse){
            var center = sourceBox.get_Center();
            var closestPoint = Microsoft.Msagl.Routing.StraightLineEdges.FindClosestPointOnBoxBoundary(sourceBox.get_Center(), targetBox);
            var dir = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(closestPoint, center);
            var vert = System.Math.Abs$$Double(dir.get_X()) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon;
            var maxWidth = (vert ? System.Math.Min$$Double$$Double(center.get_Y() - targetBox.get_Bottom(), targetBox.get_Top() - center.get_Y()) : System.Math.Min$$Double$$Double(center.get_X() - targetBox.get_Left(), targetBox.get_Right() - center.get_X())) / 2;
            var width = System.Math.Min$$Double$$Double(howMuchToStickOut, maxWidth);
            if (dir.get_Length() <= Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                dir = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(1, 0);
            var hookDir = dir.Normalize();
            var hookPerp = hookDir.Rotate(1.5707963267949);
            var p1 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(closestPoint, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(hookDir, howMuchToStickOut));
            var p2 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(p1, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(hookPerp, width));
            var p3 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(closestPoint, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(hookPerp, width));
            var end = Microsoft.Msagl.Core.Geometry.Point.op_Addition(center, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(hookPerp, width));
            var smoothedPoly = reverse ? Microsoft.Msagl.Core.Geometry.SmoothedPolyline.FromPoints([end, p3, p2, p1, closestPoint, center]) : Microsoft.Msagl.Core.Geometry.SmoothedPolyline.FromPoints([center, closestPoint, p1, p2, p3, end]);
            return smoothedPoly.CreateCurve();
        },
        FindClosestPointOnBoxBoundary: function (c, targetBox){
            var x = c.get_X() - targetBox.get_Left() < targetBox.get_Right() - c.get_X() ? targetBox.get_Left() : targetBox.get_Right();
            var y = c.get_Y() - targetBox.get_Bottom() < targetBox.get_Top() - c.get_Y() ? targetBox.get_Bottom() : targetBox.get_Top();
            return System.Math.Abs$$Double(x - c.get_X()) < System.Math.Abs$$Double(y - c.get_Y()) ? new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x, c.get_Y()) : new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(c.get_X(), y);
        },
        GetEdgeLine: function (edge){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(edge, "edge");
            var sourcePoint;
            var sourceBox;
            if (edge.get_SourcePort() == null){
                sourcePoint = edge.get_Source().get_Center();
                sourceBox = edge.get_Source().get_BoundaryCurve();
            }
            else {
                sourcePoint = edge.get_SourcePort().get_Location();
                sourceBox = edge.get_SourcePort().get_Curve();
            }
            var targetPoint;
            var targetBox;
            if (edge.get_TargetPort() == null){
                targetPoint = edge.get_Target().get_Center();
                targetBox = edge.get_Target().get_BoundaryCurve();
            }
            else {
                targetPoint = edge.get_TargetPort().get_Location();
                targetBox = edge.get_TargetPort().get_Curve();
            }
            var line = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(sourcePoint, targetPoint);
            var intersects = Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(sourceBox, line, false);
            if (intersects.get_Count() > 0){
                var trimmedLine = Cast(line.Trim(intersects.get_Item$$Int32(0).get_Par1(), 1), Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor);
                if (trimmedLine != null){
                    line = trimmedLine;
                    intersects = Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(targetBox, line, false);
                    if (intersects.get_Count() > 0){
                        trimmedLine = Cast(line.Trim(0, intersects.get_Item$$Int32(0).get_Par1()), Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor);
                        if (trimmedLine != null){
                            line = trimmedLine;
                        }
                    }
                }
            }
            return line;
        },
        CreateSimpleEdgeCurveWithUnderlyingPolyline: function (edge){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(edge, "edge");
            var a = edge.get_Source().get_Center();
            var b = edge.get_Target().get_Center();
            if (edge.get_Source() == edge.get_Target()){
                var dx = 0.666666666666667 * edge.get_Source().get_BoundaryCurve().get_BoundingBox().get_Width();
                var dy = edge.get_Source().get_BoundingBox().get_Height() / 4;
                edge.set_UnderlyingPolyline(Microsoft.Msagl.Routing.StraightLineEdges.CreateUnderlyingPolylineForSelfEdge(a, dx, dy));
                edge.set_Curve(edge.get_UnderlyingPolyline().CreateCurve());
            }
            else {
                edge.set_UnderlyingPolyline(Microsoft.Msagl.Core.Geometry.SmoothedPolyline.FromPoints([a, b]));
                edge.set_Curve(edge.get_UnderlyingPolyline().CreateCurve());
            }
            Microsoft.Msagl.Core.Layout.Arrowheads.TrimSplineAndCalculateArrowheads$$EdgeGeometry$$ICurve$$ICurve$$ICurve$$Boolean$$Boolean(edge.get_EdgeGeometry(), edge.get_Source().get_BoundaryCurve(), edge.get_Target().get_BoundaryCurve(), edge.get_Curve(), false, false);
        },
        CreateUnderlyingPolylineForSelfEdge: function (p0, dx, dy){
            var p1 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(p0, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, dy));
            var p2 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(p0, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(dx, dy));
            var p3 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(p0, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(dx, -dy));
            var p4 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(p0, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, -dy));
            var site = new Microsoft.Msagl.Core.Geometry.Site.ctor$$Point(p0);
            var polyline = new Microsoft.Msagl.Core.Geometry.SmoothedPolyline.ctor(site);
            site = new Microsoft.Msagl.Core.Geometry.Site.ctor$$Site$$Point(site, p1);
            site = new Microsoft.Msagl.Core.Geometry.Site.ctor$$Site$$Point(site, p2);
            site = new Microsoft.Msagl.Core.Geometry.Site.ctor$$Site$$Point(site, p3);
            site = new Microsoft.Msagl.Core.Geometry.Site.ctor$$Site$$Point(site, p4);
            new Microsoft.Msagl.Core.Geometry.Site.ctor$$Site$$Point(site, p0);
            return polyline;
        },
        SetStraightLineEdgesWithUnderlyingPolylines: function (graph){
            Microsoft.Msagl.Routing.SplineRouter.CreatePortsIfNeeded(graph.get_Edges());
            var $it573 = graph.get_Edges().GetEnumerator();
            while ($it573.MoveNext()){
                var edge = $it573.get_Current();
                Microsoft.Msagl.Routing.StraightLineEdges.CreateSimpleEdgeCurveWithUnderlyingPolyline(edge);
            }
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (edges, padding){
            this.edges = null;
            this.padding = 0;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.edges = edges;
            this.padding = padding;
        },
        RunInternal: function (){
            this.StartListenToLocalProgress(System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Edge.ctor, this.edges), 1);
            Microsoft.Msagl.Routing.SplineRouter.CreatePortsIfNeeded(this.edges);
            var $it572 = this.edges.GetEnumerator();
            while ($it572.MoveNext()){
                var edge = $it572.get_Current();
                Microsoft.Msagl.Routing.StraightLineEdges.RouteEdge(edge, this.padding);
                this.ProgressStep();
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$StraightLineEdges);
var Microsoft$Msagl$Core$GraphAlgorithms$ConnectedComponentCalculator$1 = {
    fullname: "Microsoft.Msagl.Core.GraphAlgorithms.ConnectedComponentCalculator$1",
    baseTypeName: "System.Object",
    staticDefinition: {
        GetComponents: function (graph){
            var $yield = [];
            var enqueueed = new Array(graph.get_NodeCount());
            for (var i = 0; i < graph.get_NodeCount(); i++)
                enqueueed[i] = false;
            var queue = new System.Collections.Generic.Queue$1.ctor(System.Int32.ctor);
            for (var i = 0; i < graph.get_NodeCount(); i++){
                if (!enqueueed[i]){
                    var nodes = new System.Collections.Generic.List$1.ctor(System.Int32.ctor);
                    Microsoft.Msagl.Core.GraphAlgorithms.ConnectedComponentCalculator$1.Enqueue(i, queue, enqueueed);
                    while (queue.get_Count() > 0){
                        var s = queue.Dequeue();
                        nodes.Add(s);
                        var $it574 = Microsoft.Msagl.Core.GraphAlgorithms.ConnectedComponentCalculator$1.Neighbors(graph, s).GetEnumerator();
                        while ($it574.MoveNext()){
                            var neighbor = $it574.get_Current();
                            Microsoft.Msagl.Core.GraphAlgorithms.ConnectedComponentCalculator$1.Enqueue(neighbor, queue, enqueueed);
                        }
                    }
                    $yield.push(nodes);
                }
            }
            return $yield;
        },
        Neighbors: function (graph, s){
            var $yield = [];
            var $it575 = graph.OutEdges(s).GetEnumerator();
            while ($it575.MoveNext()){
                var e = $it575.get_Current();
                $yield.push(e.get_Target());
            }
            var $it576 = graph.InEdges(s).GetEnumerator();
            while ($it576.MoveNext()){
                var e = $it576.get_Current();
                $yield.push(e.get_Source());
            }
            return $yield;
        },
        Enqueue: function (i, q, enqueueed){
            if (enqueueed[i] == false){
                q.Enqueue(i);
                enqueueed[i] = true;
            }
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (TEdge){
            this.TEdge = TEdge;
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$GraphAlgorithms$ConnectedComponentCalculator$1);
var Microsoft$Msagl$Core$GraphAlgorithms$CycleRemoval$1 = {
    fullname: "Microsoft.Msagl.Core.GraphAlgorithms.CycleRemoval$1",
    baseTypeName: "System.Object",
    staticDefinition: {
        GetFeedbackSetWithConstraints: function (graph, constraints){
            if (Microsoft.Msagl.Core.DataStructures.Set$1.op_Equality(constraints, null) || constraints.get_Count() == 0){
                return Microsoft.Msagl.Core.GraphAlgorithms.CycleRemoval$1.GetFeedbackSet(graph);
            }
            else
                return Microsoft.Msagl.Core.GraphAlgorithms.CycleRemoval$1.GetFeedbackSetWithConstraintsLocal(graph, constraints);
        },
        GetFeedbackSetWithConstraintsLocal: function (graph, constraints){
            var v = new Microsoft.Msagl.Core.GraphAlgorithms.CycleRemovalWithConstraints$1.ctor(this.TEdge, graph, constraints);
            return v.GetFeedbackSet();
        },
        Push: function (enumStack, vertexStack, status, vertex, outEnum){
            status[vertex] = Microsoft.Msagl.Core.GraphAlgorithms.CycleRemoval.VertStatus$1.InStack;
            enumStack.Push(outEnum);
            vertexStack.Push(vertex);
        },
        Pop: function (enumStack, vertexStack, status, vertex, outEnum){
            outEnum.Value = enumStack.Pop();
            vertex.Value = vertexStack.Pop();
            status[vertex.Value] = Microsoft.Msagl.Core.GraphAlgorithms.CycleRemoval.VertStatus$1.Visited;
        },
        GetFeedbackSet: function (graph){
            if (graph != null && graph.get_NodeCount() > 0 && graph.get_Edges().get_Count() > 0){
                var feedbackSet = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.GraphAlgorithms.IEdge.ctor);
                var status = new Array(graph.get_NodeCount());
                for (var i = 0; i < status.length; i++)
                    status[i] = Microsoft.Msagl.Core.GraphAlgorithms.CycleRemoval.VertStatus$1.NotVisited;
                for (var vertex = 0; vertex < graph.get_NodeCount(); vertex++){
                    if (status[vertex] == Microsoft.Msagl.Core.GraphAlgorithms.CycleRemoval.VertStatus$1.Visited)
                        continue;
                    System.Diagnostics.Debug.Assert$$Boolean(status[vertex] != Microsoft.Msagl.Core.GraphAlgorithms.CycleRemoval.VertStatus$1.InStack);
                    var enumStack = new System.Collections.Generic.Stack$1.ctor(System.Collections.Generic.IEnumerator$1.ctor);
                    var vertexStack = new System.Collections.Generic.Stack$1.ctor(System.Int32.ctor);
                    var outEnum = graph.OutEdges(vertex).GetEnumerator();
                    Microsoft.Msagl.Core.GraphAlgorithms.CycleRemoval$1.Push(enumStack, vertexStack, status, vertex, outEnum);
                    while (enumStack.get_Count() > 0){
                        (function (){
                            var $1 = {
                                Value: vertex
                            };
                            var $2 = {
                                Value: outEnum
                            };
                            var $res = Microsoft.Msagl.Core.GraphAlgorithms.CycleRemoval$1.Pop(enumStack, vertexStack, status, $1, $2);
                            vertex = $1.Value;
                            outEnum = $2.Value;
                            return $res;
                        })();
                        while (outEnum.MoveNext()){
                            var e = outEnum.get_Current();
                            if (e.get_Source() == e.get_Target())
                                continue;
                            var targetStatus = status[e.get_Target()];
                            if (targetStatus == Microsoft.Msagl.Core.GraphAlgorithms.CycleRemoval.VertStatus$1.InStack){
                                feedbackSet.Insert(e);
                            }
                            else if (targetStatus == Microsoft.Msagl.Core.GraphAlgorithms.CycleRemoval.VertStatus$1.NotVisited){
                                Microsoft.Msagl.Core.GraphAlgorithms.CycleRemoval$1.Push(enumStack, vertexStack, status, vertex, outEnum);
                                vertex = e.get_Target();
                                status[e.get_Target()] = Microsoft.Msagl.Core.GraphAlgorithms.CycleRemoval.VertStatus$1.Visited;
                                outEnum = graph.OutEdges(vertex).GetEnumerator();
                            }
                        }
                    }
                }
                return As(feedbackSet, System.Collections.Generic.IEnumerable$1.ctor);
            }
            else
                return new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.GraphAlgorithms.IEdge.ctor);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (TEdge){
            this.TEdge = TEdge;
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$GraphAlgorithms$CycleRemoval$1);
var Microsoft$Msagl$Core$GraphAlgorithms$CycleRemoval$VertStatus$1 = {
    fullname: "Microsoft.Msagl.Core.GraphAlgorithms.CycleRemoval.VertStatus$1",
    staticDefinition: {
        NotVisited: 0,
        InStack: 1,
        Visited: 2
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Core$GraphAlgorithms$CycleRemoval$VertStatus$1);
var Microsoft$Msagl$Core$GraphAlgorithms$CycleRemovalWithConstraints$1 = {
    fullname: "Microsoft.Msagl.Core.GraphAlgorithms.CycleRemovalWithConstraints$1",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (TEdge, graph, constraints){
            this.TEdge = TEdge;
            this.graph = null;
            this.graphOfConstraints = null;
            this.constrainedEdges = null;
            System.Object.ctor.call(this);
            this.graph = graph;
            this.constrainedEdges = constraints;
            this.graphOfConstraints = new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor$$IEnumerable$1$$Int32(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, this.constrainedEdges, graph.get_NodeCount());
        },
        GetFeedbackSet: function (){
            var $yield = [];
            var $it577 = this.CreateGraphsForCycleRemoval().GetEnumerator();
            while ($it577.MoveNext()){
                var graphForCycleRemoval = $it577.get_Current();
                var $it578 = this.GetFeedbackEdgeSet(graphForCycleRemoval).GetEnumerator();
                while ($it578.MoveNext()){
                    var edge = $it578.get_Current();
                    $yield.push(edge);
                }
            }
            return $yield;
        },
        GetFeedbackEdgeSet: function (graphForCycleRemoval){
            var $yield = [];
            graphForCycleRemoval.Initialize();
            var sl = new System.Collections.Generic.List$1.ctor(System.Int32.ctor);
            var sr = new System.Collections.Generic.List$1.ctor(System.Int32.ctor);
            while (!graphForCycleRemoval.IsEmpty()){
                var u;
                while ((function (){
                    var $1 = {
                        Value: u
                    };
                    var $res = graphForCycleRemoval.TryGetSink($1);
                    u = $1.Value;
                    return $res;
                }).call(this)){
                    graphForCycleRemoval.RemoveNode(u);
                    sr.Add(u);
                }
                while ((function (){
                    var $1 = {
                        Value: u
                    };
                    var $res = graphForCycleRemoval.TryGetSource($1);
                    u = $1.Value;
                    return $res;
                }).call(this)){
                    graphForCycleRemoval.RemoveNode(u);
                    sl.Add(u);
                }
                if ((function (){
                    var $1 = {
                        Value: u
                    };
                    var $res = graphForCycleRemoval.TryFindVertexWithNoIncomingConstrainedEdgeAndMaximumOutDegreeMinusInDedree($1);
                    u = $1.Value;
                    return $res;
                }).call(this)){
                    graphForCycleRemoval.RemoveNode(u);
                    sl.Add(u);
                }
            }
            var S = new System.Collections.Generic.Dictionary$2.ctor$$Int32(System.Int32.ctor, System.Int32.ctor, sl.get_Count() + sr.get_Count());
            var j = 0;
            var $it579 = sl.GetEnumerator();
            while ($it579.MoveNext()){
                var u = $it579.get_Current();
                S.set_Item$$TKey(u, j++);
            }
            for (var i = sr.get_Count() - 1; i >= 0; i--)
                S.set_Item$$TKey(sr.get_Item$$Int32(i), j++);
            var $it580 = graphForCycleRemoval.GetOriginalIntPairs().GetEnumerator();
            while ($it580.MoveNext()){
                var pair = $it580.get_Current();
                if (S.get_Item$$TKey(pair.get_First()) > S.get_Item$$TKey(pair.get_Second()))
                    $yield.push(pair);
            }
            return $yield;
        },
        CreateGraphsForCycleRemoval: function (){
            var $yield = [];
            var $it581 = Microsoft.Msagl.Core.GraphAlgorithms.ConnectedComponentCalculator$1.GetComponents(this.GetCommonGraph()).GetEnumerator();
            while ($it581.MoveNext()){
                var componentNodes = $it581.get_Current();
                $yield.push(this.CreateGraphForCycleRemoval(componentNodes));
            }
            return $yield;
        },
        GetCommonGraph: function (){
            return new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor$$IEnumerable$1$$Int32(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, (System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(this.TEdge, Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, this.graph.get_Edges(), $CreateAnonymousDelegate(this, function (edge){
                return new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(edge.get_Source(), edge.get_Target());
            }))), this.constrainedEdges), this.graph.get_NodeCount());
        },
        CreateGraphForCycleRemoval: function (componentNodes){
            var graphForCycleRemoval = new Microsoft.Msagl.Core.GraphAlgorithms.GraphForCycleRemoval.ctor();
            var $it582 = componentNodes.GetEnumerator();
            while ($it582.MoveNext()){
                var i = $it582.get_Current();
                var $it583 = this.graph.OutEdges(i).GetEnumerator();
                while ($it583.MoveNext()){
                    var edge = $it583.get_Current();
                    graphForCycleRemoval.AddEdge(new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(edge.get_Source(), edge.get_Target()));
                }
                var $it584 = this.graphOfConstraints.OutEdges(i).GetEnumerator();
                while ($it584.MoveNext()){
                    var intPair = $it584.get_Current();
                    graphForCycleRemoval.AddConstraintEdge(intPair);
                }
            }
            return graphForCycleRemoval;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$GraphAlgorithms$CycleRemovalWithConstraints$1);
var Microsoft$Msagl$Core$GraphAlgorithms$GraphForCycleRemoval = {
    fullname: "Microsoft.Msagl.Core.GraphAlgorithms.GraphForCycleRemoval",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.deltaDegreeBucketsForSourcesInConstrainedSubgraph = new System.Collections.Generic.SortedDictionary$2.ctor(System.Int32.ctor, Microsoft.Msagl.Core.DataStructures.Set$1.ctor);
            this.nodeInfoDictionary = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, Microsoft.Msagl.Core.GraphAlgorithms.NodeInfo.ctor);
            this.sources = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(System.Int32.ctor);
            this.sinks = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(System.Int32.ctor);
            this.edgesToKeep = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor);
            System.Object.ctor.call(this);
        },
        AddEdge: function (edge){
            this.edgesToKeep.Insert(edge);
            var source = edge.get_First();
            var target = edge.get_Second();
            this.GetOrCreateNodeInfo(source).AddOutEdge(target);
            this.GetOrCreateNodeInfo(target).AddInEdge(source);
        },
        GetOrCreateNodeInfo: function (node){
            var nodeInfo;
            if (!(function (){
                var $1 = {
                    Value: nodeInfo
                };
                var $res = this.nodeInfoDictionary.TryGetValue(node, $1);
                nodeInfo = $1.Value;
                return $res;
            }).call(this)){
                nodeInfo = new Microsoft.Msagl.Core.GraphAlgorithms.NodeInfo.ctor();
                this.nodeInfoDictionary.set_Item$$TKey(node, nodeInfo);
            }
            return nodeInfo;
        },
        AddConstraintEdge: function (intPair){
            var source = intPair.get_First();
            var target = intPair.get_Second();
            this.GetOrCreateNodeInfo(source).AddOutConstrainedEdge(target);
            this.GetOrCreateNodeInfo(target).AddInConstrainedEdge(source);
        },
        IsEmpty: function (){
            return this.nodeInfoDictionary.get_Count() == 0;
        },
        RemoveNode: function (u){
            this.sources.Remove(u);
            this.sinks.Remove(u);
            this.RemoveNodeFromItsBucket(u);
            var uNodeInfo = this.nodeInfoDictionary.get_Item$$TKey(u);
            var allNbs = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(System.Int32.ctor, uNodeInfo.get_AllNeighbors());
            var $it585 = allNbs.GetEnumerator();
            while ($it585.MoveNext()){
                var v = $it585.get_Current();
                this.RemoveNodeFromItsBucket(v);
            }
            this.DisconnectNodeFromGraph(u, uNodeInfo);
            var $it586 = allNbs.GetEnumerator();
            while ($it586.MoveNext()){
                var v = $it586.get_Current();
                this.AddNodeToBucketsSourcesAndSinks(v, this.nodeInfoDictionary.get_Item$$TKey(v));
            }
        },
        DisconnectNodeFromGraph: function (u, uNodeInfo){
            var $it587 = uNodeInfo.get_OutEdges().GetEnumerator();
            while ($it587.MoveNext()){
                var v = $it587.get_Current();
                this.nodeInfoDictionary.get_Item$$TKey(v).RemoveInEdge(u);
            }
            var $it588 = uNodeInfo.get_OutConstrainedEdges().GetEnumerator();
            while ($it588.MoveNext()){
                var v = $it588.get_Current();
                this.nodeInfoDictionary.get_Item$$TKey(v).RemoveInConstrainedEdge(u);
            }
            var $it589 = uNodeInfo.get_InEdges().GetEnumerator();
            while ($it589.MoveNext()){
                var v = $it589.get_Current();
                this.nodeInfoDictionary.get_Item$$TKey(v).RemoveOutEdge(u);
            }
            var $it590 = uNodeInfo.get_InConstrainedEdges().GetEnumerator();
            while ($it590.MoveNext()){
                var v = $it590.get_Current();
                this.nodeInfoDictionary.get_Item$$TKey(v).RemoveOutConstrainedEdge(u);
            }
            this.nodeInfoDictionary.Remove(u);
        },
        RemoveNodeFromItsBucket: function (v){
            var delta = this.DeltaDegree(v);
            var bucket;
            if ((function (){
                var $1 = {
                    Value: bucket
                };
                var $res = this.deltaDegreeBucketsForSourcesInConstrainedSubgraph.TryGetValue(delta, $1);
                bucket = $1.Value;
                return $res;
            }).call(this)){
                bucket.Remove(v);
                if (bucket.get_Count() == 0)
                    this.deltaDegreeBucketsForSourcesInConstrainedSubgraph.Remove(delta);
            }
        },
        DeltaDegree: function (v){
            var delta = this.nodeInfoDictionary.get_Item$$TKey(v).get_DeltaDegree();
            return delta;
        },
        TryFindVertexWithNoIncomingConstrainedEdgeAndMaximumOutDegreeMinusInDedree: function (u){
            var enumerator = this.deltaDegreeBucketsForSourcesInConstrainedSubgraph.GetEnumerator();
            if (enumerator.MoveNext()){
                var bucketSet = enumerator.get_Current().get_Value();
                System.Diagnostics.Debug.Assert$$Boolean(bucketSet.get_Count() > 0);
                var nodeEnumerator = bucketSet.GetEnumerator();
                nodeEnumerator.MoveNext();
                u.Value = nodeEnumerator.get_Current();
                return true;
            }
            u.Value = -1;
            return false;
        },
        TryGetSource: function (u){
            var enumerator = this.sources.GetEnumerator();
            if (enumerator.MoveNext()){
                u.Value = enumerator.get_Current();
                return true;
            }
            u.Value = -1;
            return false;
        },
        TryGetSink: function (u){
            var enumerator = this.sinks.GetEnumerator();
            if (enumerator.MoveNext()){
                u.Value = enumerator.get_Current();
                return true;
            }
            u.Value = -1;
            return false;
        },
        GetOriginalIntPairs: function (){
            return this.edgesToKeep;
        },
        Initialize: function (){
            var $it591 = this.nodeInfoDictionary.GetEnumerator();
            while ($it591.MoveNext()){
                var p = $it591.get_Current();
                this.AddNodeToBucketsSourcesAndSinks(p.get_Key(), p.get_Value());
            }
        },
        AddNodeToBucketsSourcesAndSinks: function (v, nodeInfo){
            if (nodeInfo.get_InDegree() == 0)
                this.sources.Insert(v);
            else if (nodeInfo.get_OutDegree() == 0)
                this.sinks.Insert(v);
            else if (nodeInfo.get_InDegreeOfConstrainedEdges() == 0)
                this.GetOrCreateBucket(nodeInfo.get_DeltaDegree()).Insert(v);
        },
        GetOrCreateBucket: function (delta){
            var ret;
            if ((function (){
                var $1 = {
                    Value: ret
                };
                var $res = this.deltaDegreeBucketsForSourcesInConstrainedSubgraph.TryGetValue(delta, $1);
                ret = $1.Value;
                return $res;
            }).call(this))
                return ret;
            return (function ($p35){
                this.deltaDegreeBucketsForSourcesInConstrainedSubgraph.set_Item$$TKey(delta, $p35);
                return $p35;
            }).call(this, new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(System.Int32.ctor));
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$GraphAlgorithms$GraphForCycleRemoval);
var Microsoft$Msagl$Core$GraphAlgorithms$NodeInfo = {
    fullname: "Microsoft.Msagl.Core.GraphAlgorithms.NodeInfo",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.outEdges = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(System.Int32.ctor);
            this.inEdges = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(System.Int32.ctor);
            this.outConstrainedEdges = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(System.Int32.ctor);
            this.inConstrainedEdges = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(System.Int32.ctor);
            System.Object.ctor.call(this);
        },
        OutEdges$$: "Microsoft.Msagl.Core.DataStructures.Set`1[[System.Int32]]",
        get_OutEdges: function (){
            return this.outEdges;
        },
        InEdges$$: "Microsoft.Msagl.Core.DataStructures.Set`1[[System.Int32]]",
        get_InEdges: function (){
            return this.inEdges;
        },
        OutConstrainedEdges$$: "Microsoft.Msagl.Core.DataStructures.Set`1[[System.Int32]]",
        get_OutConstrainedEdges: function (){
            return this.outConstrainedEdges;
        },
        InConstrainedEdges$$: "Microsoft.Msagl.Core.DataStructures.Set`1[[System.Int32]]",
        get_InConstrainedEdges: function (){
            return this.inConstrainedEdges;
        },
        DeltaDegree$$: "System.Int32",
        get_DeltaDegree: function (){
            return this.get_InDegree() - this.get_OutDegree();
        },
        AddOutEdge: function (v){
            this.outEdges.Insert(v);
        },
        RemoveOutEdge: function (v){
            this.outEdges.Remove(v);
        },
        AddInEdge: function (v){
            this.inEdges.Insert(v);
        },
        RemoveInEdge: function (v){
            this.inEdges.Remove(v);
        },
        AddOutConstrainedEdge: function (v){
            this.outConstrainedEdges.Insert(v);
        },
        RemoveOutConstrainedEdge: function (v){
            this.outConstrainedEdges.Remove(v);
        },
        AddInConstrainedEdge: function (v){
            this.inConstrainedEdges.Insert(v);
        },
        RemoveInConstrainedEdge: function (v){
            this.inConstrainedEdges.Remove(v);
        },
        OutDegree$$: "System.Int32",
        get_OutDegree: function (){
            return this.outEdges.get_Count() + this.outConstrainedEdges.get_Count();
        },
        InDegreeOfConstrainedEdges$$: "System.Int32",
        get_InDegreeOfConstrainedEdges: function (){
            return this.inConstrainedEdges.get_Count();
        },
        InDegree$$: "System.Int32",
        get_InDegree: function (){
            return this.inEdges.get_Count() + this.inConstrainedEdges.get_Count();
        },
        AllNeighbors$$: "System.Collections.Generic.IEnumerable`1[[System.Int32]]",
        get_AllNeighbors: function (){
            var $yield = [];
            var $it592 = this.get_OutConstrainedEdges().GetEnumerator();
            while ($it592.MoveNext()){
                var v = $it592.get_Current();
                $yield.push(v);
            }
            var $it593 = this.get_InConstrainedEdges().GetEnumerator();
            while ($it593.MoveNext()){
                var v = $it593.get_Current();
                $yield.push(v);
            }
            var $it594 = this.get_OutEdges().GetEnumerator();
            while ($it594.MoveNext()){
                var v = $it594.get_Current();
                $yield.push(v);
            }
            var $it595 = this.get_InEdges().GetEnumerator();
            while ($it595.MoveNext()){
                var v = $it595.get_Current();
                $yield.push(v);
            }
            return $yield;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$GraphAlgorithms$NodeInfo);
var Microsoft$Msagl$Layout$Layered$LayeredLayout = {
    fullname: "Microsoft.Msagl.Layout.Layered.LayeredLayout",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        },
        PreRunTransform: function (geomGraph, matrix){
            if (matrix.get_IsIdentity())
                return;
            var m = matrix.get_Inverse();
            var $it596 = geomGraph.get_Nodes().GetEnumerator();
            while ($it596.MoveNext()){
                var n = $it596.get_Current();
                n.Transform(m);
            }
            var $it597 = geomGraph.get_Edges().GetEnumerator();
            while ($it597.MoveNext()){
                var e = $it597.get_Current();
                if (e.get_Label() != null){
                    e.set_OriginalLabelWidth(e.get_Label().get_Width());
                    e.set_OriginalLabelHeight(e.get_Label().get_Height());
                    var r = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(m, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, 0)), Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(m, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(e.get_Label().get_Width(), e.get_Label().get_Height())));
                    e.get_Label().set_Width(r.get_Width());
                    e.get_Label().set_Height(r.get_Height());
                }
            }
            geomGraph.UpdateBoundingBox();
        },
        PostRunTransform: function (geometryGraph, transformation){
            var transform = !transformation.get_IsIdentity();
            if (transform){
                var $it598 = geometryGraph.get_Nodes().GetEnumerator();
                while ($it598.MoveNext()){
                    var n = $it598.get_Current();
                    n.Transform(transformation);
                }
                var $it599 = geometryGraph.get_Edges().GetEnumerator();
                while ($it599.MoveNext()){
                    var e = $it599.get_Current();
                    if (e.get_Label() != null){
                        e.get_Label().set_Width(e.get_OriginalLabelWidth());
                        e.get_Label().set_Height(e.get_OriginalLabelHeight());
                    }
                }
                Microsoft.Msagl.Layout.Layered.LayeredLayout.TransformCurves(geometryGraph, transformation);
            }
            geometryGraph.UpdateBoundingBox();
        },
        TransformCurves: function (geometryGraph, transformation){
            geometryGraph.set_BoundingBox(new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(transformation, geometryGraph.get_LeftBottom()), Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(transformation, geometryGraph.get_RightTop())));
            var $it600 = geometryGraph.get_Edges().GetEnumerator();
            while ($it600.MoveNext()){
                var e = $it600.get_Current();
                if (e.get_Label() != null)
                    e.get_Label().set_Center(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(transformation, e.get_Label().get_Center()));
                Microsoft.Msagl.Layout.Layered.LayeredLayout.TransformEdgeCurve(transformation, e);
            }
        },
        TransformEdgeCurve: function (transformation, e){
            if (e.get_Curve() != null){
                e.set_Curve(e.get_Curve().Transform(transformation));
                var eg = e.get_EdgeGeometry();
                if (eg.get_SourceArrowhead() != null)
                    eg.get_SourceArrowhead().set_TipPosition(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(transformation, eg.get_SourceArrowhead().get_TipPosition()));
                if (eg.get_TargetArrowhead() != null)
                    eg.get_TargetArrowhead().set_TipPosition(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(transformation, eg.get_TargetArrowhead().get_TipPosition()));
                Microsoft.Msagl.Layout.Layered.LayeredLayout.TransformUnderlyingPolyline(e, transformation);
            }
        },
        TransformUnderlyingPolyline: function (e, transformation){
            if (e.get_UnderlyingPolyline() != null){
                for (var s = e.get_UnderlyingPolyline().get_HeadSite(); s != null; s = s.get_Next()){
                    s.set_Point(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(transformation, s.get_Point()));
                }
            }
        },
        RecoverAlgorithmData: function (graph){
            var recoveryEngine = new Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.ctor(graph);
            graph.AlgorithmData = recoveryEngine.GetEngine();
        },
        IncrementalLayout: function (geometryGraph, node){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(geometryGraph, "geometryGraph");
            var engine = As(geometryGraph.AlgorithmData, Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.ctor);
            if (engine == null)
                return;
            Microsoft.Msagl.Layout.Layered.LayeredLayout.PreRunTransform(geometryGraph, engine.get_SugiyamaSettings().get_Transformation());
            engine.IncrementalRun(node);
            Microsoft.Msagl.Layout.Layered.LayeredLayout.PostRunTransform(geometryGraph, engine.get_SugiyamaSettings().get_Transformation());
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (geometryGraph, settings){
            this.geometryGraph = null;
            this.settings = null;
            this.engine = null;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.geometryGraph = geometryGraph;
            this.settings = settings;
            this.engine = new Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.ctor$$GeometryGraph$$SugiyamaLayoutSettings(geometryGraph, settings);
        },
        EstimateAspectRatio: function (){
            var dimensions = this.engine.CalculateApproximateDimensions();
            System.Diagnostics.Debug.Assert$$Boolean$$String(dimensions.get_X() > 0, "The estimated width of the layered layout should be greater than 0");
            System.Diagnostics.Debug.Assert$$Boolean$$String(dimensions.get_Y() > 0, "The estimated width of the layered layout should be greater than 0");
            return dimensions.get_X() / dimensions.get_Y();
        },
        RunInternal: function (){
            Microsoft.Msagl.Layout.Layered.LayeredLayout.PreRunTransform(this.geometryGraph, this.settings.get_Transformation());
            this.engine.Run();
            this.geometryGraph.AlgorithmData = this.engine;
            Microsoft.Msagl.Layout.Layered.LayeredLayout.PostRunTransform(this.geometryGraph, this.settings.get_Transformation());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$LayeredLayout);
var Microsoft$Msagl$Layout$MDS$AllPairsDistances = {
    fullname: "Microsoft.Msagl.Layout.MDS.AllPairsDistances",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        },
        Stress: function (graph){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(graph, "graph");
            var stress = 0;
            if (graph.get_Edges().get_Count() == 0){
                return stress;
            }
            var apd = new Microsoft.Msagl.Layout.MDS.AllPairsDistances.ctor(graph, false);
            apd.Run();
            var D = apd.get_Result();
            var l = System.Linq.Enumerable.Average$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, graph.get_Edges(), function (e){
                return e.get_Length();
            });
            var i = 0;
            var $it602 = graph.get_Nodes().GetEnumerator();
            while ($it602.MoveNext()){
                var u = $it602.get_Current();
                var j = 0;
                var $it603 = graph.get_Nodes().GetEnumerator();
                while ($it603.MoveNext()){
                    var v = $it603.get_Current();
                    if (i != j){
                        var duv = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(u.get_Center(), v.get_Center())).get_Length();
                        var Duv = l * D[i][j];
                        var d = Duv - duv;
                        stress += d * d / (Duv * Duv);
                    }
                    ++j;
                }
                ++i;
            }
            return stress;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (graph, directed){
            this.graph = null;
            this.directed = false;
            this._Result = null;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.graph = graph;
            this.directed = directed;
        },
        Result$$: "System.Double[][]",
        get_Result: function (){
            return this._Result;
        },
        set_Result: function (value){
            this._Result = value;
        },
        RunInternal: function (){
            this.StartListenToLocalProgress(this.graph.get_Nodes().get_Count(), 1);
            this.set_Result(new Array(this.graph.get_Nodes().get_Count()));
            var i = 0;
            var $it601 = this.graph.get_Nodes().GetEnumerator();
            while ($it601.MoveNext()){
                var source = $it601.get_Current();
                var distances = new Microsoft.Msagl.Layout.MDS.SingleSourceDistances.ctor(this.graph, source, this.directed);
                distances.Run();
                this.get_Result()[i] = distances.get_Result();
                ++i;
                this.ProgressStep();
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$MDS$AllPairsDistances);
var Microsoft$Msagl$Layout$MDS$PivotDistances = {
    fullname: "Microsoft.Msagl.Layout.MDS.PivotDistances",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (graph, directed, pivotArray){
            this.graph = null;
            this.directed = false;
            this.pivotArray = null;
            this._Result = null;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.graph = graph;
            this.directed = directed;
            this.pivotArray = pivotArray;
        },
        Result$$: "System.Double[][]",
        get_Result: function (){
            return this._Result;
        },
        set_Result: function (value){
            this._Result = value;
        },
        RunInternal: function (){
            this.set_Result(new Array(this.pivotArray.length));
            var nodes = new Array(this.graph.get_Nodes().get_Count());
            this.graph.get_Nodes().CopyTo(nodes, 0);
            var min = new Float64Array(this.graph.get_Nodes().get_Count());
            for (var i = 0; i < min.length; i++){
                min[i] = Infinity;
            }
            var pivot = nodes[0];
            this.pivotArray[0] = 0;
            for (var i = 0; ; i++){
                var ssd = new Microsoft.Msagl.Layout.MDS.SingleSourceDistances.ctor(this.graph, pivot, this.directed);
                ssd.Run();
                this.get_Result()[i] = ssd.get_Result();
                if (i + 1 < this.pivotArray.length){
                    var argmax = 0;
                    for (var j = 0; j < this.get_Result()[i].length; j++){
                        min[j] = System.Math.Min$$Double$$Double(min[j], this.get_Result()[i][j]);
                        if (min[j] > min[argmax])
                            argmax = j;
                    }
                    pivot = nodes[argmax];
                    this.pivotArray[i + 1] = argmax;
                }
                else
                    break;
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$MDS$PivotDistances);
var Microsoft$Msagl$Layout$Incremental$AxisSolver = {
    fullname: "Microsoft.Msagl.Layout.Incremental.AxisSolver",
    baseTypeName: "System.Object",
    staticDefinition: {
        DebugVerifyRectContains: function (rectOuter, rectInner, dblPaddingX, dblPaddingY, dblEpsilon){
            rectInner.PadWidth(dblPaddingX / 2 - dblEpsilon);
            rectInner.PadHeight(dblPaddingY / 2 - dblEpsilon);
            System.Diagnostics.Debug.Assert$$Boolean$$String(rectOuter.Contains$$Rectangle(rectInner), "Inner Node/Cluster rectangle is not contained within outer Cluster");
        },
        DebugVerifyRectsDisjoint: function (rect1, rect2, dblPaddingX, dblPaddingY, dblEpsilon){
            rect1.PadWidth(dblPaddingX / 2 - dblEpsilon);
            rect1.PadHeight(dblPaddingY / 2 - dblEpsilon);
            rect2.PadWidth(dblPaddingX / 2 - dblEpsilon);
            rect2.PadHeight(dblPaddingY / 2 - dblEpsilon);
            System.Diagnostics.Debug.Assert$$Boolean(!rect1.Intersects(rect2));
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (isHorizontal, nodes, clusterHierarchies, avoidOverlaps, constraintLevel, clusterSettings){
            this.structuralConstraints = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Layout.Incremental.IConstraint.ctor);
            this.ConstraintLevel = 0;
            this.OverlapRemovalParameters = null;
            this.avoidOverlaps = false;
            this.nodes = null;
            this.clusterHierarchies = null;
            this.clusterSettings = null;
            this.solver = null;
            this.cg = null;
            this._IsHorizontal = false;
            System.Object.ctor.call(this);
            this.set_IsHorizontal(isHorizontal);
            this.nodes = nodes;
            this.clusterHierarchies = clusterHierarchies;
            this.avoidOverlaps = avoidOverlaps;
            this.ConstraintLevel = constraintLevel;
            this.clusterSettings = clusterSettings;
        },
        IsHorizontal$$: "System.Boolean",
        get_IsHorizontal: function (){
            return this._IsHorizontal;
        },
        set_IsHorizontal: function (value){
            this._IsHorizontal = value;
        },
        NeedSolve$$: "System.Boolean",
        get_NeedSolve: function (){
            return this.avoidOverlaps && this.ConstraintLevel >= 2 || this.structuralConstraints.get_Count() > 0 && this.ConstraintLevel >= 1;
        },
        AddStructuralConstraint: function (c){
            this.structuralConstraints.Add(c);
        },
        Initialize: function (hPad, vPad, cHPad, cVPad, nodeCenter){
            this.cg = new Microsoft.Msagl.Core.Geometry.ConstraintGenerator.ctor$$Boolean$$Double$$Double$$Double$$Double(this.get_IsHorizontal(), this.get_IsHorizontal() ? hPad : vPad, this.get_IsHorizontal() ? vPad : hPad, this.get_IsHorizontal() ? cHPad : cVPad, this.get_IsHorizontal() ? cVPad : cHPad);
            this.solver = new Microsoft.Msagl.Core.ProjectionSolver.Solver.ctor();
            var $it604 = this.nodes.GetEnumerator();
            while ($it604.MoveNext()){
                var filNode = $it604.get_Current();
                filNode.SetOlapNode(this.get_IsHorizontal(), null);
            }
            if (this.avoidOverlaps && this.clusterHierarchies != null){
                var $it605 = this.clusterHierarchies.GetEnumerator();
                while ($it605.MoveNext()){
                    var c = $it605.get_Current();
                    this.AddOlapClusters(this.cg, null, c, nodeCenter);
                }
            }
            var $it606 = this.nodes.GetEnumerator();
            while ($it606.MoveNext()){
                var filNode = $it606.get_Current();
                if (filNode.getOlapNode(this.get_IsHorizontal()) == null){
                    this.AddOlapNode(this.cg, this.cg.get_DefaultClusterHierarchy(), filNode, nodeCenter);
                }
                filNode.getOlapNode(this.get_IsHorizontal()).CreateVariable(this.solver);
            }
            if (this.avoidOverlaps && this.ConstraintLevel >= 2){
                this.cg.Generate(this.solver, this.OverlapRemovalParameters);
            }
            this.AddStructuralConstraints();
        },
        Solve: function (){
            var solution = this.cg.Solve(this.solver, null, false);
            if (this.avoidOverlaps && this.clusterHierarchies != null){
                var $it607 = this.clusterHierarchies.GetEnumerator();
                while ($it607.MoveNext()){
                    var c = $it607.get_Current();
                    this.UpdateOlapClusters(c.get_Clusters());
                }
            }
            var $it608 = this.nodes.GetEnumerator();
            while ($it608.MoveNext()){
                var v = $it608.get_Current();
                v.UpdatePos(this.get_IsHorizontal());
            }
            return solution;
        },
        SetDesiredPositions: function (){
            var $it609 = this.nodes.GetEnumerator();
            while ($it609.MoveNext()){
                var v = $it609.get_Current();
                v.SetVariableDesiredPos(this.get_IsHorizontal());
            }
            this.solver.UpdateVariables();
        },
        AddStructuralConstraints: function (){
            var $it610 = this.structuralConstraints.GetEnumerator();
            while ($it610.MoveNext()){
                var c = $it610.get_Current();
                if (this.ConstraintLevel >= c.get_Level()){
                    var hc = As(c, Microsoft.Msagl.Layout.Incremental.HorizontalSeparationConstraint.ctor);
                    if (hc != null && this.get_IsHorizontal()){
                        var u = Cast((hc.get_LeftNode().AlgorithmData), Microsoft.Msagl.Layout.Incremental.FiNode.ctor);
                        var v = Cast((hc.get_RightNode().AlgorithmData), Microsoft.Msagl.Layout.Incremental.FiNode.ctor);
                        this.solver.AddConstraint$$Variable$$Variable$$Double$$Boolean(u.getOlapNode(this.get_IsHorizontal()).get_Variable(), v.getOlapNode(this.get_IsHorizontal()).get_Variable(), hc.get_Separation(), hc.get_IsEquality());
                    }
                    var vc = As(c, Microsoft.Msagl.Layout.Incremental.VerticalSeparationConstraint.ctor);
                    if (vc != null && !this.get_IsHorizontal()){
                        var u = Cast((vc.get_TopNode().AlgorithmData), Microsoft.Msagl.Layout.Incremental.FiNode.ctor);
                        var v = Cast((vc.get_BottomNode().AlgorithmData), Microsoft.Msagl.Layout.Incremental.FiNode.ctor);
                        this.solver.AddConstraint$$Variable$$Variable$$Double$$Boolean(u.getOlapNode(this.get_IsHorizontal()).get_Variable(), v.getOlapNode(this.get_IsHorizontal()).get_Variable(), vc.get_Separation(), vc.get_IsEquality());
                    }
                }
            }
        },
        AddOlapClusters: function (generator, olapParentCluster, incClus, nodeCenter){
            var settings = this.clusterSettings(incClus);
            var nodeSeparationH = settings.get_NodeSeparation();
            var nodeSeparationV = settings.get_NodeSeparation() + 0.0001;
            var innerPaddingH = settings.get_ClusterMargin();
            var innerPaddingV = settings.get_ClusterMargin() + 0.0001;
            var rb = incClus.get_RectangularBoundary();
            if (this.get_IsHorizontal()){
                rb.olapCluster = generator.AddCluster$$OverlapRemovalCluster$$Object$$Double$$Double$$BorderInfo$$BorderInfo$$BorderInfo$$BorderInfo(olapParentCluster, incClus, rb.get_MinWidth(), rb.get_MinHeight(), rb.get_LeftBorderInfo(), rb.get_RightBorderInfo(), rb.get_BottomBorderInfo(), rb.get_TopBorderInfo());
                rb.olapCluster.set_NodePadding(nodeSeparationH);
                rb.olapCluster.set_NodePaddingP(nodeSeparationV);
                rb.olapCluster.set_ClusterPadding(innerPaddingH);
                rb.olapCluster.set_ClusterPaddingP(innerPaddingV);
            }
            else {
                var postXLeftBorderInfo = new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double$$Double$$Double(rb.get_LeftBorderInfo().get_InnerMargin(), rb.get_Rect().get_Left(), rb.get_LeftBorderInfo().get_Weight());
                var postXRightBorderInfo = new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double$$Double$$Double(rb.get_RightBorderInfo().get_InnerMargin(), rb.get_Rect().get_Right(), rb.get_RightBorderInfo().get_Weight());
                rb.olapCluster = generator.AddCluster$$OverlapRemovalCluster$$Object$$Double$$Double$$BorderInfo$$BorderInfo$$BorderInfo$$BorderInfo(olapParentCluster, incClus, rb.get_MinHeight(), rb.get_MinWidth(), rb.get_BottomBorderInfo(), rb.get_TopBorderInfo(), postXLeftBorderInfo, postXRightBorderInfo);
                rb.olapCluster.set_NodePadding(nodeSeparationV);
                rb.olapCluster.set_NodePaddingP(nodeSeparationH);
                rb.olapCluster.set_ClusterPadding(innerPaddingV);
                rb.olapCluster.set_ClusterPaddingP(innerPaddingH);
            }
            rb.olapCluster.set_TranslateChildren(rb.get_GenerateFixedConstraints());
            var $it611 = incClus.get_Nodes().GetEnumerator();
            while ($it611.MoveNext()){
                var filNode = $it611.get_Current();
                this.AddOlapNode(generator, rb.olapCluster, Cast(filNode.AlgorithmData, Microsoft.Msagl.Layout.Incremental.FiNode.ctor), nodeCenter);
            }
            var $it612 = incClus.get_Clusters().GetEnumerator();
            while ($it612.MoveNext()){
                var incChildClus = $it612.get_Current();
                this.AddOlapClusters(generator, rb.olapCluster, incChildClus, nodeCenter);
            }
        },
        AddOlapNode: function (generator, olapParentCluster, filNode, nodeCenter){
            if (null != filNode.getOlapNode(this.get_IsHorizontal())){
                generator.AddNodeToCluster(olapParentCluster, filNode.getOlapNode(this.get_IsHorizontal()));
                return;
            }
            var center = nodeCenter(filNode);
            if (this.get_IsHorizontal()){
                filNode.mOlapNodeX = generator.AddNode(olapParentCluster, filNode, center.get_X(), center.get_Y(), filNode.Width, filNode.Height, filNode.stayWeight);
            }
            else {
                filNode.mOlapNodeY = generator.AddNode(olapParentCluster, filNode, center.get_Y(), center.get_X(), filNode.Height, filNode.Width, filNode.stayWeight);
            }
        },
        UpdateOlapClusters: function (incClusters){
            var $it613 = incClusters.GetEnumerator();
            while ($it613.MoveNext()){
                var incClus = $it613.get_Current();
                var rb = incClus.get_RectangularBoundary();
                if (this.get_IsHorizontal()){
                    rb.rectangle.set_Left(rb.olapCluster.get_Position() - (rb.olapCluster.get_Size() / 2));
                    rb.rectangle.set_Right(rb.olapCluster.get_Position() + (rb.olapCluster.get_Size() / 2));
                    if (rb.get_LeftBorderInfo().get_IsFixedPosition()){
                        rb.set_LeftBorderInfo(new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double$$Double$$Double(rb.get_LeftBorderInfo().get_InnerMargin(), rb.rectangle.get_Left(), rb.get_LeftBorderInfo().get_Weight()));
                    }
                    if (rb.get_RightBorderInfo().get_IsFixedPosition()){
                        rb.set_RightBorderInfo(new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double$$Double$$Double(rb.get_RightBorderInfo().get_InnerMargin(), rb.rectangle.get_Right(), rb.get_RightBorderInfo().get_Weight()));
                    }
                }
                else {
                    rb.rectangle.set_Bottom(rb.olapCluster.get_Position() - (rb.olapCluster.get_Size() / 2));
                    rb.rectangle.set_Top(rb.olapCluster.get_Position() + (rb.olapCluster.get_Size() / 2));
                    if (rb.get_TopBorderInfo().get_IsFixedPosition()){
                        rb.set_TopBorderInfo(new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double$$Double$$Double(rb.get_TopBorderInfo().get_InnerMargin(), rb.rectangle.get_Top(), rb.get_TopBorderInfo().get_Weight()));
                    }
                    if (rb.get_BottomBorderInfo().get_IsFixedPosition()){
                        rb.set_BottomBorderInfo(new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double$$Double$$Double(rb.get_BottomBorderInfo().get_InnerMargin(), rb.rectangle.get_Bottom(), rb.get_BottomBorderInfo().get_Weight()));
                    }
                }
                rb.olapCluster = null;
                this.UpdateOlapClusters(incClus.get_Clusters());
            }
        },
        DebugVerifyClusterHierarchy: function (solution){
            if (this.avoidOverlaps && (null != this.clusterHierarchies) && (0 != solution.get_NumberOfUnsatisfiableConstraints())){
                var $it614 = this.clusterHierarchies.GetEnumerator();
                while ($it614.MoveNext()){
                    var c = $it614.get_Current();
                }
            }
        },
        DebugVerifyClusters: function (generator, incCluster, root){
            var dblEpsilon = 0.0001;
            var clusRect = incCluster.get_RectangularBoundary().rectangle;
            var $it615 = incCluster.get_Nodes().GetEnumerator();
            while ($it615.MoveNext()){
                var v = $it615.get_Current();
                var iiFilNode = Cast(v.AlgorithmData, Microsoft.Msagl.Layout.Incremental.FiNode.ctor);
                var iiNodeRect = iiFilNode.mNode.get_BoundaryCurve().get_BoundingBox();
                if (this.get_IsHorizontal()){
                    if (incCluster != root){
                        var dblLboundSpace = iiNodeRect.get_Left() - clusRect.get_Left() - generator.get_Padding();
                        var dblRboundSpace = clusRect.get_Right() - iiNodeRect.get_Right() - generator.get_Padding();
                        System.Diagnostics.Debug.Assert$$Boolean$$String((dblLboundSpace >= -dblEpsilon) && (dblRboundSpace >= -dblEpsilon), "Node is not within parent Cluster");
                    }
                }
                else {
                    if (incCluster != root){
                    }
                    var $it616 = incCluster.get_Nodes().GetEnumerator();
                    while ($it616.MoveNext()){
                        var u = $it616.get_Current();
                        if (u == v)
                            continue;
                        var jjFilNode = Cast(u.AlgorithmData, Microsoft.Msagl.Layout.Incremental.FiNode.ctor);
                        var jjNodeRect = jjFilNode.mNode.get_BoundaryCurve().get_BoundingBox();
                    }
                    var $it617 = incCluster.get_Clusters().GetEnumerator();
                    while ($it617.MoveNext()){
                        var incClusComp = $it617.get_Current();
                    }
                }
            }
            var $it618 = incCluster.get_Clusters().GetEnumerator();
            while ($it618.MoveNext()){
                var iiIncClus = $it618.get_Current();
                var iiClusRect = iiIncClus.get_RectangularBoundary().rectangle;
                if (this.get_IsHorizontal()){
                    if (incCluster != root){
                        var dblLboundSpace = iiClusRect.get_Left() - clusRect.get_Left() - generator.get_Padding();
                        var dblRboundSpace = clusRect.get_Right() - iiClusRect.get_Right() - generator.get_Padding();
                        System.Diagnostics.Debug.Assert$$Boolean$$String((dblLboundSpace >= -dblEpsilon) && (dblRboundSpace >= -dblEpsilon), "Cluster is not within parent Cluster");
                    }
                }
                else {
                    if (incCluster != root){
                    }
                    var $it619 = incCluster.get_Clusters().GetEnumerator();
                    while ($it619.MoveNext()){
                        var jjIncClus = $it619.get_Current();
                        if (jjIncClus == iiIncClus)
                            continue;
                        var jjClusRect = jjIncClus.get_RectangularBoundary().rectangle;
                    }
                }
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Incremental$AxisSolver);
var Microsoft$Msagl$Layout$Incremental$AxisSolver$InitialCenterDelegateType = {
    fullname: "Microsoft.Msagl.Layout.Incremental.AxisSolver.InitialCenterDelegateType",
    Kind: "Delegate",
    definition: {
        ctor: function (obj, func){
            System.MulticastDelegate.ctor.call(this, obj, func);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Incremental$AxisSolver$InitialCenterDelegateType);
var Microsoft$Msagl$Core$Geometry$Disc = {
    fullname: "Microsoft.Msagl.Core.Geometry.Disc",
    baseTypeName: "System.Object",
    staticDefinition: {
        midPoint: function (startPoint, endPoint){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double((endPoint.get_X() + startPoint.get_X()) / 2, (endPoint.get_Y() + startPoint.get_Y()) / 2);
        },
        centre: function (p1, p2, p3){
            System.Diagnostics.Debug.Assert$$Boolean(p2.get_X() != p1.get_X());
            System.Diagnostics.Debug.Assert$$Boolean(p3.get_X() != p2.get_X());
            var ma,mb;
            ma = (p2.get_Y() - p1.get_Y()) / (p2.get_X() - p1.get_X());
            mb = (p3.get_Y() - p2.get_Y()) / (p3.get_X() - p2.get_X());
            System.Diagnostics.Debug.Assert$$Boolean(mb != ma);
            var c = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            c.set_X(ma * mb * (p1.get_Y() - p3.get_Y()) + mb * (p1.get_X() + p2.get_X()) - ma * (p2.get_X() + p3.get_X()));
            c.set_X(c.get_X() / 2 * (mb - ma));
            if (System.Math.Abs$$Double(ma) > System.Math.Abs$$Double(mb)){
                c.set_Y((p1.get_Y() + p2.get_Y()) / 2 - (c.get_X() - (p1.get_X() + p2.get_X()) / 2) / ma);
            }
            else {
                c.set_Y((p2.get_Y() + p3.get_Y()) / 2 - (c.get_X() - (p2.get_X() + p3.get_X()) / 2) / mb);
            }
            return c;
        },
        Collinear: function (p1, p2, p3){
            return p1.get_X() * (p2.get_Y() - p3.get_Y()) + p2.get_X() * (p3.get_Y() - p1.get_Y()) + p3.get_X() * (p1.get_Y() - p2.get_Y()) == 0;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$Point: function (center){
            this.c = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.r = 0;
            this.r2 = 0;
            System.Object.ctor.call(this);
            this.c = center;
            this.r2 = this.r = 0;
        },
        Center$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Center: function (){
            return this.c;
        },
        Radius$$: "System.Double",
        get_Radius: function (){
            return this.r;
        },
        Distance2: function (point){
            var dx = this.c.get_X() - point.get_X(),dy = this.c.get_Y() - point.get_Y();
            return dx * dx + dy * dy;
        },
        Contains$$Point: function (point){
            return this.Distance2(point) - 1E-07 <= this.r2;
        },
        Contains$$Point$Array$$Int32$Array: function (points, except){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(points, "points");
            for (var i = 0; i < points.length; ++i){
                if (!System.Linq.Enumerable.Contains$1$$IEnumerable$1$$TSource(System.Int32.ctor, except, i) && !this.Contains$$Point(points[i])){
                    return false;
                }
            }
            return true;
        },
        ctor$$Point$$Point: function (firstBoundaryPoint, secondBoundaryPoint){
            this.c = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.r = 0;
            this.r2 = 0;
            System.Object.ctor.call(this);
            this.c = Microsoft.Msagl.Core.Geometry.Disc.midPoint(firstBoundaryPoint, secondBoundaryPoint);
            this.r2 = this.Distance2(firstBoundaryPoint);
            this.r = System.Math.Sqrt(this.r2);
            System.Diagnostics.Debug.Assert$$Boolean(this.OnBoundary(firstBoundaryPoint));
            System.Diagnostics.Debug.Assert$$Boolean(this.OnBoundary(secondBoundaryPoint));
        },
        OnBoundary: function (point){
            var d = this.Distance2(point);
            return System.Math.Abs$$Double(d - this.r2) / (d + this.r2) < 1E-05;
        },
        ctor$$Point$$Point$$Point: function (p1, p2, p3){
            this.c = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.r = 0;
            this.r2 = 0;
            System.Object.ctor.call(this);
            if (Microsoft.Msagl.Core.Geometry.Disc.Collinear(p1, p2, p3)){
                var LL = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(System.Math.Min$$Double$$Double(p1.get_X(), System.Math.Min$$Double$$Double(p2.get_X(), p3.get_X())), System.Math.Min$$Double$$Double(p1.get_Y(), System.Math.Max$$Double$$Double(p2.get_Y(), p3.get_Y()))),UR = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(System.Math.Max$$Double$$Double(p1.get_X(), System.Math.Max$$Double$$Double(p2.get_X(), p3.get_X())), System.Math.Max$$Double$$Double(p1.get_Y(), System.Math.Max$$Double$$Double(p2.get_Y(), p3.get_Y())));
                this.c = Microsoft.Msagl.Core.Geometry.Disc.midPoint(LL, UR);
                this.r2 = this.Distance2(UR);
                this.r = System.Math.Sqrt(this.r2);
            }
            else {
                var dx12 = p2.get_X() - p1.get_X(),dx23 = p3.get_X() - p2.get_X(),dx13 = p3.get_X() - p1.get_X();
                if (dx12 != 0){
                    if (dx23 != 0){
                        this.c = Microsoft.Msagl.Core.Geometry.Disc.centre(p1, p2, p3);
                    }
                    else {
                        System.Diagnostics.Debug.Assert$$Boolean(dx13 != 0);
                        this.c = Microsoft.Msagl.Core.Geometry.Disc.centre(p2, p1, p3);
                    }
                }
                else {
                    System.Diagnostics.Debug.Assert$$Boolean(dx23 != 0);
                    this.c = Microsoft.Msagl.Core.Geometry.Disc.centre(p2, p3, p1);
                }
                this.r2 = this.Distance2(p1);
                this.r = System.Math.Sqrt(this.r2);
                System.Diagnostics.Debug.Assert$$Boolean(this.OnBoundary(p1));
                System.Diagnostics.Debug.Assert$$Boolean(this.OnBoundary(p2));
                System.Diagnostics.Debug.Assert$$Boolean(this.OnBoundary(p3));
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Disc);
var Microsoft$Msagl$Layout$MDS$PivotMDS = {
    fullname: "Microsoft.Msagl.Layout.MDS.PivotMDS",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (graph){
            this.graph = null;
            this._Scale = 0;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.graph = graph;
            this.set_Scale(1);
        },
        Scale$$: "System.Double",
        get_Scale: function (){
            return this._Scale;
        },
        set_Scale: function (value){
            this._Scale = value;
        },
        RunInternal: function (){
            var g = new Microsoft.Msagl.Core.Layout.GeometryGraph.ctor();
            var $it620 = this.graph.get_Nodes().GetEnumerator();
            while ($it620.MoveNext()){
                var v = $it620.get_Current();
                System.Diagnostics.Debug.Assert$$Boolean(!(Is(v, Microsoft.Msagl.Core.Layout.Cluster.ctor)));
                var u = (function (){
                    var $v80 = new Microsoft.Msagl.Core.Layout.Node.ctor$$ICurve(v.get_BoundaryCurve().Clone());
                    $v80.set_UserData(v);
                    return $v80;
                }).call(this);
                v.AlgorithmData = new Microsoft.Msagl.Layout.MDS.PivotMDS.PivotMDSNodeWrap.ctor(u);
                g.get_Nodes().Add(u);
            }
            var avgLength = 0;
            var $it621 = this.graph.get_Edges().GetEnumerator();
            while ($it621.MoveNext()){
                var e = $it621.get_Current();
                avgLength += e.get_Length();
                if (Is(e.get_Source(), Microsoft.Msagl.Core.Layout.Cluster.ctor) || Is(e.get_Target(), Microsoft.Msagl.Core.Layout.Cluster.ctor))
                    continue;
                var u = As(e.get_Source().AlgorithmData, Microsoft.Msagl.Layout.MDS.PivotMDS.PivotMDSNodeWrap.ctor);
                var v = As(e.get_Target().AlgorithmData, Microsoft.Msagl.Layout.MDS.PivotMDS.PivotMDSNodeWrap.ctor);
                var ee = (function (){
                    var $v81 = new Microsoft.Msagl.Core.Layout.Edge.ctor$$Node$$Node(u.node, v.node);
                    $v81.set_Length(e.get_Length());
                    return $v81;
                }).call(this);
                g.get_Edges().Add(ee);
            }
            if (this.graph.get_Edges().get_Count() != 0){
                avgLength /= this.graph.get_Edges().get_Count();
            }
            else {
                avgLength = 100;
            }
            var $it622 = this.graph.get_RootCluster().AllClustersDepthFirst().GetEnumerator();
            while ($it622.MoveNext()){
                var c = $it622.get_Current();
                if (c == this.graph.get_RootCluster())
                    continue;
                var u = new Microsoft.Msagl.Core.Layout.Node.ctor$$ICurve(Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateRectangle$$Double$$Double$$Point(10, 10, new Microsoft.Msagl.Core.Geometry.Point.ctor()));
                u.set_UserData(c);
                c.AlgorithmData = new Microsoft.Msagl.Layout.MDS.PivotMDS.PivotMDSNodeWrap.ctor(u);
                g.get_Nodes().Add(u);
                var $it623 = System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Layout.Node.ctor, c.get_Nodes(), System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Cluster.ctor, Microsoft.Msagl.Core.Layout.Node.ctor, c.get_Clusters(), $CreateAnonymousDelegate(this, function (cc){
                    return cc;
                }))).GetEnumerator();
                while ($it623.MoveNext()){
                    var v = $it623.get_Current();
                    var vv = As(v.AlgorithmData, Microsoft.Msagl.Layout.MDS.PivotMDS.PivotMDSNodeWrap.ctor);
                    g.get_Edges().Add((function (){
                        var $v82 = new Microsoft.Msagl.Core.Layout.Edge.ctor$$Node$$Node(u, vv.node);
                        $v82.set_Length(avgLength);
                        return $v82;
                    }).call(this));
                }
            }
            var $it624 = this.graph.get_Edges().GetEnumerator();
            while ($it624.MoveNext()){
                var e = $it624.get_Current();
                if (Is(e.get_Source(), Microsoft.Msagl.Core.Layout.Cluster.ctor) || Is(e.get_Target(), Microsoft.Msagl.Core.Layout.Cluster.ctor)){
                    var u = As(e.get_Source().AlgorithmData, Microsoft.Msagl.Layout.MDS.PivotMDS.PivotMDSNodeWrap.ctor);
                    var v = As(e.get_Target().AlgorithmData, Microsoft.Msagl.Layout.MDS.PivotMDS.PivotMDSNodeWrap.ctor);
                    var ee = (function (){
                        var $v83 = new Microsoft.Msagl.Core.Layout.Edge.ctor$$Node$$Node(u.node, v.node);
                        $v83.set_Length(e.get_Length());
                        return $v83;
                    }).call(this);
                    g.get_Edges().Add(ee);
                }
            }
            var settings = (function (){
                var $v84 = new Microsoft.Msagl.Layout.MDS.MdsLayoutSettings.ctor();
                $v84.set_ScaleX(this.get_Scale());
                $v84.set_ScaleY(this.get_Scale());
                $v84.set_IterationsWithMajorization(0);
                $v84.set_RemoveOverlaps(false);
                $v84.set_AdjustScale(false);
                return $v84;
            }).call(this);
            var mdsLayout = new Microsoft.Msagl.Layout.MDS.MdsGraphLayout.ctor(settings, g);
            this.RunChildAlgorithm(mdsLayout, 1);
            g.UpdateBoundingBox();
            var $it625 = this.graph.get_Nodes().GetEnumerator();
            while ($it625.MoveNext()){
                var v = $it625.get_Current();
                var m = As(v.AlgorithmData, Microsoft.Msagl.Layout.MDS.PivotMDS.PivotMDSNodeWrap.ctor);
                v.set_Center(m.node.get_Center());
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$MDS$PivotMDS);
var Microsoft$Msagl$Layout$MDS$PivotMDS$PivotMDSNodeWrap = {
    fullname: "Microsoft.Msagl.Layout.MDS.PivotMDS.PivotMDSNodeWrap",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (node){
            this.node = null;
            System.Object.ctor.call(this);
            this.node = node;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$MDS$PivotMDS$PivotMDSNodeWrap);
var Microsoft$Msagl$Core$Layout$Cluster = {
    fullname: "Microsoft.Msagl.Core.Layout.Cluster",
    baseTypeName: "Microsoft.Msagl.Core.Layout.Node",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.isCollapsed = false;
            this.Barycenter = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.collapsedBoundary = null;
            this.clusters = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Cluster.ctor);
            this.nodes = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor);
            this.isInInitialLayoutState = false;
            this.layoutDoneEvent = null;
            this.LayoutDoneEvent = null;
            this._RectangularBoundary = null;
            this._Weight = 0;
            Microsoft.Msagl.Core.Layout.Cluster.ctor$$Point.call(this, new Microsoft.Msagl.Core.Geometry.Point.ctor());
        },
        IsCollapsed$$: "System.Boolean",
        get_IsCollapsed: function (){
            return this.isCollapsed;
        },
        set_IsCollapsed: function (value){
            this.isCollapsed = value;
        },
        BoundaryCurve$$: "Microsoft.Msagl.Core.Geometry.Curves.ICurve",
        get_BoundaryCurve: function (){
            return this.get_IsCollapsed() ? this.get_CollapsedBoundary() : Microsoft.Msagl.Core.Layout.Node.commonPrototype.get_BoundaryCurve.call(this);
        },
        set_BoundaryCurve: function (value){
            Microsoft.Msagl.Core.Layout.Node.commonPrototype.set_BoundaryCurve.call(this, value);
        },
        add_layoutDoneEvent: function (value){
            this.layoutDoneEvent = $CombineDelegates(this.layoutDoneEvent, value);
        },
        remove_layoutDoneEvent: function (value){
            this.layoutDoneEvent = $RemoveDelegate(this.layoutDoneEvent, value);
        },
        add_LayoutDoneEvent: function (value){
            this.add_layoutDoneEvent(value);
        },
        remove_LayoutDoneEvent: function (value){
            this.remove_layoutDoneEvent(value);
        },
        CollapsedBoundary$$: "Microsoft.Msagl.Core.Geometry.Curves.ICurve",
        get_CollapsedBoundary: function (){
            return this.collapsedBoundary;
        },
        set_CollapsedBoundary: function (value){
            this.collapsedBoundary = value;
        },
        ctor$$Point: function (origin){
            this.isCollapsed = false;
            this.Barycenter = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.collapsedBoundary = null;
            this.clusters = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Cluster.ctor);
            this.nodes = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor);
            this.isInInitialLayoutState = false;
            this.layoutDoneEvent = null;
            this.LayoutDoneEvent = null;
            this._RectangularBoundary = null;
            this._Weight = 0;
            Microsoft.Msagl.Core.Layout.Node.ctor.call(this);
            this.set_Weight(0);
            this.Barycenter = origin;
        },
        ctor$$IEnumerable$1$Node: function (nodes){
            this.isCollapsed = false;
            this.Barycenter = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.collapsedBoundary = null;
            this.clusters = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Cluster.ctor);
            this.nodes = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor);
            this.isInInitialLayoutState = false;
            this.layoutDoneEvent = null;
            this.LayoutDoneEvent = null;
            this._RectangularBoundary = null;
            this._Weight = 0;
            Microsoft.Msagl.Core.Layout.Cluster.ctor.call(this);
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(nodes, "nodes");
            var $it626 = nodes.GetEnumerator();
            while ($it626.MoveNext()){
                var v = $it626.get_Current();
                this.AddNode(v);
            }
        },
        ctor$$IEnumerable$1$Node$$IEnumerable$1$Cluster: function (nodes, clusters){
            this.isCollapsed = false;
            this.Barycenter = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.collapsedBoundary = null;
            this.clusters = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Cluster.ctor);
            this.nodes = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor);
            this.isInInitialLayoutState = false;
            this.layoutDoneEvent = null;
            this.LayoutDoneEvent = null;
            this._RectangularBoundary = null;
            this._Weight = 0;
            Microsoft.Msagl.Core.Layout.Cluster.ctor$$IEnumerable$1$Node.call(this, nodes);
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(clusters, "clusters");
            var $it627 = clusters.GetEnumerator();
            while ($it627.MoveNext()){
                var c = $it627.get_Current();
                this.AddCluster(c);
            }
        },
        RectangularBoundary$$: "Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary",
        get_RectangularBoundary: function (){
            return this._RectangularBoundary;
        },
        set_RectangularBoundary: function (value){
            this._RectangularBoundary = value;
        },
        Nodes$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Layout.Node]]",
        get_Nodes: function (){
            return this.nodes;
        },
        Clusters$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Layout.Cluster]]",
        get_Clusters: function (){
            return this.clusters;
        },
        Weight$$: "System.Double",
        get_Weight: function (){
            return this._Weight;
        },
        set_Weight: function (value){
            this._Weight = value;
        },
        BoundingBox$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_BoundingBox: function (){
            if (!this.get_IsCollapsed() || this.get_CollapsedBoundary() == null){
                if (this.get_RectangularBoundary() != null){
                    return this.get_RectangularBoundary().get_Rect();
                }
                return new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$IEnumerable$1$Rectangle(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Geometry.Rectangle.ctor, System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Layout.Node.ctor, this.nodes, this.clusters), $CreateAnonymousDelegate(this, function (n){
                    return n.get_BoundingBox();
                })));
            }
            return this.get_CollapsedBoundary().get_BoundingBox();
        },
        set_BoundingBox: function (value){
            this.FitBoundaryCurveToTarget(value);
        },
        AddChild: function (child){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(child, "child");
            System.Diagnostics.Debug.Assert$$Boolean(child != this);
            var childCluster = As(child, Microsoft.Msagl.Core.Layout.Cluster.ctor);
            if (childCluster != null){
                this.clusters.Add(childCluster);
            }
            else {
                this.nodes.Add(child);
            }
            child.AddClusterParent(this);
        },
        ClearClusters: function (){
            this.clusters.Clear();
        },
        ComputeWeight: function (){
            this.set_Weight(this.nodes.get_Count());
            var $it628 = this.clusters.GetEnumerator();
            while ($it628.MoveNext()){
                var c = $it628.get_Current();
                this.set_Weight(this.get_Weight() + c.ComputeWeight());
            }
            return this.get_Weight();
        },
        SetBarycenter: function (){
            this.Barycenter = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            if ((0 != this.nodes.get_Count()) || (0 != this.clusters.get_Count())){
                if (0 == this.get_Weight()){
                    this.ComputeWeight();
                }
                if (0 != this.get_Weight()){
                    var $it629 = this.nodes.GetEnumerator();
                    while ($it629.MoveNext()){
                        var v = $it629.get_Current();
                        this.Barycenter = Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.Barycenter, v.get_Center());
                    }
                    var $it630 = this.clusters.GetEnumerator();
                    while ($it630.MoveNext()){
                        var c = $it630.get_Current();
                        this.Barycenter = Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.Barycenter, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(c.SetBarycenter(), c.get_Weight()));
                    }
                    this.Barycenter = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(this.Barycenter, this.get_Weight());
                }
            }
            System.Diagnostics.Debug.Assert$$Boolean(!System.Double.IsNaN(this.Barycenter.get_X()) && !System.Double.IsNaN(this.Barycenter.get_Y()));
            return this.Barycenter;
        },
        AllClustersDepthFirst: function (){
            var $yield = [];
            var $it631 = this.clusters.GetEnumerator();
            while ($it631.MoveNext()){
                var c = $it631.get_Current();
                var $it632 = c.AllClustersDepthFirst().GetEnumerator();
                while ($it632.MoveNext()){
                    var d = $it632.get_Current();
                    $yield.push(d);
                }
            }
            $yield.push(this);
            return $yield;
        },
        AllSuccessorsWidthFirst: function (){
            var $yield = [];
            var $it633 = this.get_Nodes().GetEnumerator();
            while ($it633.MoveNext()){
                var n = $it633.get_Current();
                $yield.push(n);
            }
            var $it634 = this.clusters.GetEnumerator();
            while ($it634.MoveNext()){
                var c = $it634.get_Current();
                $yield.push(c);
                var $it635 = c.AllSuccessorsWidthFirst().GetEnumerator();
                while ($it635.MoveNext()){
                    var n = $it635.get_Current();
                    $yield.push(n);
                }
            }
            return $yield;
        },
        AllClustersDepthFirstExcludingSelf: function (){
            var $yield = [];
            var $it636 = this.clusters.GetEnumerator();
            while ($it636.MoveNext()){
                var c = $it636.get_Current();
                var $it637 = c.AllClustersDepthFirst().GetEnumerator();
                while ($it637.MoveNext()){
                    var d = $it637.get_Current();
                    $yield.push(d);
                }
            }
            return $yield;
        },
        ForEachNode: function (f){
            var $it638 = this.nodes.GetEnumerator();
            while ($it638.MoveNext()){
                var v = $it638.get_Current();
                f(v);
            }
            var $it639 = this.clusters.GetEnumerator();
            while ($it639.MoveNext()){
                var c = $it639.get_Current();
                c.ForEachNode(f);
            }
        },
        RemoveCluster: function (cluster){
            this.clusters.Remove(cluster);
        },
        DeepContentsTranslation$$Rectangle: function (rectangle){
            var delta = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(rectangle.get_LeftBottom(), this.get_BoundingBox().get_LeftBottom());
            this.DeepContentsTranslation$$Point$$Boolean(delta, true);
        },
        DeepContentsTranslation$$Point$$Boolean: function (delta, translateEdges){
            var $it640 = this.AllClustersDepthFirst().GetEnumerator();
            while ($it640.MoveNext()){
                var c = $it640.get_Current();
                var $it641 = System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Layout.Node.ctor, c.get_Nodes(), System.Linq.Enumerable.Cast$1(Microsoft.Msagl.Core.Layout.Node.ctor, c.get_Clusters())).GetEnumerator();
                while ($it641.MoveNext()){
                    var v = $it641.get_Current();
                    var cluster = As(v, Microsoft.Msagl.Core.Layout.Cluster.ctor);
                    if (cluster != null){
                        cluster.get_RectangularBoundary().TranslateRectangle(delta);
                    }
                    v.set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Addition(v.get_Center(), delta));
                    if (translateEdges){
                        var $it642 = this.EdgesIncomingToNodeWithDescendantSource(v).GetEnumerator();
                        while ($it642.MoveNext()){
                            var e = $it642.get_Current();
                            e.Translate(delta);
                        }
                    }
                }
            }
        },
        ChildEdges: function (){
            return System.Linq.Enumerable.SelectMany$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Layout.Edge.ctor, System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Layout.Node.ctor, this.get_Nodes(), this.get_Clusters()), $CreateDelegate(this, this.EdgesIncomingToNodeWithChildSource));
        },
        EdgesIncomingToNodeWithDescendantSource: function (node){
            return System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Layout.Edge.ctor, node.get_InEdges(), node.get_SelfEdges()), $CreateAnonymousDelegate(this, function (e){
                return e.get_Source().IsDescendantOf(this);
            }));
        },
        EdgesIncomingToNodeWithChildSource: function (node){
            return System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Layout.Edge.ctor, node.get_InEdges(), node.get_SelfEdges()), $CreateAnonymousDelegate(this, function (e){
                return System.Linq.Enumerable.Contains$1$$IEnumerable$1$$TSource(Microsoft.Msagl.Core.Layout.Cluster.ctor, e.get_Source().get_ClusterParents(), this);
            }));
        },
        DeepTranslation: function (delta, translateEdges){
            this.DeepContentsTranslation$$Point$$Boolean(delta, translateEdges);
            this.get_RectangularBoundary().TranslateRectangle(delta);
            this.set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.get_Center(), delta));
        },
        CalculateBoundsFromChildren: function (padding){
            var r = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$IEnumerable$1$Rectangle(System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Geometry.Rectangle.ctor, (System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Geometry.Rectangle.ctor, this.get_Nodes(), $CreateAnonymousDelegate(this, function (v){
                return v.get_BoundingBox();
            }))), System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Cluster.ctor, Microsoft.Msagl.Core.Geometry.Rectangle.ctor, this.get_Clusters(), $CreateAnonymousDelegate(this, function (d){
                return d.get_BoundingBox();
            }))));
            r.Pad$$Double(padding);
            this.UpdateBoundary(r);
        },
        UpdateBoundary: function (bounds){
            var r = bounds;
            if (this.get_RectangularBoundary() != null){
                r = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Double$$Double$$Double$$Double(r.get_Left() - this.get_RectangularBoundary().get_LeftMargin(), r.get_Bottom() - this.get_RectangularBoundary().get_BottomMargin(), r.get_Right() + this.get_RectangularBoundary().get_RightMargin(), r.get_Top() + this.get_RectangularBoundary().get_TopMargin());
                var widthPad = (this.get_RectangularBoundary().get_MinWidth() - r.get_Width()) / 2;
                if (widthPad > 0){
                    r.PadWidth(widthPad);
                }
                var heightPad = (this.get_RectangularBoundary().get_MinHeight() - r.get_Height()) / 2;
                if (heightPad > 0){
                    r.PadHeight(heightPad);
                }
                this.get_RectangularBoundary().set_Rect(r);
            }
            this.set_BoundingBox(r);
        },
        IsInInitialLayoutState$$: "System.Boolean",
        get_IsInInitialLayoutState: function (){
            return this.isInInitialLayoutState;
        },
        SetInitialLayoutState: function (padding){
            this.isInInitialLayoutState = true;
            if (this.get_RectangularBoundary() != null){
                this.get_RectangularBoundary().StoreDefaultMargin();
                var childBounds = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$IEnumerable$1$Rectangle(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Geometry.Rectangle.ctor, System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Layout.Node.ctor, this.get_Nodes(), this.get_Clusters()), $CreateAnonymousDelegate(this, function (v){
                    return v.get_BoundingBox();
                })));
                childBounds.Pad$$Double(padding);
                this.get_RectangularBoundary().set_LeftMargin(childBounds.get_Left() - this.get_RectangularBoundary().get_Rect().get_Left());
                this.get_RectangularBoundary().set_RightMargin(this.get_RectangularBoundary().get_Rect().get_Right() - childBounds.get_Right());
                this.get_RectangularBoundary().set_BottomMargin(childBounds.get_Bottom() - this.get_RectangularBoundary().get_Rect().get_Bottom());
                this.get_RectangularBoundary().set_TopMargin(this.get_RectangularBoundary().get_Rect().get_Top() - childBounds.get_Top());
            }
        },
        UnsetInitialLayoutState: function (){
            this.isInInitialLayoutState = false;
            var rb = this.get_RectangularBoundary();
            if (rb != null){
                rb.RestoreDefaultMargin();
            }
        },
        UnsetInitialLayoutStateIncludingAncestors: function (){
            this.UnsetInitialLayoutState();
            var $it643 = this.get_AllClusterAncestors().GetEnumerator();
            while ($it643.MoveNext()){
                var c = $it643.get_Current();
                c.UnsetInitialLayoutState();
            }
        },
        AllClustersWideFirstExcludingSelf: function (){
            var $yield = [];
            var q = new System.Collections.Generic.Queue$1.ctor(Microsoft.Msagl.Core.Layout.Cluster.ctor);
            var $it644 = this.get_Clusters().GetEnumerator();
            while ($it644.MoveNext()){
                var cluster = $it644.get_Current();
                q.Enqueue(cluster);
            }
            while (q.get_Count() > 0){
                var c = q.Dequeue();
                $yield.push(c);
                var $it645 = c.get_Clusters().GetEnumerator();
                while ($it645.MoveNext()){
                    var cluster = $it645.get_Current();
                    q.Enqueue(cluster);
                }
            }
            return $yield;
        },
        AllClustersWidthFirstExcludingSelfAvoidingChildrenOfCollapsed: function (){
            var $yield = [];
            var q = new System.Collections.Generic.Queue$1.ctor(Microsoft.Msagl.Core.Layout.Cluster.ctor);
            var $it646 = this.get_Clusters().GetEnumerator();
            while ($it646.MoveNext()){
                var cluster = $it646.get_Current();
                q.Enqueue(cluster);
            }
            while (q.get_Count() > 0){
                var c = q.Dequeue();
                $yield.push(c);
                if (c.get_IsCollapsed())
                    continue;
                var $it647 = c.get_Clusters().GetEnumerator();
                while ($it647.MoveNext()){
                    var cluster = $it647.get_Current();
                    q.Enqueue(cluster);
                }
            }
            return $yield;
        },
        AddNode: function (node){
            node.AddClusterParent(this);
            this.nodes.Add(node);
        },
        AddCluster: function (cluster){
            cluster.AddClusterParent(this);
            this.clusters.Add(cluster);
        },
        AddRangeOfCluster: function (clustersToAdd){
            var $it648 = clustersToAdd.GetEnumerator();
            while ($it648.MoveNext()){
                var cluster = $it648.get_Current();
                cluster.AddClusterParent(this);
                this.clusters.Add(cluster);
            }
        },
        toString: function (){
            return this.get_UserData() != null ? this.get_UserData().toString() : Microsoft.Msagl.Core.Layout.Node.commonPrototype.toString.call(this);
        },
        RaiseLayoutDoneEvent: function (){
            if (this.layoutDoneEvent != null)
                this.layoutDoneEvent(this, null);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$Cluster);
var Microsoft$Msagl$Layout$Incremental$Feasibility = {
    fullname: "Microsoft.Msagl.Layout.Incremental.Feasibility",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Layout.Incremental.Feasibility.Pad = 0.0001;
        },
        Enforce: function (settings, currentConstraintLevel, nodes, horizontalConstraints, verticalConstraints, clusterHierarchies, clusterSettings){
            var $it649 = settings.locks.GetEnumerator();
            while ($it649.MoveNext()){
                var l = $it649.get_Current();
                l.Project();
            }
            Microsoft.Msagl.Layout.Incremental.Feasibility.ResetPositions(nodes);
            var dblVpad = settings.get_NodeSeparation() + 0.0001;
            var dblHpad = settings.get_NodeSeparation();
            var dblCVpad = settings.get_ClusterMargin() + 0.0001;
            var dblCHpad = settings.get_ClusterMargin();
            for (var level = settings.get_MinConstraintLevel(); level <= currentConstraintLevel; ++level){
                var hsSolver = new Microsoft.Msagl.Layout.Incremental.AxisSolver.ctor(true, nodes, clusterHierarchies, level >= 2 && settings.get_AvoidOverlaps(), level, clusterSettings);
                hsSolver.structuralConstraints = horizontalConstraints;
                hsSolver.OverlapRemovalParameters = (function (){
                    var $v85 = new Microsoft.Msagl.Core.Geometry.OverlapRemovalParameters.ctor();
                    $v85.set_AllowDeferToVertical(true);
                    $v85.set_ConsiderProportionalOverlap(settings.get_IdealEdgeLength().get_EdgeDirectionConstraints() != Microsoft.Msagl.Core.Geometry.Directions.None);
                    return $v85;
                })();
                hsSolver.Initialize(dblHpad, dblVpad, dblCHpad, dblCVpad, function (v){
                    return v.get_Center();
                });
                hsSolver.SetDesiredPositions();
                hsSolver.Solve();
                Microsoft.Msagl.Layout.Incremental.Feasibility.ResetPositions(nodes);
                var vsSolver = new Microsoft.Msagl.Layout.Incremental.AxisSolver.ctor(false, nodes, clusterHierarchies, level >= 2 && settings.get_AvoidOverlaps(), level, clusterSettings);
                vsSolver.structuralConstraints = verticalConstraints;
                vsSolver.Initialize(dblHpad, dblVpad, dblCHpad, dblCVpad, function (v){
                    return v.get_Center();
                });
                vsSolver.SetDesiredPositions();
                vsSolver.Solve();
                Microsoft.Msagl.Layout.Incremental.Feasibility.ResetPositions(nodes);
            }
        },
        ResetPositions: function (nodes){
            var $it650 = nodes.GetEnumerator();
            while ($it650.MoveNext()){
                var v = $it650.get_Current();
                v.previousCenter = v.desiredPosition = v.mNode.get_Center();
            }
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Incremental$Feasibility);
var Microsoft$Msagl$Layout$Incremental$TNode = {
    fullname: "Microsoft.Msagl.Layout.Incremental.TNode",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (v){
            this.stackNode = null;
            this.v = null;
            this.visited = false;
            this.outNeighbours = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Layout.Incremental.TNode.ctor);
            this.inNeighbours = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Layout.Incremental.TNode.ctor);
            System.Object.ctor.call(this);
            this.v = v;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Incremental$TNode);
var Microsoft$Msagl$Layout$Incremental$EdgeConstraintGenerator = {
    fullname: "Microsoft.Msagl.Layout.Incremental.EdgeConstraintGenerator",
    baseTypeName: "System.Object",
    staticDefinition: {
        GenerateEdgeConstraints: function (edges, settings, horizontalSolver, verticalSolver){
            if (settings.get_EdgeDirectionConstraints() == Microsoft.Msagl.Core.Geometry.Directions.None){
                return;
            }
            var g = new Microsoft.Msagl.Layout.Incremental.EdgeConstraintGenerator.ctor(edges, settings, horizontalSolver, verticalSolver);
            g.GenerateSeparationConstraints();
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (edges, settings, horizontalSolver, verticalSolver){
            this.settings = new Microsoft.Msagl.Core.Layout.IdealEdgeLengthSettings.ctor();
            this.edges = null;
            this.nodeMap = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Layout.Incremental.TNode.ctor);
            this.stack = new System.Collections.Generic.LinkedList$1.ctor(Microsoft.Msagl.Layout.Incremental.TNode.ctor);
            this.component = null;
            this.horizontalSolver = null;
            this.verticalSolver = null;
            this.cyclicComponents = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.DataStructures.Set$1.ctor);
            this.addConstraint = null;
            System.Object.ctor.call(this);
            this.edges = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, edges, $CreateAnonymousDelegate(this, function (e){
                return e.get_Source() != e.get_Target();
            }));
            this.settings = settings;
            this.horizontalSolver = horizontalSolver;
            this.verticalSolver = verticalSolver;
            var $it651 = this.edges.GetEnumerator();
            while ($it651.MoveNext()){
                var e = $it651.get_Current();
                var u = this.CreateTNode(e.get_Source()),v = this.CreateTNode(e.get_Target());
                u.outNeighbours.Add(v);
                v.inNeighbours.Add(u);
            }
            var $it652 = this.nodeMap.get_Values().GetEnumerator();
            while ($it652.MoveNext()){
                var v = $it652.get_Current();
                if (v.stackNode == null){
                    this.DFS(v);
                }
            }
            while (this.stack.get_Count() > 0){
                this.component = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Layout.Incremental.TNode.ctor);
                this.RDFS(this.stack.get_Last().get_Value());
                if (this.component.get_Count() > 1){
                    var cyclicComponent = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor);
                    var $it653 = this.component.GetEnumerator();
                    while ($it653.MoveNext()){
                        var v = $it653.get_Current();
                        cyclicComponent.Insert(v.v);
                    }
                    this.cyclicComponents.Add(cyclicComponent);
                }
            }
            switch (settings.get_EdgeDirectionConstraints()){
                case Microsoft.Msagl.Core.Geometry.Directions.South:
                    this.addConstraint = $CreateDelegate(this, this.AddSConstraint);
                    break;
                case Microsoft.Msagl.Core.Geometry.Directions.North:
                    this.addConstraint = $CreateDelegate(this, this.AddNConstraint);
                    break;
                case Microsoft.Msagl.Core.Geometry.Directions.West:
                    this.addConstraint = $CreateDelegate(this, this.AddWConstraint);
                    break;
                case Microsoft.Msagl.Core.Geometry.Directions.East:
                    this.addConstraint = $CreateDelegate(this, this.AddEConstraint);
                    break;
            }
        },
        AddSConstraint: function (u, v){
            this.verticalSolver.AddStructuralConstraint(new Microsoft.Msagl.Layout.Incremental.VerticalSeparationConstraint.ctor$$Node$$Node$$Double(u, v, (u.get_Height() + v.get_Height()) / 2 + this.settings.get_ConstrainedEdgeSeparation()));
        },
        AddNConstraint: function (u, v){
            this.verticalSolver.AddStructuralConstraint(new Microsoft.Msagl.Layout.Incremental.VerticalSeparationConstraint.ctor$$Node$$Node$$Double(v, u, (u.get_Height() + v.get_Height()) / 2 + this.settings.get_ConstrainedEdgeSeparation()));
        },
        AddEConstraint: function (u, v){
            this.horizontalSolver.AddStructuralConstraint(new Microsoft.Msagl.Layout.Incremental.HorizontalSeparationConstraint.ctor$$Node$$Node$$Double(v, u, (u.get_Width() + v.get_Width()) / 2 + this.settings.get_ConstrainedEdgeSeparation()));
        },
        AddWConstraint: function (u, v){
            this.horizontalSolver.AddStructuralConstraint(new Microsoft.Msagl.Layout.Incremental.HorizontalSeparationConstraint.ctor$$Node$$Node$$Double(u, v, (u.get_Width() + v.get_Width()) / 2 + this.settings.get_ConstrainedEdgeSeparation()));
        },
        GenerateSeparationConstraints: function (){
            var $it654 = this.edges.GetEnumerator();
            while ($it654.MoveNext()){
                var e = $it654.get_Current();
                var edgeInCycle = false;
                var u = e.get_Source(),v = e.get_Target();
                var $it655 = this.cyclicComponents.GetEnumerator();
                while ($it655.MoveNext()){
                    var c = $it655.get_Current();
                    if (c.Contains$$T(u) && c.Contains$$T(v)){
                        edgeInCycle = true;
                        break;
                    }
                }
                if (!edgeInCycle){
                    this.addConstraint(u, v);
                }
            }
        },
        CyclicComponents$$: "System.Collections.Generic.IEnumerable`1[[System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Layout.Node]]]]",
        get_CyclicComponents: function (){
            return System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.DataStructures.Set$1.ctor, System.Collections.Generic.IEnumerable$1.ctor, this.cyclicComponents, $CreateAnonymousDelegate(this, function (c){
                return System.Linq.Enumerable.AsEnumerable$1(Microsoft.Msagl.Core.Layout.Node.ctor, c);
            }));
        },
        DFS: function (u){
            u.visited = true;
            var $it656 = u.outNeighbours.GetEnumerator();
            while ($it656.MoveNext()){
                var v = $it656.get_Current();
                if (!v.visited){
                    this.DFS(v);
                }
            }
            this.PushStack(u);
        },
        RDFS: function (u){
            this.component.Add(u);
            this.PopStack(u);
            var $it657 = u.inNeighbours.GetEnumerator();
            while ($it657.MoveNext()){
                var v = $it657.get_Current();
                if (v.stackNode != null){
                    this.RDFS(v);
                }
            }
        },
        CreateTNode: function (v){
            var tv;
            if (!this.nodeMap.ContainsKey(v)){
                tv = new Microsoft.Msagl.Layout.Incremental.TNode.ctor(v);
                this.nodeMap.set_Item$$TKey(v, tv);
            }
            else {
                tv = this.nodeMap.get_Item$$TKey(v);
            }
            return tv;
        },
        PushStack: function (v){
            v.stackNode = this.stack.AddLast$$T(v);
        },
        PopStack: function (v){
            this.stack.Remove$$LinkedListNode$1(v.stackNode);
            v.stackNode = null;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Incremental$EdgeConstraintGenerator);
var Microsoft$Msagl$Layout$Incremental$EdgeConstraintGenerator$AddConstraint = {
    fullname: "Microsoft.Msagl.Layout.Incremental.EdgeConstraintGenerator.AddConstraint",
    Kind: "Delegate",
    definition: {
        ctor: function (obj, func){
            System.MulticastDelegate.ctor.call(this, obj, func);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Incremental$EdgeConstraintGenerator$AddConstraint);
var Microsoft$Msagl$Layout$Incremental$FastIncrementalLayout = {
    fullname: "Microsoft.Msagl.Layout.Incremental.FastIncrementalLayout",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        },
        CalculateMultiPorts: function (e){
            var sourceLocation = e.source.get_Center();
            var targetLocation = e.target.get_Center();
            var sourceMultiPort = As(e.mEdge.get_SourcePort(), Microsoft.Msagl.Core.Layout.MultiLocationFloatingPort.ctor);
            if (sourceMultiPort != null){
                sourceMultiPort.SetClosestLocation(targetLocation);
            }
            var targetMultiPort = As(e.mEdge.get_TargetPort(), Microsoft.Msagl.Core.Layout.MultiLocationFloatingPort.ctor);
            if (targetMultiPort != null){
                targetMultiPort.SetClosestLocation(sourceLocation);
            }
        },
        AddGravityForce: function (origin, gravity, v){
            v.force = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v.force, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(0.0001 * gravity, (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(origin, v.get_Center()))));
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (geometryGraph, settings, initialConstraintLevel, clusterSettings){
            this.basicGraph = null;
            this.components = null;
            this.constraints = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, System.Collections.Generic.List$1.ctor);
            this.edges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Layout.Incremental.FiEdge.ctor);
            this.energy = 0;
            this.graph = null;
            this.horizontalSolver = null;
            this.nodes = null;
            this.progress = 0;
            this.settings = null;
            this.stepSize = 0;
            this.verticalSolver = null;
            this.clusterSettings = null;
            this.clusterEdges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor);
            this.currentConstraintLevel = 0;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.graph = geometryGraph;
            this.settings = settings;
            this.clusterSettings = clusterSettings;
            var i = 0;
            var allNodes = this.graph.get_Nodes();
            this.nodes = new Array(allNodes.get_Count());
            var $it658 = allNodes.GetEnumerator();
            while ($it658.MoveNext()){
                var v = $it658.get_Current();
                v.AlgorithmData = this.nodes[i] = new Microsoft.Msagl.Layout.Incremental.FiNode.ctor(i, v);
                i++;
            }
            this.clusterEdges.Clear();
            this.edges.Clear();
            var $it659 = this.graph.get_Edges().GetEnumerator();
            while ($it659.MoveNext()){
                var e = $it659.get_Current();
                if (Is(e.get_Source(), Microsoft.Msagl.Core.Layout.Cluster.ctor) || Is(e.get_Target(), Microsoft.Msagl.Core.Layout.Cluster.ctor))
                    this.clusterEdges.Add(e);
                else
                    this.edges.Add(new Microsoft.Msagl.Layout.Incremental.FiEdge.ctor(e));
                var $it660 = e.get_Labels().GetEnumerator();
                while ($it660.MoveNext()){
                    var l = $it660.get_Current();
                    l.set_InnerPoints((function ($p36){
                        l.set_OuterPoints($p36);
                        return $p36;
                    }).call(this, null));
                }
            }
            this.SetLockNodeWeights();
            this.components = new System.Collections.Generic.List$1.ctor(Array);
            if (!settings.get_InterComponentForces()){
                this.basicGraph = new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor$$IEnumerable$1$$Int32(Microsoft.Msagl.Layout.Incremental.FiEdge.ctor, this.edges, this.nodes.length);
                var $it661 = Microsoft.Msagl.Core.GraphAlgorithms.ConnectedComponentCalculator$1.GetComponents(this.basicGraph).GetEnumerator();
                while ($it661.MoveNext()){
                    var componentNodes = $it661.get_Current();
                    var vs = new Array(System.Linq.Enumerable.Count$1$$IEnumerable$1(System.Int32.ctor, componentNodes));
                    var vi = 0;
                    var $it662 = componentNodes.GetEnumerator();
                    while ($it662.MoveNext()){
                        var v = $it662.get_Current();
                        vs[vi++] = this.nodes[v];
                    }
                    this.components.Add(vs);
                }
            }
            else
                this.components.Add(this.nodes);
            this.horizontalSolver = (function (){
                var $v86 = new Microsoft.Msagl.Layout.Incremental.AxisSolver.ctor(true, this.nodes, [geometryGraph.get_RootCluster()], settings.get_AvoidOverlaps(), settings.get_MinConstraintLevel(), clusterSettings);
                $v86.OverlapRemovalParameters = (function (){
                    var $v87 = new Microsoft.Msagl.Core.Geometry.OverlapRemovalParameters.ctor();
                    $v87.set_AllowDeferToVertical(true);
                    $v87.set_ConsiderProportionalOverlap(settings.get_ApplyForces());
                    return $v87;
                }).call(this);
                return $v86;
            }).call(this);
            this.verticalSolver = new Microsoft.Msagl.Layout.Incremental.AxisSolver.ctor(false, this.nodes, [geometryGraph.get_RootCluster()], settings.get_AvoidOverlaps(), settings.get_MinConstraintLevel(), clusterSettings);
            this.SetupConstraints();
            geometryGraph.get_RootCluster().ComputeWeight();
            var $it663 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Cluster.ctor, geometryGraph.get_RootCluster().AllClustersDepthFirst(), $CreateAnonymousDelegate(this, function (c){
                return c.get_RectangularBoundary() == null;
            })).GetEnumerator();
            while ($it663.MoveNext()){
                var c = $it663.get_Current();
                c.set_RectangularBoundary(new Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.ctor());
            }
            this.set_CurrentConstraintLevel(initialConstraintLevel);
        },
        SetupConstraints: function (){
            this.AddConstraintLevel(0);
            if (this.settings.get_AvoidOverlaps()){
                this.AddConstraintLevel(2);
            }
            var $it664 = this.settings.get_StructuralConstraints().GetEnumerator();
            while ($it664.MoveNext()){
                var c = $it664.get_Current();
                this.AddConstraintLevel(c.get_Level());
                if (Is(c, Microsoft.Msagl.Layout.Incremental.VerticalSeparationConstraint.ctor)){
                    this.verticalSolver.AddStructuralConstraint(c);
                }
                else if (Is(c, Microsoft.Msagl.Layout.Incremental.HorizontalSeparationConstraint.ctor)){
                    this.horizontalSolver.AddStructuralConstraint(c);
                }
                else {
                    this.AddConstraint(c);
                }
            }
            Microsoft.Msagl.Layout.Incremental.EdgeConstraintGenerator.GenerateEdgeConstraints(this.graph.get_Edges(), this.settings.get_IdealEdgeLength(), this.horizontalSolver, this.verticalSolver);
        },
        CurrentConstraintLevel$$: "System.Int32",
        get_CurrentConstraintLevel: function (){
            return this.currentConstraintLevel;
        },
        set_CurrentConstraintLevel: function (value){
            this.currentConstraintLevel = value;
            this.horizontalSolver.ConstraintLevel = value;
            this.verticalSolver.ConstraintLevel = value;
            Microsoft.Msagl.Layout.Incremental.Feasibility.Enforce(this.settings, value, this.nodes, this.horizontalSolver.structuralConstraints, this.verticalSolver.structuralConstraints, [this.graph.get_RootCluster()], this.clusterSettings);
            this.settings.Unconverge();
        },
        AddConstraint: function (c){
            if (!this.constraints.ContainsKey(c.get_Level())){
                this.constraints.set_Item$$TKey(c.get_Level(), new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Layout.Incremental.IConstraint.ctor));
            }
            this.constraints.get_Item$$TKey(c.get_Level()).Add(c);
        },
        AddConstraintLevel: function (level){
            if (!this.constraints.ContainsKey(level)){
                this.constraints.set_Item$$TKey(level, new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Layout.Incremental.IConstraint.ctor));
            }
        },
        SetLockNodeWeights: function (){
            var $it665 = this.settings.locks.GetEnumerator();
            while ($it665.MoveNext()){
                var l = $it665.get_Current();
                l.SetLockNodeWeight();
            }
        },
        ResetNodePositions: function (){
            for (var $i667 = 0,$t667 = this.nodes,$l667 = $t667.length,v = $t667[$i667]; $i667 < $l667; $i667++, v = $t667[$i667]){
                v.ResetBounds();
            }
            var $it667 = this.edges.GetEnumerator();
            while ($it667.MoveNext()){
                var e = $it667.get_Current();
                var $it668 = e.mEdge.get_Labels().GetEnumerator();
                while ($it668.MoveNext()){
                    var l = $it668.get_Current();
                    l.set_InnerPoints((function ($p37){
                        l.set_OuterPoints($p37);
                        return $p37;
                    }).call(this, null));
                }
            }
        },
        AddRepulsiveForce: function (v, repulsion){
            v.force = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(10 * this.settings.get_RepulsiveForceConstant(), repulsion);
        },
        AddLogSpringForces: function (e, duv, d){
            var l = duv.get_Length(),f = 0.0007 * this.settings.get_AttractiveForceConstant() * l * System.Math.Log$$Double((l + 0.1) / (d + 0.1));
            e.source.force = Microsoft.Msagl.Core.Geometry.Point.op_Addition(e.source.force, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(f, duv));
            e.target.force = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(e.target.force, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(f, duv));
        },
        AddSquaredSpringForces: function (e, duv, d){
            var l = duv.get_Length(),d2 = d * d + 0.1,f = this.settings.get_AttractiveForceConstant() * (l - d) / d2;
            e.source.force = Microsoft.Msagl.Core.Geometry.Point.op_Addition(e.source.force, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(f, duv));
            e.target.force = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(e.target.force, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(f, duv));
        },
        AddSpringForces: function (e){
            var duv;
            if (this.settings.get_RespectEdgePorts()){
                var sourceLocation = e.source.get_Center();
                var targetLocation = e.target.get_Center();
                var sourceFloatingPort = As(e.mEdge.get_SourcePort(), Microsoft.Msagl.Core.Layout.FloatingPort.ctor);
                if (sourceFloatingPort != null){
                    sourceLocation = sourceFloatingPort.get_Location();
                }
                var targetFloatingPort = As(e.mEdge.get_TargetPort(), Microsoft.Msagl.Core.Layout.FloatingPort.ctor);
                if (targetFloatingPort != null){
                    targetLocation = targetFloatingPort.get_Location();
                }
                duv = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(sourceLocation, targetLocation);
            }
            else {
                duv = e.vector();
            }
            if (this.settings.get_LogScaleEdgeForces()){
                this.AddLogSpringForces(e, duv, e.mEdge.get_Length());
            }
            else {
                this.AddSquaredSpringForces(e, duv, e.mEdge.get_Length());
            }
        },
        ComputeRepulsiveForces: function (vs){
            var n = vs.length;
            if (n > 16 && this.settings.get_ApproximateRepulsion()){
                var ps = new Array(vs.length);
                var angle = 0,angleDelta = 6.28318530717959 / n;
                for (var i = 0; i < n; ++i){
                    ps[i] = new Microsoft.Msagl.Layout.Incremental.KDTree.Particle.ctor(Microsoft.Msagl.Core.Geometry.Point.op_Addition(vs[i].get_Center(), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(1E-05, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(System.Math.Cos(angle), System.Math.Sin(angle)))));
                    angle += angleDelta;
                }
                var kdTree = new Microsoft.Msagl.Layout.Incremental.KDTree.ctor(ps, 8);
                kdTree.ComputeForces(5);
                for (var i = 0; i < vs.length; ++i){
                    this.AddRepulsiveForce(vs[i], ps[i].force);
                }
            }
            else {
                for (var $i670 = 0,$l670 = vs.length,u = vs[$i670]; $i670 < $l670; $i670++, u = vs[$i670]){
                    var fu = new Microsoft.Msagl.Core.Geometry.Point.ctor();
                    for (var $i671 = 0,$l671 = vs.length,v = vs[$i671]; $i671 < $l671; $i671++, v = vs[$i671]){
                        if (u != v){
                            fu = Microsoft.Msagl.Core.Geometry.Point.op_Addition(fu, Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Force(u.get_Center(), v.get_Center()));
                        }
                    }
                    this.AddRepulsiveForce(u, fu);
                }
            }
        },
        AddClusterForces: function (root){
            if (root == null)
                return;
            root.SetBarycenter();
            var $it671 = this.clusterEdges.GetEnumerator();
            while ($it671.MoveNext()){
                var e = $it671.get_Current();
                var c1 = As(e.get_Source(), Microsoft.Msagl.Core.Layout.Cluster.ctor);
                var c2 = As(e.get_Target(), Microsoft.Msagl.Core.Layout.Cluster.ctor);
                var n1 = As(e.get_Source().AlgorithmData, Microsoft.Msagl.Layout.Incremental.FiNode.ctor);
                var n2 = As(e.get_Target().AlgorithmData, Microsoft.Msagl.Layout.Incremental.FiNode.ctor);
                var center1 = c1 != null ? c1.Barycenter : n1.get_Center();
                var center2 = c2 != null ? c2.Barycenter : n2.get_Center();
                var duv = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(center1, center2);
                var l = duv.get_Length(),f = 1E-08 * this.settings.get_AttractiveInterClusterForceConstant() * l * System.Math.Log$$Double(l + 0.1);
                if (c1 != null){
                    c1.ForEachNode($CreateAnonymousDelegate(this, function (v){
                        var fv = As(v.AlgorithmData, Microsoft.Msagl.Layout.Incremental.FiNode.ctor);
                        fv.force = Microsoft.Msagl.Core.Geometry.Point.op_Addition(fv.force, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(f, duv));
                    }));
                }
                else {
                    n1.force = Microsoft.Msagl.Core.Geometry.Point.op_Addition(n1.force, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(f, duv));
                }
                if (c2 != null){
                    c2.ForEachNode($CreateAnonymousDelegate(this, function (v){
                        var fv = As(v.AlgorithmData, Microsoft.Msagl.Layout.Incremental.FiNode.ctor);
                        fv.force = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(fv.force, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(f, duv));
                    }));
                }
                else {
                    n2.force = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(n2.force, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(f, duv));
                }
            }
            var $it672 = root.AllClustersDepthFirst().GetEnumerator();
            while ($it672.MoveNext()){
                var c = $it672.get_Current();
                if (c != root){
                    c.ForEachNode($CreateAnonymousDelegate(this, function (v){
                        Microsoft.Msagl.Layout.Incremental.FastIncrementalLayout.AddGravityForce(c.Barycenter, this.settings.get_ClusterGravity(), Cast(v.AlgorithmData, Microsoft.Msagl.Layout.Incremental.FiNode.ctor));
                    }));
                }
            }
        },
        ComputeForces: function (){
            if (this.components != null){
                this.components.ForEach($CreateDelegate(this, this.ComputeRepulsiveForces));
            }
            else {
                this.ComputeRepulsiveForces(this.nodes);
            }
            this.edges.ForEach($CreateDelegate(this, this.AddSpringForces));
            var $it673 = this.components.GetEnumerator();
            while ($it673.MoveNext()){
                var c = $it673.get_Current();
                var origin = new Microsoft.Msagl.Core.Geometry.Point.ctor();
                for (var i = 0; i < c.length; ++i){
                    origin = Microsoft.Msagl.Core.Geometry.Point.op_Addition(origin, c[i].get_Center());
                }
                origin = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(origin, c.length);
                var maxForce = -Infinity;
                for (var i = 0; i < c.length; ++i){
                    var v = c[i];
                    Microsoft.Msagl.Layout.Incremental.FastIncrementalLayout.AddGravityForce(origin, this.settings.get_GravityConstant(), v);
                    if (v.force.get_Length() > maxForce){
                        maxForce = v.force.get_Length();
                    }
                }
                if (maxForce > 100){
                    for (var i = 0; i < c.length; ++i){
                        c[i].force = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(c[i].force, 100 / maxForce);
                    }
                }
            }
            this.AddClusterForces(this.graph.get_RootCluster());
        },
        SatisfyConstraints: function (){
            for (var i = 0; i < this.settings.get_ProjectionIterations(); ++i){
                var $it674 = this.constraints.get_Keys().GetEnumerator();
                while ($it674.MoveNext()){
                    var level = $it674.get_Current();
                    if (level > this.get_CurrentConstraintLevel()){
                        break;
                    }
                    var $it675 = this.constraints.get_Item$$TKey(level).GetEnumerator();
                    while ($it675.MoveNext()){
                        var c = $it675.get_Current();
                        c.Project();
                        var $it676 = c.get_Nodes().GetEnumerator();
                        while ($it676.MoveNext()){
                            var v = $it676.get_Current();
                            (Cast(v.AlgorithmData, Microsoft.Msagl.Layout.Incremental.FiNode.ctor)).set_Center(v.get_Center());
                        }
                    }
                }
                var $it677 = this.settings.locks.GetEnumerator();
                while ($it677.MoveNext()){
                    var l = $it677.get_Current();
                    l.Project();
                    var $it678 = l.get_Nodes().GetEnumerator();
                    while ($it678.MoveNext()){
                        var v = $it678.get_Current();
                        var fiNode = As(v.AlgorithmData, Microsoft.Msagl.Layout.Incremental.FiNode.ctor);
                        if (fiNode != null && v.AlgorithmData != null){
                            fiNode.ResetBounds();
                        }
                    }
                }
            }
        },
        NeedSolve: function (){
            return this.horizontalSolver.get_NeedSolve() || this.verticalSolver.get_NeedSolve();
        },
        VerletIntegration: function (){
            var energy0 = this.energy;
            this.energy = this.ComputeDescentDirection(1);
            this.UpdateStepSize(energy0);
            this.SolveSeparationConstraints();
            var displacementSquared = 0;
            for (var i = 0; i < this.nodes.length; ++i){
                var v = this.nodes[i];
                displacementSquared += (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v.get_Center(), v.previousCenter)).get_LengthSquared();
            }
            return displacementSquared;
        },
        SolveSeparationConstraints: function (){
            if (this.NeedSolve()){
                var dblVpad = this.settings.get_NodeSeparation();
                var dblHpad = dblVpad + 0.0001;
                var dblCVpad = this.settings.get_ClusterMargin();
                var dblCHpad = dblCVpad + 0.0001;
                for (var $i680 = 0,$t680 = this.nodes,$l680 = $t680.length,v = $t680[$i680]; $i680 < $l680; $i680++, v = $t680[$i680]){
                    v.desiredPosition = v.get_Center();
                }
                this.horizontalSolver.Initialize(dblHpad, dblVpad, dblCHpad, dblCVpad, $CreateAnonymousDelegate(this, function (v){
                    return v.previousCenter;
                }));
                this.horizontalSolver.SetDesiredPositions();
                this.horizontalSolver.Solve();
                this.verticalSolver.Initialize(dblHpad, dblVpad, dblCHpad, dblCVpad, $CreateAnonymousDelegate(this, function (v){
                    return v.get_Center();
                }));
                this.verticalSolver.SetDesiredPositions();
                this.verticalSolver.Solve();
                var $it680 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Layout.Incremental.LockPosition.ctor, this.settings.locks, $CreateAnonymousDelegate(this, function (l){
                    return !l.get_Sticky();
                })).GetEnumerator();
                while ($it680.MoveNext()){
                    var l = $it680.get_Current();
                    l.set_Bounds(l.node.get_BoundingBox());
                }
            }
        },
        ComputeDescentDirection: function (alpha){
            this.ResetForceVectors();
            if (this.settings.get_ApplyForces()){
                this.ComputeForces();
            }
            var lEnergy = 0;
            for (var $i682 = 0,$t682 = this.nodes,$l682 = $t682.length,v = $t682[$i682]; $i682 < $l682; $i682++, v = $t682[$i682]){
                lEnergy += v.force.get_LengthSquared();
                var dx = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v.get_Center(), v.previousCenter);
                v.previousCenter = v.get_Center();
                dx = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(dx, this.settings.get_Friction());
                var a = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(-this.stepSize * alpha, v.force);
                System.Diagnostics.Debug.Assert$$Boolean$$String(!System.Double.IsNaN(a.get_X()), "!double.IsNaN(a.X)");
                System.Diagnostics.Debug.Assert$$Boolean$$String(!System.Double.IsNaN(a.get_Y()), "!double.IsNaN(a.Y)");
                System.Diagnostics.Debug.Assert$$Boolean$$String(!System.Double.IsInfinity(a.get_X()), "!double.IsInfinity(a.X)");
                System.Diagnostics.Debug.Assert$$Boolean$$String(!System.Double.IsInfinity(a.get_Y()), "!double.IsInfinity(a.Y)");
                dx = Microsoft.Msagl.Core.Geometry.Point.op_Addition(dx, a);
                dx = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(dx, v.stayWeight);
                v.set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Addition(v.get_Center(), dx));
            }
            this.SatisfyConstraints();
            return lEnergy;
        },
        ResetForceVectors: function (){
            for (var $i683 = 0,$t683 = this.nodes,$l683 = $t683.length,v = $t683[$i683]; $i683 < $l683; $i683++, v = $t683[$i683]){
                v.force = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            }
        },
        UpdateStepSize: function (energy0){
            if (this.energy < energy0){
                if (++this.progress >= 3){
                    this.progress = 0;
                    this.stepSize /= this.settings.get_Decay();
                }
            }
            else {
                this.progress = 0;
                this.stepSize *= this.settings.get_Decay();
            }
        },
        RungeKuttaIntegration: function (){
            var y0 = new Array(this.nodes.length);
            var k1 = new Array(this.nodes.length);
            var k2 = new Array(this.nodes.length);
            var k3 = new Array(this.nodes.length);
            var k4 = new Array(this.nodes.length);
            var energy0 = this.energy;
            this.SatisfyConstraints();
            for (var i = 0; i < this.nodes.length; ++i){
                y0[i] = this.nodes[i].previousCenter = this.nodes[i].get_Center();
            }
            var alpha = 3;
            this.ComputeDescentDirection(alpha);
            for (var i = 0; i < this.nodes.length; ++i){
                k1[i] = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.nodes[i].get_Center(), this.nodes[i].previousCenter);
                this.nodes[i].set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Addition(y0[i], Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(0.5, k1[i])));
            }
            this.ComputeDescentDirection(alpha);
            for (var i = 0; i < this.nodes.length; ++i){
                k2[i] = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.nodes[i].get_Center(), this.nodes[i].previousCenter);
                this.nodes[i].previousCenter = y0[i];
                this.nodes[i].set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Addition(y0[i], Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(0.5, k2[i])));
            }
            this.ComputeDescentDirection(alpha);
            for (var i = 0; i < this.nodes.length; ++i){
                k3[i] = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.nodes[i].get_Center(), this.nodes[i].previousCenter);
                this.nodes[i].previousCenter = y0[i];
                this.nodes[i].set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Addition(y0[i], k3[i]));
            }
            this.energy = this.ComputeDescentDirection(alpha);
            for (var i = 0; i < this.nodes.length; ++i){
                k4[i] = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.nodes[i].get_Center(), this.nodes[i].previousCenter);
                this.nodes[i].previousCenter = y0[i];
                var dx = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Addition(k1[i], Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(2, k2[i])), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(2, k3[i])), k4[i])), 6);
                this.nodes[i].set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Addition(y0[i], dx));
            }
            this.UpdateStepSize(energy0);
            this.SolveSeparationConstraints();
            return System.Linq.Enumerable.Sum$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Layout.Incremental.FiNode.ctor, this.nodes, $CreateAnonymousDelegate(this, function (v){
                return (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v.get_Center(), v.previousCenter)).get_LengthSquared();
            }));
        },
        RunInternal: function (){
            this.settings.set_Converged(false);
            this.settings.set_EdgeRoutesUpToDate(false);
            if (this.settings.set_Iterations(this.settings.get_Iterations() + 1) == 0){
                this.stepSize = this.settings.get_InitialStepSize();
                this.energy = 3.402823E+38;
                this.progress = 0;
            }
            this.StartListenToLocalProgress(this.settings.get_MinorIterations(), 1);
            for (var i = 0; i < this.settings.get_MinorIterations(); ++i){
                if (this.settings.get_RespectEdgePorts()){
                    this.edges.ForEach(Microsoft.Msagl.Layout.Incremental.FastIncrementalLayout.CalculateMultiPorts);
                }
                var d2 = this.settings.get_RungeKuttaIntegration() ? this.RungeKuttaIntegration() : this.VerletIntegration();
                if (d2 < this.settings.get_DisplacementThreshold() || this.settings.get_Iterations() > this.settings.get_MaxIterations()){
                    this.settings.set_Converged(true);
                    this.ProgressComplete();
                    break;
                }
                this.ProgressStep();
            }
            this.FinalizeClusterBoundaries();
        },
        FinalizeClusterBoundaries: function (){
            var $it683 = this.graph.get_RootCluster().AllClustersDepthFirst().GetEnumerator();
            while ($it683.MoveNext()){
                var c = $it683.get_Current();
                if (c == this.graph.get_RootCluster())
                    continue;
                if (!this.NeedSolve() && this.settings.get_UpdateClusterBoundariesFromChildren()){
                    c.CalculateBoundsFromChildren(this.settings.get_ClusterMargin());
                }
                else {
                    c.set_BoundingBox(c.get_RectangularBoundary().get_Rect());
                }
                c.RaiseLayoutDoneEvent();
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Incremental$FastIncrementalLayout);
var Microsoft$Msagl$Layout$Incremental$FiEdge = {
    fullname: "Microsoft.Msagl.Layout.Incremental.FiEdge",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Core.GraphAlgorithms.IEdge"],
    Kind: "Class",
    definition: {
        ctor: function (mEdge){
            this.mEdge = null;
            this.source = null;
            this.target = null;
            System.Object.ctor.call(this);
            this.mEdge = mEdge;
            this.source = Cast(mEdge.get_Source().AlgorithmData, Microsoft.Msagl.Layout.Incremental.FiNode.ctor);
            this.target = Cast(mEdge.get_Target().AlgorithmData, Microsoft.Msagl.Layout.Incremental.FiNode.ctor);
        },
        Source$$: "System.Int32",
        get_Source: function (){
            return this.source.index;
        },
        set_Source: function (value){
        },
        Target$$: "System.Int32",
        get_Target: function (){
            return this.target.index;
        },
        set_Target: function (value){
        },
        vector: function (){
            return Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.source.mNode.get_Center(), this.target.mNode.get_Center());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Incremental$FiEdge);
var Microsoft$Msagl$Layout$Incremental$FiNode = {
    fullname: "Microsoft.Msagl.Layout.Incremental.FiNode",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (index, mNode){
            this.desiredPosition = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.force = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.index = 0;
            this.mNode = null;
            this.mOlapNodeX = null;
            this.mOlapNodeY = null;
            this.previousCenter = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.center = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.stayWeight = 1;
            this.Width = 0;
            this.Height = 0;
            System.Object.ctor.call(this);
            this.index = index;
            this.mNode = mNode;
            this.ResetBounds();
        },
        Center$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Center: function (){
            return this.center;
        },
        set_Center: function (value){
            this.center = (function ($p38){
                this.mNode.set_Center($p38);
                return $p38;
            }).call(this, value);
        },
        ResetBounds: function (){
            this.center = this.previousCenter = this.mNode.get_Center();
            this.Width = this.mNode.get_Width();
            this.Height = this.mNode.get_Height();
        },
        getOlapNode: function (horizontal){
            return horizontal ? this.mOlapNodeX : this.mOlapNodeY;
        },
        SetOlapNode: function (horizontal, olapNode){
            if (horizontal)
                this.mOlapNodeX = olapNode;
            else
                this.mOlapNodeY = olapNode;
        },
        SetVariableDesiredPos: function (horizontal){
            if (horizontal)
                this.mOlapNodeX.get_Variable().set_DesiredPos(this.desiredPosition.get_X());
            else
                this.mOlapNodeY.get_Variable().set_DesiredPos(this.desiredPosition.get_Y());
        },
        UpdatePos: function (horizontal){
            if (horizontal)
                this.set_Center(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.getOlapNode(true).get_Position(), this.previousCenter.get_Y()));
            else
                this.set_Center(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.get_Center().get_X(), this.getOlapNode(false).get_Position()));
        },
        toString: function (){
            return "FINode(" + this.index + "):" + this.mNode;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Incremental$FiNode);
var Microsoft$Msagl$Layout$Incremental$HorizontalSeparationConstraint = {
    fullname: "Microsoft.Msagl.Layout.Incremental.HorizontalSeparationConstraint",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Layout.Incremental.IConstraint"],
    Kind: "Class",
    definition: {
        ctor$$Node$$Node$$Double: function (u, v, separation){
            this.equality = false;
            this.u = null;
            this.v = null;
            this.separation = 0;
            System.Object.ctor.call(this);
            this.u = u;
            this.v = v;
            this.separation = separation;
        },
        IsEquality$$: "System.Boolean",
        get_IsEquality: function (){
            return this.equality;
        },
        LeftNode$$: "Microsoft.Msagl.Core.Layout.Node",
        get_LeftNode: function (){
            return this.u;
        },
        RightNode$$: "Microsoft.Msagl.Core.Layout.Node",
        get_RightNode: function (){
            return this.v;
        },
        Separation$$: "System.Double",
        get_Separation: function (){
            return this.separation;
        },
        set_Separation: function (value){
            this.separation = value;
        },
        ctor$$Node$$Node$$Double$$Boolean: function (u, v, separation, equality){
            this.equality = false;
            this.u = null;
            this.v = null;
            this.separation = 0;
            System.Object.ctor.call(this);
            this.equality = equality;
            this.u = u;
            this.v = v;
            this.separation = separation;
        },
        Project: function (){
            var uv = this.v.get_Center().get_X() - this.u.get_Center().get_X();
            var d = this.separation - uv;
            if (d > 0){
                var wu = (Cast(this.u.AlgorithmData, Microsoft.Msagl.Layout.Incremental.FiNode.ctor)).stayWeight,wv = (Cast(this.v.AlgorithmData, Microsoft.Msagl.Layout.Incremental.FiNode.ctor)).stayWeight;
                var f = d / (wu + wv);
                this.u.set_Center(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.u.get_Center().get_X() - wv * f, this.u.get_Center().get_Y()));
                this.v.set_Center(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.v.get_Center().get_X() + wu * f, this.v.get_Center().get_Y()));
                return d;
            }
            else {
                return 0;
            }
        },
        Level$$: "System.Int32",
        get_Level: function (){
            return 0;
        },
        Nodes$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Layout.Node]]",
        get_Nodes: function (){
            return [this.u, this.v];
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Incremental$HorizontalSeparationConstraint);
var Microsoft$Msagl$Layout$Incremental$IConstraint = {
    fullname: "Microsoft.Msagl.Layout.Incremental.IConstraint",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Interface"
};
JsTypes.push(Microsoft$Msagl$Layout$Incremental$IConstraint);
var Microsoft$Msagl$Layout$Incremental$LockPosition = {
    fullname: "Microsoft.Msagl.Layout.Incremental.LockPosition",
    baseTypeName: "System.Object",
    staticDefinition: {
        SetFINodeWeight: function (child, weight){
            var v = As(child.AlgorithmData, Microsoft.Msagl.Layout.Incremental.FiNode.ctor);
            if (v != null){
                v.stayWeight = weight;
            }
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Layout.Incremental.IConstraint"],
    Kind: "Class",
    definition: {
        ctor$$Node$$Rectangle: function (node, bounds){
            this.weight = 1000000;
            this.node = null;
            this.listNode = null;
            this._Bounds = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
            this._Sticky = false;
            System.Object.ctor.call(this);
            this.node = node;
            this.set_Bounds(bounds);
        },
        ctor$$Node$$Rectangle$$Double: function (node, bounds, weight){
            this.weight = 1000000;
            this.node = null;
            this.listNode = null;
            this._Bounds = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
            this._Sticky = false;
            Microsoft.Msagl.Layout.Incremental.LockPosition.ctor$$Node$$Rectangle.call(this, node, bounds);
            this.set_Weight(weight);
        },
        Weight$$: "System.Double",
        get_Weight: function (){
            return this.weight;
        },
        set_Weight: function (value){
            if (value > 1E+20){
                throw $CreateException(new System.ArgumentOutOfRangeException.ctor$$String$$String("value", "must be < 1e10 or we run out of precision"), new Error());
            }
            if (value < 0.001){
                throw $CreateException(new System.ArgumentOutOfRangeException.ctor$$String$$String("value", "must be > 1e-3 or we run out of precision"), new Error());
            }
            this.weight = value;
        },
        Bounds$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_Bounds: function (){
            return this._Bounds;
        },
        set_Bounds: function (value){
            this._Bounds = value;
        },
        Sticky$$: "System.Boolean",
        get_Sticky: function (){
            return this._Sticky;
        },
        set_Sticky: function (value){
            this._Sticky = value;
        },
        Project: function (){
            var delta = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.get_Bounds().get_LeftBottom(), this.node.get_BoundingBox().get_LeftBottom());
            var deltaLength = delta.get_Length();
            var displacement = deltaLength;
            var cluster = As(this.node, Microsoft.Msagl.Core.Layout.Cluster.ctor);
            if (cluster != null){
                var $it684 = cluster.AllClustersDepthFirst().GetEnumerator();
                while ($it684.MoveNext()){
                    var c = $it684.get_Current();
                    var $it685 = c.get_Nodes().GetEnumerator();
                    while ($it685.MoveNext()){
                        var v = $it685.get_Current();
                        v.set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Addition(v.get_Center(), delta));
                        displacement += deltaLength;
                    }
                    if (c == cluster){
                        cluster.get_RectangularBoundary().set_Rect(this.get_Bounds());
                    }
                    else {
                        var r = c.get_RectangularBoundary().get_Rect();
                        c.get_RectangularBoundary().set_Rect(new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Addition(r.get_LeftBottom(), delta), Microsoft.Msagl.Core.Geometry.Point.op_Addition(r.get_RightTop(), delta)));
                    }
                }
            }
            else {
                this.node.set_BoundingBox(this.get_Bounds());
            }
            return displacement;
        },
        Level$$: "System.Int32",
        get_Level: function (){
            return 0;
        },
        SetLockNodeWeight: function (){
            var cluster = As(this.node, Microsoft.Msagl.Core.Layout.Cluster.ctor);
            if (cluster != null){
                var cb = cluster.get_RectangularBoundary();
                cb.Lock$$Double$$Double$$Double$$Double(this.get_Bounds().get_Left(), this.get_Bounds().get_Right(), this.get_Bounds().get_Top(), this.get_Bounds().get_Bottom());
                var $it686 = cluster.AllClustersDepthFirst().GetEnumerator();
                while ($it686.MoveNext()){
                    var c = $it686.get_Current();
                    c.get_RectangularBoundary().set_GenerateFixedConstraints(true);
                    var $it687 = c.get_Nodes().GetEnumerator();
                    while ($it687.MoveNext()){
                        var child = $it687.get_Current();
                        Microsoft.Msagl.Layout.Incremental.LockPosition.SetFINodeWeight(child, this.weight);
                    }
                }
            }
            else {
                Microsoft.Msagl.Layout.Incremental.LockPosition.SetFINodeWeight(this.node, this.weight);
            }
            var $it688 = this.node.get_AllClusterAncestors().GetEnumerator();
            while ($it688.MoveNext()){
                var ancestor = $it688.get_Current();
                if (ancestor.get_RectangularBoundary() != null){
                    ancestor.get_RectangularBoundary().set_GenerateFixedConstraints(false);
                }
                ancestor.UnsetInitialLayoutState();
            }
        },
        RestoreNodeWeight: function (){
            var cluster = As(this.node, Microsoft.Msagl.Core.Layout.Cluster.ctor);
            if (cluster != null){
                cluster.get_RectangularBoundary().Unlock();
                var $it689 = cluster.AllClustersDepthFirst().GetEnumerator();
                while ($it689.MoveNext()){
                    var c = $it689.get_Current();
                    c.get_RectangularBoundary().set_GenerateFixedConstraints(c.get_RectangularBoundary().get_GenerateFixedConstraintsDefault());
                    var $it690 = c.get_Nodes().GetEnumerator();
                    while ($it690.MoveNext()){
                        var child = $it690.get_Current();
                        Microsoft.Msagl.Layout.Incremental.LockPosition.SetFINodeWeight(child, 1);
                    }
                }
            }
            else {
                Microsoft.Msagl.Layout.Incremental.LockPosition.SetFINodeWeight(this.node, 1);
            }
            var parent = System.Linq.Enumerable.FirstOrDefault$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, this.node.get_ClusterParents());
            while (parent != null){
                if (parent.get_RectangularBoundary() != null){
                    parent.get_RectangularBoundary().set_GenerateFixedConstraints(parent.get_RectangularBoundary().get_GenerateFixedConstraintsDefault());
                }
                parent = System.Linq.Enumerable.FirstOrDefault$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, parent.get_ClusterParents());
            }
        },
        Nodes$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Layout.Node]]",
        get_Nodes: function (){
            var nodes = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor);
            var cluster = As(this.node, Microsoft.Msagl.Core.Layout.Cluster.ctor);
            if (cluster != null){
                cluster.ForEachNode($CreateDelegate(nodes, nodes.Add));
            }
            else {
                nodes.Add(this.node);
            }
            return nodes;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Incremental$LockPosition);
var Microsoft$Msagl$Layout$Incremental$MaxSeparationConstraint = {
    fullname: "Microsoft.Msagl.Layout.Incremental.MaxSeparationConstraint",
    baseTypeName: "Microsoft.Msagl.Layout.Incremental.StickConstraint",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (u, v, separation){
            Microsoft.Msagl.Layout.Incremental.StickConstraint.ctor.call(this, u, v, separation);
        },
        Project: function (){
            var uv = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.v.get_Center(), this.u.get_Center());
            if (uv.get_Length() > this.separation){
                return Microsoft.Msagl.Layout.Incremental.StickConstraint.commonPrototype.Project.call(this);
            }
            else {
                return 0;
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Incremental$MaxSeparationConstraint);
var Microsoft$Msagl$Layout$Incremental$MinSeparationConstraint = {
    fullname: "Microsoft.Msagl.Layout.Incremental.MinSeparationConstraint",
    baseTypeName: "Microsoft.Msagl.Layout.Incremental.StickConstraint",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (u, v, separation){
            Microsoft.Msagl.Layout.Incremental.StickConstraint.ctor.call(this, u, v, separation);
        },
        Project: function (){
            var uv = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.v.get_Center(), this.u.get_Center());
            if (uv.get_Length() < this.separation){
                return Microsoft.Msagl.Layout.Incremental.StickConstraint.commonPrototype.Project.call(this);
            }
            else {
                return 0;
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Incremental$MinSeparationConstraint);
var Microsoft$Msagl$Layout$Incremental$KDTree = {
    fullname: "Microsoft.Msagl.Layout.Incremental.KDTree",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (particles, bucketSize){
            this.particles = null;
            this.root = null;
            this.leaves = null;
            System.Object.ctor.call(this);
            this.particles = particles;
            var ps = [this.particlesBy(Microsoft.Msagl.Layout.Incremental.KDTree.Particle.Dim.Horizontal), this.particlesBy(Microsoft.Msagl.Layout.Incremental.KDTree.Particle.Dim.Vertical)];
            this.leaves = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Layout.Incremental.KDTree.LeafKdNode.ctor);
            var l = new Microsoft.Msagl.Layout.Incremental.KDTree.LeafKdNode.ctor(ps),r;
            this.leaves.Add(l);
            this.root = (function (){
                var $1 = {
                    Value: r
                };
                var $res = l.Split($1);
                r = $1.Value;
                return $res;
            }).call(this);
            this.leaves.Add(r);
            var splitQueue = new Microsoft.Msagl.Layout.Incremental.KDTree.SplitQueue.ctor(bucketSize);
            splitQueue.Enqueue$$LeafKdNode$$LeafKdNode(l, r);
            while (splitQueue.get_Count() > 0){
                l = splitQueue.Dequeue();
                (function (){
                    var $1 = {
                        Value: r
                    };
                    var $res = l.Split($1);
                    r = $1.Value;
                    return $res;
                }).call(this);
                this.leaves.Add(r);
                splitQueue.Enqueue$$LeafKdNode$$LeafKdNode(l, r);
            }
        },
        particlesBy: function (d){
            return System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Layout.Incremental.KDTree.Particle.ctor, (System.Linq.Enumerable.OrderBy$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Layout.Incremental.KDTree.Particle.ctor, System.Double.ctor, System.Linq.Enumerable.Cast$1(Microsoft.Msagl.Layout.Incremental.KDTree.Particle.ctor, this.particles), $CreateAnonymousDelegate(this, function (p){
                return p.pos(d);
            }))));
        },
        ComputeForces: function (precision){
            this.root.computeMultipoleCoefficients(precision);
            var $it691 = this.leaves.GetEnumerator();
            while ($it691.MoveNext()){
                var l = $it691.get_Current();
                l.ComputeForces();
                var stack = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Layout.Incremental.KDTree.KdNode.ctor);
                stack.Add(this.root);
                while (stack.get_Count() > 0){
                    var v = System.Linq.Enumerable.Last$1$$IEnumerable$1(Microsoft.Msagl.Layout.Incremental.KDTree.KdNode.ctor, stack);
                    stack.RemoveAt(stack.get_Count() - 1);
                    if (!l.intersects(v)){
                        for (var $i693 = 0,$t693 = l.particles[0],$l693 = $t693.length,p = $t693[$i693]; $i693 < $l693; $i693++, p = $t693[$i693]){
                            p.force = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(p.force, v.multipoleCoefficients.ApproximateForce(p.point));
                        }
                    }
                    else {
                        var leaf = As(v, Microsoft.Msagl.Layout.Incremental.KDTree.LeafKdNode.ctor);
                        if (leaf != null){
                            for (var $i694 = 0,$t694 = l.particles[0],$l694 = $t694.length,p = $t694[$i694]; $i694 < $l694; $i694++, p = $t694[$i694]){
                                for (var $i695 = 0,$t695 = leaf.particles[0],$l695 = $t695.length,q = $t695[$i695]; $i695 < $l695; $i695++, q = $t695[$i695]){
                                    if (p != q){
                                        p.force = Microsoft.Msagl.Core.Geometry.Point.op_Addition(p.force, Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Force(p.point, q.point));
                                    }
                                }
                            }
                        }
                        else {
                            var n = As(v, Microsoft.Msagl.Layout.Incremental.KDTree.InternalKdNode.ctor);
                            stack.Add(n.leftChild);
                            stack.Add(n.rightChild);
                        }
                    }
                }
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Incremental$KDTree);
var Microsoft$Msagl$Layout$Incremental$KDTree$Particle = {
    fullname: "Microsoft.Msagl.Layout.Incremental.KDTree.Particle",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (point){
            this.force = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.point = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.splitLeft = false;
            System.Object.ctor.call(this);
            this.point = point;
            this.force = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, 0);
        },
        pos: function (d){
            return d == Microsoft.Msagl.Layout.Incremental.KDTree.Particle.Dim.Horizontal ? this.point.get_X() : this.point.get_Y();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Incremental$KDTree$Particle);
var Microsoft$Msagl$Layout$Incremental$KDTree$KdNode = {
    fullname: "Microsoft.Msagl.Layout.Incremental.KDTree.KdNode",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.parent = null;
            this.med = null;
            this.multipoleCoefficients = null;
            System.Object.ctor.call(this);
        },
        intersects: function (v){
            var d = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v.med.get_Center(), this.med.get_Center());
            var l = d.get_Length();
            return l < v.med.get_Radius() + this.med.get_Radius();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Incremental$KDTree$KdNode);
var Microsoft$Msagl$Layout$Incremental$KDTree$LeafKdNode = {
    fullname: "Microsoft.Msagl.Layout.Incremental.KDTree.LeafKdNode",
    baseTypeName: "Microsoft.Msagl.Layout.Incremental.KDTree.KdNode",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (particles){
            this.particles = null;
            this.ps = null;
            Microsoft.Msagl.Layout.Incremental.KDTree.KdNode.ctor.call(this);
            System.Diagnostics.Debug.Assert$$Boolean(particles[0].length == particles[1].length);
            this.particles = particles;
            this.ComputeMED();
        },
        computeMultipoleCoefficients: function (precision){
            this.multipoleCoefficients = new Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.ctor$$Int32$$Point$$Point$Array(precision, this.med.get_Center(), this.ps);
        },
        ComputeMED: function (){
            var n = this.Size();
            this.ps = new Array(n);
            for (var i = 0; i < n; ++i){
                this.ps[i] = this.particles[0][i].point;
            }
            return this.med = Microsoft.Msagl.Core.Geometry.MinimumEnclosingDisc.LinearComputation(this.ps);
        },
        Min: function (d){
            return this.particles[d][0].pos(d);
        },
        Size: function (){
            return this.particles[0].length;
        },
        Max: function (d){
            return this.particles[d][this.Size() - 1].pos(d);
        },
        Dimension: function (d){
            return this.Max(d) - this.Min(d);
        },
        Split: function (rightSibling){
            var splitDirection = this.Dimension(Microsoft.Msagl.Layout.Incremental.KDTree.Particle.Dim.Horizontal) > this.Dimension(Microsoft.Msagl.Layout.Incremental.KDTree.Particle.Dim.Vertical) ? Microsoft.Msagl.Layout.Incremental.KDTree.Particle.Dim.Horizontal : Microsoft.Msagl.Layout.Incremental.KDTree.Particle.Dim.Vertical;
            var nonSplitDirection = splitDirection == Microsoft.Msagl.Layout.Incremental.KDTree.Particle.Dim.Horizontal ? Microsoft.Msagl.Layout.Incremental.KDTree.Particle.Dim.Vertical : Microsoft.Msagl.Layout.Incremental.KDTree.Particle.Dim.Horizontal;
            var n = this.Size(),nLeft = (n / 2) | 0,nRight = n - nLeft;
            var leftParticles = [new Array(nLeft), new Array(nLeft)],rightParticles = [new Array(nRight), new Array(nRight)];
            var lCtr = 0,rCtr = 0;
            for (var i = 0; i < n; ++i){
                var p = this.particles[splitDirection][i];
                if (i < nLeft){
                    leftParticles[splitDirection][i] = p;
                    p.splitLeft = true;
                }
                else {
                    rightParticles[splitDirection][i - nLeft] = p;
                    p.splitLeft = false;
                }
            }
            for (var i = 0; i < n; ++i){
                var p = this.particles[nonSplitDirection][i];
                if (p.splitLeft){
                    leftParticles[nonSplitDirection][lCtr++] = p;
                }
                else {
                    rightParticles[nonSplitDirection][rCtr++] = p;
                }
            }
            System.Diagnostics.Debug.Assert$$Boolean(lCtr == nLeft);
            System.Diagnostics.Debug.Assert$$Boolean(rCtr == nRight);
            var parentMED = this.med;
            this.particles = leftParticles;
            this.ComputeMED();
            rightSibling.Value = new Microsoft.Msagl.Layout.Incremental.KDTree.LeafKdNode.ctor(rightParticles);
            return new Microsoft.Msagl.Layout.Incremental.KDTree.InternalKdNode.ctor(parentMED, this, rightSibling.Value);
        },
        ComputeForces: function (){
            for (var $i696 = 0,$t696 = this.particles[0],$l696 = $t696.length,u = $t696[$i696]; $i696 < $l696; $i696++, u = $t696[$i696]){
                for (var $i697 = 0,$t697 = this.particles[0],$l697 = $t697.length,v = $t697[$i697]; $i697 < $l697; $i697++, v = $t697[$i697]){
                    if (u != v){
                        u.force = Microsoft.Msagl.Core.Geometry.Point.op_Addition(u.force, Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Force(u.point, v.point));
                    }
                }
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Incremental$KDTree$LeafKdNode);
var Microsoft$Msagl$Layout$Incremental$KDTree$InternalKdNode = {
    fullname: "Microsoft.Msagl.Layout.Incremental.KDTree.InternalKdNode",
    baseTypeName: "Microsoft.Msagl.Layout.Incremental.KDTree.KdNode",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (med, left, right){
            this.leftChild = null;
            this.rightChild = null;
            Microsoft.Msagl.Layout.Incremental.KDTree.KdNode.ctor.call(this);
            this.med = med;
            this.parent = left.parent;
            if (this.parent != null){
                if (this.parent.leftChild == left){
                    this.parent.leftChild = this;
                }
                else {
                    System.Diagnostics.Debug.Assert$$Boolean(this.parent.rightChild == left);
                    this.parent.rightChild = this;
                }
            }
            this.leftChild = left;
            this.rightChild = right;
            left.parent = this;
            right.parent = this;
        },
        computeMultipoleCoefficients: function (precision){
            this.leftChild.computeMultipoleCoefficients(precision);
            this.rightChild.computeMultipoleCoefficients(precision);
            this.multipoleCoefficients = new Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.ctor$$Point$$MultipoleCoefficients$$MultipoleCoefficients(this.med.get_Center(), this.leftChild.multipoleCoefficients, this.rightChild.multipoleCoefficients);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Incremental$KDTree$InternalKdNode);
var Microsoft$Msagl$Layout$Incremental$KDTree$SplitQueue = {
    fullname: "Microsoft.Msagl.Layout.Incremental.KDTree.SplitQueue",
    baseTypeName: "System.Collections.Generic.Queue$1",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (B){
            this.B = 0;
            System.Collections.Generic.Queue$1.ctor.call(this, Microsoft.Msagl.Layout.Incremental.KDTree.LeafKdNode.ctor);
            this.B = B;
        },
        Enqueue$$LeafKdNode$$LeafKdNode: function (l, r){
            if (l.Size() > this.B){
                this.Enqueue(l);
            }
            if (r.Size() > this.B){
                this.Enqueue(r);
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Incremental$KDTree$SplitQueue);
var Microsoft$Msagl$Layout$Incremental$FastIncrementalLayoutSettings = {
    fullname: "Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings",
    baseTypeName: "Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings",
    staticDefinition: {
        CreateFastIncrementalLayoutSettings: function (){
            return (function (){
                var $v88 = new Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.ctor();
                $v88.set_ApplyForces(false);
                $v88.set_ApproximateRepulsion(true);
                $v88.set_ApproximateRouting(true);
                $v88.set_AttractiveForceConstant(1);
                $v88.set_AttractiveInterClusterForceConstant(1);
                $v88.set_AvoidOverlaps(true);
                $v88.set_ClusterGravity(1);
                $v88.set_Decay(0.9);
                $v88.set_DisplacementThreshold(5E-08);
                $v88.set_Friction(0.8);
                $v88.set_GravityConstant(1);
                $v88.set_InitialStepSize(2);
                $v88.set_InterComponentForces(false);
                $v88.set_Iterations(0);
                $v88.set_LogScaleEdgeForces(false);
                $v88.set_MaxConstraintLevel(2);
                $v88.set_MaxIterations(20);
                $v88.set_MinConstraintLevel(0);
                $v88.set_MinorIterations(1);
                $v88.set_ProjectionIterations(5);
                $v88.set_RepulsiveForceConstant(2);
                $v88.set_RespectEdgePorts(false);
                $v88.set_RouteEdges(false);
                $v88.set_RungeKuttaIntegration(true);
                $v88.set_UpdateClusterBoundariesFromChildren(true);
                $v88.set_NodeSeparation(20);
                return $v88;
            })();
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.maxIterations = 100;
            this.minorIterations = 3;
            this.iterations = 0;
            this.projectionIterations = 5;
            this.approximateRepulsion = true;
            this.initialStepSize = 1.4;
            this.decay = 0.9;
            this.friction = 0.8;
            this.repulsiveForceConstant = 1;
            this.attractiveForceConstant = 1;
            this.gravity = 1;
            this.interComponentForces = true;
            this.applyForces = true;
            this.algorithm = null;
            this.locks = new System.Collections.Generic.LinkedList$1.ctor(Microsoft.Msagl.Layout.Incremental.LockPosition.ctor);
            this.structuralConstraints = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Layout.Incremental.IConstraint.ctor);
            this.approximateRouting = true;
            this.logScaleEdgeForces = true;
            this.displacementThreshold = 0.1;
            this.converged = false;
            this.maxConstraintLevel = 2;
            this.minConstraintLevel = 0;
            this.attractiveInterClusterForceConstant = 1;
            this.clusterGravity = 1;
            this.updateClusterBoundaries = true;
            this._RungeKuttaIntegration = false;
            this._AvoidOverlaps = false;
            this._RespectEdgePorts = false;
            this._RouteEdges = false;
            this._EdgeRoutesUpToDate = false;
            this._IdealEdgeLength = new Microsoft.Msagl.Core.Layout.IdealEdgeLengthSettings.ctor();
            Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings.ctor.call(this);
        },
        MaxIterations$$: "System.Int32",
        get_MaxIterations: function (){
            return this.maxIterations;
        },
        set_MaxIterations: function (value){
            this.maxIterations = value;
        },
        MinorIterations$$: "System.Int32",
        get_MinorIterations: function (){
            return this.minorIterations;
        },
        set_MinorIterations: function (value){
            this.minorIterations = value;
        },
        Iterations$$: "System.Int32",
        get_Iterations: function (){
            return this.iterations;
        },
        set_Iterations: function (value){
            this.iterations = value;
        },
        ProjectionIterations$$: "System.Int32",
        get_ProjectionIterations: function (){
            return this.projectionIterations;
        },
        set_ProjectionIterations: function (value){
            this.projectionIterations = value;
        },
        ApproximateRepulsion$$: "System.Boolean",
        get_ApproximateRepulsion: function (){
            return this.approximateRepulsion;
        },
        set_ApproximateRepulsion: function (value){
            this.approximateRepulsion = value;
        },
        RungeKuttaIntegration$$: "System.Boolean",
        get_RungeKuttaIntegration: function (){
            return this._RungeKuttaIntegration;
        },
        set_RungeKuttaIntegration: function (value){
            this._RungeKuttaIntegration = value;
        },
        InitialStepSize$$: "System.Double",
        get_InitialStepSize: function (){
            return this.initialStepSize;
        },
        set_InitialStepSize: function (value){
            if (value <= 0 || value > 2){
                throw $CreateException(new System.ArgumentException.ctor$$String("ForceScalar should be greater than 0 and less than 2 (if we let you set it to 0 nothing would happen, greater than 2 would most likely be very unstable!)"), new Error());
            }
            this.initialStepSize = value;
        },
        Decay$$: "System.Double",
        get_Decay: function (){
            return this.decay;
        },
        set_Decay: function (value){
            if (value < 0.1 || value > 1){
                throw $CreateException(new System.ArgumentException.ctor$$String("Setting decay too small gives no progress.  1==no decay, 0.1==minimum allowed value"), new Error());
            }
            this.decay = value;
        },
        Friction$$: "System.Double",
        get_Friction: function (){
            return this.friction;
        },
        set_Friction: function (value){
            if (value < 0 || value > 1){
                throw $CreateException(new System.ArgumentException.ctor$$String("Setting friction less than 0 or greater than 1 would just be strange.  1==no friction, 0==no conservation of velocity"), new Error());
            }
            this.friction = value;
        },
        RepulsiveForceConstant$$: "System.Double",
        get_RepulsiveForceConstant: function (){
            return this.repulsiveForceConstant;
        },
        set_RepulsiveForceConstant: function (value){
            this.repulsiveForceConstant = value;
        },
        AttractiveForceConstant$$: "System.Double",
        get_AttractiveForceConstant: function (){
            return this.attractiveForceConstant;
        },
        set_AttractiveForceConstant: function (value){
            this.attractiveForceConstant = value;
        },
        GravityConstant$$: "System.Double",
        get_GravityConstant: function (){
            return this.gravity;
        },
        set_GravityConstant: function (value){
            this.gravity = value;
        },
        InterComponentForces$$: "System.Boolean",
        get_InterComponentForces: function (){
            return this.interComponentForces;
        },
        set_InterComponentForces: function (value){
            this.interComponentForces = value;
        },
        ApplyForces$$: "System.Boolean",
        get_ApplyForces: function (){
            return this.applyForces;
        },
        set_ApplyForces: function (value){
            this.applyForces = value;
        },
        CreateLock$$Node$$Rectangle: function (node, bounds){
            var lp = new Microsoft.Msagl.Layout.Incremental.LockPosition.ctor$$Node$$Rectangle(node, bounds);
            lp.listNode = this.locks.AddLast$$T(lp);
            return lp;
        },
        CreateLock$$Node$$Rectangle$$Double: function (node, bounds, weight){
            var lp = new Microsoft.Msagl.Layout.Incremental.LockPosition.ctor$$Node$$Rectangle$$Double(node, bounds, weight);
            lp.listNode = this.locks.AddLast$$T(lp);
            return lp;
        },
        ClearLocks: function (){
            this.locks.Clear();
        },
        RemoveLock: function (lockPosition){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(lockPosition, "lockPosition");
            if (lockPosition.listNode != null){
                lockPosition.RestoreNodeWeight();
                try{
                    this.locks.Remove$$LinkedListNode$1(lockPosition.listNode);
                }
                catch(e){
                    System.Console.WriteLine$$String("Problem in FastIncrementalLayoutSettings.RemoveLock " + e.get_Message());
                }
                lockPosition.listNode = null;
            }
        },
        ResetLayout: function (){
            this.Unconverge();
            if (this.algorithm != null){
                this.algorithm.ResetNodePositions();
                this.algorithm.SetLockNodeWeights();
            }
        },
        Unconverge: function (){
            this.iterations = 0;
            this.converged = false;
        },
        InitializeLayout$$GeometryGraph$$Int32: function (graph, initialConstraintLevel){
            this.InitializeLayout$$GeometryGraph$$Int32$$Func$2$Cluster$LayoutAlgorithmSettings(graph, initialConstraintLevel, $CreateAnonymousDelegate(this, function (anyCluster){
                return this;
            }));
        },
        InitializeLayout$$GeometryGraph$$Int32$$Func$2$Cluster$LayoutAlgorithmSettings: function (graph, initialConstraintLevel, clusterSettings){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(graph, "graph");
            this.algorithm = new Microsoft.Msagl.Layout.Incremental.FastIncrementalLayout.ctor(graph, this, initialConstraintLevel, clusterSettings);
            this.ResetLayout();
        },
        Uninitialize: function (){
            this.algorithm = null;
        },
        IsInitialized$$: "System.Boolean",
        get_IsInitialized: function (){
            return this.algorithm != null;
        },
        IncrementalRun$$GeometryGraph: function (graph){
            this.IncrementalRun$$GeometryGraph$$Func$2$Cluster$LayoutAlgorithmSettings(graph, $CreateAnonymousDelegate(this, function (anyCluster){
                return this;
            }));
        },
        SetupIncrementalRun: function (graph, clusterSettings){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(graph, "graph");
            if (!this.get_IsInitialized()){
                this.InitializeLayout$$GeometryGraph$$Int32$$Func$2$Cluster$LayoutAlgorithmSettings(graph, this.get_MaxConstraintLevel(), clusterSettings);
            }
            else if (this.get_IsDone()){
                this.ResetLayout();
            }
        },
        IncrementalRun$$GeometryGraph$$Func$2$Cluster$LayoutAlgorithmSettings: function (graph, clusterSettings){
            this.SetupIncrementalRun(graph, clusterSettings);
            this.algorithm.Run();
            graph.UpdateBoundingBox();
        },
        IncrementalRun$$CancelToken$$GeometryGraph$$Func$2$Cluster$LayoutAlgorithmSettings: function (cancelToken, graph, clusterSettings){
            if (cancelToken != null){
                cancelToken.ThrowIfCanceled();
            }
            this.SetupIncrementalRun(graph, clusterSettings);
            this.algorithm.Run$$CancelToken(cancelToken);
            graph.UpdateBoundingBox();
        },
        Clone: function (){
            return As(this.MemberwiseClone(), Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings.ctor);
        },
        StructuralConstraints$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Layout.Incremental.IConstraint]]",
        get_StructuralConstraints: function (){
            return this.structuralConstraints;
        },
        AddStructuralConstraint: function (cc){
            this.structuralConstraints.Add(cc);
        },
        ClearConstraints: function (){
            this.locks.Clear();
            this.structuralConstraints.Clear();
        },
        ClearStructuralConstraints: function (){
            this.structuralConstraints.Clear();
        },
        AvoidOverlaps$$: "System.Boolean",
        get_AvoidOverlaps: function (){
            return this._AvoidOverlaps;
        },
        set_AvoidOverlaps: function (value){
            this._AvoidOverlaps = value;
        },
        RespectEdgePorts$$: "System.Boolean",
        get_RespectEdgePorts: function (){
            return this._RespectEdgePorts;
        },
        set_RespectEdgePorts: function (value){
            this._RespectEdgePorts = value;
        },
        RouteEdges$$: "System.Boolean",
        get_RouteEdges: function (){
            return this._RouteEdges;
        },
        set_RouteEdges: function (value){
            this._RouteEdges = value;
        },
        ApproximateRouting$$: "System.Boolean",
        get_ApproximateRouting: function (){
            return this.approximateRouting;
        },
        set_ApproximateRouting: function (value){
            this.approximateRouting = value;
        },
        LogScaleEdgeForces$$: "System.Boolean",
        get_LogScaleEdgeForces: function (){
            return this.logScaleEdgeForces;
        },
        set_LogScaleEdgeForces: function (value){
            this.logScaleEdgeForces = value;
        },
        DisplacementThreshold$$: "System.Double",
        get_DisplacementThreshold: function (){
            return this.displacementThreshold;
        },
        set_DisplacementThreshold: function (value){
            this.displacementThreshold = value;
        },
        Converged$$: "System.Boolean",
        get_Converged: function (){
            return this.converged;
        },
        set_Converged: function (value){
            this.converged = value;
        },
        PercentDone$$: "System.Int32",
        get_PercentDone: function (){
            if (this.get_Converged()){
                return 100;
            }
            else {
                return (((100 * this.iterations) / this.get_MaxIterations())) | 0;
            }
        },
        IsDone$$: "System.Boolean",
        get_IsDone: function (){
            return this.get_Converged() || this.iterations >= this.get_MaxIterations();
        },
        Energy$$: "System.Single",
        get_Energy: function (){
            if (this.algorithm != null){
                return this.algorithm.energy;
            }
            return 0;
        },
        EdgeRoutesUpToDate$$: "System.Boolean",
        get_EdgeRoutesUpToDate: function (){
            return this._EdgeRoutesUpToDate;
        },
        set_EdgeRoutesUpToDate: function (value){
            this._EdgeRoutesUpToDate = value;
        },
        MaxConstraintLevel$$: "System.Int32",
        get_MaxConstraintLevel: function (){
            return this.maxConstraintLevel;
        },
        set_MaxConstraintLevel: function (value){
            if (this.maxConstraintLevel != value){
                this.maxConstraintLevel = value;
                if (this.get_IsInitialized()){
                    this.Uninitialize();
                }
            }
        },
        MinConstraintLevel$$: "System.Int32",
        get_MinConstraintLevel: function (){
            return this.minConstraintLevel;
        },
        set_MinConstraintLevel: function (value){
            this.minConstraintLevel = value;
        },
        CurrentConstraintLevel$$: "System.Int32",
        get_CurrentConstraintLevel: function (){
            return this.algorithm.get_CurrentConstraintLevel();
        },
        set_CurrentConstraintLevel: function (value){
            this.algorithm.set_CurrentConstraintLevel(value);
        },
        AttractiveInterClusterForceConstant$$: "System.Double",
        get_AttractiveInterClusterForceConstant: function (){
            return this.attractiveInterClusterForceConstant;
        },
        set_AttractiveInterClusterForceConstant: function (value){
            this.attractiveInterClusterForceConstant = value;
        },
        ctor$$FastIncrementalLayoutSettings: function (previousSettings){
            this.maxIterations = 100;
            this.minorIterations = 3;
            this.iterations = 0;
            this.projectionIterations = 5;
            this.approximateRepulsion = true;
            this.initialStepSize = 1.4;
            this.decay = 0.9;
            this.friction = 0.8;
            this.repulsiveForceConstant = 1;
            this.attractiveForceConstant = 1;
            this.gravity = 1;
            this.interComponentForces = true;
            this.applyForces = true;
            this.algorithm = null;
            this.locks = new System.Collections.Generic.LinkedList$1.ctor(Microsoft.Msagl.Layout.Incremental.LockPosition.ctor);
            this.structuralConstraints = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Layout.Incremental.IConstraint.ctor);
            this.approximateRouting = true;
            this.logScaleEdgeForces = true;
            this.displacementThreshold = 0.1;
            this.converged = false;
            this.maxConstraintLevel = 2;
            this.minConstraintLevel = 0;
            this.attractiveInterClusterForceConstant = 1;
            this.clusterGravity = 1;
            this.updateClusterBoundaries = true;
            this._RungeKuttaIntegration = false;
            this._AvoidOverlaps = false;
            this._RespectEdgePorts = false;
            this._RouteEdges = false;
            this._EdgeRoutesUpToDate = false;
            this._IdealEdgeLength = new Microsoft.Msagl.Core.Layout.IdealEdgeLengthSettings.ctor();
            Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings.ctor.call(this);
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(previousSettings, "previousSettings");
            this.maxIterations = previousSettings.maxIterations;
            this.minorIterations = previousSettings.minorIterations;
            this.projectionIterations = previousSettings.projectionIterations;
            this.approximateRepulsion = previousSettings.approximateRepulsion;
            this.initialStepSize = previousSettings.initialStepSize;
            this.set_RungeKuttaIntegration(previousSettings.get_RungeKuttaIntegration());
            this.decay = previousSettings.decay;
            this.friction = previousSettings.friction;
            this.repulsiveForceConstant = previousSettings.repulsiveForceConstant;
            this.attractiveForceConstant = previousSettings.attractiveForceConstant;
            this.gravity = previousSettings.gravity;
            this.interComponentForces = previousSettings.interComponentForces;
            this.applyForces = previousSettings.applyForces;
            this.set_IdealEdgeLength(previousSettings.get_IdealEdgeLength());
            this.set_AvoidOverlaps(previousSettings.get_AvoidOverlaps());
            this.set_RespectEdgePorts(previousSettings.get_RespectEdgePorts());
            this.set_RouteEdges(previousSettings.get_RouteEdges());
            this.approximateRouting = previousSettings.approximateRouting;
            this.logScaleEdgeForces = previousSettings.logScaleEdgeForces;
            this.displacementThreshold = previousSettings.displacementThreshold;
            this.minConstraintLevel = previousSettings.minConstraintLevel;
            this.maxConstraintLevel = previousSettings.maxConstraintLevel;
            this.attractiveInterClusterForceConstant = previousSettings.attractiveInterClusterForceConstant;
            this.clusterGravity = previousSettings.clusterGravity;
            this.set_PackingAspectRatio(previousSettings.get_PackingAspectRatio());
            this.set_NodeSeparation(previousSettings.get_NodeSeparation());
            this.set_ClusterMargin(previousSettings.get_ClusterMargin());
        },
        ClusterGravity$$: "System.Double",
        get_ClusterGravity: function (){
            return this.clusterGravity;
        },
        set_ClusterGravity: function (value){
            this.clusterGravity = value;
        },
        IdealEdgeLength$$: "Microsoft.Msagl.Core.Layout.IdealEdgeLengthSettings",
        get_IdealEdgeLength: function (){
            return this._IdealEdgeLength;
        },
        set_IdealEdgeLength: function (value){
            this._IdealEdgeLength = value;
        },
        UpdateClusterBoundariesFromChildren$$: "System.Boolean",
        get_UpdateClusterBoundariesFromChildren: function (){
            return this.updateClusterBoundaries;
        },
        set_UpdateClusterBoundariesFromChildren: function (value){
            this.updateClusterBoundaries = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Incremental$FastIncrementalLayoutSettings);
var Microsoft$Msagl$Core$Geometry$MoveToFront = {
    fullname: "Microsoft.Msagl.Core.Geometry.MoveToFront",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (ps){
            this.L = null;
            this.ps = null;
            this.disc = null;
            this.boundary = null;
            System.Object.ctor.call(this);
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(ps, "ps");
            this.ps = ps;
            this.L = new System.Collections.Generic.LinkedList$1.ctor(System.Int32.ctor);
            for (var i = 0; i < ps.length; ++i){
                this.L.AddLast$$T(i);
            }
            var md = this.mtf_md(null, new System.Collections.Generic.List$1.ctor(System.Int32.ctor));
            this.disc = md.disc;
            this.boundary = md.boundary;
        },
        collinear3: function (b){
            if (b.get_Count() == 3){
                return Microsoft.Msagl.Core.Geometry.Disc.Collinear(this.ps[b.get_Item$$Int32(0)], this.ps[b.get_Item$$Int32(1)], this.ps[b.get_Item$$Int32(2)]);
            }
            return false;
        },
        mtf_md: function (lPtr, b){
            System.Diagnostics.Debug.Assert$$Boolean(b.get_Count() <= 3);
            var md = new Microsoft.Msagl.Core.Geometry.MoveToFront.MinDisc.ctor(this.ps, b);
            if (b.get_Count() == 3){
                return md;
            }
            var lnode = this.L.get_First();
            while (lnode != null && lnode != lPtr){
                var lnext = lnode.get_Next();
                var p = lnode.get_Value();
                if (!md.contains(this.ps[p])){
                    var _b = new System.Collections.Generic.List$1.ctor$$IEnumerable$1(System.Int32.ctor, b);
                    _b.Add(p);
                    System.Diagnostics.Debug.Assert$$Boolean$$String(!this.collinear3(_b), "Collinear points on boundary of minimal enclosing disc");
                    md = this.mtf_md(lnode, _b);
                    this.L.Remove$$LinkedListNode$1(lnode);
                    this.L.AddFirst$$LinkedListNode$1(lnode);
                }
                lnode = lnext;
            }
            return md;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$MoveToFront);
var Microsoft$Msagl$Core$Geometry$MoveToFront$MinDisc = {
    fullname: "Microsoft.Msagl.Core.Geometry.MoveToFront.MinDisc",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (ps, b){
            this.disc = null;
            this.boundary = null;
            System.Object.ctor.call(this);
            this.boundary = b;
            System.Diagnostics.Debug.Assert$$Boolean(b.get_Count() <= 3);
            switch (b.get_Count()){
                case 0:
                    this.disc = null;
                    break;
                case 1:
                    this.disc = new Microsoft.Msagl.Core.Geometry.Disc.ctor$$Point(ps[b.get_Item$$Int32(0)]);
                    break;
                case 2:
                    this.disc = new Microsoft.Msagl.Core.Geometry.Disc.ctor$$Point$$Point(ps[b.get_Item$$Int32(0)], ps[b.get_Item$$Int32(1)]);
                    break;
                case 3:
                    this.disc = new Microsoft.Msagl.Core.Geometry.Disc.ctor$$Point$$Point$$Point(ps[b.get_Item$$Int32(0)], ps[b.get_Item$$Int32(1)], ps[b.get_Item$$Int32(2)]);
                    break;
            }
        },
        contains: function (p){
            if (this.disc == null){
                return false;
            }
            return this.disc.Contains$$Point(p);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$MoveToFront$MinDisc);
var Microsoft$Msagl$Core$Geometry$MinimumEnclosingDisc = {
    fullname: "Microsoft.Msagl.Core.Geometry.MinimumEnclosingDisc",
    baseTypeName: "System.Object",
    staticDefinition: {
        LinearComputation: function (points){
            var m = new Microsoft.Msagl.Core.Geometry.MoveToFront.ctor(points);
            return m.disc;
        },
        SlowComputation: function (points){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(points, "points");
            var n = points.length;
            var mc = null;
            var b = null;
            for (var i = 0; i < n; ++i){
                for (var j = 0; j < n; ++j){
                    if (i != j){
                        var c = new Microsoft.Msagl.Core.Geometry.Disc.ctor$$Point$$Point(points[i], points[j]);
                        if (c.Contains$$Point$Array$$Int32$Array(points, new Int32Array([i, j]))){
                            if (mc == null || mc.get_Radius() > c.get_Radius()){
                                mc = c;
                                b = new Int32Array([i, j]);
                            }
                        }
                    }
                    for (var k = 0; k < n; ++k){
                        if (k != i && k != j && !Microsoft.Msagl.Core.Geometry.Disc.Collinear(points[i], points[j], points[k])){
                            var c3 = new Microsoft.Msagl.Core.Geometry.Disc.ctor$$Point$$Point$$Point(points[i], points[j], points[k]);
                            if (c3.Contains$$Point$Array$$Int32$Array(points, new Int32Array([i, j, k]))){
                                if (mc == null || mc.get_Radius() > c3.get_Radius()){
                                    mc = c3;
                                    b = new Int32Array([i, j, k]);
                                }
                            }
                        }
                    }
                }
            }
            System.Diagnostics.Debug.Assert$$Boolean(b != null);
            return mc;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$MinimumEnclosingDisc);
var Microsoft$Msagl$Layout$Incremental$MultipoleCoefficients = {
    fullname: "Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients",
    baseTypeName: "System.Object",
    staticDefinition: {
        factorial: function (n){
            var f = 1;
            for (var i = 2; i <= n; ++i){
                f *= i;
            }
            return f;
        },
        binomial: function (n, k){
            return Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.factorial(n) / (Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.factorial(k) * Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.factorial(n - k));
        },
        Force: function (u, v){
            var duv = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v, u);
            var l = duv.get_LengthSquared();
            if (l < 0.1){
                if (l != 0){
                    return Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(duv, 0.1);
                }
                return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(1, 0);
            }
            return Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(duv, l);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$Int32$$Point$$Point$Array: function (precision, center, points){
            this.z0 = new Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.ctor();
            this.a = null;
            this.p = 0;
            System.Object.ctor.call(this);
            this.p = precision;
            this.z0 = new Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.ctor$$Double$$Double(center.get_X(), center.get_Y());
            this.a = new Array(precision);
            for (var k = 0; k < precision; ++k){
                this.a[k] = this.compute(k, points);
            }
        },
        ctor$$Point$$MultipoleCoefficients$$MultipoleCoefficients: function (center, m1, m2){
            this.z0 = new Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.ctor();
            this.a = null;
            this.p = 0;
            System.Object.ctor.call(this);
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(m1, "m1");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(m2, "m2");
            System.Diagnostics.Debug.Assert$$Boolean(m1.p == m2.p);
            this.p = m1.p;
            this.z0 = new Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.ctor$$Double$$Double(center.get_X(), center.get_Y());
            var m1a = m1.shift(this.z0),m2a = m2.shift(this.z0);
            this.a = new Array(this.p);
            for (var i = 0; i < this.p; ++i){
                this.a[i] = Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.op_Addition(m1a[i], m2a[i]);
            }
        },
        sum: function (l, z0_minus_z1){
            var s = new Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.ctor$$Double(0);
            for (var k = 1; k <= l; ++k){
                var bi = new Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.ctor$$Double(Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.binomial(l - 1, k - 1));
                s = Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.op_Addition(s, Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.op_Multiply$$Complex$$Complex(Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.op_Multiply$$Complex$$Complex(this.a[k], Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.Pow(z0_minus_z1, l - k)), bi));
            }
            return s;
        },
        shift: function (z1){
            var b = new Array(this.p);
            var a0 = b[0] = this.a[0];
            var z0_minus_z1 = Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.op_Subtraction(this.z0, z1);
            for (var l = 1; l < this.p; ++l){
                var lz = new Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.ctor$$Double(l);
                b[l] = Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.op_Addition(Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.op_Division(Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.op_Multiply$$Complex$$Complex(Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.op_UnaryNegation(a0), Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.Pow(z0_minus_z1, l)), lz), this.sum(l, z0_minus_z1));
            }
            return b;
        },
        compute: function (k, ps){
            var m = ps.length;
            var ak = new Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.ctor$$Double(0);
            if (k == 0){
                ak.re = m;
            }
            else {
                for (var i = 0; i < m; ++i){
                    var q = ps[i];
                    var pc = new Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.ctor$$Double$$Double(q.get_X(), q.get_Y());
                    ak = Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.op_Subtraction(ak, Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.Pow(Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.op_Subtraction(pc, this.z0), k));
                }
                ak.divideBy(k);
            }
            return ak;
        },
        ApproximateForce: function (v){
            var z = new Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.ctor$$Double$$Double(v.get_X(), v.get_Y());
            var z_minus_z0 = Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.op_Subtraction(z, this.z0);
            var fz = Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.op_Division(this.a[0], z_minus_z0);
            var z_minus_z0_to_k_plus_1 = z_minus_z0;
            var k = 0;
            while (true){
                fz = Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.op_Subtraction(fz, Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.op_Division((Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.op_Multiply$$Complex$$Double(this.a[k], k)), z_minus_z0_to_k_plus_1));
                ++k;
                if (k == this.p){
                    break;
                }
                z_minus_z0_to_k_plus_1 = Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.op_Multiply$$Complex$$Complex(z_minus_z0_to_k_plus_1, z_minus_z0);
            }
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(fz.re, -fz.im);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Incremental$MultipoleCoefficients);
var Microsoft$Msagl$Layout$Incremental$MultipoleCoefficients$Complex = {
    fullname: "Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex",
    baseTypeName: "System.ValueType",
    staticDefinition: {
        op_Addition: function (a, b){
            return (new Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.ctor$$Double$$Double(a.re + b.re, a.im + b.im));
        },
        op_UnaryNegation: function (a){
            return (new Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.ctor$$Double$$Double(-a.re, -a.im));
        },
        op_Subtraction: function (a, b){
            return (new Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.ctor$$Double$$Double(a.re - b.re, a.im - b.im));
        },
        op_Multiply$$Complex$$Complex: function (a, b){
            return (new Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.ctor$$Double$$Double(a.re * b.re - a.im * b.im, a.re * b.im + b.re * a.im));
        },
        op_Multiply$$Complex$$Double: function (a, b){
            return (new Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.ctor$$Double$$Double(a.re * b, b * a.im));
        },
        op_Division: function (a, b){
            var c1,c2,d;
            d = b.re * b.re + b.im * b.im;
            if (d == 0){
                return (new Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.ctor$$Double(0));
            }
            c1 = a.re * b.re + a.im * b.im;
            c2 = a.im * b.re - a.re * b.im;
            return (new Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.ctor$$Double$$Double(c1 / d, c2 / d));
        },
        Pow: function (a, k){
            System.Diagnostics.Debug.Assert$$Boolean(k >= 0);
            switch (k){
                case 0:
                    return new Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.ctor$$Double(1);
                case 1:
                    return a;
                case 2:
                    return Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.op_Multiply$$Complex$$Complex(a, a);
                case 3:
                    return Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.op_Multiply$$Complex$$Complex(Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.op_Multiply$$Complex$$Complex(a, a), a);
                default:
                    return Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.op_Multiply$$Complex$$Complex(Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.Pow(a, (k / 2) | 0), Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Complex.Pow(a, ((k / 2) | 0) + (k % 2)));
            }
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Struct",
    definition: {
        ctor$$Double$$Double: function (re, im){
            this.re = 0;
            this.im = 0;
            System.ValueType.ctor.call(this);
            this.re = re;
            this.im = im;
        },
        ctor$$Double: function (re){
            this.re = 0;
            this.im = 0;
            System.ValueType.ctor.call(this);
            this.re = re;
            this.im = 0;
        },
        divideBy: function (r){
            this.re /= r;
            this.im /= r;
        },
        ctor: function (){
            this.re = 0;
            this.im = 0;
            System.ValueType.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Incremental$MultipoleCoefficients$Complex);
var Microsoft$Msagl$Layout$Incremental$ProcrustesCircleConstraint = {
    fullname: "Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint",
    baseTypeName: "System.Object",
    staticDefinition: {
        matrixProduct: function (A, B){
            var R = new Array(2);
            var x0 = 0,y0 = 0,x1 = 0,y1 = 0;
            for (var i = 0; i < A.length; ++i){
                x0 += A[i].get_X() * B[i].get_X();
                y0 += A[i].get_X() * B[i].get_Y();
                x1 += A[i].get_Y() * B[i].get_X();
                y1 += A[i].get_Y() * B[i].get_Y();
            }
            R[0] = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x0, y0);
            R[1] = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x1, y1);
            return R;
        },
        matrixProductNoTranspose: function (A, B){
            var R = new Array(2);
            R[0] = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(A[0].get_X() * B[0].get_X() + A[0].get_Y() * B[1].get_X(), A[0].get_X() * B[0].get_Y() + A[0].get_Y() * B[1].get_Y());
            R[1] = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(A[1].get_X() * B[0].get_X() + A[1].get_Y() * B[1].get_X(), A[1].get_X() * B[0].get_Y() + A[1].get_Y() * B[1].get_Y());
            return R;
        },
        MatrixTimesVector: function (A, v){
            var a = A[0].get_X(),b = A[0].get_Y(),c = A[1].get_X(),d = A[1].get_Y();
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(a * v.get_X() + b * v.get_Y(), c * v.get_X() + d * v.get_Y());
        },
        eigenSystem2: function (B, Q){
            var b = new Array(B.length);
            for (var i = 0; i < B.length; i++){
                b[i] = new Float64Array(2);
                b[i][0] = B[i].get_X();
                b[i][1] = B[i].get_Y();
            }
            var lambda1;
            var q1;
            var lambda2;
            var q2;
            (function (){
                var $1 = {
                    Value: q1
                };
                var $2 = {
                    Value: lambda1
                };
                var $3 = {
                    Value: q2
                };
                var $4 = {
                    Value: lambda2
                };
                var $res = Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.SpectralDecomposition$$Double$Array$Array$$Double$Array$$Double$$Double$Array$$Double$$Int32$$Double(b, $1, $2, $3, $4, 300, 1E-08);
                q1 = $1.Value;
                lambda1 = $2.Value;
                q2 = $3.Value;
                lambda2 = $4.Value;
                return $res;
            })();
            Q.Value = [new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(q1[0], q1[1]), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(q2[0], q2[1])];
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(lambda1, lambda2);
        },
        eigenSystem3: function (A, Q){
            var a = A[0].get_X(),b = A[0].get_Y(),c = A[1].get_X(),d = A[1].get_Y();
            var T = a + d;
            var D = a * d - b * c;
            var l1,l2;
            var t = System.Math.Sqrt(T * T / 4 - D);
            l1 = l2 = T / 2;
            l1 -= t;
            l2 += t;
            var q1,q2;
            if (c != 0){
                q1 = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(l1 - d, c);
                q2 = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(l2 - d, c);
            }
            else if (b != 0){
                q1 = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(b, l1 - a);
                q2 = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(b, l2 - a);
            }
            else {
                q1 = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(1, 0);
                q2 = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, 1);
            }
            Q.Value = [q1.Normalize(), q2.Normalize()];
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(l1, l2);
        },
        cmpPoint: function (x, y){
            if (System.Math.Abs$$Double(x.get_X() - y.get_X()) > 0.0001){
                return false;
            }
            if (System.Math.Abs$$Double(x.get_Y() - y.get_Y()) > 0.0001){
                return false;
            }
            return true;
        },
        SingularValueDecomposition: function (X, P, Q){
            var XX = Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.matrixProduct(X, X);
            var l = Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.eigenSystem2(XX, Q);
            var s = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(System.Math.Sqrt(l.get_X()), System.Math.Sqrt(l.get_Y()));
            P.Value = Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.matrixProductNoTranspose(X, Q.Value);
            P.Value = Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.matrixProductNoTranspose(P.Value, [new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(1 / s.get_X(), 0), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, 1 / s.get_Y())]);
            return s;
        },
        PrintMatrix: function (points){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(points, "points");
            System.Console.Write$$String("{");
            for (var i = 0; i < points.length;){
                System.Console.Write$$String$$Object$$Object("{{{0},{1}}}", points[i].get_X(), points[i].get_Y());
                if (++i != points.length){
                    System.Console.Write$$String(",");
                }
            }
            System.Console.WriteLine$$String("};");
        },
        Transpose: function (X){
            return [new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(X[0].get_X(), X[1].get_X()), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(X[0].get_Y(), X[1].get_Y())];
        },
        Test: function (){
            var XX = new Float64Array([1, 2, -1, 2, -1, -2, 1, -2]),YY = new Float64Array([0.07, 2.62, 0.93, 3.12, 1.93, 1.38, 1.07, 0.88]);
            var ni = 4;
            var X = new Array(ni);
            var Y = new Array(ni);
            for (var i = 0; i < ni; ++i){
                X[i] = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(XX[i,0], XX[i,1]);
                Y[i] = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(YY[i,0], YY[i,1]);
            }
            var XY = Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.matrixProduct(X, Y);
            System.Console.Write$$String("XY=");
            Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.PrintMatrix(XY);
            var P,Q;
            (function (){
                var $1 = {
                    Value: P
                };
                var $2 = {
                    Value: Q
                };
                var $res = Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.SingularValueDecomposition(XY, $1, $2);
                P = $1.Value;
                Q = $2.Value;
                return $res;
            })();
            Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.PrintMatrix(P);
            Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.PrintMatrix(Q);
            var T;
            var s;
            var t;
            (function (){
                var $1 = {
                    Value: T
                };
                var $2 = {
                    Value: s
                };
                var $3 = {
                    Value: t
                };
                var $res = Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.FindTransform(X, Y, $1, $2, $3);
                T = $1.Value;
                s = $2.Value;
                t = $3.Value;
                return $res;
            })();
            Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.PrintMatrix(T);
            System.Console.WriteLine$$String$$Object("s={0}", s);
            System.Console.WriteLine$$String$$Object$$Object("t=({0},{1})", t.get_X(), t.get_Y());
        },
        FindTransform: function (X, Y, T, s, t){
            var ni = X.length;
            var C = Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.matrixProduct(X, Y);
            var P,Q;
            (function (){
                var $1 = {
                    Value: P
                };
                var $2 = {
                    Value: Q
                };
                var $res = Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.SingularValueDecomposition(C, $1, $2);
                P = $1.Value;
                Q = $2.Value;
                return $res;
            })();
            T.Value = Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.matrixProductNoTranspose(Q, Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.Transpose(P));
            var XYT = Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.matrixProductNoTranspose(C, T.Value);
            var Y2 = Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.matrixProduct(Y, Y);
            s.Value = XYT[0].get_X() + XYT[1].get_Y();
            s.Value /= Y2[0].get_X() + Y2[1].get_Y();
            t.Value = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            for (var i = 0; i < ni; ++i){
                t.Value = Microsoft.Msagl.Core.Geometry.Point.op_Addition(t.Value, Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(X[i], Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(s.Value, Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.MatrixTimesVector(T.Value, Y[i]))));
            }
            t.Value = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(t.Value, ni);
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Layout.Incremental.IConstraint"],
    Kind: "Class",
    definition: {
        ctor$$IEnumerable$1$Node: function (nodes){
            this.V = null;
            this.n = 0;
            this.X = null;
            this.Y = null;
            System.Object.ctor.call(this);
            this.V = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Layout.Node.ctor, nodes);
            this.n = this.V.length;
            this.X = new Array(this.n);
            this.Y = new Array(this.n);
            var angle = 6.28318530717959 / this.n;
            var r = 10 * this.n;
            for (var i = 0; i < this.n; ++i){
                var theta = angle * i;
                this.Y[i] = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(r * System.Math.Cos(theta), r * System.Math.Sin(theta));
            }
        },
        ctor$$IEnumerable$1$Node$$IEnumerable$1$Point: function (nodes, targetConfiguration){
            this.V = null;
            this.n = 0;
            this.X = null;
            this.Y = null;
            System.Object.ctor.call(this);
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(nodes, "nodes");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(targetConfiguration, "targetConfiguration");
            this.V = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Layout.Node.ctor, nodes);
            this.n = this.V.length;
            this.X = new Array(this.n);
            this.Y = new Array(this.n);
            var i = 0;
            var yc = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            var $it697 = targetConfiguration.GetEnumerator();
            while ($it697.MoveNext()){
                var p = $it697.get_Current();
                this.Y[i++] = p;
                yc = Microsoft.Msagl.Core.Geometry.Point.op_Addition(yc, p);
            }
            yc = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(yc, this.n);
            for (i = 0; i < this.n; ++i){
                this.Y[i] = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.Y[i], yc);
            }
        },
        Project: function (){
            for (var i = 0; i < this.n; ++i){
                this.X[i] = this.V[i].get_Center();
            }
            var T;
            var s;
            var t;
            (function (){
                var $1 = {
                    Value: T
                };
                var $2 = {
                    Value: s
                };
                var $3 = {
                    Value: t
                };
                var $res = Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.FindTransform(this.X, this.Y, $1, $2, $3);
                T = $1.Value;
                s = $2.Value;
                t = $3.Value;
                return $res;
            }).call(this);
            var TT = Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.Transpose(T);
            var displacement = 0;
            for (var i = 0; i < this.n; ++i){
                var v = this.V[i];
                v.set_Center(System.Double.IsNaN(s) ? this.Y[i] : Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(s, Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.MatrixTimesVector(TT, this.Y[i])), t));
                displacement += (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v.get_Center(), this.X[i])).get_Length();
            }
            return displacement;
        },
        Level$$: "System.Int32",
        get_Level: function (){
            return 1;
        },
        Nodes$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Layout.Node]]",
        get_Nodes: function (){
            return System.Linq.Enumerable.AsEnumerable$1(Microsoft.Msagl.Core.Layout.Node.ctor, this.V);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Incremental$ProcrustesCircleConstraint);
var Microsoft$Msagl$Core$Geometry$RectangularClusterBoundary = {
    fullname: "Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.rectangle = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
            this.olapCluster = null;
            this.generateFixedConstraintsDefault = false;
            this.defaultMargin = null;
            this._LeftBorderInfo = new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor();
            this._RightBorderInfo = new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor();
            this._TopBorderInfo = new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor();
            this._BottomBorderInfo = new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor();
            this._GenerateFixedConstraints = false;
            this._RadiusX = 0;
            this._RadiusY = 0;
            this._MinWidth = 0;
            this._MinHeight = 0;
            System.Object.ctor.call(this);
            this.set_LeftBorderInfo(new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double(0));
            this.set_RightBorderInfo(new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double(0));
            this.set_TopBorderInfo(new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double(0));
            this.set_BottomBorderInfo(new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double(0));
        },
        LeftMargin$$: "System.Double",
        get_LeftMargin: function (){
            return this.get_LeftBorderInfo().get_InnerMargin();
        },
        set_LeftMargin: function (value){
            this.set_LeftBorderInfo(new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double$$Double$$Double(value, this.get_LeftBorderInfo().get_FixedPosition(), this.get_LeftBorderInfo().get_Weight()));
        },
        RightMargin$$: "System.Double",
        get_RightMargin: function (){
            return this.get_RightBorderInfo().get_InnerMargin();
        },
        set_RightMargin: function (value){
            this.set_RightBorderInfo(new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double$$Double$$Double(value, this.get_RightBorderInfo().get_FixedPosition(), this.get_RightBorderInfo().get_Weight()));
        },
        TopMargin$$: "System.Double",
        get_TopMargin: function (){
            return this.get_TopBorderInfo().get_InnerMargin();
        },
        set_TopMargin: function (value){
            this.set_TopBorderInfo(new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double$$Double$$Double(value, this.get_TopBorderInfo().get_FixedPosition(), this.get_TopBorderInfo().get_Weight()));
        },
        BottomMargin$$: "System.Double",
        get_BottomMargin: function (){
            return this.get_BottomBorderInfo().get_InnerMargin();
        },
        set_BottomMargin: function (value){
            this.set_BottomBorderInfo(new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double$$Double$$Double(value, this.get_BottomBorderInfo().get_FixedPosition(), this.get_BottomBorderInfo().get_Weight()));
        },
        LeftBorderInfo$$: "Microsoft.Msagl.Core.Geometry.BorderInfo",
        get_LeftBorderInfo: function (){
            return this._LeftBorderInfo;
        },
        set_LeftBorderInfo: function (value){
            this._LeftBorderInfo = value;
        },
        RightBorderInfo$$: "Microsoft.Msagl.Core.Geometry.BorderInfo",
        get_RightBorderInfo: function (){
            return this._RightBorderInfo;
        },
        set_RightBorderInfo: function (value){
            this._RightBorderInfo = value;
        },
        TopBorderInfo$$: "Microsoft.Msagl.Core.Geometry.BorderInfo",
        get_TopBorderInfo: function (){
            return this._TopBorderInfo;
        },
        set_TopBorderInfo: function (value){
            this._TopBorderInfo = value;
        },
        BottomBorderInfo$$: "Microsoft.Msagl.Core.Geometry.BorderInfo",
        get_BottomBorderInfo: function (){
            return this._BottomBorderInfo;
        },
        set_BottomBorderInfo: function (value){
            this._BottomBorderInfo = value;
        },
        GenerateFixedConstraints$$: "System.Boolean",
        get_GenerateFixedConstraints: function (){
            return this._GenerateFixedConstraints;
        },
        set_GenerateFixedConstraints: function (value){
            this._GenerateFixedConstraints = value;
        },
        GenerateFixedConstraintsDefault$$: "System.Boolean",
        get_GenerateFixedConstraintsDefault: function (){
            return this.generateFixedConstraintsDefault;
        },
        set_GenerateFixedConstraintsDefault: function (value){
            this.set_GenerateFixedConstraints(this.generateFixedConstraintsDefault = value);
        },
        RectangularHull: function (){
            System.Diagnostics.Debug.Assert$$Boolean(this.rectangle.get_Bottom() <= this.rectangle.get_Top());
            if (this.get_RadiusX() > 0 || this.get_RadiusY() > 0){
                return Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateRectangleWithRoundedCorners$$Double$$Double$$Double$$Double$$Point(this.rectangle.get_Width(), this.rectangle.get_Height(), this.get_RadiusX(), this.get_RadiusY(), this.rectangle.get_Center());
            }
            else {
                return Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateRectangle$$Double$$Double$$Point(this.rectangle.get_Width(), this.rectangle.get_Height(), this.rectangle.get_Center());
            }
        },
        Rect$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_Rect: function (){
            return this.rectangle;
        },
        set_Rect: function (value){
            this.rectangle = value;
        },
        InnerRect$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_InnerRect: function (){
            var outer = this.get_Rect();
            var inner = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Double$$Double$$Double$$Double(outer.get_Left() + this.get_LeftMargin(), outer.get_Bottom() + this.get_BottomMargin(), outer.get_Right() - this.get_RightMargin(), outer.get_Top() - this.get_TopMargin());
            return inner;
        },
        DefaultMarginIsSet$$: "System.Boolean",
        get_DefaultMarginIsSet: function (){
            return this.defaultMargin != null;
        },
        DefaultLeftMargin$$: "System.Double",
        get_DefaultLeftMargin: function (){
            return this.defaultMargin.Left;
        },
        DefaultTopMargin$$: "System.Double",
        get_DefaultTopMargin: function (){
            return this.defaultMargin.Top;
        },
        DefaultRightMargin$$: "System.Double",
        get_DefaultRightMargin: function (){
            return this.defaultMargin.Right;
        },
        DefaultBottomMargin$$: "System.Double",
        get_DefaultBottomMargin: function (){
            return this.defaultMargin.Bottom;
        },
        StoreDefaultMargin: function (){
            this.defaultMargin = (function (){
                var $v89 = new Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.Margin.ctor();
                $v89.Left = this.get_LeftMargin();
                $v89.Right = this.get_RightMargin();
                $v89.Bottom = this.get_BottomMargin();
                $v89.Top = this.get_TopMargin();
                return $v89;
            }).call(this);
        },
        StoreDefaultMargin$$Double$$Double$$Double$$Double: function (left, right, bottom, top){
            this.defaultMargin = (function (){
                var $v90 = new Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.Margin.ctor();
                $v90.Left = left;
                $v90.Right = right;
                $v90.Bottom = bottom;
                $v90.Top = top;
                return $v90;
            }).call(this);
        },
        RestoreDefaultMargin: function (){
            if (this.defaultMargin != null){
                this.set_LeftMargin(this.defaultMargin.Left);
                this.set_RightMargin(this.defaultMargin.Right);
                this.set_TopMargin(this.defaultMargin.Top);
                this.set_BottomMargin(this.defaultMargin.Bottom);
            }
        },
        TranslateRectangle: function (delta){
            this.rectangle = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Double$$Double$$Point(this.rectangle.get_Left() + delta.get_X(), this.rectangle.get_Bottom() + delta.get_Y(), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.rectangle.get_Width(), this.rectangle.get_Height()));
        },
        RadiusX$$: "System.Double",
        get_RadiusX: function (){
            return this._RadiusX;
        },
        set_RadiusX: function (value){
            this._RadiusX = value;
        },
        RadiusY$$: "System.Double",
        get_RadiusY: function (){
            return this._RadiusY;
        },
        set_RadiusY: function (value){
            this._RadiusY = value;
        },
        Lock$$Double$$Double$$Double$$Double: function (left, right, top, bottom){
            var weight = 10000;
            this.set_LeftBorderInfo(new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double$$Double$$Double(this.get_LeftBorderInfo().get_InnerMargin(), left, weight));
            this.set_RightBorderInfo(new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double$$Double$$Double(this.get_RightBorderInfo().get_InnerMargin(), right, weight));
            this.set_TopBorderInfo(new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double$$Double$$Double(this.get_TopBorderInfo().get_InnerMargin(), top, weight));
            this.set_BottomBorderInfo(new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double$$Double$$Double(this.get_BottomBorderInfo().get_InnerMargin(), bottom, weight));
        },
        Unlock: function (){
            this.set_LeftBorderInfo(new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double(this.get_LeftBorderInfo().get_InnerMargin()));
            this.set_RightBorderInfo(new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double(this.get_RightBorderInfo().get_InnerMargin()));
            this.set_TopBorderInfo(new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double(this.get_TopBorderInfo().get_InnerMargin()));
            this.set_BottomBorderInfo(new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double(this.get_BottomBorderInfo().get_InnerMargin()));
        },
        Lock: function (){
            this.Lock$$Double$$Double$$Double$$Double(this.rectangle.get_Left(), this.rectangle.get_Right(), this.rectangle.get_Top(), this.rectangle.get_Bottom());
        },
        MinWidth$$: "System.Double",
        get_MinWidth: function (){
            return this._MinWidth;
        },
        set_MinWidth: function (value){
            this._MinWidth = value;
        },
        MinHeight$$: "System.Double",
        get_MinHeight: function (){
            return this._MinHeight;
        },
        set_MinHeight: function (value){
            this._MinHeight = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$RectangularClusterBoundary);
var Microsoft$Msagl$Core$Geometry$RectangularClusterBoundary$Margin = {
    fullname: "Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.Margin",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.Left = 0;
            this.Right = 0;
            this.Top = 0;
            this.Bottom = 0;
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$RectangularClusterBoundary$Margin);
var Microsoft$Msagl$Layout$Initial$InitialLayout = {
    fullname: "Microsoft.Msagl.Layout.Initial.InitialLayout",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (graph, settings){
            this.graph = null;
            this.settings = null;
            this.componentCount = 0;
            this._SingleComponent = false;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(graph, "graph");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(settings, "settings");
            this.graph = graph;
            this.settings = new Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.ctor$$FastIncrementalLayoutSettings(settings);
            this.settings.set_ApplyForces(true);
            this.settings.set_InterComponentForces(true);
            this.settings.set_RungeKuttaIntegration(false);
            this.settings.set_RespectEdgePorts(false);
        },
        SingleComponent$$: "System.Boolean",
        get_SingleComponent: function (){
            return this._SingleComponent;
        },
        set_SingleComponent: function (value){
            this._SingleComponent = value;
        },
        RunInternal: function (){
            if (this.get_SingleComponent()){
                this.componentCount = 1;
                this.LayoutComponent(this.graph);
            }
            else {
                var $it698 = this.graph.get_RootCluster().AllClustersDepthFirst().GetEnumerator();
                while ($it698.MoveNext()){
                    var c = $it698.get_Current();
                    if (c == this.graph.get_RootCluster() || c.get_RectangularBoundary() == null)
                        continue;
                    c.get_RectangularBoundary().set_GenerateFixedConstraints(false);
                }
                var components = System.Linq.Enumerable.ToList$1(Microsoft.Msagl.Core.Layout.GeometryGraph.ctor, Microsoft.Msagl.Core.Layout.GraphConnectedComponents.GetClusteredConnectedComponents(this.graph));
                this.componentCount = components.get_Count();
                var $it699 = components.GetEnumerator();
                while ($it699.MoveNext()){
                    var component = $it699.get_Current();
                    this.LayoutComponent(component);
                }
                this.graph.set_BoundingBox(Microsoft.Msagl.Layout.MDS.MdsGraphLayout.PackGraphs(components, this.settings));
                this.ProgressComplete();
                var $it700 = this.graph.get_Nodes().GetEnumerator();
                while ($it700.MoveNext()){
                    var v = $it700.get_Current();
                    var copy = As(v.AlgorithmData, Microsoft.Msagl.Core.Layout.GraphConnectedComponents.AlgorithmDataNodeWrap.ctor);
                    System.Diagnostics.Debug.Assert$$Boolean(copy != null);
                    v.set_Center(copy.node.get_Center());
                }
                var $it701 = this.graph.get_Edges().GetEnumerator();
                while ($it701.MoveNext()){
                    var e = $it701.get_Current();
                    var copy = As(e.AlgorithmData, Microsoft.Msagl.Core.Layout.Edge.ctor);
                    if (copy != null){
                        e.set_EdgeGeometry(copy.get_EdgeGeometry());
                        e.get_EdgeGeometry().set_Curve(copy.get_Curve());
                    }
                }
                var $it702 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Cluster.ctor, this.graph.get_RootCluster().AllClustersDepthFirst(), $CreateAnonymousDelegate(this, function (c){
                    return c != this.graph.get_RootCluster();
                })).GetEnumerator();
                while ($it702.MoveNext()){
                    var c = $it702.get_Current();
                    var copy = As(c.AlgorithmData, Microsoft.Msagl.Core.Layout.GraphConnectedComponents.AlgorithmDataNodeWrap.ctor);
                    var copyCluster = As(copy.node, Microsoft.Msagl.Core.Layout.Cluster.ctor);
                    System.Diagnostics.Debug.Assert$$Boolean(copyCluster != null);
                    c.set_RectangularBoundary(copyCluster.get_RectangularBoundary());
                    c.get_RectangularBoundary().set_GenerateFixedConstraints(c.get_RectangularBoundary().get_GenerateFixedConstraintsDefault());
                    c.set_BoundingBox(c.get_RectangularBoundary().get_Rect());
                    c.RaiseLayoutDoneEvent();
                }
            }
        },
        LayoutComponent: function (component){
            if (component.get_Nodes().get_Count() > 1 || System.Linq.Enumerable.Any$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, component.get_RootCluster().get_Clusters())){
                this.settings.set_MaxIterations(Microsoft.Msagl.Core.Layout.LayoutAlgorithmHelpers.NegativeLinearInterpolation$$Int32$$Int32$$Int32$$Int32$$Int32(component.get_Nodes().get_Count(), 50, 500, 5, 10));
                this.settings.set_MinorIterations(Microsoft.Msagl.Core.Layout.LayoutAlgorithmHelpers.NegativeLinearInterpolation$$Int32$$Int32$$Int32$$Int32$$Int32(component.get_Nodes().get_Count(), 50, 500, 3, 20));
                if (this.settings.get_MinConstraintLevel() == 0){
                    var pivotMDS = (function (){
                        var $v91 = new Microsoft.Msagl.Layout.MDS.PivotMDS.ctor(component);
                        $v91.set_Scale(2);
                        return $v91;
                    }).call(this);
                    this.RunChildAlgorithm(pivotMDS, 0.5 / this.componentCount);
                }
                var fil = new Microsoft.Msagl.Layout.Incremental.FastIncrementalLayout.ctor(component, this.settings, this.settings.get_MinConstraintLevel(), $CreateAnonymousDelegate(this, function (anyCluster){
                    return this.settings;
                }));
                System.Diagnostics.Debug.Assert$$Boolean(this.settings.get_Iterations() == 0);
                var $it703 = this.GetConstraintLevels(component).GetEnumerator();
                while ($it703.MoveNext()){
                    var level = $it703.get_Current();
                    if (level > this.settings.get_MaxConstraintLevel()){
                        break;
                    }
                    if (level > this.settings.get_MinConstraintLevel()){
                        fil.set_CurrentConstraintLevel(level);
                    }
                    do{
                        fil.Run();
                    }
                    while (!this.settings.get_IsDone())
                }
            }
            component.set_Margins(this.settings.get_NodeSeparation());
            component.UpdateBoundingBox();
            component.Translate(Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(component.get_BoundingBox().get_LeftBottom()));
        },
        GetConstraintLevels: function (component){
            var keys = System.Linq.Enumerable.ToList$1(System.Int32.ctor, (System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Layout.Incremental.IConstraint.ctor, System.Int32.ctor, this.settings.get_StructuralConstraints(), $CreateAnonymousDelegate(this, function (c){
                return c.get_Level();
            }))));
            keys.Add(0);
            if (this.settings.get_IdealEdgeLength().get_EdgeDirectionConstraints() != Microsoft.Msagl.Core.Geometry.Directions.None){
                keys.Add(1);
            }
            if (this.settings.get_AvoidOverlaps() && component.get_Nodes().get_Count() < 2000){
                keys.Add(2);
            }
            return System.Linq.Enumerable.Distinct$1$$IEnumerable$1(System.Int32.ctor, keys);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Initial$InitialLayout);
var Microsoft$Msagl$Layout$Incremental$StickConstraint = {
    fullname: "Microsoft.Msagl.Layout.Incremental.StickConstraint",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Layout.Incremental.IConstraint"],
    Kind: "Class",
    definition: {
        ctor: function (u, v, separation){
            this.u = null;
            this.v = null;
            this.separation = 0;
            System.Object.ctor.call(this);
            this.u = u;
            this.v = v;
            this.separation = separation;
        },
        Project: function (){
            var uv = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.v.get_Center(), this.u.get_Center());
            var d = this.separation - uv.get_Length(),wu = (Cast(this.u.AlgorithmData, Microsoft.Msagl.Layout.Incremental.FiNode.ctor)).stayWeight,wv = (Cast(this.v.AlgorithmData, Microsoft.Msagl.Layout.Incremental.FiNode.ctor)).stayWeight;
            var f = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(d, uv.Normalize()), (wu + wv));
            this.u.set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.u.get_Center(), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(wv, f)));
            this.v.set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.v.get_Center(), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(wu, f)));
            return System.Math.Abs$$Double(d);
        },
        Level$$: "System.Int32",
        get_Level: function (){
            return 0;
        },
        Nodes$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Layout.Node]]",
        get_Nodes: function (){
            return [this.u, this.v];
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Incremental$StickConstraint);
var Microsoft$Msagl$Layout$Incremental$VerticalSeparationConstraint = {
    fullname: "Microsoft.Msagl.Layout.Incremental.VerticalSeparationConstraint",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Layout.Incremental.IConstraint"],
    Kind: "Class",
    definition: {
        ctor$$Node$$Node$$Double: function (u, v, separation){
            this.equality = false;
            this.u = null;
            this.v = null;
            this.separation = 0;
            System.Object.ctor.call(this);
            this.u = u;
            this.v = v;
            this.separation = separation;
        },
        IsEquality$$: "System.Boolean",
        get_IsEquality: function (){
            return this.equality;
        },
        TopNode$$: "Microsoft.Msagl.Core.Layout.Node",
        get_TopNode: function (){
            return this.u;
        },
        BottomNode$$: "Microsoft.Msagl.Core.Layout.Node",
        get_BottomNode: function (){
            return this.v;
        },
        Separation$$: "System.Double",
        get_Separation: function (){
            return this.separation;
        },
        set_Separation: function (value){
            this.separation = value;
        },
        ctor$$Node$$Node$$Double$$Boolean: function (u, v, separation, equality){
            this.equality = false;
            this.u = null;
            this.v = null;
            this.separation = 0;
            System.Object.ctor.call(this);
            this.equality = equality;
            this.u = u;
            this.v = v;
            this.separation = separation;
        },
        Project: function (){
            var uv = this.v.get_Center().get_Y() - this.u.get_Center().get_Y();
            var d = this.separation - uv;
            if (d > 0){
                var wu = (Cast(this.u.AlgorithmData, Microsoft.Msagl.Layout.Incremental.FiNode.ctor)).stayWeight,wv = (Cast(this.v.AlgorithmData, Microsoft.Msagl.Layout.Incremental.FiNode.ctor)).stayWeight;
                var f = d / (wu + wv);
                this.u.set_Center(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.u.get_Center().get_X(), this.u.get_Center().get_Y() - wv * f));
                this.v.set_Center(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.v.get_Center().get_X(), this.v.get_Center().get_Y() + wu * f));
                return d;
            }
            else {
                return 0;
            }
        },
        Level$$: "System.Int32",
        get_Level: function (){
            return 0;
        },
        Nodes$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Layout.Node]]",
        get_Nodes: function (){
            return [this.u, this.v];
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Incremental$VerticalSeparationConstraint);
var Microsoft$Msagl$Core$DataStructures$BinaryHeapPriorityQueue = {
    fullname: "Microsoft.Msagl.Core.DataStructures.BinaryHeapPriorityQueue",
    baseTypeName: "System.Object",
    staticDefinition: {
        Test: function (){
            var q = new Microsoft.Msagl.Core.DataStructures.BinaryHeapPriorityQueue.ctor(10);
            q.Enqueue(2, 2);
            q.Enqueue(1, 1);
            q.Enqueue(9, 9);
            q.Enqueue(8, 8);
            q.Enqueue(5, 5);
            q.Enqueue(3, 3);
            q.Enqueue(4, 4);
            q.Enqueue(7, 7);
            q.Enqueue(6, 6);
            q.Enqueue(0, 0);
            for (var i = 0; i < 10; i++)
                System.Console.WriteLine$$Int32(q.Dequeue());
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (n){
            this.A = null;
            this.cache = null;
            this.heapSize = 0;
            System.Object.ctor.call(this);
            this.cache = new Array(n);
            this.A = new Array(n + 1);
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this.heapSize;
        },
        SwapWithParent: function (i){
            var parent = this.A[i >> 1];
            this.PutAtI(i >> 1, this.A[i]);
            this.PutAtI(i, parent);
        },
        Enqueue: function (o, priority){
            this.heapSize++;
            var i = this.heapSize;
            System.Diagnostics.Debug.Assert$$Boolean(this.cache[o] == null);
            this.A[i] = this.cache[o] = new Microsoft.Msagl.Core.DataStructures.HeapElem.ctor(i, priority, o);
            while (i > 1 && this.A[i >> 1].priority.CompareTo$$Double(priority) > 0){
                this.SwapWithParent(i);
                i >>= 1;
            }
        },
        IsEmpty: function (){
            return this.heapSize == 0;
        },
        PutAtI: function (i, h){
            this.A[i] = h;
            h.indexToA = i;
        },
        Dequeue: function (){
            if (this.heapSize == 0)
                throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            var ret = this.A[1].v;
            this.cache[ret] = null;
            if (this.heapSize > 1){
                this.PutAtI(1, this.A[this.heapSize]);
                var i = 1;
                while (true){
                    var smallest = i;
                    var l = i << 1;
                    if (l <= this.heapSize && this.A[l].priority.CompareTo$$Double(this.A[i].priority) < 0)
                        smallest = l;
                    var r = l + 1;
                    if (r <= this.heapSize && this.A[r].priority.CompareTo$$Double(this.A[smallest].priority) < 0)
                        smallest = r;
                    if (smallest != i)
                        this.SwapWithParent(smallest);
                    else
                        break;
                    i = smallest;
                }
            }
            this.heapSize--;
            return ret;
        },
        DecreasePriority: function (o, newPriority){
            var h = this.cache[o];
            h.priority = newPriority;
            var i = h.indexToA;
            while (i > 1){
                if (this.A[i].priority.CompareTo$$Double(this.A[i >> 1].priority) < 0)
                    this.SwapWithParent(i);
                else
                    break;
                i >>= 1;
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$DataStructures$BinaryHeapPriorityQueue);
var Microsoft$Msagl$Core$DataStructures$BinaryHeapWithComparer$1 = {
    fullname: "Microsoft.Msagl.Core.DataStructures.BinaryHeapWithComparer$1",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (T){
            Microsoft.Msagl.Core.DataStructures.BinaryHeapWithComparer$1.initialHeapCapacity = 16;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (T, comparer){
            this.T = T;
            this.A = null;
            this.heapSize = 0;
            this.comparer = null;
            System.Object.ctor.call(this);
            this.A = new Array(17);
            this.comparer = comparer;
        },
        Enqueue: function (element){
            if (this.heapSize == this.A.length - 1){
                var newA = new Array(this.A.length * 2);
                System.Array.Copy(this.A, 1, newA, 1, this.heapSize);
                this.A = newA;
            }
            var i = this.heapSize + 1;
            this.A[i] = element;
            this.heapSize++;
            var j = i >> 1;
            var parent,son;
            while (i > 1 && this.Less(son = this.A[i], parent = this.A[j])){
                this.A[j] = son;
                this.A[i] = parent;
                i = j;
                j = i >> 1;
            }
        },
        Dequeue: function (){
            if (this.heapSize < 1)
                throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            var ret = this.A[1];
            var candidate = this.A[this.heapSize];
            this.heapSize--;
            this.ChangeMinimum(candidate);
            return ret;
        },
        Peak$$: "`0",
        get_Peak: function (){
            System.Diagnostics.Debug.Assert$$Boolean(this.heapSize > 0);
            return this.A[1];
        },
        ChangeMinimum: function (candidate){
            this.A[1] = candidate;
            var j = 1;
            var i = 2;
            var done = false;
            while (i < this.heapSize && !done){
                done = true;
                var leftSon = this.A[i];
                var rigthSon = this.A[i + 1];
                var compareResult = this.comparer.Compare(leftSon, rigthSon);
                if (compareResult < 0){
                    if (this.comparer.Compare(leftSon, candidate) < 0){
                        this.A[j] = leftSon;
                        this.A[i] = candidate;
                        done = false;
                        j = i;
                        i = j << 1;
                    }
                }
                else {
                    if (this.comparer.Compare(rigthSon, candidate) < 0){
                        this.A[j] = rigthSon;
                        this.A[i + 1] = candidate;
                        done = false;
                        j = i + 1;
                        i = j << 1;
                    }
                }
            }
            if (i == this.heapSize){
                var leftSon = this.A[i];
                if (this.comparer.Compare(leftSon, candidate) < 0){
                    this.A[j] = leftSon;
                    this.A[i] = candidate;
                }
            }
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this.heapSize;
        },
        Less: function (a, b){
            return this.comparer.Compare(a, b) < 0;
        },
        GetMinimum: function (){
            return this.A[1];
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$DataStructures$BinaryHeapWithComparer$1);
var Microsoft$Msagl$Core$Layout$GraphConnectedComponents = {
    fullname: "Microsoft.Msagl.Core.Layout.GraphConnectedComponents",
    baseTypeName: "System.Object",
    staticDefinition: {
        CreateComponents: function (nodes, edges){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(nodes, "nodes");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(edges, "edges");
            var nodeIndex = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, System.Int32.ctor);
            var nodeCount = 0;
            var $it704 = nodes.GetEnumerator();
            while ($it704.MoveNext()){
                var v = $it704.get_Current();
                nodeIndex.set_Item$$TKey(v, nodeCount++);
            }
            var intEdges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.SimpleIntEdge.ctor);
            var $it705 = edges.GetEnumerator();
            while ($it705.MoveNext()){
                var e = $it705.get_Current();
                intEdges.Add((function (){
                    var $v92 = new Microsoft.Msagl.Core.Layout.SimpleIntEdge.ctor();
                    $v92.set_Source(nodeIndex.get_Item$$TKey(e.get_Source()));
                    $v92.set_Target(nodeIndex.get_Item$$TKey(e.get_Target()));
                    return $v92;
                })());
            }
            var components = Microsoft.Msagl.Core.GraphAlgorithms.ConnectedComponentCalculator$1.GetComponents(new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor$$IEnumerable$1$$Int32(Microsoft.Msagl.Core.Layout.SimpleIntEdge.ctor, intEdges, nodeCount));
            var nodeToGraph = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Layout.GeometryGraph.ctor);
            var graphs = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.GeometryGraph.ctor);
            var $it706 = components.GetEnumerator();
            while ($it706.MoveNext()){
                var c = $it706.get_Current();
                var g = new Microsoft.Msagl.Core.Layout.GeometryGraph.ctor();
                var $it707 = c.GetEnumerator();
                while ($it707.MoveNext()){
                    var i = $it707.get_Current();
                    var v = nodes.get_Item$$Int32(i);
                    g.get_Nodes().Add(v);
                    nodeToGraph.set_Item$$TKey(v, g);
                }
                graphs.Add(g);
            }
            var $it708 = edges.GetEnumerator();
            while ($it708.MoveNext()){
                var e = $it708.get_Current();
                var g = nodeToGraph.get_Item$$TKey(e.get_Source());
                System.Diagnostics.Debug.Assert$$Boolean$$String(nodeToGraph.get_Item$$TKey(e.get_Target()) == g, "source and target of edge are not in the same graph");
                g.get_Edges().Add(e);
            }
            return graphs;
        },
        GetClusteredConnectedComponents: function (graph){
            var flatGraph = Microsoft.Msagl.Core.Layout.GraphConnectedComponents.FlatGraph(graph);
            var basicFlatGraph = new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor$$IEnumerable$1$$Int32(Microsoft.Msagl.Core.Layout.GraphConnectedComponents.AlgorithmDataEdgeWrap.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, Microsoft.Msagl.Core.Layout.GraphConnectedComponents.AlgorithmDataEdgeWrap.ctor, flatGraph.get_Edges(), function (e){
                return Cast(e.AlgorithmData, Microsoft.Msagl.Core.Layout.GraphConnectedComponents.AlgorithmDataEdgeWrap.ctor);
            }), flatGraph.get_Nodes().get_Count());
            var nodes = System.Linq.Enumerable.ToList$1(Microsoft.Msagl.Core.Layout.Node.ctor, flatGraph.get_Nodes());
            var graphComponents = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.GeometryGraph.ctor);
            var $it709 = Microsoft.Msagl.Core.GraphAlgorithms.ConnectedComponentCalculator$1.GetComponents(basicFlatGraph).GetEnumerator();
            while ($it709.MoveNext()){
                var componentNodes = $it709.get_Current();
                var g = new Microsoft.Msagl.Core.Layout.GeometryGraph.ctor();
                var topClusters = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Cluster.ctor);
                var topNodes = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor);
                var $it710 = componentNodes.GetEnumerator();
                while ($it710.MoveNext()){
                    var i = $it710.get_Current();
                    var v = nodes.get_Item$$Int32(i);
                    var original = Cast(v.get_UserData(), Microsoft.Msagl.Core.Layout.Node.ctor);
                    var topLevel = (Cast(original.AlgorithmData, Microsoft.Msagl.Core.Layout.GraphConnectedComponents.AlgorithmDataNodeWrap.ctor)).TopLevel;
                    if (Is(v.get_UserData(), Microsoft.Msagl.Core.Layout.Cluster.ctor)){
                        if (topLevel){
                            topClusters.Add(Cast(original, Microsoft.Msagl.Core.Layout.Cluster.ctor));
                        }
                    }
                    else {
                        v.ClearEdges();
                        g.get_Nodes().Add(v);
                        if (topLevel){
                            topNodes.Add(v);
                        }
                    }
                }
                var index = g.get_Nodes().get_Count();
                if (topClusters.get_Count() != 0){
                    var root = new Microsoft.Msagl.Core.Layout.Cluster.ctor$$IEnumerable$1$Node(topNodes);
                    var $it711 = topClusters.GetEnumerator();
                    while ($it711.MoveNext()){
                        var top = $it711.get_Current();
                        root.AddChild((function (){
                            var $1 = {
                                Value: index
                            };
                            var $res = Microsoft.Msagl.Core.Layout.GraphConnectedComponents.CopyCluster(top, $1);
                            index = $1.Value;
                            return $res;
                        })());
                    }
                    g.set_RootCluster(root);
                }
                var $it712 = g.GetFlattenedNodesAndClusters().GetEnumerator();
                while ($it712.MoveNext()){
                    var v = $it712.get_Current();
                    var original = As(v.get_UserData(), Microsoft.Msagl.Core.Layout.Node.ctor);
                    System.Diagnostics.Debug.Assert$$Boolean(original != null);
                    var $it713 = original.get_InEdges().GetEnumerator();
                    while ($it713.MoveNext()){
                        var e = $it713.get_Current();
                        var source = Microsoft.Msagl.Core.Layout.GraphConnectedComponents.GetCopy(e.get_Source());
                        var target = Microsoft.Msagl.Core.Layout.GraphConnectedComponents.GetCopy(e.get_Target());
                        var copy = (function (){
                            var $v93 = new Microsoft.Msagl.Core.Layout.Edge.ctor$$Node$$Node(source, target);
                            $v93.set_Length(e.get_Length());
                            $v93.set_UserData(e);
                            $v93.set_EdgeGeometry(e.get_EdgeGeometry());
                            return $v93;
                        })();
                        e.AlgorithmData = copy;
                        g.get_Edges().Add(copy);
                    }
                }
                graphComponents.Add(g);
            }
            return graphComponents;
        },
        GetCopy: function (node){
            return (Cast(node.AlgorithmData, Microsoft.Msagl.Core.Layout.GraphConnectedComponents.AlgorithmDataNodeWrap.ctor)).node;
        },
        CopyCluster: function (top, index){
            var copy = (function (){
                var $v94 = new Microsoft.Msagl.Core.Layout.Cluster.ctor$$IEnumerable$1$Node(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Layout.Node.ctor, top.get_Nodes(), function (v){
                    return Microsoft.Msagl.Core.Layout.GraphConnectedComponents.GetCopy(v);
                }));
                $v94.set_UserData(top);
                $v94.set_RectangularBoundary(top.get_RectangularBoundary());
                $v94.set_BoundaryCurve(top.get_BoundaryCurve().Clone());
                $v94.set_CollapsedBoundary(top.get_CollapsedBoundary() == null ? null : top.get_CollapsedBoundary().Clone());
                return $v94;
            })();
            top.AlgorithmData = new Microsoft.Msagl.Core.Layout.GraphConnectedComponents.AlgorithmDataNodeWrap.ctor(index.Value++, copy);
            var $it714 = top.get_Clusters().GetEnumerator();
            while ($it714.MoveNext()){
                var c = $it714.get_Current();
                copy.AddChild(Microsoft.Msagl.Core.Layout.GraphConnectedComponents.CopyCluster(c, index));
            }
            return copy;
        },
        FlatGraph: function (graph){
            var flatGraph = new Microsoft.Msagl.Core.Layout.GeometryGraph.ctor();
            var $it715 = graph.get_Nodes().GetEnumerator();
            while ($it715.MoveNext()){
                var v = $it715.get_Current();
                System.Diagnostics.Debug.Assert$$Boolean(!(Is(v, Microsoft.Msagl.Core.Layout.Cluster.ctor)));
                var u = (function (){
                    var $v95 = new Microsoft.Msagl.Core.Layout.Node.ctor$$ICurve(v.get_BoundaryCurve().Clone());
                    $v95.set_UserData(v);
                    return $v95;
                })();
                v.AlgorithmData = new Microsoft.Msagl.Core.Layout.GraphConnectedComponents.AlgorithmDataNodeWrap.ctor(flatGraph.get_Nodes().get_Count(), u);
                flatGraph.get_Nodes().Add(u);
            }
            var avgLength = 0;
            var $it716 = graph.get_Edges().GetEnumerator();
            while ($it716.MoveNext()){
                var e = $it716.get_Current();
                avgLength += e.get_Length();
                if (Is(e.get_Source(), Microsoft.Msagl.Core.Layout.Cluster.ctor) || Is(e.get_Target(), Microsoft.Msagl.Core.Layout.Cluster.ctor))
                    continue;
                flatGraph.get_Edges().Add(Microsoft.Msagl.Core.Layout.GraphConnectedComponents.AlgorithmDataEdgeWrap.MakeEdge(e));
            }
            if (graph.get_Edges().get_Count() != 0)
                avgLength /= graph.get_Edges().get_Count();
            else
                avgLength = 100;
            var rootCluster = graph.get_RootCluster();
            var $it717 = rootCluster.AllClustersDepthFirst().GetEnumerator();
            while ($it717.MoveNext()){
                var c = $it717.get_Current();
                if (c == rootCluster)
                    continue;
                if (c.get_BoundaryCurve() == null)
                    c.set_BoundaryCurve(Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateRectangleWithRoundedCorners$$Double$$Double$$Double$$Double$$Point(10, 10, 1, 1, new Microsoft.Msagl.Core.Geometry.Point.ctor()));
                var uOfCluster = (function (){
                    var $v96 = new Microsoft.Msagl.Core.Layout.Node.ctor$$ICurve(c.get_BoundaryCurve().Clone());
                    $v96.set_UserData(c);
                    return $v96;
                })();
                var uuOfCluster = new Microsoft.Msagl.Core.Layout.GraphConnectedComponents.AlgorithmDataNodeWrap.ctor(flatGraph.get_Nodes().get_Count(), uOfCluster);
                c.AlgorithmData = uuOfCluster;
                flatGraph.get_Nodes().Add(uOfCluster);
                var $it718 = System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Layout.Node.ctor, c.get_Nodes(), System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Cluster.ctor, Microsoft.Msagl.Core.Layout.Node.ctor, c.get_Clusters(), function (cc){
                    return cc;
                })).GetEnumerator();
                while ($it718.MoveNext()){
                    var v = $it718.get_Current();
                    flatGraph.get_Edges().Add(Microsoft.Msagl.Core.Layout.GraphConnectedComponents.AlgorithmDataEdgeWrap.MakeDummyEdgeFromNodeToItsCluster(As(v.AlgorithmData, Microsoft.Msagl.Core.Layout.GraphConnectedComponents.AlgorithmDataNodeWrap.ctor), uuOfCluster, avgLength));
                }
            }
            var $it719 = System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Layout.Node.ctor, rootCluster.get_Nodes(), System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Cluster.ctor, Microsoft.Msagl.Core.Layout.Node.ctor, rootCluster.get_Clusters(), function (cc){
                return cc;
            })).GetEnumerator();
            while ($it719.MoveNext()){
                var v = $it719.get_Current();
                (Cast(v.AlgorithmData, Microsoft.Msagl.Core.Layout.GraphConnectedComponents.AlgorithmDataNodeWrap.ctor)).TopLevel = true;
            }
            var $it720 = graph.get_Edges().GetEnumerator();
            while ($it720.MoveNext()){
                var e = $it720.get_Current();
                if (Is(e.get_Source(), Microsoft.Msagl.Core.Layout.Cluster.ctor) || Is(e.get_Target(), Microsoft.Msagl.Core.Layout.Cluster.ctor))
                    flatGraph.get_Edges().Add(Microsoft.Msagl.Core.Layout.GraphConnectedComponents.AlgorithmDataEdgeWrap.MakeEdge(e));
            }
            return flatGraph;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$GraphConnectedComponents);
var Microsoft$Msagl$Core$Layout$GraphConnectedComponents$AlgorithmDataNodeWrap = {
    fullname: "Microsoft.Msagl.Core.Layout.GraphConnectedComponents.AlgorithmDataNodeWrap",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (index, node){
            this.index = 0;
            this.node = null;
            this.TopLevel = false;
            System.Object.ctor.call(this);
            this.index = index;
            this.node = node;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$GraphConnectedComponents$AlgorithmDataNodeWrap);
var Microsoft$Msagl$Core$Layout$GraphConnectedComponents$AlgorithmDataEdgeWrap = {
    fullname: "Microsoft.Msagl.Core.Layout.GraphConnectedComponents.AlgorithmDataEdgeWrap",
    baseTypeName: "System.Object",
    staticDefinition: {
        MakeDummyEdgeFromNodeToItsCluster: function (u, v, length){
            var e = (function (){
                var $v97 = new Microsoft.Msagl.Core.Layout.Edge.ctor$$Node$$Node(u.node, v.node);
                $v97.set_Length(length);
                $v97.AlgorithmData = (function (){
                    var $v98 = new Microsoft.Msagl.Core.Layout.GraphConnectedComponents.AlgorithmDataEdgeWrap.ctor();
                    $v98.set_Source(u.index);
                    $v98.set_Target(v.index);
                    return $v98;
                })();
                return $v97;
            })();
            return e;
        },
        MakeEdge: function (original){
            var u = As(original.get_Source().AlgorithmData, Microsoft.Msagl.Core.Layout.GraphConnectedComponents.AlgorithmDataNodeWrap.ctor);
            var v = As(original.get_Target().AlgorithmData, Microsoft.Msagl.Core.Layout.GraphConnectedComponents.AlgorithmDataNodeWrap.ctor);
            var e = (function (){
                var $v99 = new Microsoft.Msagl.Core.Layout.Edge.ctor$$Node$$Node(u.node, v.node);
                $v99.set_Length(original.get_Length());
                $v99.set_UserData(original);
                $v99.AlgorithmData = (function (){
                    var $v100 = new Microsoft.Msagl.Core.Layout.GraphConnectedComponents.AlgorithmDataEdgeWrap.ctor();
                    $v100.set_Source(u.index);
                    $v100.set_Target(v.index);
                    return $v100;
                })();
                return $v99;
            })();
            return e;
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Core.GraphAlgorithms.IEdge"],
    Kind: "Class",
    definition: {
        ctor: function (){
            this._Source = 0;
            this._Target = 0;
            System.Object.ctor.call(this);
        },
        Source$$: "System.Int32",
        get_Source: function (){
            return this._Source;
        },
        set_Source: function (value){
            this._Source = value;
        },
        Target$$: "System.Int32",
        get_Target: function (){
            return this._Target;
        },
        set_Target: function (value){
            this._Target = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$GraphConnectedComponents$AlgorithmDataEdgeWrap);
var Microsoft$Msagl$Core$Layout$PortEntryOnCurve = {
    fullname: "Microsoft.Msagl.Core.Layout.PortEntryOnCurve",
    baseTypeName: "System.Object",
    staticDefinition: {
        MiddlePoint: function (c){
            return c.get_Item$$Double((c.get_ParStart() + c.get_ParEnd()) / 2);
        },
        SpanPointsFromCurveSegments: function (curve){
            return System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, curve.get_Segments(), Microsoft.Msagl.Core.Layout.PortEntryOnCurve.MiddlePoint);
        },
        SpanPointsFromPolyline: function (poly, span){
            var $yield = [];
            var trimmedPoly = Cast(poly.TrimWithWrap(span.get_Item1(), span.get_Item2()), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            for (var p = trimmedPoly.get_StartPoint(); p.get_Next() != null; p = p.get_Next())
                $yield.push(Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Addition(p.get_Point(), p.get_Next().get_Point())), 2));
            return $yield;
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Core.Layout.IPortEntry"],
    Kind: "Class",
    definition: {
        ctor: function (entryCurve, parameterSpans){
            this.allowedRects = null;
            this._Spans = null;
            this._EntryCurve = null;
            System.Object.ctor.call(this);
            this.set_EntryCurve(entryCurve);
            this.set_Spans(parameterSpans);
        },
        AllowedRectangles$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Geometry.Rectangle]]",
        get_AllowedRectangles: function (){
            if (this.allowedRects == null){
                this.allowedRects = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Geometry.Rectangle.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.Tuple$2.ctor, Microsoft.Msagl.Core.Geometry.Rectangle.ctor, this.get_Spans(), $CreateAnonymousDelegate(this, function (span){
                    return this.TrimEntryCurve(span).get_BoundingBox();
                })));
            }
            return this.allowedRects;
        },
        TrimEntryCurve: function (span){
            var start = span.get_Item1();
            var end = span.get_Item2();
            if (start < end){
                return this.get_EntryCurve().Trim(start, end);
            }
            if ((Is(this.get_EntryCurve(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor)) || (Is(this.get_EntryCurve(), Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor)) || (Is(this.get_EntryCurve(), Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.ctor))){
                return this.get_EntryCurve().TrimWithWrap(start, end);
            }
            if (Is(this.get_EntryCurve(), Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor)){
                var c = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor();
                c.AddSegment(this.get_EntryCurve().Trim(start, this.get_EntryCurve().get_ParEnd()));
                c.AddSegment(this.get_EntryCurve().Trim(this.get_EntryCurve().get_ParStart(), end));
                return c;
            }
            return this.get_EntryCurve().Trim(end, start);
        },
        Spans$$: "System.Collections.Generic.IEnumerable`1[[System.Tuple`2[[System.Double],[System.Double]]]]",
        get_Spans: function (){
            return this._Spans;
        },
        set_Spans: function (value){
            this._Spans = value;
        },
        EntryCurve$$: "Microsoft.Msagl.Core.Geometry.Curves.ICurve",
        get_EntryCurve: function (){
            return this._EntryCurve;
        },
        set_EntryCurve: function (value){
            this._EntryCurve = value;
        },
        GetEntryPoints: function (){
            return System.Linq.Enumerable.SelectMany$2$$IEnumerable$1$$Func$2(System.Tuple$2.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, this.get_Spans(), $CreateDelegate(this, this.SpanPoints));
        },
        SpanPoints: function (span){
            if (span.get_Item1() == this.get_EntryCurve().get_ParStart() && span.get_Item2() == this.get_EntryCurve().get_ParEnd() || span.get_Item2() == this.get_EntryCurve().get_ParStart() && span.get_Item1() == this.get_EntryCurve().get_ParEnd())
                return [Microsoft.Msagl.Core.Layout.PortEntryOnCurve.MiddlePoint(this.get_EntryCurve())];
            var poly = As(this.get_EntryCurve(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            if (poly != null)
                return Microsoft.Msagl.Core.Layout.PortEntryOnCurve.SpanPointsFromPolyline(poly, span);
            if ((Is(this.get_EntryCurve(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor)) || (Is(this.get_EntryCurve(), Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor)) || (Is(this.get_EntryCurve(), Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.ctor))){
                var trimmedCurve = As(this.TrimEntryCurve(span), Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor);
                if (trimmedCurve != null){
                    return Microsoft.Msagl.Core.Layout.PortEntryOnCurve.SpanPointsFromCurveSegments(trimmedCurve);
                }
            }
            return [this.get_EntryCurve().get_Item$$Double(this.MiddleOfSpan(span))];
        },
        MiddleOfSpan: function (span){
            if (span.get_Item1() < span.get_Item2())
                return 0.5 * (span.get_Item1() + span.get_Item2());
            var halfLen = this.GetSpanLength(span) / 2;
            var t = span.get_Item1() + halfLen;
            return t <= this.get_EntryCurve().get_ParEnd() ? t : t - this.get_EntryCurve().get_ParStart();
        },
        GetSpanLength: function (span){
            return span.get_Item1() < span.get_Item2() ? span.get_Item2() - span.get_Item1() : this.get_EntryCurve().get_ParEnd() - span.get_Item1() + span.get_Item2();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$PortEntryOnCurve);
var Microsoft$Msagl$Core$ProgressChangedEventArgs = {
    fullname: "Microsoft.Msagl.Core.ProgressChangedEventArgs",
    baseTypeName: "System.EventArgs",
    staticDefinition: {
        cctor: function (){
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$Double: function (ratioComplete){
            this.algorithmDescription = null;
            this.ratioComplete = 0;
            Microsoft.Msagl.Core.ProgressChangedEventArgs.ctor$$Double$$String.call(this, ratioComplete, null);
        },
        ctor$$Double$$String: function (ratioComplete, algorithmDescription){
            this.algorithmDescription = null;
            this.ratioComplete = 0;
            System.EventArgs.ctor.call(this);
            this.ratioComplete = ratioComplete;
            this.algorithmDescription = algorithmDescription;
        },
        AlgorithmDescription$$: "System.String",
        get_AlgorithmDescription: function (){
            return this.algorithmDescription;
        },
        RatioComplete$$: "System.Double",
        get_RatioComplete: function (){
            return this.ratioComplete;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$ProgressChangedEventArgs);
var Microsoft$Msagl$Core$Routing$EdgeRoutingSettings = {
    fullname: "Microsoft.Msagl.Core.Routing.EdgeRoutingSettings",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.edgeRoutingMode = Microsoft.Msagl.Core.Routing.EdgeRoutingMode.SugiyamaSplines;
            this.coneAngle = 0.523598775598299;
            this.padding = 3;
            this.polylinePadding = 1.5;
            this.routingToParentConeAngle = 0.523598775598299;
            this.simpleSelfLoopsForParentEdgesThreshold = 200;
            this.incrementalRoutingThreshold = 5000000;
            this.routeMultiEdgesAsBundles = true;
            this._CornerRadius = 0;
            this._BendPenalty = 0;
            this._BundlingSettings = null;
            this._UseObstacleRectangles = false;
            this._KeepOriginalSpline = false;
            System.Object.ctor.call(this);
        },
        EdgeRoutingMode$$: "Microsoft.Msagl.Core.Routing.EdgeRoutingMode",
        get_EdgeRoutingMode: function (){
            return this.edgeRoutingMode;
        },
        set_EdgeRoutingMode: function (value){
            this.edgeRoutingMode = value;
        },
        ConeAngle$$: "System.Double",
        get_ConeAngle: function (){
            return this.coneAngle;
        },
        set_ConeAngle: function (value){
            this.coneAngle = value;
        },
        Padding$$: "System.Double",
        get_Padding: function (){
            return this.padding;
        },
        set_Padding: function (value){
            this.padding = value;
        },
        PolylinePadding$$: "System.Double",
        get_PolylinePadding: function (){
            return this.polylinePadding;
        },
        set_PolylinePadding: function (value){
            this.polylinePadding = value;
        },
        CornerRadius$$: "System.Double",
        get_CornerRadius: function (){
            return this._CornerRadius;
        },
        set_CornerRadius: function (value){
            this._CornerRadius = value;
        },
        BendPenalty$$: "System.Double",
        get_BendPenalty: function (){
            return this._BendPenalty;
        },
        set_BendPenalty: function (value){
            this._BendPenalty = value;
        },
        BundlingSettings$$: "Microsoft.Msagl.Core.Routing.BundlingSettings",
        get_BundlingSettings: function (){
            return this._BundlingSettings;
        },
        set_BundlingSettings: function (value){
            this._BundlingSettings = value;
        },
        UseObstacleRectangles$$: "System.Boolean",
        get_UseObstacleRectangles: function (){
            return this._UseObstacleRectangles;
        },
        set_UseObstacleRectangles: function (value){
            this._UseObstacleRectangles = value;
        },
        RoutingToParentConeAngle$$: "System.Double",
        get_RoutingToParentConeAngle: function (){
            return this.routingToParentConeAngle;
        },
        set_RoutingToParentConeAngle: function (value){
            this.routingToParentConeAngle = value;
        },
        SimpleSelfLoopsForParentEdgesThreshold$$: "System.Int32",
        get_SimpleSelfLoopsForParentEdgesThreshold: function (){
            return this.simpleSelfLoopsForParentEdgesThreshold;
        },
        set_SimpleSelfLoopsForParentEdgesThreshold: function (value){
            this.simpleSelfLoopsForParentEdgesThreshold = value;
        },
        IncrementalRoutingThreshold$$: "System.Int32",
        get_IncrementalRoutingThreshold: function (){
            return this.incrementalRoutingThreshold;
        },
        set_IncrementalRoutingThreshold: function (value){
            this.incrementalRoutingThreshold = value;
        },
        KeepOriginalSpline$$: "System.Boolean",
        get_KeepOriginalSpline: function (){
            return this._KeepOriginalSpline;
        },
        set_KeepOriginalSpline: function (value){
            this._KeepOriginalSpline = value;
        },
        RouteMultiEdgesAsBundles$$: "System.Boolean",
        get_RouteMultiEdgesAsBundles: function (){
            return this.routeMultiEdgesAsBundles;
        },
        set_RouteMultiEdgesAsBundles: function (value){
            this.routeMultiEdgesAsBundles = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Routing$EdgeRoutingSettings);
var Microsoft$Msagl$Core$Geometry$RTree$1 = {
    fullname: "Microsoft.Msagl.Core.Geometry.RTree$1",
    baseTypeName: "System.Object",
    staticDefinition: {
        GetNodeRects: function (nodes){
            return System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.Collections.Generic.KeyValuePair$2.ctor, Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, nodes, function (v){
                return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(this.TData, v.get_Value(), v.get_Key());
            });
        },
        AddNodeToTreeRecursive: function (newNode, existingNode){
            if (existingNode.get_IsLeaf()){
                existingNode.set_Left(new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(this.TData, existingNode.get_UserData(), existingNode.get_Rectangle()));
                existingNode.set_Right(newNode);
                existingNode.set_Count(2);
                existingNode.set_UserData(Default(this.TData));
            }
            else {
                existingNode.set_Count(existingNode.get_Count() + 1);
                var leftBox;
                var rightBox;
                if (2 * existingNode.get_Left().get_Count() < existingNode.get_Right().get_Count()){
                    Microsoft.Msagl.Core.Geometry.RTree$1.AddNodeToTreeRecursive(newNode, existingNode.get_Left());
                    existingNode.get_Left().set_Rectangle(new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Rectangle$$Rectangle(existingNode.get_Left().get_Rectangle(), newNode.get_Rectangle()));
                }
                else if (2 * existingNode.get_Right().get_Count() < existingNode.get_Left().get_Count()){
                    Microsoft.Msagl.Core.Geometry.RTree$1.AddNodeToTreeRecursive(newNode, existingNode.get_Right());
                    existingNode.get_Right().set_Rectangle(new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Rectangle$$Rectangle(existingNode.get_Right().get_Rectangle(), newNode.get_Rectangle()));
                }
                else {
                    leftBox = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Rectangle$$Rectangle(existingNode.get_Left().get_Rectangle(), newNode.get_Rectangle());
                    var delLeft = leftBox.get_Area() - existingNode.get_Left().get_Rectangle().get_Area();
                    rightBox = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Rectangle$$Rectangle(existingNode.get_Right().get_Rectangle(), newNode.get_Rectangle());
                    var delRight = rightBox.get_Area() - existingNode.get_Right().get_Rectangle().get_Area();
                    if (delLeft < delRight){
                        Microsoft.Msagl.Core.Geometry.RTree$1.AddNodeToTreeRecursive(newNode, existingNode.get_Left());
                        existingNode.get_Left().set_Rectangle(leftBox);
                    }
                    else if (delLeft > delRight){
                        Microsoft.Msagl.Core.Geometry.RTree$1.AddNodeToTreeRecursive(newNode, existingNode.get_Right());
                        existingNode.get_Right().set_Rectangle(rightBox);
                    }
                    else {
                        if (leftBox.get_Area() < rightBox.get_Area()){
                            Microsoft.Msagl.Core.Geometry.RTree$1.AddNodeToTreeRecursive(newNode, existingNode.get_Left());
                            existingNode.get_Left().set_Rectangle(leftBox);
                        }
                        else {
                            Microsoft.Msagl.Core.Geometry.RTree$1.AddNodeToTreeRecursive(newNode, existingNode.get_Right());
                            existingNode.get_Right().set_Rectangle(rightBox);
                        }
                    }
                }
            }
            existingNode.set_Rectangle(new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Rectangle$$Rectangle(existingNode.get_Left().get_Rectangle(), existingNode.get_Right().get_Rectangle()));
        },
        TreeIsCorrect: function (node){
            if (node == null)
                return true;
            var ret = node.get_Left() != null && node.get_Right() != null || node.get_Left() == null && node.get_Right() == null;
            if (!ret)
                return false;
            return Microsoft.Msagl.Core.Geometry.RTree$1.TreeIsCorrect(node.get_Left()) && Microsoft.Msagl.Core.Geometry.RTree$1.TreeIsCorrect(node.get_Right());
        },
        UpdateParent: function (parent){
            for (var node = parent.get_Parent(); node != null; node = node.get_Parent()){
                node.set_Count(node.get_Count() - 1);
                node.set_Rectangle(new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Rectangle$$Rectangle(node.get_Left().get_Rectangle(), node.get_Right().get_Rectangle()));
            }
        },
        TransferFromSibling: function (parent, sibling){
            parent.set_UserData(sibling.get_UserData());
            parent.set_Left(sibling.get_Left());
            parent.set_Right(sibling.get_Right());
            parent.set_Count(parent.get_Count() - 1);
            parent.set_Rectangle(sibling.get_Rectangle());
        },
        RebuildUnderNodeWithoutLeaf: function (nodeForRebuild, leaf){
            System.Diagnostics.Debug.Assert$$Boolean(leaf.get_IsLeaf());
            System.Diagnostics.Debug.Assert$$Boolean(!nodeForRebuild.get_IsLeaf());
            var newNode = Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnEnumeration(System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, nodeForRebuild.GetAllLeafNodes(), function (n){
                return !(n.Equals$$Object(leaf));
            }));
            nodeForRebuild.set_Count(newNode.get_Count());
            nodeForRebuild.set_Left(newNode.get_Left());
            nodeForRebuild.set_Right(newNode.get_Right());
            nodeForRebuild.set_Rectangle(new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Rectangle$$Rectangle(newNode.get_Left().rectangle, newNode.get_Right().rectangle));
        },
        FindTopUnbalancedNode: function (node){
            for (var parent = node.get_Parent(); parent != null; parent = parent.get_Parent())
                if (!Microsoft.Msagl.Core.Geometry.RTree$1.Balanced(parent))
                    return parent;
            return null;
        },
        Balanced: function (rectangleNode){
            return 2 * rectangleNode.get_Left().get_Count() >= rectangleNode.get_Right().get_Count() && 2 * rectangleNode.get_Right().get_Count() >= rectangleNode.get_Left().get_Count();
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$IEnumerable$1: function (TData, rectsAndData){
            this.TData = TData;
            this.rootNode = null;
            System.Object.ctor.call(this);
            this.rootNode = Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnEnumeration(Microsoft.Msagl.Core.Geometry.RTree$1.GetNodeRects(rectsAndData));
        },
        RootNode$$: "Microsoft.Msagl.Core.Geometry.RectangleNode`1[[`0]]",
        get_RootNode: function (){
            return this.rootNode;
        },
        set_RootNode: function (value){
            this.rootNode = value;
        },
        ctor$$RectangleNode$1: function (TData, rootNode){
            this.TData = TData;
            this.rootNode = null;
            System.Object.ctor.call(this);
            this.rootNode = rootNode;
        },
        ctor: function (TData){
            this.TData = TData;
            this.rootNode = null;
            System.Object.ctor.call(this);
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this.rootNode == null ? 0 : this.rootNode.get_Count();
        },
        Add$$Rectangle$$TData: function (key, value){
            this.Add$$RectangleNode$1(new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(this.TData, value, key));
        },
        Add$$RectangleNode$1: function (node){
            if (this.rootNode == null)
                this.rootNode = node;
            else if (this.get_Count() <= 2)
                this.rootNode = Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnEnumeration(System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, this.rootNode.GetAllLeafNodes(), [node]));
            else
                Microsoft.Msagl.Core.Geometry.RTree$1.AddNodeToTreeRecursive(node, this.rootNode);
        },
        Rebuild: function (){
            this.rootNode = Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnEnumeration(this.rootNode.GetAllLeafNodes());
        },
        GetAllLeaves: function (){
            return this.rootNode != null && this.get_Count() > 0 ? this.rootNode.GetAllLeaves() : new Array(0);
        },
        GetAllIntersecting: function (queryRegion){
            return this.rootNode == null || this.get_Count() == 0 ? new Array(0) : this.rootNode.GetNodeItemsIntersectingRectangle(queryRegion);
        },
        GetAllLeavesIntersectingRectangle: function (queryRegion){
            return this.rootNode == null || this.get_Count() == 0 ? new Array(0) : this.rootNode.GetLeafRectangleNodesIntersectingRectangle(queryRegion);
        },
        IsIntersecting: function (queryRegion){
            return System.Linq.Enumerable.Any$1$$IEnumerable$1(this.TData, this.GetAllIntersecting(queryRegion));
        },
        Contains: function (rectangle, userData){
            if (this.rootNode == null)
                return false;
            return System.Linq.Enumerable.Any$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, this.rootNode.GetLeafRectangleNodesIntersectingRectangle(rectangle), $CreateAnonymousDelegate(this, function (node){
                return node.get_UserData().Equals$$Object(userData);
            }));
        },
        Remove: function (rectangle, userData){
            if (this.rootNode == null){
                return Default(this.TData);
            }
            var ret = System.Linq.Enumerable.FirstOrDefault$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, this.rootNode.GetLeafRectangleNodesIntersectingRectangle(rectangle), $CreateAnonymousDelegate(this, function (node){
                return node.get_UserData().Equals$$Object(userData);
            }));
            if (ret == null)
                return Default(this.TData);
            if (this.get_RootNode().get_Count() == 1)
                this.set_RootNode(null);
            else
                this.RemoveLeaf(ret);
            return ret.get_UserData();
        },
        RemoveLeaf: function (leaf){
            System.Diagnostics.Debug.Assert$$Boolean(leaf.get_IsLeaf());
            var unbalancedNode = Microsoft.Msagl.Core.Geometry.RTree$1.FindTopUnbalancedNode(leaf);
            if (unbalancedNode != null){
                Microsoft.Msagl.Core.Geometry.RTree$1.RebuildUnderNodeWithoutLeaf(unbalancedNode, leaf);
                Microsoft.Msagl.Core.Geometry.RTree$1.UpdateParent(unbalancedNode);
            }
            else {
                var parent = leaf.get_Parent();
                if (parent == null){
                    System.Diagnostics.Debug.Assert$$Boolean(this.rootNode == leaf);
                    this.rootNode = new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor(this.TData);
                }
                else {
                    Microsoft.Msagl.Core.Geometry.RTree$1.TransferFromSibling(parent, leaf.get_IsLeftChild() ? parent.get_Right() : parent.get_Left());
                    Microsoft.Msagl.Core.Geometry.RTree$1.UpdateParent(parent);
                }
            }
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.RTree$1.TreeIsCorrect(this.get_RootNode()));
        },
        Clean: function (){
            this.set_RootNode(null);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$RTree$1);
var Microsoft$Msagl$Core$CancelToken = {
    fullname: "Microsoft.Msagl.Core.CancelToken",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.canceled = false;
            System.Object.ctor.call(this);
        },
        Canceled$$: "System.Boolean",
        get_Canceled: function (){
            return this.canceled;
        },
        set_Canceled: function (value){
            this.canceled = value;
        },
        ThrowIfCanceled: function (){
            if (this.get_Canceled())
                throw $CreateException(new System.OperationCanceledException.ctor(), new Error());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$CancelToken);
var Microsoft$Msagl$Core$Routing$EdgeRoutingMode = {
    fullname: "Microsoft.Msagl.Core.Routing.EdgeRoutingMode",
    staticDefinition: {
        Spline: 0,
        SplineBundling: 1,
        StraightLine: 2,
        SugiyamaSplines: 3,
        Rectilinear: 4,
        RectilinearToCenter: 5,
        None: 6
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Core$Routing$EdgeRoutingMode);
var Microsoft$Msagl$DebugHelpers$DebugShape = {
    fullname: "Microsoft.Msagl.DebugHelpers.DebugShape",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this._Pen = 0;
            this._Color = null;
            this._FillColor = null;
            System.Object.ctor.call(this);
        },
        Pen$$: "System.Int32",
        get_Pen: function (){
            return this._Pen;
        },
        set_Pen: function (value){
            this._Pen = value;
        },
        Color$$: "System.String",
        get_Color: function (){
            return this._Color;
        },
        set_Color: function (value){
            this._Color = value;
        },
        FillColor$$: "System.String",
        get_FillColor: function (){
            return this._FillColor;
        },
        set_FillColor: function (value){
            this._FillColor = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$DebugHelpers$DebugShape);
var Microsoft$Msagl$DebugHelpers$DebugEllipse = {
    fullname: "Microsoft.Msagl.DebugHelpers.DebugEllipse",
    baseTypeName: "Microsoft.Msagl.DebugHelpers.DebugShape",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this._Ellipse = null;
            Microsoft.Msagl.DebugHelpers.DebugShape.ctor.call(this);
        },
        Ellipse$$: "Microsoft.Msagl.Core.Geometry.Curves.Ellipse",
        get_Ellipse: function (){
            return this._Ellipse;
        },
        set_Ellipse: function (value){
            this._Ellipse = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$DebugHelpers$DebugEllipse);
var Microsoft$Msagl$Core$Layout$EdgeGeometry = {
    fullname: "Microsoft.Msagl.Core.Layout.EdgeGeometry",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.curve = null;
            this.smoothedPolyline = null;
            this.LayoutChangeEvent = null;
            this._SourceArrowhead = null;
            this._TargetArrowhead = null;
            this._SourcePort = null;
            this._TargetPort = null;
            this._Waypoints = null;
            this._LineWidth = 0;
            System.Object.ctor.call(this);
        },
        ctor$$Port$$Port: function (sourcePort, targetPort){
            this.curve = null;
            this.smoothedPolyline = null;
            this.LayoutChangeEvent = null;
            this._SourceArrowhead = null;
            this._TargetArrowhead = null;
            this._SourcePort = null;
            this._TargetPort = null;
            this._Waypoints = null;
            this._LineWidth = 0;
            System.Object.ctor.call(this);
            this.set_SourcePort(sourcePort);
            this.set_TargetPort(targetPort);
        },
        SourceArrowhead$$: "Microsoft.Msagl.Core.Layout.Arrowhead",
        get_SourceArrowhead: function (){
            return this._SourceArrowhead;
        },
        set_SourceArrowhead: function (value){
            this._SourceArrowhead = value;
        },
        TargetArrowhead$$: "Microsoft.Msagl.Core.Layout.Arrowhead",
        get_TargetArrowhead: function (){
            return this._TargetArrowhead;
        },
        set_TargetArrowhead: function (value){
            this._TargetArrowhead = value;
        },
        SourcePort$$: "Microsoft.Msagl.Core.Layout.Port",
        get_SourcePort: function (){
            return this._SourcePort;
        },
        set_SourcePort: function (value){
            this._SourcePort = value;
        },
        TargetPort$$: "Microsoft.Msagl.Core.Layout.Port",
        get_TargetPort: function (){
            return this._TargetPort;
        },
        set_TargetPort: function (value){
            this._TargetPort = value;
        },
        Waypoints$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Geometry.Point]]",
        get_Waypoints: function (){
            return this._Waypoints;
        },
        set_Waypoints: function (value){
            this._Waypoints = value;
        },
        HasWaypoints$$: "System.Boolean",
        get_HasWaypoints: function (){
            return (this.get_Waypoints() != null) && System.Linq.Enumerable.Any$1$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Point.ctor, this.get_Waypoints());
        },
        toString: function (){
            return System.String.Format$$IFormatProvider$$String$$Object$Array(System.Globalization.CultureInfo.get_InvariantCulture(), "{0}->{1}", [this.get_SourcePort().get_Location(), this.get_TargetPort().get_Location()]);
        },
        LineWidth$$: "System.Double",
        get_LineWidth: function (){
            return this._LineWidth;
        },
        set_LineWidth: function (value){
            this._LineWidth = value;
        },
        Curve$$: "Microsoft.Msagl.Core.Geometry.Curves.ICurve",
        get_Curve: function (){
            return this.curve;
        },
        set_Curve: function (value){
            this.RaiseLayoutChangeEvent(value);
            this.curve = value;
        },
        SmoothedPolyline$$: "Microsoft.Msagl.Core.Geometry.SmoothedPolyline",
        get_SmoothedPolyline: function (){
            return this.smoothedPolyline;
        },
        set_SmoothedPolyline: function (value){
            this.smoothedPolyline = value;
        },
        BoundingBox$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_BoundingBox: function (){
            var bBox = this.get_Curve().get_BoundingBox();
            if (this.get_SourceArrowhead() != null)
                bBox.Add$$Point(this.get_SourceArrowhead().get_TipPosition());
            if (this.get_TargetArrowhead() != null)
                bBox.Add$$Point(this.get_TargetArrowhead().get_TipPosition());
            var del = 0.5 * this.get_LineWidth();
            var delta = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-del, del);
            bBox.Add$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Addition(bBox.get_LeftTop(), delta));
            bBox.Add$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(bBox.get_RightBottom(), delta));
            return bBox;
        },
        SetSmoothedPolylineAndCurve: function (poly){
            this.set_SmoothedPolyline(poly);
            this.set_Curve(poly.CreateCurve());
        },
        Translate: function (delta){
            if (delta.get_X() == 0 && delta.get_Y() == 0)
                return;
            this.RaiseLayoutChangeEvent(delta);
            if (this.get_Curve() != null)
                this.get_Curve().Translate(delta);
            if (this.get_SmoothedPolyline() != null)
                for (var s = this.get_SmoothedPolyline().get_HeadSite(),s0 = this.get_SmoothedPolyline().get_HeadSite(); s != null; s = s.get_Next(), s0 = s0.get_Next())
                    s.set_Point(Microsoft.Msagl.Core.Geometry.Point.op_Addition(s0.get_Point(), delta));
            if (this.get_SourceArrowhead() != null)
                this.get_SourceArrowhead().set_TipPosition(Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.get_SourceArrowhead().get_TipPosition(), delta));
            if (this.get_TargetArrowhead() != null)
                this.get_TargetArrowhead().set_TipPosition(Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.get_TargetArrowhead().get_TipPosition(), delta));
        },
        GetMaxArrowheadLength: function (){
            var l = 0;
            if (this.get_SourceArrowhead() != null)
                l = this.get_SourceArrowhead().get_Length();
            if (this.get_TargetArrowhead() != null && this.get_TargetArrowhead().get_Length() > l)
                return this.get_TargetArrowhead().get_Length();
            return l;
        },
        add_LayoutChangeEvent: function (value){
            this.LayoutChangeEvent = $CombineDelegates(this.LayoutChangeEvent, value);
        },
        remove_LayoutChangeEvent: function (value){
            this.LayoutChangeEvent = $RemoveDelegate(this.LayoutChangeEvent, value);
        },
        RaiseLayoutChangeEvent: function (newValue){
            if (this.LayoutChangeEvent != null)
                this.LayoutChangeEvent(this, (function (){
                    var $v101 = new Microsoft.Msagl.Core.Layout.LayoutChangeEventArgs.ctor();
                    $v101.DataAfterChange = newValue;
                    return $v101;
                }).call(this));
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$EdgeGeometry);
var Microsoft$Msagl$Core$Layout$FloatingPort = {
    fullname: "Microsoft.Msagl.Core.Layout.FloatingPort",
    baseTypeName: "Microsoft.Msagl.Core.Layout.Port",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (curve, location){
            this.curve = null;
            this.location = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            Microsoft.Msagl.Core.Layout.Port.ctor.call(this);
            this.curve = curve;
            this.location = location;
        },
        Location$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Location: function (){
            return this.location;
        },
        Translate: function (delta){
            this.location = Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.location, delta);
        },
        Curve$$: "Microsoft.Msagl.Core.Geometry.Curves.ICurve",
        get_Curve: function (){
            return this.curve;
        },
        set_Curve: function (value){
            this.curve = value;
        },
        toString: function (){
            return this.get_Location().toString();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$FloatingPort);
var Microsoft$Msagl$Core$Layout$GeometryGraph = {
    fullname: "Microsoft.Msagl.Core.Layout.GeometryGraph",
    baseTypeName: "Microsoft.Msagl.Core.Layout.GeometryObject",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.nodes = null;
            this.edges = null;
            this.rootCluster = null;
            this.boundingBox = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
            this.margins = 0;
            this._MinimalWidth = 0;
            this._MinimalHeight = 0;
            this._LgData = null;
            Microsoft.Msagl.Core.Layout.GeometryObject.ctor.call(this);
            this.nodes = new Microsoft.Msagl.Core.Layout.NodeCollection.ctor(this);
            this.edges = new Microsoft.Msagl.Core.Layout.EdgeCollection.ctor(this);
            this.rootCluster = new Microsoft.Msagl.Core.Layout.Cluster.ctor();
        },
        RootCluster$$: "Microsoft.Msagl.Core.Layout.Cluster",
        get_RootCluster: function (){
            return this.rootCluster;
        },
        set_RootCluster: function (value){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(value, "value");
            this.rootCluster = value;
        },
        BoundingBox$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_BoundingBox: function (){
            return this.boundingBox;
        },
        set_BoundingBox: function (value){
            this.boundingBox = value;
        },
        Margins$$: "System.Double",
        get_Margins: function (){
            return this.margins;
        },
        set_Margins: function (value){
            this.margins = value;
        },
        Width$$: "System.Double",
        get_Width: function (){
            return this.get_BoundingBox().get_RightBottom().get_X() - this.get_BoundingBox().get_LeftTop().get_X();
        },
        Height$$: "System.Double",
        get_Height: function (){
            return this.get_BoundingBox().get_Height();
        },
        Left$$: "System.Double",
        get_Left: function (){
            return this.get_BoundingBox().get_Left();
        },
        Right$$: "System.Double",
        get_Right: function (){
            return this.get_BoundingBox().get_Right();
        },
        LeftBottom$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_LeftBottom: function (){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.get_BoundingBox().get_Left(), this.get_BoundingBox().get_Bottom());
        },
        RightTop$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_RightTop: function (){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.get_Right(), this.get_Top());
        },
        Bottom$$: "System.Double",
        get_Bottom: function (){
            return this.get_BoundingBox().get_Bottom();
        },
        Top$$: "System.Double",
        get_Top: function (){
            return this.get_BoundingBox().get_Bottom() + this.get_BoundingBox().get_Height();
        },
        Nodes$$: "System.Collections.Generic.IList`1[[Microsoft.Msagl.Core.Layout.Node]]",
        get_Nodes: function (){
            return this.nodes;
        },
        set_Nodes: function (value){
            this.nodes = value;
        },
        Edges$$: "Microsoft.Msagl.Core.Layout.EdgeCollection",
        get_Edges: function (){
            return this.edges;
        },
        set_Edges: function (value){
            this.edges = value;
        },
        CollectAllLabels: function (){
            return System.Linq.Enumerable.ToList$1(Microsoft.Msagl.Core.Layout.Label.ctor, System.Linq.Enumerable.SelectMany$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, Microsoft.Msagl.Core.Layout.Label.ctor, this.get_Edges(), $CreateAnonymousDelegate(this, function (e){
                return e.get_Labels();
            })));
        },
        Transform: function (matrix){
            var $it721 = this.get_Nodes().GetEnumerator();
            while ($it721.MoveNext()){
                var node = $it721.get_Current();
                node.Transform(matrix);
            }
            var $it722 = this.get_Edges().GetEnumerator();
            while ($it722.MoveNext()){
                var edge = $it722.get_Current();
                edge.Transform(matrix);
            }
            this.UpdateBoundingBox();
        },
        PumpTheBoxToTheGraphWithMargins: function (){
            var b = Microsoft.Msagl.Core.Geometry.Rectangle.CreateAnEmptyBox();
            (function (){
                var $1 = {
                    Value: b
                };
                var $res = this.PumpTheBoxToTheGraph($1);
                b = $1.Value;
                return $res;
            }).call(this);
            var del = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.get_Margins(), -this.get_Margins());
            b.set_RightBottom(Microsoft.Msagl.Core.Geometry.Point.op_Addition(b.get_RightBottom(), del));
            b.set_LeftTop(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b.get_LeftTop(), del));
            b.set_Width(System.Math.Max$$Double$$Double(b.get_Width(), this.get_MinimalWidth()));
            b.set_Height(System.Math.Max$$Double$$Double(b.get_Height(), this.get_MinimalHeight()));
            return b;
        },
        MinimalWidth$$: "System.Double",
        get_MinimalWidth: function (){
            return this._MinimalWidth;
        },
        set_MinimalWidth: function (value){
            this._MinimalWidth = value;
        },
        MinimalHeight$$: "System.Double",
        get_MinimalHeight: function (){
            return this._MinimalHeight;
        },
        set_MinimalHeight: function (value){
            this._MinimalHeight = value;
        },
        PumpTheBoxToTheGraph: function (b){
            var $it723 = this.get_Edges().GetEnumerator();
            while ($it723.MoveNext()){
                var e = $it723.get_Current();
                if (e.UnderCollapsedCluster())
                    continue;
                if (e.get_Curve() != null){
                    var cb = e.get_Curve().get_BoundingBox();
                    cb.Pad$$Double(e.get_LineWidth());
                    b.Value.Add$$Rectangle(cb);
                }
                var $it724 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Label.ctor, e.get_Labels(), $CreateAnonymousDelegate(this, function (lbl){
                    return lbl != null;
                })).GetEnumerator();
                while ($it724.MoveNext()){
                    var l = $it724.get_Current();
                    b.Value.Add$$Rectangle(l.get_BoundingBox());
                }
            }
            var $it725 = this.get_Nodes().GetEnumerator();
            while ($it725.MoveNext()){
                var n = $it725.get_Current();
                if (n.UnderCollapsedCluster())
                    continue;
                b.Value.Add$$Rectangle(n.get_BoundingBox());
            }
            var $it726 = this.get_RootCluster().get_Clusters().GetEnumerator();
            while ($it726.MoveNext()){
                var c = $it726.get_Current();
                if (c.get_BoundaryCurve() == null){
                    if (c.get_RectangularBoundary() != null)
                        c.set_BoundaryCurve(c.get_RectangularBoundary().RectangularHull());
                }
                if (c.get_BoundaryCurve() != null)
                    b.Value.Add$$Rectangle(c.get_BoundaryCurve().get_BoundingBox());
            }
        },
        Translate: function (delta){
            var nodeSet = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Node.ctor, this.get_Nodes());
            var $it727 = this.get_Nodes().GetEnumerator();
            while ($it727.MoveNext()){
                var v = $it727.get_Current();
                v.set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Addition(v.get_Center(), delta));
            }
            var $it728 = this.get_RootCluster().AllClustersDepthFirstExcludingSelf().GetEnumerator();
            while ($it728.MoveNext()){
                var cluster = $it728.get_Current();
                var $it729 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Node.ctor, cluster.get_Nodes(), $CreateAnonymousDelegate(this, function (n){
                    return !nodeSet.Contains$$T(n);
                })).GetEnumerator();
                while ($it729.MoveNext()){
                    var node = $it729.get_Current();
                    node.set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Addition(node.get_Center(), delta));
                }
                cluster.set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Addition(cluster.get_Center(), delta));
                cluster.get_RectangularBoundary().TranslateRectangle(delta);
            }
            var $it730 = this.edges.GetEnumerator();
            while ($it730.MoveNext()){
                var e = $it730.get_Current();
                e.Translate(delta);
            }
            this.set_BoundingBox(new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Double$$Double$$Point(this.get_BoundingBox().get_Left() + delta.get_X(), this.get_BoundingBox().get_Bottom() + delta.get_Y(), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.get_BoundingBox().get_Width(), this.get_BoundingBox().get_Height())));
        },
        UpdateBoundingBox: function (){
            this.set_BoundingBox(this.PumpTheBoxToTheGraphWithMargins());
        },
        GetFlattenedNodesAndClusters: function (){
            var $yield = [];
            var $it731 = this.get_Nodes().GetEnumerator();
            while ($it731.MoveNext()){
                var v = $it731.get_Current();
                $yield.push(v);
            }
            var $it732 = this.get_RootCluster().AllClustersDepthFirst().GetEnumerator();
            while ($it732.MoveNext()){
                var cluster = $it732.get_Current();
                if (cluster != this.get_RootCluster()){
                    $yield.push(cluster);
                }
            }
            return $yield;
        },
        FindNodeByUserData: function (userData){
            return System.Linq.Enumerable.FirstOrDefault$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Node.ctor, this.get_Nodes(), $CreateAnonymousDelegate(this, function (n){
                return n.get_UserData().Equals$$Object(userData);
            }));
        },
        LgData$$: "Microsoft.Msagl.Layout.LargeGraphLayout.LgData",
        get_LgData: function (){
            return this._LgData;
        },
        set_LgData: function (value){
            this._LgData = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$GeometryGraph);
var Microsoft$Msagl$Core$Layout$GeometryObject = {
    fullname: "Microsoft.Msagl.Core.Layout.GeometryObject",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.geometryParent = null;
            this.AlgorithmData = null;
            this.beforeLayoutChangeEvent = null;
            this.BeforeLayoutChangeEvent = null;
            this._UserData = null;
            this._BoundingBox = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
            System.Object.ctor.call(this);
        },
        GeometryParent$$: "Microsoft.Msagl.Core.Layout.GeometryObject",
        get_GeometryParent: function (){
            return this.geometryParent;
        },
        set_GeometryParent: function (value){
            this.geometryParent = value;
        },
        UserData$$: "System.Object",
        get_UserData: function (){
            return this._UserData;
        },
        set_UserData: function (value){
            this._UserData = value;
        },
        add_beforeLayoutChangeEvent: function (value){
            this.beforeLayoutChangeEvent = $CombineDelegates(this.beforeLayoutChangeEvent, value);
        },
        remove_beforeLayoutChangeEvent: function (value){
            this.beforeLayoutChangeEvent = $RemoveDelegate(this.beforeLayoutChangeEvent, value);
        },
        add_BeforeLayoutChangeEvent: function (value){
            this.add_beforeLayoutChangeEvent(value);
        },
        remove_BeforeLayoutChangeEvent: function (value){
            this.remove_beforeLayoutChangeEvent(value);
        },
        BoundingBox$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_BoundingBox: function (){
            return this._BoundingBox;
        },
        set_BoundingBox: function (value){
            this._BoundingBox = value;
        },
        RaiseLayoutChangeEvent: function (newValue){
            if (this.beforeLayoutChangeEvent != null)
                this.beforeLayoutChangeEvent(this, (function (){
                    var $v102 = new Microsoft.Msagl.Core.Layout.LayoutChangeEventArgs.ctor();
                    $v102.DataAfterChange = newValue;
                    return $v102;
                }).call(this));
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$GeometryObject);
var Microsoft$Msagl$Core$DataStructures$GenericHeapElement$1 = {
    fullname: "Microsoft.Msagl.Core.DataStructures.GenericHeapElement$1",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (T, index, priority, v){
            this.T = T;
            this.indexToA = 0;
            this.priority = 0;
            this.v = null;
            System.Object.ctor.call(this);
            this.indexToA = index;
            this.priority = priority;
            this.v = v;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$DataStructures$GenericHeapElement$1);
var Microsoft$Msagl$Core$DataStructures$HeapElem = {
    fullname: "Microsoft.Msagl.Core.DataStructures.HeapElem",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (index, priority, v){
            this.indexToA = 0;
            this.priority = 0;
            this.v = 0;
            System.Object.ctor.call(this);
            this.indexToA = index;
            this.priority = priority;
            this.v = v;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$DataStructures$HeapElem);
var Microsoft$Msagl$Layout$Layered$HorizontalConstraintsForSugiyama = {
    fullname: "Microsoft.Msagl.Layout.Layered.HorizontalConstraintsForSugiyama",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.leftRightConstraints = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(System.Tuple$2.ctor);
            this.leftRightNeighbors = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(System.Tuple$2.ctor);
            this.nodeToBlockRoot = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, System.Int32.ctor);
            this.upDownVerticalConstraints = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(System.Tuple$2.ctor);
            this.BlockRootToBlock = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, System.Collections.Generic.List$1.ctor);
            this.LeftRighInts = null;
            this.LeftRightIntNeibs = null;
            this.VerticalInts = null;
            this.nodeIdToIndex = null;
            System.Object.ctor.call(this);
        },
        LeftRightNeighbors$$: "Microsoft.Msagl.Core.DataStructures.Set`1[[System.Tuple`2[[Microsoft.Msagl.Core.Layout.Node],[Microsoft.Msagl.Core.Layout.Node]]]]",
        get_LeftRightNeighbors: function (){
            return this.leftRightNeighbors;
        },
        UpDownVerticalConstraints$$: "Microsoft.Msagl.Core.DataStructures.Set`1[[System.Tuple`2[[Microsoft.Msagl.Core.Layout.Node],[Microsoft.Msagl.Core.Layout.Node]]]]",
        get_UpDownVerticalConstraints: function (){
            return this.upDownVerticalConstraints;
        },
        LeftRightConstraints$$: "Microsoft.Msagl.Core.DataStructures.Set`1[[System.Tuple`2[[Microsoft.Msagl.Core.Layout.Node],[Microsoft.Msagl.Core.Layout.Node]]]]",
        get_LeftRightConstraints: function (){
            return this.leftRightConstraints;
        },
        IsEmpty$$: "System.Boolean",
        get_IsEmpty: function (){
            return this.get_LeftRightNeighbors().get_Count() == 0 && this.get_UpDownVerticalConstraints().get_Count() == 0 && this.get_LeftRightConstraints().get_Count() == 0;
        },
        Clear: function (){
        },
        AddSameLayerNeighbors: function (neighbors){
            for (var i = 0; i < neighbors.get_Count() - 1; i++)
                this.AddSameLayerNeighborsPair(neighbors.get_Item$$Int32(i), neighbors.get_Item$$Int32(i + 1));
        },
        AddSameLayerNeighborsPair: function (leftNode, rightNode){
            this.get_LeftRightNeighbors().Insert(new System.Tuple$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Layout.Node.ctor, leftNode, rightNode));
        },
        NodeToBlockRootSoft: function (i){
            var blockRoot;
            if ((function (){
                var $1 = {
                    Value: blockRoot
                };
                var $res = this.nodeToBlockRoot.TryGetValue(i, $1);
                blockRoot = $1.Value;
                return $res;
            }).call(this))
                return blockRoot;
            return i;
        },
        CreateMappingOfNeibBlocks: function (){
            var graph = this.BasicGraphFromLeftRightIntNeibs();
            for (var root = 0; root < graph.get_NodeCount(); root++)
                if (graph.InEdges(root).get_Count() == 0 && !this.nodeToBlockRoot.ContainsKey(root)){
                    var block = new System.Collections.Generic.List$1.ctor(System.Int32.ctor);
                    var current = root;
                    for (var outEdges = graph.OutEdges(current); outEdges.get_Count() > 0; outEdges = graph.OutEdges(current)){
                        current = outEdges.get_Item$$Int32(0).get_Second();
                        block.Add(current);
                        this.nodeToBlockRoot.set_Item$$TKey(current, root);
                    }
                    if (block.get_Count() > 0)
                        this.BlockRootToBlock.set_Item$$TKey(root, block);
                }
        },
        BasicGraphFromLeftRightIntNeibs: function (){
            return new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.Tuple$2.ctor, Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, this.LeftRightIntNeibs, $CreateAnonymousDelegate(this, function (p){
                return new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(p.get_Item1(), p.get_Item2());
            })));
        },
        NodeIndex: function (node){
            var index;
            if ((function (){
                var $1 = {
                    Value: index
                };
                var $res = this.nodeIdToIndex.TryGetValue(node, $1);
                index = $1.Value;
                return $res;
            }).call(this))
                return index;
            return -1;
        },
        PrepareForOrdering: function (nodeToIndexParameter, yLayers){
            this.nodeIdToIndex = nodeToIndexParameter;
            this.MapNodesToToIntegers(yLayers);
            this.CreateMappingOfNeibBlocks();
            this.LiftLeftRightRelationsToNeibBlocks();
        },
        LiftLeftRightRelationsToNeibBlocks: function (){
            this.LeftRighInts = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(System.Tuple$2.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(null, System.Tuple$2.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(null, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(null, null, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(null, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.Tuple$2.ctor, null, this.leftRightConstraints, $CreateAnonymousDelegate(this, function (p){
                return $CreateAnonymousObject({
                    p: p,
                    ip: new System.Tuple$2.ctor(System.Int32.ctor, System.Int32.ctor, this.NodeIndex(p.get_Item1()), this.NodeIndex(p.get_Item2()))
                });
            })), $CreateAnonymousDelegate(this, function ($$x0){
                return $$x0.get_ip().get_Item1() != -1 && $$x0.get_ip().get_Item2() != -1;
            })), $CreateAnonymousDelegate(this, function ($$x1){
                return $CreateAnonymousObject({
                    $$x1: $$x1,
                    ipb: new System.Tuple$2.ctor(System.Int32.ctor, System.Int32.ctor, this.NodeToBlockRootSoft($$x1.get_ip().get_Item1()), this.NodeToBlockRootSoft($$x1.get_ip().get_Item2()))
                });
            })), $CreateAnonymousDelegate(this, function ($$x2){
                return $$x2.get_ipb().get_Item1() != $$x2.get_ipb().get_Item2();
            })), $CreateAnonymousDelegate(this, function ($$x3){
                return $$x3.get_ipb();
            })));
            var feedbackSet = Microsoft.Msagl.Core.GraphAlgorithms.CycleRemoval$1.GetFeedbackSet(new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.Tuple$2.ctor, Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, this.LeftRighInts, $CreateAnonymousDelegate(this, function (p){
                return new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(p.get_Item1(), p.get_Item2());
            }))));
            var $it733 = feedbackSet.GetEnumerator();
            while ($it733.MoveNext()){
                var ip = $it733.get_Current();
                this.LeftRighInts.Remove(new System.Tuple$2.ctor(System.Int32.ctor, System.Int32.ctor, ip.get_First(), ip.get_Second()));
            }
        },
        MapNodesToToIntegers: function (yLayers){
            this.LeftRightIntNeibs = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(System.Tuple$2.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(null, System.Tuple$2.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(null, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(null, null, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(null, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.Tuple$2.ctor, null, this.get_LeftRightNeighbors(), $CreateAnonymousDelegate(this, function (p){
                return $CreateAnonymousObject({
                    p: p,
                    left: this.NodeIndex(p.get_Item1())
                });
            })), $CreateAnonymousDelegate(this, function ($$x4){
                return $$x4.get_left() != -1;
            })), $CreateAnonymousDelegate(this, function ($$x5){
                return $CreateAnonymousObject({
                    $$x5: $$x5,
                    right: this.NodeIndex($$x5.get_p().get_Item2())
                });
            })), $CreateAnonymousDelegate(this, function ($$x6){
                return $$x6.get_right() != -1;
            })), $CreateAnonymousDelegate(this, function ($$x7){
                return new System.Tuple$2.ctor(System.Int32.ctor, System.Int32.ctor, $$x7.get_$$x5().get_left(), $$x7.get_right());
            })));
            this.VerticalInts = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(System.Tuple$2.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(null, System.Tuple$2.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(null, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(null, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(null, null, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(null, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.Tuple$2.ctor, null, this.get_UpDownVerticalConstraints(), $CreateAnonymousDelegate(this, function (p){
                return $CreateAnonymousObject({
                    p: p,
                    upper: this.NodeIndex(p.get_Item1())
                });
            })), $CreateAnonymousDelegate(this, function ($$x8){
                return $$x8.get_upper() != -1;
            })), $CreateAnonymousDelegate(this, function ($$x9){
                return $CreateAnonymousObject({
                    $$x9: $$x9,
                    lower: this.NodeIndex($$x9.get_p().get_Item2())
                });
            })), $CreateAnonymousDelegate(this, function ($$x10){
                return $$x10.get_lower() != -1;
            })), $CreateAnonymousDelegate(this, function ($$x11){
                return yLayers[$$x11.get_$$x9().get_upper()] > yLayers[$$x11.get_lower()];
            })), $CreateAnonymousDelegate(this, function ($$x12){
                return new System.Tuple$2.ctor(System.Int32.ctor, System.Int32.ctor, $$x12.get_$$x9().get_upper(), $$x12.get_lower());
            })));
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$HorizontalConstraintsForSugiyama);
var Microsoft$Msagl$Core$GraphAlgorithms$IEdge = {
    fullname: "Microsoft.Msagl.Core.GraphAlgorithms.IEdge",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Interface"
};
JsTypes.push(Microsoft$Msagl$Core$GraphAlgorithms$IEdge);
var Microsoft$Msagl$Core$Layout$ILabeledObject = {
    fullname: "Microsoft.Msagl.Core.Layout.ILabeledObject",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Interface"
};
JsTypes.push(Microsoft$Msagl$Core$Layout$ILabeledObject);
var Microsoft$Msagl$Core$DataStructures$GenericBinaryHeapPriorityQueue$1 = {
    fullname: "Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueue$1",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (T){
            Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueue$1.InitialHeapCapacity = 16;
        },
        Test: function (){
            var q = new Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueue$1.ctor(System.Int32.ctor);
            q.Enqueue(2, 2);
            q.Enqueue(1, 1);
            q.Enqueue(9, 9);
            q.Enqueue(8, 8);
            q.Enqueue(5, 5);
            q.Enqueue(3, 3);
            q.Enqueue(4, 4);
            q.Enqueue(7, 7);
            q.Enqueue(6, 6);
            q.Enqueue(0, 0);
            q.DecreasePriority(4, 2.5);
            while (q.IsEmpty() == false)
                System.Console.WriteLine$$Int32(q.Dequeue());
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IEnumerable$1"],
    Kind: "Class",
    definition: {
        ctor: function (T){
            this.T = T;
            this.A = null;
            this.cache = null;
            this.heapSize = 0;
            System.Object.ctor.call(this);
            this.cache = new System.Collections.Generic.Dictionary$2.ctor(this.T, Microsoft.Msagl.Core.DataStructures.GenericHeapElement$1.ctor);
            this.A = new Array(17);
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this.heapSize;
        },
        ContainsElement: function (key){
            return this.cache.ContainsKey(key);
        },
        SwapWithParent: function (i){
            var parent = this.A[i >> 1];
            this.PutAtI(i >> 1, this.A[i]);
            this.PutAtI(i, parent);
        },
        Enqueue: function (element, priority){
            if (this.heapSize == this.A.length - 1){
                var newA = new Array(this.A.length * 2);
                System.Array.Copy(this.A, 1, newA, 1, this.heapSize);
                this.A = newA;
            }
            this.heapSize++;
            var i = this.heapSize;
            var h;
            this.A[i] = (function ($p39){
                this.cache.set_Item$$TKey(element, $p39);
                return $p39;
            }).call(this, h = new Microsoft.Msagl.Core.DataStructures.GenericHeapElement$1.ctor(this.T, i, priority, element));
            while (i > 1 && this.A[i >> 1].priority.CompareTo$$Double(priority) > 0){
                this.SwapWithParent(i);
                i >>= 1;
            }
        },
        IsEmpty: function (){
            return this.heapSize == 0;
        },
        PutAtI: function (i, h){
            this.A[i] = h;
            h.indexToA = i;
        },
        Dequeue: function (){
            if (this.heapSize == 0)
                throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            var ret = this.A[1].v;
            this.MoveQueueOneStepForward(ret);
            return ret;
        },
        Dequeue$$Double: function (priority){
            if (this.heapSize == 0)
                throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            var ret = this.A[1].v;
            priority.Value = this.A[1].priority;
            this.MoveQueueOneStepForward(ret);
            return ret;
        },
        MoveQueueOneStepForward: function (ret){
            this.cache.Remove(ret);
            this.PutAtI(1, this.A[this.heapSize]);
            var i = 1;
            while (true){
                var smallest = i;
                var l = i << 1;
                if (l <= this.heapSize && this.A[l].priority.CompareTo$$Double(this.A[i].priority) < 0)
                    smallest = l;
                var r = l + 1;
                if (r <= this.heapSize && this.A[r].priority.CompareTo$$Double(this.A[smallest].priority) < 0)
                    smallest = r;
                if (smallest != i)
                    this.SwapWithParent(smallest);
                else
                    break;
                i = smallest;
            }
            this.heapSize--;
        },
        DecreasePriority: function (element, newPriority){
            var h;
            if (!(function (){
                var $1 = {
                    Value: h
                };
                var $res = this.cache.TryGetValue(element, $1);
                h = $1.Value;
                return $res;
            }).call(this))
                return;
            h.priority = newPriority;
            var i = h.indexToA;
            while (i > 1){
                if (this.A[i].priority.CompareTo$$Double(this.A[i >> 1].priority) < 0)
                    this.SwapWithParent(i);
                else
                    break;
                i >>= 1;
            }
        },
        GetEnumerator: function (){
            var $yield = [];
            for (var i = 1; i <= this.heapSize; i++)
                $yield.push(this.A[i].v);
            return $yield.GetEnumerator();
        },
        Peek: function (priority){
            if (this.get_Count() == 0){
                priority.Value = 0;
                return Default(this.T);
            }
            priority.Value = this.A[1].priority;
            return this.A[1].v;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$DataStructures$GenericBinaryHeapPriorityQueue$1);
var Microsoft$Msagl$Core$Layout$Label = {
    fullname: "Microsoft.Msagl.Core.Layout.Label",
    baseTypeName: "Microsoft.Msagl.Core.Layout.GeometryObject",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$Double$$Double$$GeometryObject: function (labelWidth, labelHeight, parentP){
            this.boundingBox = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
            this.attachmentSegmentStart = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.edgeAttachmentPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.placementStrategyPriority = [Microsoft.Msagl.Core.Layout.Label.PlacementStrategy.Horizontal, Microsoft.Msagl.Core.Layout.Label.PlacementStrategy.AlongCurve];
            this.placementOffset = 0.5;
            this._Side = Microsoft.Msagl.Core.Layout.Label.PlacementSide.Any;
            this._InnerPoints = null;
            this._OuterPoints = null;
            this._PlacementResult = Microsoft.Msagl.Core.Layout.LabelPlacementResult.OverlapsOtherLabels;
            Microsoft.Msagl.Core.Layout.GeometryObject.ctor.call(this);
            this.set_Width(labelWidth);
            this.set_Height(labelHeight);
            this.set_GeometryParent(parentP);
            this.set_PlacementStrategyPriority([Microsoft.Msagl.Core.Layout.Label.PlacementStrategy.AlongCurve, Microsoft.Msagl.Core.Layout.Label.PlacementStrategy.Horizontal]);
        },
        Center$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Center: function (){
            return this.boundingBox.get_Center();
        },
        set_Center: function (value){
            this.RaiseLayoutChangeEvent(value);
            this.boundingBox.set_Center(value);
        },
        Width$$: "System.Double",
        get_Width: function (){
            return this.boundingBox.get_Width();
        },
        set_Width: function (value){
            this.RaiseLayoutChangeEvent(value);
            this.boundingBox.set_Width(value);
        },
        Height$$: "System.Double",
        get_Height: function (){
            return this.boundingBox.get_Height();
        },
        set_Height: function (value){
            this.RaiseLayoutChangeEvent(value);
            this.boundingBox.set_Height(value);
        },
        ctor: function (){
            this.boundingBox = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
            this.attachmentSegmentStart = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.edgeAttachmentPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.placementStrategyPriority = [Microsoft.Msagl.Core.Layout.Label.PlacementStrategy.Horizontal, Microsoft.Msagl.Core.Layout.Label.PlacementStrategy.AlongCurve];
            this.placementOffset = 0.5;
            this._Side = Microsoft.Msagl.Core.Layout.Label.PlacementSide.Any;
            this._InnerPoints = null;
            this._OuterPoints = null;
            this._PlacementResult = Microsoft.Msagl.Core.Layout.LabelPlacementResult.OverlapsOtherLabels;
            Microsoft.Msagl.Core.Layout.GeometryObject.ctor.call(this);
        },
        BoundingBox$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_BoundingBox: function (){
            return this.boundingBox;
        },
        set_BoundingBox: function (value){
            this.RaiseLayoutChangeEvent(value);
            this.boundingBox = value;
        },
        ctor$$GeometryObject: function (parentPar){
            this.boundingBox = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
            this.attachmentSegmentStart = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.edgeAttachmentPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.placementStrategyPriority = [Microsoft.Msagl.Core.Layout.Label.PlacementStrategy.Horizontal, Microsoft.Msagl.Core.Layout.Label.PlacementStrategy.AlongCurve];
            this.placementOffset = 0.5;
            this._Side = Microsoft.Msagl.Core.Layout.Label.PlacementSide.Any;
            this._InnerPoints = null;
            this._OuterPoints = null;
            this._PlacementResult = Microsoft.Msagl.Core.Layout.LabelPlacementResult.OverlapsOtherLabels;
            Microsoft.Msagl.Core.Layout.GeometryObject.ctor.call(this);
            this.set_GeometryParent(parentPar);
        },
        CreateBoundary: function (){
            var w = this.get_Width() / 2;
            var h = this.get_Height() / 2;
            var curve = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor();
            Microsoft.Msagl.Core.Geometry.Curves.Curve.AddLineSegment$$Curve$$Double$$Double$$Double$$Double(curve, this.get_Center().get_X() - w, this.get_Center().get_Y() - h, this.get_Center().get_X() - w, this.get_Center().get_Y() + h);
            Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Double$$Double(curve, this.get_Center().get_X() + w, this.get_Center().get_Y() + h);
            Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Double$$Double(curve, this.get_Center().get_X() + w, this.get_Center().get_Y() - h);
            Microsoft.Msagl.Core.Geometry.Curves.Curve.CloseCurve(curve);
            return curve;
        },
        AttachmentSegmentStart$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_AttachmentSegmentStart: function (){
            return this.attachmentSegmentStart;
        },
        set_AttachmentSegmentStart: function (value){
            this.RaiseLayoutChangeEvent(value);
            this.attachmentSegmentStart = value;
        },
        AttachmentSegmentEnd$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_AttachmentSegmentEnd: function (){
            return this.edgeAttachmentPoint;
        },
        set_AttachmentSegmentEnd: function (value){
            if (value.get_X() == 0)
                System.Console.WriteLine();
            this.RaiseLayoutChangeEvent(value);
            this.edgeAttachmentPoint = value;
        },
        PlacementOffset$$: "System.Double",
        get_PlacementOffset: function (){
            return this.placementOffset;
        },
        set_PlacementOffset: function (value){
            this.placementOffset = value;
        },
        Side$$: "Microsoft.Msagl.Core.Layout.Label+PlacementSide",
        get_Side: function (){
            return this._Side;
        },
        set_Side: function (value){
            this._Side = value;
        },
        PlacementStrategyPriority$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Layout.Label+PlacementStrategy]]",
        get_PlacementStrategyPriority: function (){
            return this.placementStrategyPriority;
        },
        set_PlacementStrategyPriority: function (value){
            this.placementStrategyPriority = value;
        },
        InnerPoints$$: "System.Collections.Generic.IList`1[[Microsoft.Msagl.Core.Geometry.Point]]",
        get_InnerPoints: function (){
            return this._InnerPoints;
        },
        set_InnerPoints: function (value){
            this._InnerPoints = value;
        },
        OuterPoints$$: "System.Collections.Generic.IList`1[[Microsoft.Msagl.Core.Geometry.Point]]",
        get_OuterPoints: function (){
            return this._OuterPoints;
        },
        set_OuterPoints: function (value){
            this._OuterPoints = value;
        },
        PlacementResult$$: "Microsoft.Msagl.Core.Layout.LabelPlacementResult",
        get_PlacementResult: function (){
            return this._PlacementResult;
        },
        set_PlacementResult: function (value){
            this._PlacementResult = value;
        },
        Translate: function (delta){
            this.RaiseLayoutChangeEvent(delta);
            if (this.get_InnerPoints() != null){
                for (var i = 0; i < this.get_InnerPoints().get_Count(); ++i){
                    this.get_InnerPoints().set_Item$$Int32(i, Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.get_InnerPoints().get_Item$$Int32(i), delta));
                }
            }
            if (this.get_OuterPoints() != null){
                for (var i = 0; i < this.get_OuterPoints().get_Count(); ++i){
                    this.get_OuterPoints().set_Item$$Int32(i, Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.get_OuterPoints().get_Item$$Int32(i), delta));
                }
            }
            this.boundingBox = Microsoft.Msagl.Core.Geometry.Rectangle.Translate(this.boundingBox, delta);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$Label);
var Microsoft$Msagl$Core$Layout$Label$PlacementSide = {
    fullname: "Microsoft.Msagl.Core.Layout.Label.PlacementSide",
    staticDefinition: {
        Any: 0,
        Port: 1,
        Starboard: 2,
        Top: 3,
        Bottom: 4,
        Left: 5,
        Right: 6
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Core$Layout$Label$PlacementSide);
var Microsoft$Msagl$Core$Layout$Label$PlacementStrategy = {
    fullname: "Microsoft.Msagl.Core.Layout.Label.PlacementStrategy",
    staticDefinition: {
        AlongCurve: 0,
        Horizontal: 1
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Core$Layout$Label$PlacementStrategy);
var Microsoft$Msagl$Core$Layout$MultiLocationFloatingPort = {
    fullname: "Microsoft.Msagl.Core.Layout.MultiLocationFloatingPort",
    baseTypeName: "Microsoft.Msagl.Core.Layout.RelativeFloatingPort",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (curveDelegate, centerDelegate, possibleOffsets){
            this.PossibleOffsets = null;
            this._ActiveOffsetIndex = 0;
            Microsoft.Msagl.Core.Layout.RelativeFloatingPort.ctor$$Func$1$ICurve$$Func$1$Point.call(this, curveDelegate, centerDelegate);
            this.PossibleOffsets = possibleOffsets;
        },
        LocationOffsets$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Geometry.Point]]",
        get_LocationOffsets: function (){
            return this.PossibleOffsets;
        },
        ActiveOffsetIndex$$: "System.Int32",
        get_ActiveOffsetIndex: function (){
            return this._ActiveOffsetIndex;
        },
        set_ActiveOffsetIndex: function (value){
            this._ActiveOffsetIndex = value;
        },
        LocationOffset$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_LocationOffset: function (){
            return this.PossibleOffsets.get_Item$$Int32(this.get_ActiveOffsetIndex());
        },
        SetClosestLocation: function (point){
            this.set_ActiveOffsetIndex(0);
            var mind = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(point, this.get_Location())).get_LengthSquared();
            var n = this.PossibleOffsets.get_Count();
            for (var i = 1; i < n; ++i){
                var p = Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.PossibleOffsets.get_Item$$Int32(i), this.get_CenterDelegate()());
                var d = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(point, p)).get_LengthSquared();
                if (d < mind){
                    mind = d;
                    this.set_ActiveOffsetIndex(i);
                }
            }
        },
        toString: function (){
            var builder = new System.Text.StringBuilder.ctor();
            builder.Append$$Object(this.get_CenterDelegate()());
            builder.Append$$String(" [");
            var first = false;
            var $it734 = this.get_LocationOffsets().GetEnumerator();
            while ($it734.MoveNext()){
                var p = $it734.get_Current();
                if (first){
                    builder.Append$$String(", ");
                    first = false;
                }
                builder.Append$$String(p.toString());
            }
            builder.Append$$String("]");
            return builder.toString();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$MultiLocationFloatingPort);
var Microsoft$Msagl$Layout$Layered$NetworkEdge = {
    fullname: "Microsoft.Msagl.Layout.Layered.NetworkEdge",
    baseTypeName: "Microsoft.Msagl.Layout.Layered.IntEdge",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Layout.Layered.NetworkEdge.Infinity = 2147483647;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (e){
            this.inTree = false;
            this.cut = 2147483647;
            Microsoft.Msagl.Layout.Layered.IntEdge.ctor$$Int32$$Int32.call(this, e.get_Source(), e.get_Target());
            this.set_Weight(e.get_Weight());
            this.set_Separation(e.get_Separation());
        },
        Cut$$: "System.Int32",
        get_Cut: function (){
            return this.cut;
        },
        set_Cut: function (value){
            this.cut = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$NetworkEdge);
var Microsoft$Msagl$Layout$Layered$NetworkSimplexForGeneralGraph = {
    fullname: "Microsoft.Msagl.Layout.Layered.NetworkSimplexForGeneralGraph",
    baseTypeName: "System.Object",
    staticDefinition: {
        GetMapsToComponent: function (comps){
            var ret = new System.Collections.Generic.List$1.ctor(System.Collections.Generic.Dictionary$2.ctor);
            var $it736 = comps.GetEnumerator();
            while ($it736.MoveNext()){
                var comp = $it736.get_Current();
                ret.Add(Microsoft.Msagl.Layout.Layered.NetworkSimplexForGeneralGraph.MapForComp(comp));
            }
            return ret;
        },
        MapForComp: function (comp){
            var i = 0;
            var map = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, System.Int32.ctor);
            var $it737 = comp.GetEnumerator();
            while ($it737.MoveNext()){
                var v = $it737.get_Current();
                map.set_Item$$TKey(v, i++);
            }
            return map;
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Layout.Layered.LayerCalculator"],
    Kind: "Class",
    definition: {
        ctor: function (graph, cancelObject){
            this.graph = null;
            this._Cancel = null;
            System.Object.ctor.call(this);
            this.graph = graph;
            this.set_Cancel(cancelObject);
        },
        Cancel$$: "Microsoft.Msagl.Core.CancelToken",
        get_Cancel: function (){
            return this._Cancel;
        },
        set_Cancel: function (value){
            this._Cancel = value;
        },
        GetLayers: function (){
            var comps = new System.Collections.Generic.List$1.ctor$$IEnumerable$1(System.Collections.Generic.IEnumerable$1.ctor, Microsoft.Msagl.Core.GraphAlgorithms.ConnectedComponentCalculator$1.GetComponents(this.graph));
            if (comps.get_Count() == 1){
                var ns = new Microsoft.Msagl.Layout.Layered.NetworkSimplex.ctor(this.graph, this.get_Cancel());
                return ns.GetLayers();
            }
            var mapToComponenents = Microsoft.Msagl.Layout.Layered.NetworkSimplexForGeneralGraph.GetMapsToComponent(comps);
            var layerings = new Array(comps.get_Count());
            for (var i = 0; i < comps.get_Count(); i++){
                var shrunkedComp = this.ShrunkComponent(mapToComponenents.get_Item$$Int32(i));
                var ns = new Microsoft.Msagl.Layout.Layered.NetworkSimplex.ctor(shrunkedComp, this.get_Cancel());
                layerings[i] = ns.GetLayers();
            }
            return this.UniteLayerings(layerings, mapToComponenents);
        },
        ShrunkComponent: function (dictionary){
            return new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$2.ctor$$IEnumerable$1$$Int32(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Layout.Layered.IntEdge.ctor, System.Linq.Enumerable.SelectMany$3$$IEnumerable$1$$Func$2$$Func$3(null, Microsoft.Msagl.Layout.Layered.IntEdge.ctor, Microsoft.Msagl.Layout.Layered.IntEdge.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(null, null, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.Collections.Generic.KeyValuePair$2.ctor, null, dictionary, $CreateAnonymousDelegate(this, function (p){
                return $CreateAnonymousObject({
                    p: p,
                    v: p.get_Key()
                });
            })), $CreateAnonymousDelegate(this, function ($$x0){
                return $CreateAnonymousObject({
                    $$x0: $$x0,
                    newEdgeSource: $$x0.get_p().get_Value()
                });
            })), $CreateAnonymousDelegate(this, function ($$x1){
                return this.graph.OutEdges($$x1.get_$$x0().get_v());
            }), $CreateAnonymousDelegate(this, function ($$x2, e){
                return (function (){
                    var $v103 = new Microsoft.Msagl.Layout.Layered.IntEdge.ctor$$Int32$$Int32($$x2.get_newEdgeSource(), dictionary.get_Item$$TKey(e.get_Target()));
                    $v103.set_Separation(e.get_Separation());
                    $v103.set_Weight(e.get_Weight());
                    return $v103;
                }).call(this);
            })), dictionary.get_Count());
        },
        UniteLayerings: function (layerings, mapToComponenents){
            var ret = new Int32Array(this.graph.get_NodeCount());
            for (var i = 0; i < layerings.length; i++){
                var layering = layerings[i];
                var mapToComp = mapToComponenents.get_Item$$Int32(i);
                var reverseMap = new Int32Array(mapToComp.get_Count());
                var $it735 = mapToComp.GetEnumerator();
                while ($it735.MoveNext()){
                    var p = $it735.get_Current();
                    reverseMap[p.get_Value()] = p.get_Key();
                }
                for (var j = 0; j < layering.length; j++)
                    ret[reverseMap[j]] = layering[j];
            }
            return ret;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$NetworkSimplexForGeneralGraph);
var Microsoft$Msagl$Core$Geometry$Point = {
    fullname: "Microsoft.Msagl.Core.Geometry.Point",
    baseTypeName: "System.ValueType",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Core.Geometry.Point.rnd = new System.Random.ctor$$Int32(1);
        },
        P: function (xCoordinate, yCoordinate){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(xCoordinate, yCoordinate);
        },
        op_Equality: function (point0, point1){
            return point0.get_X() == point1.get_X() && point0.get_Y() == point1.get_Y();
        },
        op_LessThan: function (point0, point1){
            return point0.CompareTo(point1) < 0;
        },
        op_LessThanOrEqual: function (point0, point1){
            return point0.CompareTo(point1) <= 0;
        },
        op_GreaterThanOrEqual: function (point0, point1){
            return point0.CompareTo(point1) >= 0;
        },
        op_GreaterThan: function (point0, point1){
            return point0.CompareTo(point1) > 0;
        },
        op_Inequality: function (point0, point1){
            return !(Microsoft.Msagl.Core.Geometry.Point.op_Equality(point0, point1));
        },
        op_UnaryNegation: function (point0){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-point0.get_X(), -point0.get_Y());
        },
        op_Addition: function (point0, point1){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(point0.get_X() + point1.get_X(), point0.get_Y() + point1.get_Y());
        },
        Add: function (point0, point1){
            return Microsoft.Msagl.Core.Geometry.Point.op_Addition(point0, point1);
        },
        op_Subtraction: function (point0, point1){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(point0.get_X() - point1.get_X(), point0.get_Y() - point1.get_Y());
        },
        Subtract: function (point0, point1){
            return Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(point0, point1);
        },
        op_Multiply$$Point$$Point: function (point0, point1){
            return point0.get_X() * point1.get_X() + point0.get_Y() * point1.get_Y();
        },
        CrossProduct: function (point0, point1){
            return point0.get_X() * point1.get_Y() - point0.get_Y() * point1.get_X();
        },
        Scale: function (xScale, yScale, point){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(xScale * point.get_X(), yScale * point.get_Y());
        },
        op_Multiply$$Double$$Point: function (coefficient, point){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(coefficient * point.get_X(), coefficient * point.get_Y());
        },
        op_Multiply$$Point$$Double: function (point, coefficient){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(coefficient * point.get_X(), coefficient * point.get_Y());
        },
        Multiply$$Double$$Point: function (coefficient, point){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(coefficient * point.get_X(), coefficient * point.get_Y());
        },
        Multiply$$Point$$Double: function (point, coefficient){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(coefficient * point.get_X(), coefficient * point.get_Y());
        },
        op_Division$$Point$$Double: function (point, coefficient){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(point.get_X() / coefficient, point.get_Y() / coefficient);
        },
        op_Division$$Double$$Point: function (coefficient, point){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(point.get_X() / coefficient, point.get_Y() / coefficient);
        },
        Divide$$Point$$Double: function (point, coefficient){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(point.get_X() / coefficient, point.get_Y() / coefficient);
        },
        Divide$$Double$$Point: function (coefficient, point){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(point.get_X() / coefficient, point.get_Y() / coefficient);
        },
        DoubleToString: function (d){
            return (System.Math.Abs$$Double(d) < 1E-11) ? "0" : d.ToString$$String$$IFormatProvider("#.##########", System.Globalization.CultureInfo.get_InvariantCulture());
        },
        ParallelWithinEpsilon: function (a, b, eps){
            var alength = a.get_Length();
            var blength = b.get_Length();
            if (alength < eps || blength < eps)
                return true;
            a = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(a, alength);
            b = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(b, blength);
            return System.Math.Abs$$Double(-a.get_X() * b.get_Y() + a.get_Y() * b.get_X()) < eps;
        },
        Angle$$Point$$Point$$Point: function (point1, center, point3){
            return Microsoft.Msagl.Core.Geometry.Point.Angle$$Point$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(point1, center), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(point3, center));
        },
        Angle$$Point$$Point: function (side0, side1){
            var ax = side0.get_X();
            var ay = side0.get_Y();
            var bx = side1.get_X();
            var by = side1.get_Y();
            var cross = ax * by - ay * bx;
            var dot = ax * bx + ay * by;
            if (System.Math.Abs$$Double(dot) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance()){
                if (System.Math.Abs$$Double(cross) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                    return 0;
                if (cross < -Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                    return 4.71238898038469;
                return 1.5707963267949;
            }
            if (System.Math.Abs$$Double(cross) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance()){
                if (dot < -Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                    return 3.14159265358979;
                return 0;
            }
            var atan2 = System.Math.Atan2(cross, dot);
            if (cross >= -Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                return atan2;
            return 6.28318530717959 + atan2;
        },
        GetOrientationOf3Vectors: function (vector0, vector1, vector2){
            var multiplier = 1000;
            vector0 = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(vector0, multiplier);
            vector1 = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(vector1, multiplier);
            vector2 = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(vector2, multiplier);
            var xp2 = Microsoft.Msagl.Core.Geometry.Point.CrossProduct(vector0, vector2);
            var dotp2 = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(vector0, vector2);
            var xp1 = Microsoft.Msagl.Core.Geometry.Point.CrossProduct(vector0, vector1);
            var dotp1 = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(vector0, vector1);
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(xp1, 0) && Microsoft.Msagl.Core.Geometry.ApproximateComparer.GreaterOrEqual(dotp1, 0)){
                if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(xp2, 0) && Microsoft.Msagl.Core.Geometry.ApproximateComparer.GreaterOrEqual(dotp2, 0))
                    return 0;
                return 1;
            }
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(xp2, 0) && Microsoft.Msagl.Core.Geometry.ApproximateComparer.GreaterOrEqual(dotp2, 0)){
                return -1;
            }
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(xp1, 0) || Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(xp2, 0) || xp1 * xp2 > 0){
                return Microsoft.Msagl.Core.Geometry.ApproximateComparer.Compare(Microsoft.Msagl.Core.Geometry.Point.CrossProduct(vector2, vector1), 0);
            }
            return -Microsoft.Msagl.Core.Geometry.ApproximateComparer.Compare(System.Math.Sign$$Double(xp1), 0);
        },
        SignedDoubledTriangleArea: function (cornerA, cornerB, cornerC){
            return (cornerB.get_X() - cornerA.get_X()) * (cornerC.get_Y() - cornerA.get_Y()) - (cornerC.get_X() - cornerA.get_X()) * (cornerB.get_Y() - cornerA.get_Y());
        },
        GetTriangleOrientation: function (cornerA, cornerB, cornerC){
            var area = Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(cornerA, cornerB, cornerC);
            if (area > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise;
            if (area < -Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise;
            return Microsoft.Msagl.Core.Geometry.TriangleOrientation.Collinear;
        },
        GetTriangleOrientationWithIntersectionEpsilon: function (cornerA, cornerB, cornerC){
            var area = Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(cornerA, cornerB, cornerC);
            if (area > Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_IntersectionEpsilon())
                return Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise;
            if (area < -Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_IntersectionEpsilon())
                return Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise;
            return Microsoft.Msagl.Core.Geometry.TriangleOrientation.Collinear;
        },
        GetTriangleOrientationWithNoEpsilon: function (cornerA, cornerB, cornerC){
            var area = Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(cornerA, cornerB, cornerC);
            if (area > 0)
                return Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise;
            if (area < 0)
                return Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise;
            return Microsoft.Msagl.Core.Geometry.TriangleOrientation.Collinear;
        },
        CanProject: function (point, segmentStart, segmentEnd){
            var bc = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(segmentEnd, segmentStart);
            var ba = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(point, segmentStart);
            if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(ba, bc) < 0)
                return false;
            var ca = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(point, segmentEnd);
            if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(ca, bc) > 0)
                return false;
            return true;
        },
        IntervalIntersectsRay: function (segStart, segEnd, rayOrigin, rayDirection, x){
            if (!Microsoft.Msagl.Core.Geometry.Point.LineLineIntersection(segStart, segEnd, rayOrigin, Microsoft.Msagl.Core.Geometry.Point.op_Addition(rayOrigin, rayDirection), x))
                return false;
            var ds = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(segStart, x.Value);
            var de = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(x.Value, segEnd);
            if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(ds, de) <= 0)
                return false;
            if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(x.Value, rayOrigin)), rayDirection) < 0)
                return false;
            return Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(ds, ds) > Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_SquareOfDistanceEpsilon() && Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(de, de) >= Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_SquareOfDistanceEpsilon();
        },
        RayIntersectsRayInteriors: function (aOrig, aDirection, bOrig, bDirection, x){
            return Microsoft.Msagl.Core.Geometry.Point.LineLineIntersection(aOrig, Microsoft.Msagl.Core.Geometry.Point.op_Addition(aOrig, aDirection), bOrig, Microsoft.Msagl.Core.Geometry.Point.op_Addition(bOrig, bDirection), x) && Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(x.Value, aOrig)), aDirection) / aDirection.get_L1() > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon && Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(x.Value, bOrig)), bDirection) / bDirection.get_L1() > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon;
        },
        RayIntersectsRay: function (aOrig, aDirection, bOrig, bDirection, x){
            return Microsoft.Msagl.Core.Geometry.Point.LineLineIntersection(aOrig, Microsoft.Msagl.Core.Geometry.Point.op_Addition(aOrig, aDirection), bOrig, Microsoft.Msagl.Core.Geometry.Point.op_Addition(bOrig, bDirection), x) && Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(x.Value, aOrig)), aDirection) >= -Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance() && Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(x.Value, bOrig)), bDirection) >= -Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance();
        },
        ProjectionToLine: function (pointOnLine0, pointOnLine1, point){
            var d = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(pointOnLine1, pointOnLine0);
            var dLen = d.get_Length();
            if (dLen < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return pointOnLine0;
            d = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(d, dLen);
            var pr = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(point, pointOnLine0)), d);
            var ret = Microsoft.Msagl.Core.Geometry.Point.op_Addition(pointOnLine0, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(pr, d));
            System.Diagnostics.Debug.Assert$$Boolean(System.Math.Abs$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(point, ret)), d)) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon);
            return ret;
        },
        DistToLineSegment: function (point, segmentStart, segmentEnd, parameter){
            var bc = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(segmentEnd, segmentStart);
            var ba = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(point, segmentStart);
            var c1,c2;
            if ((c1 = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(bc, ba)) <= 0 + Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance()){
                parameter.Value = 0;
                return ba.get_Length();
            }
            if ((c2 = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(bc, bc)) <= c1 + Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance()){
                parameter.Value = 1;
                return (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(point, segmentEnd)).get_Length();
            }
            parameter.Value = c1 / c2;
            return (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(ba, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(parameter.Value, bc))).get_Length();
        },
        ClosestPointAtLineSegment: function (point, segmentStart, segmentEnd){
            var bc = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(segmentEnd, segmentStart);
            var ba = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(point, segmentStart);
            var c1,c2;
            if ((c1 = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(bc, ba)) <= 0 + Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                return segmentStart;
            if ((c2 = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(bc, bc)) <= c1 + Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                return segmentEnd;
            var parameter = c1 / c2;
            return Microsoft.Msagl.Core.Geometry.Point.op_Addition(segmentStart, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(parameter, bc));
        },
        ClosestParameterOnLineSegment: function (point, segmentStart, segmentEnd){
            var bc = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(segmentEnd, segmentStart);
            var ba = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(point, segmentStart);
            var c1,c2;
            if ((c1 = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(bc, ba)) <= 0 + Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                return 0;
            if ((c2 = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(bc, bc)) <= c1 + Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                return 1;
            return c1 / c2;
        },
        MinDistBetweenLineSegments: function (a, b, c, d, parab, parcd){
            var u = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b, a);
            var v = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(d, c);
            var w = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a, c);
            var D = Microsoft.Msagl.Core.Geometry.Point.CrossProduct(u, v);
            var uu = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(u, u);
            var uv = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(u, v);
            var vv = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(v, v);
            var uw = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(u, w);
            var vw = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(v, w);
            var sN,tN;
            var absD = System.Math.Abs$$Double(D);
            var sD = absD,tD = absD;
            if (absD < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance()){
                sN = 0;
                sD = 1;
                tN = vw;
                tD = vv;
            }
            else {
                sN = Microsoft.Msagl.Core.Geometry.Point.CrossProduct(v, w);
                tN = Microsoft.Msagl.Core.Geometry.Point.CrossProduct(u, w);
                if (D < 0){
                    sN = -sN;
                    tN = -tN;
                }
                if (sN < 0){
                    sN = 0;
                    tN = vw;
                    tD = vv;
                }
                else if (sN > sD){
                    sN = sD = 1;
                    tN = vw + uv;
                    tD = vv;
                }
            }
            if (tN < 0){
                tN = 0;
                if (-uw < 0)
                    sN = 0;
                else if (-uw > uu)
                    sN = sD;
                else {
                    sN = -uw;
                    sD = uu;
                }
            }
            else if (tN > tD){
                tN = tD = 1;
                if ((-uw + uv) < 0)
                    sN = 0;
                else if ((-uw + uv) > uu)
                    sN = sD;
                else {
                    sN = (-uw + uv);
                    sD = uu;
                }
            }
            parab.Value = (System.Math.Abs$$Double(sN) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance() ? 0 : sN / sD);
            parcd.Value = (System.Math.Abs$$Double(tN) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance() ? 0 : tN / tD);
            var dP = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(Microsoft.Msagl.Core.Geometry.Point.op_Addition(w, (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(parab.Value, u))), (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(parcd.Value, v)));
            return dP.get_Length();
        },
        LineLineIntersection: function (a, b, c, d, x){
            var u,v;
            var ba = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b, a);
            var cd = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(c, d);
            var ca = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(c, a);
            var ret = (function (){
                var $1 = {
                    Value: u
                };
                var $2 = {
                    Value: v
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.LinearSystem2.Solve(ba.get_X(), cd.get_X(), ca.get_X(), ba.get_Y(), cd.get_Y(), ca.get_Y(), $1, $2);
                u = $1.Value;
                v = $2.Value;
                return $res;
            })();
            if (ret){
                x.Value = Microsoft.Msagl.Core.Geometry.Point.op_Addition(a, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(u, ba));
                return true;
            }
            else {
                x.Value = new Microsoft.Msagl.Core.Geometry.Point.ctor();
                return false;
            }
        },
        SegmentSegmentIntersection: function (a, b, c, d, x){
            var u,v;
            var ba = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b, a);
            var cd = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(c, d);
            var ca = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(c, a);
            var ret = (function (){
                var $1 = {
                    Value: u
                };
                var $2 = {
                    Value: v
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.LinearSystem2.Solve(ba.get_X(), cd.get_X(), ca.get_X(), ba.get_Y(), cd.get_Y(), ca.get_Y(), $1, $2);
                u = $1.Value;
                v = $2.Value;
                return $res;
            })();
            var eps = Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance();
            if (ret && u > -eps && u < 1 + eps && v > -eps && v < 1 + eps){
                x.Value = Microsoft.Msagl.Core.Geometry.Point.op_Addition(a, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(u, ba));
                return true;
            }
            else {
                x.Value = new Microsoft.Msagl.Core.Geometry.Point.ctor();
                return false;
            }
        },
        PointToTheLeftOfLineOrOnLine: function (point, linePoint0, linePoint1){
            return Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(point, linePoint0, linePoint1) >= 0;
        },
        PointToTheLeftOfLine: function (point, linePoint0, linePoint1){
            return Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(point, linePoint0, linePoint1) > 0;
        },
        PointToTheRightOfLineOrOnLine: function (point, linePoint0, linePoint1){
            return Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(linePoint0, linePoint1, point) <= 0;
        },
        PointToTheRightOfLine: function (point, linePoint0, linePoint1){
            return Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(linePoint0, linePoint1, point) < 0;
        },
        PointIsInsideCone: function (p, apex, leftSideConePoint, rightSideConePoint){
            return Microsoft.Msagl.Core.Geometry.Point.PointToTheRightOfLineOrOnLine(p, apex, leftSideConePoint) && Microsoft.Msagl.Core.Geometry.Point.PointToTheLeftOfLineOrOnLine(p, apex, rightSideConePoint);
        },
        RandomPoint: function (){
            var x = -1 + 2 * Microsoft.Msagl.Core.Geometry.Point.rnd.NextDouble();
            var y = -1 + 2 * Microsoft.Msagl.Core.Geometry.Point.rnd.NextDouble();
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x, y).Normalize();
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.IComparable$1"],
    Kind: "Struct",
    definition: {
        ctor$$Double$$Double: function (xCoordinate, yCoordinate){
            this.m_X = 0;
            this.m_Y = 0;
            this._hashKey = null;
            System.ValueType.ctor.call(this);
            this.m_X = xCoordinate;
            this.m_Y = yCoordinate;
            this._hashKey = null;
            this.UpdateHashKey();
        },
        Equals$$Object: function (obj){
            if (!(Is(obj, Microsoft.Msagl.Core.Geometry.Point.ctor)))
                return false;
            return Microsoft.Msagl.Core.Geometry.Point.op_Equality(Cast(obj, Microsoft.Msagl.Core.Geometry.Point.ctor), this);
        },
        GetHashCode: function (){
            var hc = (this.get_X().GetHashCode()) | 0;
            return (((hc << 5 | hc >> 27) + (this.get_Y().GetHashCode()) | 0)) | 0;
        },
        Length$$: "System.Double",
        get_Length: function (){
            return System.Math.Sqrt(this.get_X() * this.get_X() + this.get_Y() * this.get_Y());
        },
        LengthSquared$$: "System.Double",
        get_LengthSquared: function (){
            return this.get_X() * this.get_X() + this.get_Y() * this.get_Y();
        },
        Negate: function (){
            return Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(this);
        },
        toString: function (){
            return "(" + Microsoft.Msagl.Core.Geometry.Point.DoubleToString(this.get_X()) + "," + Microsoft.Msagl.Core.Geometry.Point.DoubleToString(this.get_Y()) + ")";
        },
        X$$: "System.Double",
        get_X: function (){
            return this.m_X;
        },
        set_X: function (value){
            this.m_X = value;
            this.UpdateHashKey();
        },
        Y$$: "System.Double",
        get_Y: function (){
            return this.m_Y;
        },
        set_Y: function (value){
            this.m_Y = value;
            this.UpdateHashKey();
        },
        UpdateHashKey: function (){
            this._hashKey = "(" + this.get_X() + "," + this.get_Y() + ")";
        },
        Clone: function (){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.m_X, this.m_Y);
        },
        Rotate: function (angle){
            var c = System.Math.Cos(angle);
            var s = System.Math.Sin(angle);
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(c * this.get_X() - s * this.get_Y(), s * this.get_X() + c * this.get_Y());
        },
        Normalize: function (){
            var length = this.get_Length();
            if (length < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            return Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(this, length);
        },
        CompareTo: function (other){
            var r = this.get_X().CompareTo$$Double(other.get_X());
            return r != 0 ? r : this.get_Y().CompareTo$$Double(other.get_Y());
        },
        CompassDirection$$: "Microsoft.Msagl.Core.Geometry.Directions",
        get_CompassDirection: function (){
            return Microsoft.Msagl.Core.Geometry.CompassVector.VectorDirection$$Point(this);
        },
        L1$$: "System.Double",
        get_L1: function (){
            return System.Math.Abs$$Double(this.get_X()) + System.Math.Abs$$Double(this.get_Y());
        },
        Rotate90Ccw: function (){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-this.get_Y(), this.get_X());
        },
        Rotate90Cw: function (){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.get_Y(), -this.get_X());
        },
        ctor: function (){
            this.m_X = 0;
            this.m_Y = 0;
            this._hashKey = null;
            System.ValueType.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Point);
var Microsoft$Msagl$Core$Layout$Port = {
    fullname: "Microsoft.Msagl.Core.Layout.Port",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this._Curve = null;
            this._PortEntry = null;
            System.Object.ctor.call(this);
        },
        Location$$: "Microsoft.Msagl.Core.Geometry.Point",
        Curve$$: "Microsoft.Msagl.Core.Geometry.Curves.ICurve",
        get_Curve: function (){
            return this._Curve;
        },
        set_Curve: function (value){
            this._Curve = value;
        },
        PortEntry$$: "Microsoft.Msagl.Core.Layout.IPortEntry",
        get_PortEntry: function (){
            return this._PortEntry;
        },
        set_PortEntry: function (value){
            this._PortEntry = value;
        },
        toString: function (){
            return this.get_Location().toString();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$Port);
var Microsoft$Msagl$Core$Layout$IPortEntry = {
    fullname: "Microsoft.Msagl.Core.Layout.IPortEntry",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Interface"
};
JsTypes.push(Microsoft$Msagl$Core$Layout$IPortEntry);
var Microsoft$Msagl$Core$DataStructures$DefaultComperer$1 = {
    fullname: "Microsoft.Msagl.Core.DataStructures.DefaultComperer$1",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IComparer$1"],
    Kind: "Class",
    definition: {
        ctor: function (T){
            this.T = T;
            System.Object.ctor.call(this);
        },
        Compare: function (x, y){
            return (x).CompareTo(y);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$DataStructures$DefaultComperer$1);
var Microsoft$Msagl$Core$DataStructures$RBColor = {
    fullname: "Microsoft.Msagl.Core.DataStructures.RBColor",
    staticDefinition: {
        Red: 0,
        Black: 1
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Core$DataStructures$RBColor);
var Microsoft$Msagl$Core$DataStructures$RBNode$1 = {
    fullname: "Microsoft.Msagl.Core.DataStructures.RBNode$1",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$RBColor: function (T, color){
            this.T = T;
            this.color = Microsoft.Msagl.Core.DataStructures.RBColor.Red;
            this.Item = null;
            this.parent = null;
            this.left = null;
            this.right = null;
            System.Object.ctor.call(this);
            this.color = color;
        },
        ctor$$RBColor$$T$$RBNode$1$$RBNode$1$$RBNode$1: function (T, color, item, p, left, right){
            this.T = T;
            this.color = Microsoft.Msagl.Core.DataStructures.RBColor.Red;
            this.Item = null;
            this.parent = null;
            this.left = null;
            this.right = null;
            System.Object.ctor.call(this);
            this.color = color;
            this.parent = p;
            this.left = left;
            this.right = right;
            this.Item = item;
        },
        toString: function (){
            return this.Item.toString();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$DataStructures$RBNode$1);
var Microsoft$Msagl$Core$DataStructures$RbTree$1 = {
    fullname: "Microsoft.Msagl.Core.DataStructures.RbTree$1",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IEnumerable$1"],
    Kind: "Class",
    definition: {
        ctor: function (T){
            this.T = T;
            this.comparer = null;
            this.nil = null;
            this.root = null;
            this.count = 0;
            System.Object.ctor.call(this);
            this.comparer = new Microsoft.Msagl.Core.DataStructures.DefaultComperer$1.ctor(this.T);
            this.root = this.nil = new Microsoft.Msagl.Core.DataStructures.RBNode$1.ctor$$RBColor(this.T, Microsoft.Msagl.Core.DataStructures.RBColor.Black);
        },
        FindFirst$$Func$2: function (predicate){
            return this.FindFirst$$RBNode$1$$Func$2(this.root, predicate);
        },
        FindFirst$$RBNode$1$$Func$2: function (n, p){
            if (n == this.nil)
                return null;
            var good = null;
            while (n != this.nil)
                n = p(n.Item) ? (good = n).left : n.right;
            return good;
        },
        FindLast$$Func$2: function (predicate){
            return this.FindLast$$RBNode$1$$Func$2(this.root, predicate);
        },
        FindLast$$RBNode$1$$Func$2: function (n, p){
            if (n == this.nil)
                return null;
            var good = null;
            while (n != this.nil)
                n = p(n.Item) ? (good = n).right : n.left;
            return good;
        },
        Comparer$$: "System.Collections.Generic.IComparer`1[[`0]]",
        get_Comparer: function (){
            return this.comparer;
        },
        GetEnumerator: function (){
            return new Microsoft.Msagl.Core.DataStructures.RBTreeEnumerator$1.ctor(this.T, this);
        },
        Nil$$: "Microsoft.Msagl.Core.DataStructures.RBNode`1[[`0]]",
        get_Nil: function (){
            return this.nil;
        },
        Root$$: "Microsoft.Msagl.Core.DataStructures.RBNode`1[[`0]]",
        get_Root: function (){
            return this.root;
        },
        Next: function (x){
            if (x.right != this.nil)
                return this.TreeMinimum$$RBNode$1(x.right);
            var y = x.parent;
            while (y != this.nil && x == y.right){
                x = y;
                y = y.parent;
            }
            return this.ToNull(y);
        },
        ToNull: function (y){
            return y != this.nil ? y : null;
        },
        Previous: function (x){
            if (x.left != this.nil)
                return this.TreeMaximum$$RBNode$1(x.left);
            var y = x.parent;
            while (y != this.nil && x == y.left){
                x = y;
                y = y.parent;
            }
            return this.ToNull(y);
        },
        TreeMinimum$$RBNode$1: function (x){
            while (x.left != this.nil)
                x = x.left;
            return this.ToNull(x);
        },
        TreeMinimum: function (){
            return this.TreeMinimum$$RBNode$1(this.root);
        },
        TreeMaximum$$RBNode$1: function (x){
            while (x.right != this.nil)
                x = x.right;
            return this.ToNull(x);
        },
        TreeMaximum: function (){
            return this.TreeMaximum$$RBNode$1(this.root);
        },
        toString: function (){
            var ret = "{";
            var i = 0;
            var $it738 = this.GetEnumerator();
            while ($it738.MoveNext()){
                var p = $it738.get_Current();
                ret += p.toString();
                if (i != this.count - 1){
                    ret += ",";
                }
                i++;
            }
            return ret + "}";
        },
        DeleteSubtree: function (z){
            System.Diagnostics.Debug.Assert$$Boolean(z != this.nil);
            var y;
            if (z.left == this.nil || z.right == this.nil){
                y = z;
            }
            else {
                y = z.right;
                while (y.left != this.nil)
                    y = y.left;
            }
            var x = y.left != this.nil ? y.left : y.right;
            x.parent = y.parent;
            if (y.parent == this.nil)
                this.root = x;
            else {
                if (y == y.parent.left)
                    y.parent.left = x;
                else
                    y.parent.right = x;
            }
            if (y != z)
                z.Item = y.Item;
            if (y.color == Microsoft.Msagl.Core.DataStructures.RBColor.Black)
                this.DeleteFixup(x);
            return this.ToNull(z);
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this.count;
        },
        Remove: function (i){
            var n = this.Find$$T(i);
            if (n != null){
                this.count--;
                return this.DeleteSubtree(n);
            }
            return null;
        },
        DeleteNodeInternal: function (x){
            this.count--;
            this.DeleteSubtree(x);
        },
        Find$$RBNode$1$$T: function (x, i){
            var compareResult;
            while (x != this.nil && (compareResult = this.get_Comparer().Compare(i, x.Item)) != 0)
                x = compareResult < 0 ? x.left : x.right;
            return this.ToNull(x);
        },
        Find$$T: function (i){
            return this.Find$$RBNode$1$$T(this.root, i);
        },
        Contains: function (i){
            return this.Find$$T(i) != null;
        },
        DeleteFixup: function (x){
            while (x != this.root && x.color == Microsoft.Msagl.Core.DataStructures.RBColor.Black){
                if (x == x.parent.left){
                    var w = x.parent.right;
                    if (w.color == Microsoft.Msagl.Core.DataStructures.RBColor.Red){
                        w.color = Microsoft.Msagl.Core.DataStructures.RBColor.Black;
                        x.parent.color = Microsoft.Msagl.Core.DataStructures.RBColor.Red;
                        this.LeftRotate(x.parent);
                        w = x.parent.right;
                    }
                    if (w.left.color == Microsoft.Msagl.Core.DataStructures.RBColor.Black && w.right.color == Microsoft.Msagl.Core.DataStructures.RBColor.Black){
                        w.color = Microsoft.Msagl.Core.DataStructures.RBColor.Red;
                        x = x.parent;
                    }
                    else {
                        if (w.right.color == Microsoft.Msagl.Core.DataStructures.RBColor.Black){
                            w.left.color = Microsoft.Msagl.Core.DataStructures.RBColor.Black;
                            w.color = Microsoft.Msagl.Core.DataStructures.RBColor.Red;
                            this.RightRotate(w);
                            w = x.parent.right;
                        }
                        w.color = x.parent.color;
                        x.parent.color = Microsoft.Msagl.Core.DataStructures.RBColor.Black;
                        w.right.color = Microsoft.Msagl.Core.DataStructures.RBColor.Black;
                        this.LeftRotate(x.parent);
                        x = this.root;
                    }
                }
                else {
                    var w = x.parent.left;
                    if (w.color == Microsoft.Msagl.Core.DataStructures.RBColor.Red){
                        w.color = Microsoft.Msagl.Core.DataStructures.RBColor.Black;
                        x.parent.color = Microsoft.Msagl.Core.DataStructures.RBColor.Red;
                        this.RightRotate(x.parent);
                        w = x.parent.left;
                    }
                    if (w.right.color == Microsoft.Msagl.Core.DataStructures.RBColor.Black && w.left.color == Microsoft.Msagl.Core.DataStructures.RBColor.Black){
                        w.color = Microsoft.Msagl.Core.DataStructures.RBColor.Red;
                        x = x.parent;
                    }
                    else {
                        if (w.left.color == Microsoft.Msagl.Core.DataStructures.RBColor.Black){
                            w.right.color = Microsoft.Msagl.Core.DataStructures.RBColor.Black;
                            w.color = Microsoft.Msagl.Core.DataStructures.RBColor.Red;
                            this.LeftRotate(w);
                            w = x.parent.left;
                        }
                        w.color = x.parent.color;
                        x.parent.color = Microsoft.Msagl.Core.DataStructures.RBColor.Black;
                        w.left.color = Microsoft.Msagl.Core.DataStructures.RBColor.Black;
                        this.RightRotate(x.parent);
                        x = this.root;
                    }
                }
            }
            x.color = Microsoft.Msagl.Core.DataStructures.RBColor.Black;
        },
        IsEmpty: function (){
            return this.root == this.nil;
        },
        TreeInsert: function (z){
            var y = this.nil;
            var x = this.root;
            var compareRes = 0;
            while (x != this.nil){
                y = x;
                compareRes = this.get_Comparer().Compare(z, x.Item);
                x = compareRes < 0 ? x.left : x.right;
            }
            var nz = new Microsoft.Msagl.Core.DataStructures.RBNode$1.ctor$$RBColor$$T$$RBNode$1$$RBNode$1$$RBNode$1(this.T, Microsoft.Msagl.Core.DataStructures.RBColor.Black, z, y, this.nil, this.nil);
            if (y == this.nil)
                this.root = nz;
            else if (compareRes < 0)
                y.left = nz;
            else
                y.right = nz;
            return this.ToNull(nz);
        },
        InsertPrivate: function (x){
            this.count++;
            x.color = Microsoft.Msagl.Core.DataStructures.RBColor.Red;
            while (x != this.root && x.parent.color == Microsoft.Msagl.Core.DataStructures.RBColor.Red){
                if (x.parent == x.parent.parent.left){
                    var y = x.parent.parent.right;
                    if (y.color == Microsoft.Msagl.Core.DataStructures.RBColor.Red){
                        x.parent.color = Microsoft.Msagl.Core.DataStructures.RBColor.Black;
                        y.color = Microsoft.Msagl.Core.DataStructures.RBColor.Black;
                        x.parent.parent.color = Microsoft.Msagl.Core.DataStructures.RBColor.Red;
                        x = x.parent.parent;
                    }
                    else {
                        if (x == x.parent.right){
                            x = x.parent;
                            this.LeftRotate(x);
                        }
                        x.parent.color = Microsoft.Msagl.Core.DataStructures.RBColor.Black;
                        x.parent.parent.color = Microsoft.Msagl.Core.DataStructures.RBColor.Red;
                        this.RightRotate(x.parent.parent);
                    }
                }
                else {
                    var y = x.parent.parent.left;
                    if (y.color == Microsoft.Msagl.Core.DataStructures.RBColor.Red){
                        x.parent.color = Microsoft.Msagl.Core.DataStructures.RBColor.Black;
                        y.color = Microsoft.Msagl.Core.DataStructures.RBColor.Black;
                        x.parent.parent.color = Microsoft.Msagl.Core.DataStructures.RBColor.Red;
                        x = x.parent.parent;
                    }
                    else {
                        if (x == x.parent.left){
                            x = x.parent;
                            this.RightRotate(x);
                        }
                        x.parent.color = Microsoft.Msagl.Core.DataStructures.RBColor.Black;
                        x.parent.parent.color = Microsoft.Msagl.Core.DataStructures.RBColor.Red;
                        this.LeftRotate(x.parent.parent);
                    }
                }
            }
            this.root.color = Microsoft.Msagl.Core.DataStructures.RBColor.Black;
        },
        Insert: function (v){
            var x = this.TreeInsert(v);
            this.InsertPrivate(x);
            return this.ToNull(x);
        },
        LeftRotate: function (x){
            var y = x.right;
            x.right = y.left;
            if (y.left != this.nil)
                y.left.parent = x;
            y.parent = x.parent;
            if (x.parent == this.nil)
                this.root = y;
            else if (x == x.parent.left)
                x.parent.left = y;
            else
                x.parent.right = y;
            y.left = x;
            x.parent = y;
        },
        RightRotate: function (x){
            var y = x.left;
            x.left = y.right;
            if (y.right != this.nil)
                y.right.parent = x;
            y.parent = x.parent;
            if (x.parent == this.nil)
                this.root = y;
            else if (x == x.parent.right)
                x.parent.right = y;
            else
                x.parent.left = y;
            y.right = x;
            x.parent = y;
        },
        ctor$$Func$3: function (T, func){
            this.T = T;
            this.comparer = null;
            this.nil = null;
            this.root = null;
            this.count = 0;
            Microsoft.Msagl.Core.DataStructures.RbTree$1.ctor$$IComparer$1.call(this, this.T, new Microsoft.Msagl.Core.DataStructures.ComparerOnDelegate$1.ctor(this.T, func));
        },
        ctor$$IComparer$1: function (T, comparer){
            this.T = T;
            this.comparer = null;
            this.nil = null;
            this.root = null;
            this.count = 0;
            System.Object.ctor.call(this);
            this.root = this.nil = new Microsoft.Msagl.Core.DataStructures.RBNode$1.ctor$$RBColor(this.T, Microsoft.Msagl.Core.DataStructures.RBColor.Black);
            this.comparer = comparer;
        },
        AddCollection: function (enumerable){
            var $it739 = enumerable.GetEnumerator();
            while ($it739.MoveNext()){
                var p = $it739.get_Current();
                this.Insert(p);
            }
        },
        InsertUnique: function (item){
            var node = this.Find$$T(item);
            if (node != null)
                return node;
            return this.Insert(item);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$DataStructures$RbTree$1);
var Microsoft$Msagl$Core$DataStructures$RBTreeEnumerator$1 = {
    fullname: "Microsoft.Msagl.Core.DataStructures.RBTreeEnumerator$1",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IEnumerator$1"],
    Kind: "Class",
    definition: {
        ctor: function (T, tree){
            this.T = T;
            this.initialState = false;
            this.tree = null;
            this.c = null;
            System.Object.ctor.call(this);
            this.tree = tree;
            this.Reset();
        },
        Current$$: "`0",
        get_Current: function (){
            return this.c.Item;
        },
        Reset: function (){
            this.initialState = true;
        },
        MoveNext: function (){
            if (this.tree.IsEmpty())
                return false;
            if (this.initialState == true){
                this.initialState = false;
                this.c = this.tree.TreeMinimum();
            }
            else {
                this.c = this.tree.Next(this.c);
            }
            return this.c != null;
        },
        Dispose: function (){
            System.GC.SuppressFinalize(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$DataStructures$RBTreeEnumerator$1);
var Microsoft$Msagl$Core$DataStructures$RealNumberSpan = {
    fullname: "Microsoft.Msagl.Core.DataStructures.RealNumberSpan",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this._IsEmpty = false;
            this._Min = 0;
            this._Max = 0;
            System.Object.ctor.call(this);
            this.set_IsEmpty(true);
        },
        Intersects: function (a){
            return !(a.get_Max() < this.get_Min() || a.get_Min() > this.get_Max());
        },
        IsEmpty$$: "System.Boolean",
        get_IsEmpty: function (){
            return this._IsEmpty;
        },
        set_IsEmpty: function (value){
            this._IsEmpty = value;
        },
        AddValue: function (x){
            if (this.get_IsEmpty()){
                this.set_Min((function ($p40){
                    this.set_Max($p40);
                    return $p40;
                }).call(this, x));
                this.set_IsEmpty(false);
            }
            else if (x < this.get_Min())
                this.set_Min(x);
            else if (x > this.get_Max())
                this.set_Max(x);
        },
        Min$$: "System.Double",
        get_Min: function (){
            return this._Min;
        },
        set_Min: function (value){
            this._Min = value;
        },
        Max$$: "System.Double",
        get_Max: function (){
            return this._Max;
        },
        set_Max: function (value){
            this._Max = value;
        },
        Length$$: "System.Double",
        get_Length: function (){
            return this.get_Max() - this.get_Min();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$DataStructures$RealNumberSpan);
var Microsoft$Msagl$Core$Layout$RelativeFloatingPort = {
    fullname: "Microsoft.Msagl.Core.Layout.RelativeFloatingPort",
    baseTypeName: "Microsoft.Msagl.Core.Layout.FloatingPort",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$Func$1$ICurve$$Func$1$Point$$Point: function (curveDelegate, centerDelegate, locationOffset){
            this._CenterDelegate = null;
            this._CurveDelegate = null;
            this._LocationOffset = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            Microsoft.Msagl.Core.Layout.FloatingPort.ctor.call(this, null, Microsoft.Msagl.Core.Geometry.Point.op_Addition(centerDelegate(), locationOffset));
            this.set_LocationOffset(locationOffset);
            this.set_CurveDelegate(curveDelegate);
            this.set_CenterDelegate(centerDelegate);
        },
        CenterDelegate$$: "System.Func`1[[Microsoft.Msagl.Core.Geometry.Point]]",
        get_CenterDelegate: function (){
            return this._CenterDelegate;
        },
        set_CenterDelegate: function (value){
            this._CenterDelegate = value;
        },
        CurveDelegate$$: "System.Func`1[[Microsoft.Msagl.Core.Geometry.Curves.ICurve]]",
        get_CurveDelegate: function (){
            return this._CurveDelegate;
        },
        set_CurveDelegate: function (value){
            this._CurveDelegate = value;
        },
        LocationOffset$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_LocationOffset: function (){
            return this._LocationOffset;
        },
        set_LocationOffset: function (value){
            this._LocationOffset = value;
        },
        ctor$$Func$1$ICurve$$Func$1$Point: function (curveDelegate, centerDelegate){
            this._CenterDelegate = null;
            this._CurveDelegate = null;
            this._LocationOffset = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            Microsoft.Msagl.Core.Layout.RelativeFloatingPort.ctor$$Func$1$ICurve$$Func$1$Point$$Point.call(this, curveDelegate, centerDelegate, new Microsoft.Msagl.Core.Geometry.Point.ctor());
        },
        Location$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Location: function (){
            return Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.get_CenterDelegate()(), this.get_LocationOffset());
        },
        Curve$$: "Microsoft.Msagl.Core.Geometry.Curves.ICurve",
        get_Curve: function (){
            return this.get_CurveDelegate()();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$RelativeFloatingPort);
var Microsoft$Msagl$Core$Geometry$SmoothedPolyline = {
    fullname: "Microsoft.Msagl.Core.Geometry.SmoothedPolyline",
    baseTypeName: "System.Object",
    staticDefinition: {
        FromPoints: function (points){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(points, "points");
            var ret = null;
            var site = null;
            var $it740 = points.GetEnumerator();
            while ($it740.MoveNext()){
                var p = $it740.get_Current();
                if (site == null){
                    site = new Microsoft.Msagl.Core.Geometry.Site.ctor$$Point(p);
                    ret = new Microsoft.Msagl.Core.Geometry.SmoothedPolyline.ctor(site);
                }
                else {
                    var s = new Microsoft.Msagl.Core.Geometry.Site.ctor$$Point(p);
                    s.set_Previous(site);
                    site.set_Next(s);
                    site = s;
                }
            }
            return ret;
        },
        CreateBezierSegOnSite: function (b){
            var kPrev = b.get_PreviousBezierSegmentFitCoefficient();
            var kNext = b.get_NextBezierSegmentFitCoefficient();
            var a = b.get_Previous();
            var c = b.get_Next();
            var s = Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(kPrev, a.get_Point()), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point((1 - kPrev), b.get_Point()));
            var e = Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(kNext, c.get_Point()), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point((1 - kNext), b.get_Point()));
            var u = Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(s, b.get_PreviousTangentCoefficient()), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point((1 - b.get_PreviousTangentCoefficient()), b.get_Point()));
            var v = Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(e, b.get_NextTangentCoefficient()), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point((1 - b.get_NextTangentCoefficient()), b.get_Point()));
            return new Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ctor(s, u, v, e);
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IEnumerable$1"],
    Kind: "Class",
    definition: {
        ctor: function (head){
            this.headSite = null;
            System.Object.ctor.call(this);
            this.headSite = head;
        },
        HeadSite$$: "Microsoft.Msagl.Core.Geometry.Site",
        get_HeadSite: function (){
            return this.headSite;
        },
        Clone: function (){
            var h;
            var s = this.headSite;
            var prev = null;
            var headOfTheClone = null;
            while (s != null){
                h = s.Clone();
                h.set_Previous(prev);
                if (prev != null)
                    prev.set_Next(h);
                else
                    headOfTheClone = h;
                s = s.get_Next();
                prev = h;
            }
            return new Microsoft.Msagl.Core.Geometry.SmoothedPolyline.ctor(headOfTheClone);
        },
        LastSite$$: "Microsoft.Msagl.Core.Geometry.Site",
        get_LastSite: function (){
            var ret = this.headSite;
            while (ret.get_Next() != null)
                ret = ret.get_Next();
            return ret;
        },
        CreateCurve: function (){
            var curve = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor();
            var a = this.get_HeadSite();
            var b;
            var c;
            while ((function (){
                var $1 = {
                    Value: b
                };
                var $2 = {
                    Value: c
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.FindCorner(a, $1, $2);
                b = $1.Value;
                c = $2.Value;
                return $res;
            }).call(this)){
                var bezierSeg = Microsoft.Msagl.Core.Geometry.SmoothedPolyline.CreateBezierSegOnSite(b);
                if (curve.get_Segments().get_Count() == 0){
                    if (!Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(a.get_Point(), bezierSeg.get_Start()))
                        Microsoft.Msagl.Core.Geometry.Curves.Curve.AddLineSegment$$Curve$$Point$$Point(curve, a.get_Point(), bezierSeg.get_Start());
                }
                else if (!Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(curve.get_End(), bezierSeg.get_Start()))
                    Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Point(curve, bezierSeg.get_Start());
                curve.AddSegment(bezierSeg);
                a = b;
            }
            System.Diagnostics.Debug.Assert$$Boolean(a.get_Next().get_Next() == null);
            if (curve.get_Segments().get_Count() == 0){
                if (!Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(a.get_Point(), a.get_Next().get_Point())){
                    Microsoft.Msagl.Core.Geometry.Curves.Curve.AddLineSegment$$Curve$$Point$$Point(curve, a.get_Point(), a.get_Next().get_Point());
                }
                else {
                    var w = 5;
                    curve.get_Segments().Add(new Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ctor(a.get_Point(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(a.get_Point(), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(w, w)), Microsoft.Msagl.Core.Geometry.Point.op_Addition(a.get_Point(), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-w, w)), b.get_Point()));
                }
            }
            else if (!Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(curve.get_End(), a.get_Next().get_Point()))
                Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Point(curve, a.get_Next().get_Point());
            return curve;
        },
        GetEnumerator: function (){
            return new Microsoft.Msagl.Core.Geometry.PointNodesList.ctor$$Site(this.headSite);
        },
        Reverse: function (){
            var ret = Microsoft.Msagl.Core.Geometry.SmoothedPolyline.FromPoints(this);
            var a = ret.get_HeadSite();
            var b = ret.get_LastSite();
            while (b != null){
                a.set_NextBezierSegmentFitCoefficient(b.get_PreviousBezierSegmentFitCoefficient());
                a.set_PreviousBezierSegmentFitCoefficient(b.get_NextBezierSegmentFitCoefficient());
                b = b.get_Previous();
                a = a.get_Next();
            }
            return ret;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$SmoothedPolyline);
var Microsoft$Msagl$Core$Geometry$TriangleOrientation = {
    fullname: "Microsoft.Msagl.Core.Geometry.TriangleOrientation",
    staticDefinition: {
        Clockwise: 0,
        Counterclockwise: 1,
        Collinear: 2
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$TriangleOrientation);
var Microsoft$Msagl$Layout$Layered$VerticalConstraintsForSugiyama = {
    fullname: "Microsoft.Msagl.Layout.Layered.VerticalConstraintsForSugiyama",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this._maxLayerOfGeomGraph = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor);
            this._minLayerOfGeomGraph = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor);
            this.sameLayerConstraints = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(System.Tuple$2.ctor);
            this.upDownConstraints = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(System.Tuple$2.ctor);
            this.gluedUpDownIntConstraints = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor);
            this.nodeIdToIndex = null;
            this.intGraph = null;
            this.gluedIntGraph = null;
            this.maxRepresentative = 0;
            this.minRepresentative = 0;
            this.sameLayerDictionaryOfRepresentatives = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, System.Int32.ctor);
            this.representativeToItsLayer = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, System.Collections.Generic.IEnumerable$1.ctor);
            this.maxLayerInt = new System.Collections.Generic.List$1.ctor(System.Int32.ctor);
            this.minLayerInt = new System.Collections.Generic.List$1.ctor(System.Int32.ctor);
            this.sameLayerInts = new System.Collections.Generic.List$1.ctor(System.Tuple$2.ctor);
            this.upDownInts = new System.Collections.Generic.List$1.ctor(System.Tuple$2.ctor);
            System.Object.ctor.call(this);
        },
        MaxLayerOfGeomGraph$$: "Microsoft.Msagl.Core.DataStructures.Set`1[[Microsoft.Msagl.Core.Layout.Node]]",
        get_MaxLayerOfGeomGraph: function (){
            return this._maxLayerOfGeomGraph;
        },
        MinLayerOfGeomGraph$$: "Microsoft.Msagl.Core.DataStructures.Set`1[[Microsoft.Msagl.Core.Layout.Node]]",
        get_MinLayerOfGeomGraph: function (){
            return this._minLayerOfGeomGraph;
        },
        SameLayerConstraints$$: "Microsoft.Msagl.Core.DataStructures.Set`1[[System.Tuple`2[[Microsoft.Msagl.Core.Layout.Node],[Microsoft.Msagl.Core.Layout.Node]]]]",
        get_SameLayerConstraints: function (){
            return this.sameLayerConstraints;
        },
        UpDownConstraints$$: "Microsoft.Msagl.Core.DataStructures.Set`1[[System.Tuple`2[[Microsoft.Msagl.Core.Layout.Node],[Microsoft.Msagl.Core.Layout.Node]]]]",
        get_UpDownConstraints: function (){
            return this.upDownConstraints;
        },
        PinNodeToMaxLayer: function (node){
            this.get_MaxLayerOfGeomGraph().Insert(node);
        },
        UnpinNodeFromMaxLayer: function (node){
            this.get_MaxLayerOfGeomGraph().Remove(node);
        },
        PinNodeToMinLayer: function (node){
            System.Diagnostics.Debug.Assert$$Boolean(node != null);
            this.get_MinLayerOfGeomGraph().Insert(node);
        },
        UnpinNodeFromMinLayer: function (node){
            this.get_MinLayerOfGeomGraph().Remove(node);
        },
        IsEmpty$$: "System.Boolean",
        get_IsEmpty: function (){
            return this.get_MaxLayerOfGeomGraph().get_Count() == 0 && this.get_MinLayerOfGeomGraph().get_Count() == 0 && this.get_SameLayerConstraints().get_Count() == 0 && this.get_UpDownConstraints().get_Count() == 0;
        },
        Clear: function (){
            this.get_MaxLayerOfGeomGraph().Clear();
            this.get_MinLayerOfGeomGraph().Clear();
            this.get_SameLayerConstraints().Clear();
            this.get_UpDownConstraints().Clear();
        },
        GluedUpDownIntConstraints$$: "Microsoft.Msagl.Core.DataStructures.Set`1[[Microsoft.Msagl.Core.GraphAlgorithms.IntPair]]",
        get_GluedUpDownIntConstraints: function (){
            return this.gluedUpDownIntConstraints;
        },
        set_GluedUpDownIntConstraints: function (value){
            this.gluedUpDownIntConstraints = value;
        },
        GetFeedbackSet$$BasicGraph$2$Node$IntEdge$$Dictionary$2$Node$Int32: function (intGraphPar, nodeIdToIndexPar){
            this.nodeIdToIndex = nodeIdToIndexPar;
            this.intGraph = intGraphPar;
            this.maxRepresentative = -1;
            this.minRepresentative = -1;
            this.CreateIntegerConstraints();
            this.GlueTogetherSameConstraintsMaxAndMin();
            this.AddMaxMinConstraintsToGluedConstraints();
            this.RemoveCyclesFromGluedConstraints();
            return this.GetFeedbackSet();
        },
        RemoveCyclesFromGluedConstraints: function (){
            var feedbackSet = Microsoft.Msagl.Core.GraphAlgorithms.CycleRemoval$1.GetFeedbackSetWithConstraints(new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor$$IEnumerable$1$$Int32(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, this.get_GluedUpDownIntConstraints(), this.intGraph.get_NodeCount()), null);
            var $it741 = feedbackSet.GetEnumerator();
            while ($it741.MoveNext()){
                var p = $it741.get_Current();
                this.get_GluedUpDownIntConstraints().Remove(p);
            }
        },
        AddMaxMinConstraintsToGluedConstraints: function (){
            if (this.maxRepresentative != -1)
                for (var i = 0; i < this.intGraph.get_NodeCount(); i++){
                    var j = this.NodeToRepr(i);
                    if (j != this.maxRepresentative)
                        this.get_GluedUpDownIntConstraints().Insert(new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(this.maxRepresentative, j));
                }
            if (this.minRepresentative != -1)
                for (var i = 0; i < this.intGraph.get_NodeCount(); i++){
                    var j = this.NodeToRepr(i);
                    if (j != this.minRepresentative)
                        this.get_GluedUpDownIntConstraints().Insert(new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(j, this.minRepresentative));
                }
        },
        GlueTogetherSameConstraintsMaxAndMin: function (){
            this.CreateDictionaryOfSameLayerRepresentatives();
            this.set_GluedUpDownIntConstraints(new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.Tuple$2.ctor, Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, this.get_UpDownInts(), $CreateAnonymousDelegate(this, function (p){
                return this.GluedIntPair$$Tuple$2$Int32$Int32(p);
            }))));
        },
        GluedIntPair$$Tuple$2$Int32$Int32: function (p){
            return new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(this.NodeToRepr(p.get_Item1()), this.NodeToRepr(p.get_Item2()));
        },
        GluedIntPair$$IntEdge: function (p){
            return new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(this.NodeToRepr(p.get_Source()), this.NodeToRepr(p.get_Target()));
        },
        GluedIntPair$$IntPair: function (p){
            return new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(this.NodeToRepr(p.get_First()), this.NodeToRepr(p.get_Second()));
        },
        GluedIntEdge: function (intEdge){
            var sourceRepr = this.NodeToRepr(intEdge.get_Source());
            var targetRepr = this.NodeToRepr(intEdge.get_Target());
            var ie = new Microsoft.Msagl.Layout.Layered.IntEdge.ctor$$Int32$$Int32(sourceRepr, targetRepr);
            ie.set_Separation(intEdge.get_Separation());
            ie.set_Weight(0);
            ie.set_Edge(intEdge.get_Edge());
            return ie;
        },
        NodeToRepr: function (node){
            var repr;
            if ((function (){
                var $1 = {
                    Value: repr
                };
                var $res = this.sameLayerDictionaryOfRepresentatives.TryGetValue(node, $1);
                repr = $1.Value;
                return $res;
            }).call(this))
                return repr;
            return node;
        },
        CreateDictionaryOfSameLayerRepresentatives: function (){
            var graphOfSameLayers = this.CreateGraphOfSameLayers();
            var $it742 = Microsoft.Msagl.Core.GraphAlgorithms.ConnectedComponentCalculator$1.GetComponents(graphOfSameLayers).GetEnumerator();
            while ($it742.MoveNext()){
                var comp = $it742.get_Current();
                this.GlueSameLayerNodesOfALayer(comp);
            }
        },
        CreateGraphOfSameLayers: function (){
            return new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor$$IEnumerable$1$$Int32(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, this.CreateEdgesOfSameLayers(), this.intGraph.get_NodeCount());
        },
        CreateEdgesOfSameLayers: function (){
            var ret = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor);
            if (this.maxRepresentative != -1)
                ret.AddRange(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.Int32.ctor, Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(System.Int32.ctor, this.maxLayerInt, $CreateAnonymousDelegate(this, function (v){
                    return v != this.maxRepresentative;
                })), $CreateAnonymousDelegate(this, function (v){
                    return new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(this.maxRepresentative, v);
                })));
            if (this.minRepresentative != -1)
                ret.AddRange(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.Int32.ctor, Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(System.Int32.ctor, this.minLayerInt, $CreateAnonymousDelegate(this, function (v){
                    return v != this.minRepresentative;
                })), $CreateAnonymousDelegate(this, function (v){
                    return new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(this.minRepresentative, v);
                })));
            ret.AddRange(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.Tuple$2.ctor, Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, this.get_SameLayerInts(), $CreateAnonymousDelegate(this, function (couple){
                return new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(couple.get_Item1(), couple.get_Item2());
            })));
            return ret;
        },
        GlueSameLayerNodesOfALayer: function (sameLayerNodes){
            if (System.Linq.Enumerable.Count$1$$IEnumerable$1(System.Int32.ctor, sameLayerNodes) > 1){
                var representative = -1;
                if (this.ComponentsIsMaxLayer(sameLayerNodes)){
                    var $it743 = sameLayerNodes.GetEnumerator();
                    while ($it743.MoveNext()){
                        var v = $it743.get_Current();
                        this.sameLayerDictionaryOfRepresentatives.set_Item$$TKey(v, representative = this.maxRepresentative);
                    }
                }
                else if (this.ComponentIsMinLayer(sameLayerNodes)){
                    var $it744 = sameLayerNodes.GetEnumerator();
                    while ($it744.MoveNext()){
                        var v = $it744.get_Current();
                        this.sameLayerDictionaryOfRepresentatives.set_Item$$TKey(v, representative = this.minRepresentative);
                    }
                }
                else {
                    var $it745 = sameLayerNodes.GetEnumerator();
                    while ($it745.MoveNext()){
                        var v = $it745.get_Current();
                        if (representative == -1)
                            representative = v;
                        this.sameLayerDictionaryOfRepresentatives.set_Item$$TKey(v, representative);
                    }
                }
                this.representativeToItsLayer.set_Item$$TKey(representative, sameLayerNodes);
            }
        },
        ComponentIsMinLayer: function (component){
            return System.Linq.Enumerable.Contains$1$$IEnumerable$1$$TSource(System.Int32.ctor, component, this.minRepresentative);
        },
        ComponentsIsMaxLayer: function (component){
            return System.Linq.Enumerable.Contains$1$$IEnumerable$1$$TSource(System.Int32.ctor, component, this.maxRepresentative);
        },
        SameLayerInts$$: "System.Collections.Generic.List`1[[System.Tuple`2[[System.Int32],[System.Int32]]]]",
        get_SameLayerInts: function (){
            return this.sameLayerInts;
        },
        set_SameLayerInts: function (value){
            this.sameLayerInts = value;
        },
        UpDownInts$$: "System.Collections.Generic.List`1[[System.Tuple`2[[System.Int32],[System.Int32]]]]",
        get_UpDownInts: function (){
            return this.upDownInts;
        },
        set_UpDownInts: function (value){
            this.upDownInts = value;
        },
        CreateIntegerConstraints: function (){
            this.CreateMaxIntConstraints();
            this.CreateMinIntConstraints();
            this.CreateUpDownConstraints();
            this.CreateSameLayerConstraints();
        },
        CreateSameLayerConstraints: function (){
            this.set_SameLayerInts(this.CreateIntConstraintsFromStringCouples(this.get_SameLayerConstraints()));
        },
        CreateUpDownConstraints: function (){
            this.set_UpDownInts(this.CreateIntConstraintsFromStringCouples(this.get_UpDownConstraints()));
        },
        CreateIntConstraintsFromStringCouples: function (set){
            return new System.Collections.Generic.List$1.ctor$$IEnumerable$1(System.Tuple$2.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(null, System.Tuple$2.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(null, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.Tuple$2.ctor, null, set, $CreateAnonymousDelegate(this, function (couple){
                return $CreateAnonymousObject({
                    couple: couple,
                    t: new System.Tuple$2.ctor(System.Int32.ctor, System.Int32.ctor, this.NodeIndex(couple.get_Item1()), this.NodeIndex(couple.get_Item2()))
                });
            })), $CreateAnonymousDelegate(this, function ($$x0){
                return $$x0.get_t().get_Item1() != -1 && $$x0.get_t().get_Item2() != -1;
            })), $CreateAnonymousDelegate(this, function ($$x1){
                return $$x1.get_t();
            })));
        },
        CreateMinIntConstraints: function (){
            this.minLayerInt = this.CreateIntConstraintsFromExtremeLayer(this.get_MinLayerOfGeomGraph());
            if (this.minLayerInt.get_Count() > 0)
                this.minRepresentative = this.minLayerInt.get_Item$$Int32(0);
        },
        CreateMaxIntConstraints: function (){
            this.maxLayerInt = this.CreateIntConstraintsFromExtremeLayer(this.get_MaxLayerOfGeomGraph());
            if (this.maxLayerInt.get_Count() > 0)
                this.maxRepresentative = this.maxLayerInt.get_Item$$Int32(0);
        },
        CreateIntConstraintsFromExtremeLayer: function (setOfNodes){
            return new System.Collections.Generic.List$1.ctor$$IEnumerable$1(System.Int32.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(null, System.Int32.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(null, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Node.ctor, null, setOfNodes, $CreateAnonymousDelegate(this, function (node){
                return $CreateAnonymousObject({
                    node: node,
                    index: this.NodeIndex(node)
                });
            })), $CreateAnonymousDelegate(this, function ($$x2){
                return $$x2.get_index() != -1;
            })), $CreateAnonymousDelegate(this, function ($$x3){
                return $$x3.get_index();
            })));
        },
        NodeIndex: function (node){
            var index;
            if ((function (){
                var $1 = {
                    Value: index
                };
                var $res = this.nodeIdToIndex.TryGetValue(node, $1);
                index = $1.Value;
                return $res;
            }).call(this))
                return index;
            return -1;
        },
        GetFeedbackSet: function (){
            this.gluedIntGraph = this.CreateGluedGraph();
            return this.UnglueIntPairs(Microsoft.Msagl.Core.GraphAlgorithms.CycleRemoval$1.GetFeedbackSetWithConstraints(this.gluedIntGraph, this.get_GluedUpDownIntConstraints()));
        },
        UnglueIntPairs: function (gluedEdges){
            var $yield = [];
            var $it746 = gluedEdges.GetEnumerator();
            while ($it746.MoveNext()){
                var gluedEdge = $it746.get_Current();
                var $it747 = this.UnglueEdge(gluedEdge).GetEnumerator();
                while ($it747.MoveNext()){
                    var ungluedEdge = $it747.get_Current();
                    $yield.push(ungluedEdge);
                }
            }
            return $yield;
        },
        UnglueEdge: function (gluedEdge){
            var $yield = [];
            var $it748 = this.UnglueNode(gluedEdge.get_Source()).GetEnumerator();
            while ($it748.MoveNext()){
                var source = $it748.get_Current();
                var $it749 = this.intGraph.OutEdges(source).GetEnumerator();
                while ($it749.MoveNext()){
                    var edge = $it749.get_Current();
                    if (this.NodeToRepr(edge.get_Target()) == gluedEdge.get_Target())
                        $yield.push(edge);
                }
            }
            return $yield;
        },
        CreateGluedGraph: function (){
            return new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor$$IEnumerable$1$$Int32(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Layout.Layered.IntEdge.ctor, Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, this.intGraph.get_Edges(), $CreateAnonymousDelegate(this, function (edge){
                return this.GluedIntPair$$IntEdge(edge);
            }))), this.intGraph.get_NodeCount());
        },
        UnglueNode: function (node){
            var layer;
            if ((function (){
                var $1 = {
                    Value: layer
                };
                var $res = this.representativeToItsLayer.TryGetValue(node, $1);
                layer = $1.Value;
                return $res;
            }).call(this))
                return layer;
            return new Int32Array([node]);
        },
        GetGluedNodeCounts: function (){
            var ret = new Int32Array(this.nodeIdToIndex.get_Count());
            for (var node = 0; node < ret.length; node++)
                ret[this.NodeToRepr(node)]++;
            return ret;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$VerticalConstraintsForSugiyama);
var Microsoft$Msagl$Layout$MDS$MdsLayoutSettings = {
    fullname: "Microsoft.Msagl.Layout.MDS.MdsLayoutSettings",
    baseTypeName: "Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.pivotNumber = 50;
            this.iterationsWithMajorization = 30;
            this.scaleX = 200;
            this.scaleY = 200;
            this.exponent = -2;
            this.rotationAngle = 0;
            this.removeOverlaps = true;
            this.overlapMethod = Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MST.OverlapRemovalMethod.Pmst;
            this.RunInParallel = false;
            this._IdealEdgeLength = new Microsoft.Msagl.Core.Layout.IdealEdgeLengthSettings.ctor();
            this._AdjustScale = false;
            Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings.ctor.call(this);
        },
        RemoveOverlaps$$: "System.Boolean",
        get_RemoveOverlaps: function (){
            return this.removeOverlaps;
        },
        set_RemoveOverlaps: function (value){
            this.removeOverlaps = value;
        },
        PivotNumber$$: "System.Int32",
        get_PivotNumber: function (){
            return this.pivotNumber;
        },
        set_PivotNumber: function (value){
            this.pivotNumber = value;
        },
        IterationsWithMajorization$$: "System.Int32",
        get_IterationsWithMajorization: function (){
            return this.iterationsWithMajorization;
        },
        set_IterationsWithMajorization: function (value){
            this.iterationsWithMajorization = value;
        },
        ScaleX$$: "System.Double",
        get_ScaleX: function (){
            return this.scaleX;
        },
        set_ScaleX: function (value){
            this.scaleX = value;
        },
        ScaleY$$: "System.Double",
        get_ScaleY: function (){
            return this.scaleY;
        },
        set_ScaleY: function (value){
            this.scaleY = value;
        },
        Exponent$$: "System.Double",
        get_Exponent: function (){
            return this.exponent;
        },
        set_Exponent: function (value){
            this.exponent = value;
        },
        RotationAngle$$: "System.Double",
        get_RotationAngle: function (){
            return this.rotationAngle;
        },
        set_RotationAngle: function (value){
            this.rotationAngle = value % 360;
        },
        Clone: function (){
            return As(this.MemberwiseClone(), Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings.ctor);
        },
        IdealEdgeLength$$: "Microsoft.Msagl.Core.Layout.IdealEdgeLengthSettings",
        get_IdealEdgeLength: function (){
            return this._IdealEdgeLength;
        },
        set_IdealEdgeLength: function (value){
            this._IdealEdgeLength = value;
        },
        AdjustScale$$: "System.Boolean",
        get_AdjustScale: function (){
            return this._AdjustScale;
        },
        set_AdjustScale: function (value){
            this._AdjustScale = value;
        },
        OverlapRemovalMethod$$: "Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MST.OverlapRemovalMethod",
        get_OverlapRemovalMethod: function (){
            return this.overlapMethod;
        },
        set_OverlapRemovalMethod: function (value){
            this.overlapMethod = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$MDS$MdsLayoutSettings);
var Microsoft$Msagl$Core$Geometry$MultidimensionalScaling = {
    fullname: "Microsoft.Msagl.Core.Geometry.MultidimensionalScaling",
    baseTypeName: "System.Object",
    staticDefinition: {
        DoubleCenter: function (matrix){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(matrix, "matrix");
            var rowMean = new Float64Array(matrix.length);
            var colMean = new Float64Array(matrix[0].length);
            var mean = 0;
            for (var i = 0; i < matrix.length; i++){
                for (var j = 0; j < matrix[0].length; j++){
                    rowMean[i] += matrix[i][j];
                    colMean[j] += matrix[i][j];
                    mean += matrix[i][j];
                }
            }
            for (var i = 0; i < matrix.length; i++)
                rowMean[i] /= matrix.length;
            for (var j = 0; j < matrix[0].length; j++)
                colMean[j] /= matrix[0].length;
            mean /= matrix.length;
            mean /= matrix[0].length;
            for (var i = 0; i < matrix.length; i++){
                for (var j = 0; j < matrix[0].length; j++){
                    matrix[i][j] -= rowMean[i] + colMean[j] - mean;
                }
            }
        },
        SquareEntries: function (matrix){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(matrix, "matrix");
            for (var i = 0; i < matrix.length; i++){
                for (var j = 0; j < matrix[0].length; j++){
                    matrix[i][j] = System.Math.Pow(matrix[i][j], 2);
                }
            }
        },
        Multiply$$Double$Array$Array$$Double: function (matrix, factor){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(matrix, "matrix");
            for (var i = 0; i < matrix.length; i++){
                for (var j = 0; j < matrix[0].length; j++){
                    matrix[i][j] *= factor;
                }
            }
        },
        Multiply$$Double$Array$Array$$Double$Array: function (A, x){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(A, "A");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(x, "x");
            if (A[0].length != x.length)
                return null;
            var y = new Float64Array(x.length);
            for (var i = 0; i < A.length; i++){
                for (var j = 0; j < A[0].length; j++){
                    y[i] += A[i][j] * x[j];
                }
            }
            return y;
        },
        Norm: function (x){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(x, "x");
            var norm = 0;
            for (var i = 0; i < x.length; i++){
                norm += System.Math.Pow(x[i], 2);
            }
            norm = System.Math.Sqrt(norm);
            return norm;
        },
        Normalize: function (x){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(x, "x");
            var lambda = Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.Norm(x);
            if (lambda <= 0)
                return 0;
            for (var i = 0; i < x.length; i++){
                x[i] /= lambda;
            }
            return lambda;
        },
        RandomUnitLengthVector: function (n, seed){
            var result = new Float64Array(n);
            var random = new System.Random.ctor$$Int32(seed);
            for (var i = 0; i < n; i++){
                result[i] = random.NextDouble();
            }
            Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.Normalize(result);
            return result;
        },
        SpectralDecomposition$$Double$Array$Array$$Double$Array$$Double$$Double$Array$$Double: function (A, u1, lambda1, u2, lambda2){
            Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.SpectralDecomposition$$Double$Array$Array$$Double$Array$$Double$$Double$Array$$Double$$Int32$$Double(A, u1, lambda1, u2, lambda2, 30, 1E-06);
        },
        SpectralDecomposition$$Double$Array$Array$$Double$Array$$Double$$Double$Array$$Double$$Int32$$Double: function (A, u1, lambda1, u2, lambda2, maxIterations, epsilon){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(A, "A");
            var n = A[0].length;
            u1.Value = Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.RandomUnitLengthVector(n, 0);
            lambda1.Value = 0;
            u2.Value = Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.RandomUnitLengthVector(n, 1);
            lambda2.Value = 0;
            var r = 0;
            var limit = 1 - epsilon;
            for (var i = 0; (i < maxIterations && r < limit); i++){
                var x1 = Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.Multiply$$Double$Array$Array$$Double$Array(A, u1.Value);
                var x2 = Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.Multiply$$Double$Array$Array$$Double$Array(A, u2.Value);
                lambda1.Value = Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.Normalize(x1);
                lambda2.Value = Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.Normalize(x2);
                Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.MakeOrthogonal(x2, x1);
                Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.Normalize(x2);
                r = System.Math.Min$$Double$$Double(Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.DotProduct(u1.Value, x1), Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.DotProduct(u2.Value, x2));
                u1.Value = x1;
                u2.Value = x2;
            }
        },
        DotProduct: function (x, y){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(x, "x");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(y, "y");
            if (x.length != y.length)
                return 0;
            var result = 0;
            for (var i = 0; i < x.length; i++){
                result += x[i] * y[i];
            }
            return result;
        },
        MakeOrthogonal: function (x, y){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(x, "x");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(y, "y");
            if (x.length != y.length)
                return;
            var prod = Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.DotProduct(x, y) / Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.DotProduct(y, y);
            for (var i = 0; i < x.length; i++){
                x[i] -= prod * y[i];
            }
        },
        ClassicalScaling: function (d, x, y){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(d, "d");
            var b = new Array(d.length);
            for (var i = 0; i < d.length; i++){
                b[i] = new Float64Array(d[0].length);
                d[i].CopyTo(b[i], 0);
            }
            Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.SquareEntries(b);
            Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.DoubleCenter(b);
            Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.Multiply$$Double$Array$Array$$Double(b, -0.5);
            var lambda1;
            var lambda2;
            (function (){
                var $1 = {
                    Value: lambda1
                };
                var $2 = {
                    Value: lambda2
                };
                var $res = Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.SpectralDecomposition$$Double$Array$Array$$Double$Array$$Double$$Double$Array$$Double(b, x, $1, y, $2);
                lambda1 = $1.Value;
                lambda2 = $2.Value;
                return $res;
            })();
            lambda1 = System.Math.Sqrt(System.Math.Abs$$Double(lambda1));
            lambda2 = System.Math.Sqrt(System.Math.Abs$$Double(lambda2));
            for (var i = 0; i < x.Value.length; i++){
                x.Value[i] *= lambda1;
                y.Value[i] *= lambda2;
            }
        },
        DistanceScalingSubset: function (d, x, y, w, numberOfIterations){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(d, "d");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(x, "x");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(y, "y");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(w, "w");
            var n = x.length;
            var k = d.length;
            var index = new Int32Array(k);
            for (var i = 0; i < k; i++){
                for (var j = 0; j < n; j++){
                    if (d[i][j] == 0){
                        index[i] = j;
                    }
                }
            }
            var wSum = new Float64Array(k);
            for (var i = 0; i < k; i++){
                for (var j = 0; j < n; j++){
                    if (index[i] != j){
                        wSum[i] += w[i][j];
                    }
                }
            }
            for (var c = 0; c < numberOfIterations; c++){
                for (var i = 0; i < k; i++){
                    var xNew = 0;
                    var yNew = 0;
                    for (var j = 0; j < n; j++){
                        if (i != j){
                            var inv = System.Math.Sqrt(System.Math.Pow(x[index[i]] - x[j], 2) + System.Math.Pow(y[index[i]] - y[j], 2));
                            if (inv > 0)
                                inv = 1 / inv;
                            xNew += w[i][j] * (x[j] + d[i][j] * (x[index[i]] - x[j]) * inv);
                            yNew += w[i][j] * (y[j] + d[i][j] * (y[index[i]] - y[j]) * inv);
                        }
                    }
                    x[index[i]] = xNew / wSum[i];
                    y[index[i]] = yNew / wSum[i];
                }
            }
        },
        DistanceScaling: function (d, x, y, w, iter){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(d, "d");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(x, "x");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(y, "y");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(w, "w");
            var n = x.length;
            var wSum = new Float64Array(n);
            for (var i = 0; i < n; i++){
                for (var j = 0; j < n; j++){
                    if (i != j)
                        wSum[i] += w[i][j];
                }
            }
            System.Console.Write$$String("distance scaling ");
            for (var c = 0; c < iter; c++){
                for (var i = 0; i < n; i++){
                    var xNew = 0;
                    var yNew = 0;
                    for (var j = 0; j < n; j++){
                        if (i != j){
                            var inv = System.Math.Sqrt(System.Math.Pow(x[i] - x[j], 2) + System.Math.Pow(y[i] - y[j], 2));
                            if (inv > 0)
                                inv = 1 / inv;
                            xNew += w[i][j] * (x[j] + d[i][j] * (x[i] - x[j]) * inv);
                            yNew += w[i][j] * (y[j] + d[i][j] * (y[i] - y[j]) * inv);
                        }
                    }
                    x[i] = xNew / wSum[i];
                    y[i] = yNew / wSum[i];
                }
            }
        },
        ExponentialWeightMatrix: function (d, exponent){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(d, "d");
            var w = new Array(d.length);
            for (var i = 0; i < d.length; i++){
                w[i] = new Float64Array(d[i].length);
                for (var j = 0; j < d[i].length; j++){
                    if (d[i][j] > 0)
                        w[i][j] = System.Math.Pow(d[i][j], exponent);
                }
            }
            return w;
        },
        EuclideanDistanceMatrix: function (x, y){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(x, "x");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(y, "y");
            var d = new Array(x.length);
            for (var i = 0; i < x.length; i++){
                d[i] = new Float64Array(x.length);
                for (var j = 0; j < x.length; j++){
                    d[i][j] = System.Math.Sqrt(System.Math.Pow(x[i] - x[j], 2) + System.Math.Pow(y[i] - y[j], 2));
                }
            }
            return d;
        },
        LandmarkClassicalScaling: function (d, x, y, pivotArray){
            var c = new Array(d.length);
            for (var i = 0; i < d.length; i++){
                c[i] = new Float64Array(d.length);
                for (var j = 0; j < d.length; j++){
                    c[i][j] = d[i][pivotArray[j]];
                }
            }
            Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.SquareEntries(c);
            var mean = new Float64Array(d.length);
            for (var i = 0; i < d.length; i++){
                for (var j = 0; j < d.length; j++){
                    mean[i] += c[i][j];
                }
                mean[i] /= d.length;
            }
            Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.DoubleCenter(c);
            Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.Multiply$$Double$Array$Array$$Double(c, -0.5);
            var u1,u2;
            var lambda1,lambda2;
            (function (){
                var $1 = {
                    Value: u1
                };
                var $2 = {
                    Value: lambda1
                };
                var $3 = {
                    Value: u2
                };
                var $4 = {
                    Value: lambda2
                };
                var $res = Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.SpectralDecomposition$$Double$Array$Array$$Double$Array$$Double$$Double$Array$$Double(c, $1, $2, $3, $4);
                u1 = $1.Value;
                lambda1 = $2.Value;
                u2 = $3.Value;
                lambda2 = $4.Value;
                return $res;
            })();
            lambda1 = System.Math.Sqrt(System.Math.Abs$$Double(lambda1));
            lambda2 = System.Math.Sqrt(System.Math.Abs$$Double(lambda2));
            x.Value = new Float64Array(d[0].length);
            y.Value = new Float64Array(d[0].length);
            for (var i = 0; i < x.Value.length; i++){
                for (var j = 0; j < c.length; j++){
                    x.Value[i] -= u1[j] * (System.Math.Pow(d[j][i], 2) - mean[j]) / 2;
                    y.Value[i] -= u2[j] * (System.Math.Pow(d[j][i], 2) - mean[j]) / 2;
                }
            }
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$MultidimensionalScaling);
var Microsoft$Msagl$Layout$MDS$SingleSourceDistances = {
    fullname: "Microsoft.Msagl.Layout.MDS.SingleSourceDistances",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        },
        ComponentGraphs: function (graph, nodeToNodeIndex){
            var nodes = new Array(graph.get_Nodes().get_Count());
            graph.get_Nodes().CopyTo(nodes, 0);
            var basicGraph = new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor$$IEnumerable$1$$Int32(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, graph.get_Edges(), function (edge){
                return !(Is(edge.get_Source(), Microsoft.Msagl.Core.Layout.Cluster.ctor) || Is(edge.get_Target(), Microsoft.Msagl.Core.Layout.Cluster.ctor));
            }), function (edge){
                return new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(nodeToNodeIndex.get_Item$$TKey(edge.get_Source()), nodeToNodeIndex.get_Item$$TKey(edge.get_Target()));
            }), graph.get_Nodes().get_Count());
            var comps = new System.Collections.Generic.List$1.ctor$$IEnumerable$1(System.Collections.Generic.IEnumerable$1.ctor, Microsoft.Msagl.Core.GraphAlgorithms.ConnectedComponentCalculator$1.GetComponents(basicGraph));
            if (comps.get_Count() == 1)
                return [graph];
            var ret = new Array(comps.get_Count());
            var i = 0;
            var $it752 = comps.GetEnumerator();
            while ($it752.MoveNext()){
                var comp = $it752.get_Current();
                ret[i++] = Microsoft.Msagl.Layout.MDS.SingleSourceDistances.GeomGraphFromBasicGraph(comp, nodes);
            }
            return ret;
        },
        GeomGraphFromBasicGraph: function (componentNodeIndices, nodes){
            var geometryGraph = new Microsoft.Msagl.Core.Layout.GeometryGraph.ctor();
            var nodeMap = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Layout.Node.ctor);
            var $it753 = componentNodeIndices.GetEnumerator();
            while ($it753.MoveNext()){
                var v = $it753.get_Current();
                var originalNode = nodes[v];
                var newNode = new Microsoft.Msagl.Core.Layout.Node.ctor$$ICurve(originalNode.get_BoundaryCurve().Clone());
                newNode.set_UserData(originalNode);
                newNode.set_Center(originalNode.get_Center());
                geometryGraph.get_Nodes().Add(newNode);
                nodeMap.set_Item$$TKey(originalNode, newNode);
            }
            var $it754 = componentNodeIndices.GetEnumerator();
            while ($it754.MoveNext()){
                var v = $it754.get_Current();
                var node = nodes[v];
                var $it755 = node.get_OutEdges().GetEnumerator();
                while ($it755.MoveNext()){
                    var e = $it755.get_Current();
                    var ed = new Microsoft.Msagl.Core.Layout.Edge.ctor$$Node$$Node(nodeMap.get_Item$$TKey(e.get_Source()), nodeMap.get_Item$$TKey(e.get_Target()));
                    ed.set_Length(e.get_Length());
                    geometryGraph.get_Edges().Add(ed);
                }
            }
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Layout.MDS.SingleSourceDistances.IsConnected(geometryGraph));
            return geometryGraph;
        },
        IsConnected: function (geometryGraph){
            return System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.GeometryGraph.ctor, Microsoft.Msagl.Core.Layout.GraphConnectedComponents.CreateComponents(geometryGraph.get_Nodes(), geometryGraph.get_Edges())) == 1;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (graph, source, directed){
            this.graph = null;
            this.source = null;
            this.directed = false;
            this._Result = null;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.graph = graph;
            this.source = source;
            this.directed = directed;
        },
        Result$$: "System.Double[]",
        get_Result: function (){
            return this._Result;
        },
        set_Result: function (value){
            this._Result = value;
        },
        RunInternal: function (){
            this.StartListenToLocalProgress(this.graph.get_Nodes().get_Count(), 1);
            this.set_Result(new Float64Array(this.graph.get_Nodes().get_Count()));
            var q = new Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueue$1.ctor(Microsoft.Msagl.Core.Layout.Node.ctor);
            var d = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, System.Double.ctor);
            var $it750 = this.graph.get_Nodes().GetEnumerator();
            while ($it750.MoveNext()){
                var node = $it750.get_Current();
                q.Enqueue(node, Infinity);
                d.set_Item$$TKey(node, Infinity);
            }
            q.DecreasePriority(this.source, 0);
            while (q.get_Count() > 0){
                this.ProgressStep();
                var prio;
                var u = (function (){
                    var $1 = {
                        Value: prio
                    };
                    var $res = q.Dequeue$$Double($1);
                    prio = $1.Value;
                    return $res;
                }).call(this);
                d.set_Item$$TKey(u, prio);
                var enumerator;
                if (this.directed)
                    enumerator = u.get_OutEdges().GetEnumerator();
                else
                    enumerator = u.get_Edges().GetEnumerator();
                while (enumerator.MoveNext()){
                    var uv = enumerator.get_Current();
                    var v = uv.get_Target();
                    if (u == v)
                        v = uv.get_Source();
                    if (d.get_Item$$TKey(v) > d.get_Item$$TKey(u) + uv.get_Length()){
                        d.set_Item$$TKey(v, d.get_Item$$TKey(u) + uv.get_Length());
                        q.DecreasePriority(v, d.get_Item$$TKey(v));
                    }
                }
            }
            var i = 0;
            var $it751 = this.graph.get_Nodes().GetEnumerator();
            while ($it751.MoveNext()){
                var v = $it751.get_Current();
                var dummy;
                if (!(function (){
                    var $1 = {
                        Value: dummy
                    };
                    var $res = d.TryGetValue(v, $1);
                    dummy = $1.Value;
                    return $res;
                }).call(this))
                    dummy = Infinity;
                this.get_Result()[i] = dummy;
                i++;
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$MDS$SingleSourceDistances);
var Microsoft$Msagl$Layout$MDS$MdsGraphLayout = {
    fullname: "Microsoft.Msagl.Layout.MDS.MdsGraphLayout",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        },
        ScaleToAverageEdgeLength: function (g, x, y){
            var index = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, System.Int32.ctor);
            var c = 0;
            var $it756 = g.get_Nodes().GetEnumerator();
            while ($it756.MoveNext()){
                var node = $it756.get_Current();
                index.Add(node, c);
                c++;
            }
            var avgSum = 0,avgLength = 0;
            var $it757 = g.get_Edges().GetEnumerator();
            while ($it757.MoveNext()){
                var edge = $it757.get_Current();
                var i = index.get_Item$$TKey(edge.get_Source());
                var j = index.get_Item$$TKey(edge.get_Target());
                avgSum += System.Math.Sqrt(System.Math.Pow(x[i] - x[j], 2) + System.Math.Pow(y[i] - y[j], 2));
                avgLength += edge.get_Length();
            }
            if (avgLength > 0)
                avgSum /= avgLength;
            if (avgSum > 0)
                for (var i = 0; i < x.length; i++){
                    x[i] /= avgSum;
                    y[i] /= avgSum;
                }
        },
        LayoutGraphWithMds: function (geometryGraph, settings, x, y){
            x.Value = new Float64Array(geometryGraph.get_Nodes().get_Count());
            y.Value = new Float64Array(geometryGraph.get_Nodes().get_Count());
            if (geometryGraph.get_Nodes().get_Count() == 0)
                return;
            if (geometryGraph.get_Nodes().get_Count() == 1){
                x.Value[0] = y.Value[0] = 0;
                return;
            }
            var k = System.Math.Min$$Int32$$Int32(settings.get_PivotNumber(), geometryGraph.get_Nodes().get_Count());
            var iter = settings.get_IterationsWithMajorization();
            var exponent = settings.get_Exponent();
            var pivotArray = new Int32Array(k);
            var pivotDistances = new Microsoft.Msagl.Layout.MDS.PivotDistances.ctor(geometryGraph, false, pivotArray);
            pivotDistances.Run();
            var c = pivotDistances.get_Result();
            Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.LandmarkClassicalScaling(c, x, y, pivotArray);
            Microsoft.Msagl.Layout.MDS.MdsGraphLayout.ScaleToAverageEdgeLength(geometryGraph, x.Value, y.Value);
            if (iter > 0){
                var apd = new Microsoft.Msagl.Layout.MDS.AllPairsDistances.ctor(geometryGraph, false);
                apd.Run();
                var d = apd.get_Result();
                var w = Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.ExponentialWeightMatrix(d, exponent);
                Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.DistanceScalingSubset(d, x.Value, y.Value, w, iter);
            }
        },
        UpdateTree: function (tree){
            if (tree.get_IsLeaf())
                tree.set_Rectangle(tree.get_UserData().get_BoundingBox());
            else {
                Microsoft.Msagl.Layout.MDS.MdsGraphLayout.UpdateTree(tree.get_Left());
                Microsoft.Msagl.Layout.MDS.MdsGraphLayout.UpdateTree(tree.get_Right());
                tree.rectangle = tree.get_Left().rectangle;
                tree.rectangle.Add$$Rectangle(tree.get_Right().rectangle);
            }
        },
        NumberOfHits: function (numberOfChecks, random, tree, maxNumberOfHits){
            var numberOfHits = 0;
            for (var i = 0; i < numberOfChecks; i++){
                var point = (function (){
                    var $1 = {
                        Value: tree.rectangle
                    };
                    var $res = Microsoft.Msagl.Layout.MDS.MdsGraphLayout.RandomPointFromBox(random, $1);
                    tree.rectangle = $1.Value;
                    return $res;
                })();
                if ((tree.FirstHitNode$$Point$$Func$3(point, function (p, t){
                    return Microsoft.Msagl.Core.Geometry.HitTestBehavior.Stop;
                })) != null)
                    numberOfHits++;
                if (numberOfHits == maxNumberOfHits)
                    return maxNumberOfHits;
            }
            return numberOfHits;
        },
        BuildNodeTree: function (nodes){
            return Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnEnumeration(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, nodes, function (n){
                return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(Microsoft.Msagl.Core.Layout.Node.ctor, n, n.get_BoundingBox());
            }));
        },
        RandomPointFromBox: function (random, boundingBox){
            var x = random.NextDouble();
            var y = random.NextDouble();
            var p = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(boundingBox.Value.get_Left() + boundingBox.Value.get_Width() * x, boundingBox.Value.get_Bottom() + boundingBox.Value.get_Height() * y);
            return p;
        },
        PackGraphs: function (components, settings){
            Microsoft.Msagl.Core.ValidateArg.IsNotEmpty$1(Microsoft.Msagl.Core.Layout.GeometryGraph.ctor, components, "components");
            var rectangles = System.Linq.Enumerable.ToList$1(Microsoft.Msagl.Core.Geometry.RectangleToPack$1.ctor, (System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.GeometryGraph.ctor, Microsoft.Msagl.Core.Geometry.RectangleToPack$1.ctor, components, function (c){
                return new Microsoft.Msagl.Core.Geometry.RectangleToPack$1.ctor(Microsoft.Msagl.Core.Layout.GeometryGraph.ctor, c.get_BoundingBox(), c);
            })));
            if (rectangles.get_Count() > 1){
                var packing = settings.get_PackingMethod() == Microsoft.Msagl.Core.Layout.PackingMethod.Compact ? new Microsoft.Msagl.Core.Geometry.OptimalRectanglePacking$1.ctor(Microsoft.Msagl.Core.Layout.GeometryGraph.ctor, rectangles, settings.get_PackingAspectRatio()) : new Microsoft.Msagl.Core.Geometry.OptimalColumnPacking$1.ctor(Microsoft.Msagl.Core.Layout.GeometryGraph.ctor, rectangles, settings.get_PackingAspectRatio());
                packing.Run();
                var $it761 = rectangles.GetEnumerator();
                while ($it761.MoveNext()){
                    var r = $it761.get_Current();
                    var component = r.get_Data();
                    var delta = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(r.get_Rectangle().get_LeftBottom(), component.boundingBox.get_LeftBottom());
                    component.Translate(delta);
                }
                return new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Double$$Double$$Double$$Double(0, 0, packing.get_PackedWidth(), packing.get_PackedHeight());
            }
            return rectangles.get_Item$$Int32(0).get_Rectangle();
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (settings, geometryGraph){
            this.graph = null;
            this.settings = null;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.settings = settings;
            this.graph = geometryGraph;
        },
        RunInternal: function (){
            this.LayoutConnectedComponents();
            this.SetGraphBoundingBox();
        },
        SetGraphBoundingBox: function (){
            this.graph.set_BoundingBox(this.graph.PumpTheBoxToTheGraphWithMargins());
        },
        LayoutConnectedComponents: function (){
            var graphs = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Layout.GeometryGraph.ctor, Microsoft.Msagl.Core.Layout.GraphConnectedComponents.CreateComponents(this.graph.get_Nodes(), this.graph.get_Edges()));
            if (this.settings.RunInParallel){
                var options = new System.Threading.Tasks.ParallelOptions.ctor();
                System.Threading.Tasks.Parallel.ForEach$1$$IEnumerable$1$$ParallelOptions$$Action$1(Microsoft.Msagl.Core.Layout.GeometryGraph.ctor, graphs, options, $CreateDelegate(this, this.LayoutConnectedGraphWithMds));
            }
            else
                for (var i = 0; i < graphs.length; i++){
                    System.Console.WriteLine$$String$$Object("laying out {0} connected component", i);
                    this.LayoutConnectedGraphWithMds(graphs[i]);
                }
            if (graphs.length > 1){
                System.Console.WriteLine$$String("packing");
                Microsoft.Msagl.Layout.MDS.MdsGraphLayout.PackGraphs(graphs, this.settings);
                System.Console.WriteLine$$String("done packing");
                var $it758 = System.Linq.Enumerable.SelectMany$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.GeometryGraph.ctor, Microsoft.Msagl.Core.Layout.Node.ctor, graphs, $CreateAnonymousDelegate(this, function (g){
                    return g.get_Nodes();
                })).GetEnumerator();
                while ($it758.MoveNext()){
                    var node = $it758.get_Current();
                    node.set_GeometryParent(this.graph);
                }
            }
            System.Console.WriteLine$$String("done with LayoutConnectedComponents");
        },
        LayoutConnectedGraphWithMds: function (compGraph){
            System.Console.WriteLine$$String$$Object$$Object("LayoutConnectedGraphWithMds: nodes {0} edges {1}", System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Node.ctor, compGraph.get_Nodes()), System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Edge.ctor, compGraph.get_Edges()));
            var x,y;
            (function (){
                var $1 = {
                    Value: x
                };
                var $2 = {
                    Value: y
                };
                var $res = Microsoft.Msagl.Layout.MDS.MdsGraphLayout.LayoutGraphWithMds(compGraph, this.settings, $1, $2);
                x = $1.Value;
                y = $2.Value;
                return $res;
            }).call(this);
            if (this.settings.get_RotationAngle() != 0)
                Microsoft.Msagl.Layout.MDS.Transform.Rotate(x, y, this.settings.get_RotationAngle());
            var scaleX = this.settings.get_ScaleX();
            var scaleY = this.settings.get_ScaleY();
            var index = 0;
            var $it759 = compGraph.get_Nodes().GetEnumerator();
            while ($it759.MoveNext()){
                var node = $it759.get_Current();
                node.set_Center(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x[index] * scaleX, y[index] * scaleY));
                index++;
                if ((index % 100) == 0){
                    this.ProgressStep();
                }
            }
            if (this.settings.get_AdjustScale())
                this.AdjustScale(compGraph.get_Nodes());
            if (this.settings.get_RemoveOverlaps()){
                switch (this.settings.get_OverlapRemovalMethod()){
                    case Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MST.OverlapRemovalMethod.Prism:
                        Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.RemoveOverlaps(compGraph, this.settings.get_NodeSeparation());
                        break;
                    case Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MST.OverlapRemovalMethod.Pmst:
                        Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MST.OverlapRemoval.RemoveOverlaps(compGraph, this.settings.get_NodeSeparation());
                        break;
                    default:
                        throw $CreateException(new System.ArgumentOutOfRangeException.ctor(), new Error());
                }
            }
            compGraph.set_BoundingBox(compGraph.PumpTheBoxToTheGraphWithMargins());
        },
        AdjustScale: function (nodes){
            if (nodes.get_Count() <= 5)
                return;
            var repetitions = 10;
            var scale = 1;
            var delta = 0.5;
            var tree = Microsoft.Msagl.Layout.MDS.MdsGraphLayout.BuildNodeTree(nodes);
            var random = new System.Random.ctor$$Int32(1);
            do{
                var minNumberOfHits = 6;
                var maxNumberOfHits = 15;
                var numberOfChecks = 100;
                var hits = Microsoft.Msagl.Layout.MDS.MdsGraphLayout.NumberOfHits(numberOfChecks, random, tree, maxNumberOfHits);
                if (hits < minNumberOfHits)
                    scale /= 1 + delta;
                else if (hits > maxNumberOfHits)
                    scale *= 1 + delta;
                else {
                    return;
                }
                delta /= 2;
                this.ScaleNodes(nodes, scale);
                if (repetitions-- == 0)
                    return;
                Microsoft.Msagl.Layout.MDS.MdsGraphLayout.UpdateTree(tree);
            }
            while (true)
        },
        ScaleNodes: function (nodes, scale){
            var i = 0;
            var $it760 = nodes.GetEnumerator();
            while ($it760.MoveNext()){
                var node = $it760.get_Current();
                node.set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(node.get_Center(), scale));
                i++;
                if ((i % 100) == 0)
                    this.ProgressStep();
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$MDS$MdsGraphLayout);
var Microsoft$Msagl$Layout$MDS$Transform = {
    fullname: "Microsoft.Msagl.Layout.MDS.Transform",
    baseTypeName: "System.Object",
    staticDefinition: {
        Rotate: function (x, y, angle){
            var sin = System.Math.Sin(angle * 3.14159265358979 / 180);
            var cos = System.Math.Cos(angle * 3.14159265358979 / 180);
            for (var i = 0; i < x.length; i++){
                var xNew = cos * x[i] + sin * y[i];
                var yNew = cos * y[i] - sin * x[i];
                x[i] = xNew;
                y[i] = yNew;
            }
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$MDS$Transform);
var Microsoft$Msagl$Layout$Layered$AdjacentSwapsWithConstraints = {
    fullname: "Microsoft.Msagl.Layout.Layered.AdjacentSwapsWithConstraints",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Layout.Layered.AdjacentSwapsWithConstraints.maxNumberOfAdjacentExchanges = 50;
        },
        MaxNumberOfAdjacentExchanges$$: "System.Int32",
        get_MaxNumberOfAdjacentExchanges: function (){
            return 50;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (layerArray, hasCrossWeights, properLayeredGraph, layerInfos){
            this.hasCrossWeights = false;
            this.layerInfos = null;
            this.layering = null;
            this.layers = null;
            this.properLayeredGraph = null;
            this.random = new System.Random.ctor$$Int32(1);
            this.X = null;
            this.inCrossingCount = null;
            this.outCrossingCount = null;
            this.P = null;
            this.POrder = null;
            this.S = null;
            this.SOrder = null;
            System.Object.ctor.call(this);
            this.X = layerArray.get_X();
            this.layering = layerArray.Y;
            this.layers = layerArray.get_Layers();
            this.properLayeredGraph = properLayeredGraph;
            this.hasCrossWeights = hasCrossWeights;
            this.layerInfos = layerInfos;
        },
        ExchangeWithGainWithNoDisturbance: function (layer){
            var wasGain = false;
            var gain;
            do{
                gain = this.ExchangeWithGain(layer);
                wasGain = wasGain || gain;
            }
            while (gain)
            return wasGain;
        },
        CanSwap: function (i, j){
            if (this.IsVirtualNode(i) || this.IsVirtualNode(j))
                return true;
            var layerInfo = this.layerInfos[this.layering[i]];
            if (layerInfo == null)
                return true;
            if (Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.BelongsToNeighbBlock(i, layerInfo) || Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.BelongsToNeighbBlock(j, layerInfo) || layerInfo.constrainedFromAbove.ContainsKey(i) || layerInfo.constrainedFromBelow.ContainsKey(j))
                return false;
            if (layerInfo.leftRight.Contains$$T(new System.Tuple$2.ctor(System.Int32.ctor, System.Int32.ctor, i, j)))
                return false;
            return true;
        },
        IsVirtualNode: function (v){
            return this.properLayeredGraph.IsVirtualNode(v);
        },
        SwapWithGain: function (u, v){
            var gain = this.SwapGain(u, v);
            if (gain > 0){
                this.Swap(u, v);
                return true;
            }
            return false;
        },
        SwapGain: function (u, v){
            if (!this.CanSwap(u, v))
                return -1;
            var cuv;
            var cvu;
            (function (){
                var $1 = {
                    Value: cuv
                };
                var $2 = {
                    Value: cvu
                };
                var $res = this.CalcPair(u, v, $1, $2);
                cuv = $1.Value;
                cvu = $2.Value;
                return $res;
            }).call(this);
            return cuv - cvu;
        },
        CalcPair: function (u, v, cuv, cvu){
            var su = this.S[u],sv = this.S[v],pu = this.P[u],pv = this.P[v];
            if (!this.hasCrossWeights){
                cuv.Value = this.CountOnArrays$$Int32$Array$$Int32$Array(su, sv) + this.CountOnArrays$$Int32$Array$$Int32$Array(pu, pv);
                cvu.Value = this.CountOnArrays$$Int32$Array$$Int32$Array(sv, su) + this.CountOnArrays$$Int32$Array$$Int32$Array(pv, pu);
            }
            else {
                var uOutCrossCounts = this.outCrossingCount[u];
                var vOutCrossCounts = this.outCrossingCount[v];
                var uInCrossCounts = this.inCrossingCount[u];
                var vInCrossCounts = this.inCrossingCount[v];
                cuv.Value = this.CountOnArrays$$Int32$Array$$Int32$Array$$Dictionary$2$Int32$Int32$$Dictionary$2$Int32$Int32(su, sv, uOutCrossCounts, vOutCrossCounts) + this.CountOnArrays$$Int32$Array$$Int32$Array$$Dictionary$2$Int32$Int32$$Dictionary$2$Int32$Int32(pu, pv, uInCrossCounts, vInCrossCounts);
                cvu.Value = this.CountOnArrays$$Int32$Array$$Int32$Array$$Dictionary$2$Int32$Int32$$Dictionary$2$Int32$Int32(sv, su, vOutCrossCounts, uOutCrossCounts) + this.CountOnArrays$$Int32$Array$$Int32$Array$$Dictionary$2$Int32$Int32$$Dictionary$2$Int32$Int32(pv, pu, vInCrossCounts, uInCrossCounts);
            }
        },
        CountOnArrays$$Int32$Array$$Int32$Array: function (unbs, vnbs){
            var ret = 0;
            var vl = vnbs.length - 1;
            var j = -1;
            var vnbsSeenAlready = 0;
            for (var $i763 = 0,$l763 = unbs.length,uNeighbor = unbs[$i763]; $i763 < $l763; $i763++, uNeighbor = unbs[$i763]){
                var xu = this.X[uNeighbor];
                for (; j < vl && this.X[vnbs[j + 1]] < xu; j++)
                    vnbsSeenAlready++;
                ret += vnbsSeenAlready;
            }
            return ret;
        },
        CountOnArrays$$Int32$Array$$Int32$Array$$Dictionary$2$Int32$Int32$$Dictionary$2$Int32$Int32: function (unbs, vnbs, uCrossingCounts, vCrossingCount){
            var ret = 0;
            var vl = vnbs.length - 1;
            var j = -1;
            var vCrossingNumberSeenAlready = 0;
            for (var $i764 = 0,$l764 = unbs.length,uNeib = unbs[$i764]; $i764 < $l764; $i764++, uNeib = unbs[$i764]){
                var xu = this.X[uNeib];
                var vnb;
                for (; j < vl && this.X[vnb = vnbs[j + 1]] < xu; j++)
                    vCrossingNumberSeenAlready += vCrossingCount.get_Item$$TKey(vnb);
                ret += vCrossingNumberSeenAlready * uCrossingCounts.get_Item$$TKey(uNeib);
            }
            return ret;
        },
        Swap: function (u, v){
            var left = this.X[u];
            var right = this.X[v];
            var ln = this.layering[u];
            var layer = this.layers[ln];
            layer[left] = v;
            layer[right] = u;
            this.X[u] = right;
            this.X[v] = left;
            this.UpdateSsContainingUV(u, v);
            this.UpdatePsContainingUV(u, v);
        },
        ExchangeWithGain: function (layer){
            for (var i = 0; i < layer.length - 1; i++)
                if (this.SwapWithGain(layer[i], layer[i + 1])){
                    this.SwapToTheLeft(layer, i);
                    this.SwapToTheRight(layer, i + 1);
                    return true;
                }
            return false;
        },
        HeadOfTheCoin: function (){
            return this.random.Next$$Int32(2) == 0;
        },
        DoSwaps: function (){
            this.InitArrays();
            var count = 0;
            var progress = true;
            while (progress && count++ < Microsoft.Msagl.Layout.Layered.AdjacentSwapsWithConstraints.get_MaxNumberOfAdjacentExchanges()){
                progress = false;
                for (var i = 0; i < this.layers.length; i++)
                    progress = this.AdjExchangeLayer(i) || progress;
                for (var i = this.layers.length - 2; i >= 0; i--)
                    progress = this.AdjExchangeLayer(i) || progress;
            }
        },
        InitArrays: function (){
            if (this.S == null)
                this.AllocArrays();
            for (var i = 0; i < this.properLayeredGraph.get_NodeCount(); i++){
                this.POrder[i].Clear();
                this.SOrder[i].Clear();
            }
            for (var i = 0; i < this.layers.length; i++)
                this.InitPSArraysForLayer(this.layers[i]);
        },
        DisturbLayer: function (layer){
            for (var i = 0; i < layer.length - 1; i++)
                this.AdjacentSwapToTheRight(layer, i);
        },
        AdjExchangeLayer: function (i){
            var layer = this.layers[i];
            var gain = this.ExchangeWithGainWithNoDisturbance(layer);
            if (gain)
                return true;
            this.DisturbLayer(layer);
            return this.ExchangeWithGainWithNoDisturbance(layer);
        },
        AllocArrays: function (){
            var n = this.properLayeredGraph.get_NodeCount();
            this.P = new Array(n);
            this.S = new Array(n);
            this.POrder = new Array(n);
            this.SOrder = new Array(n);
            if (this.hasCrossWeights){
                this.outCrossingCount = new Array(n);
                this.inCrossingCount = new Array(n);
            }
            for (var i = 0; i < n; i++){
                var count = this.properLayeredGraph.InEdgesCount(i);
                this.P[i] = new Int32Array(count);
                if (this.hasCrossWeights){
                    var inCounts = this.inCrossingCount[i] = new System.Collections.Generic.Dictionary$2.ctor$$Int32(System.Int32.ctor, System.Int32.ctor, count);
                    var $it764 = this.properLayeredGraph.InEdges(i).GetEnumerator();
                    while ($it764.MoveNext()){
                        var le = $it764.get_Current();
                        inCounts.set_Item$$TKey(le.get_Source(), le.get_CrossingWeight());
                    }
                }
                this.POrder[i] = new System.Collections.Generic.Dictionary$2.ctor$$Int32(System.Int32.ctor, System.Int32.ctor, count);
                count = this.properLayeredGraph.OutEdgesCount(i);
                this.S[i] = new Int32Array(count);
                this.SOrder[i] = new System.Collections.Generic.Dictionary$2.ctor$$Int32(System.Int32.ctor, System.Int32.ctor, count);
                if (this.hasCrossWeights){
                    var outCounts = this.outCrossingCount[i] = new System.Collections.Generic.Dictionary$2.ctor$$Int32(System.Int32.ctor, System.Int32.ctor, count);
                    var $it765 = this.properLayeredGraph.OutEdges(i).GetEnumerator();
                    while ($it765.MoveNext()){
                        var le = $it765.get_Current();
                        outCounts.set_Item$$TKey(le.get_Target(), le.get_CrossingWeight());
                    }
                }
            }
        },
        UpdatePsContainingUV: function (u, v){
            if (this.S[u].length <= this.S[v].length)
                for (var $i767 = 0,$t767 = this.S[u],$l767 = $t767.length,a = $t767[$i767]; $i767 < $l767; $i767++, a = $t767[$i767]){
                    var porder = this.POrder[a];
                    if (porder.ContainsKey(v)){
                        var vOffset = porder.get_Item$$TKey(v);
                        var p = this.P[a];
                        p[vOffset - 1] = v;
                        p[vOffset] = u;
                        porder.set_Item$$TKey(v, vOffset - 1);
                        porder.set_Item$$TKey(u, vOffset);
                    }
                }
            else
                for (var $i768 = 0,$t768 = this.S[v],$l768 = $t768.length,a = $t768[$i768]; $i768 < $l768; $i768++, a = $t768[$i768]){
                    var porder = this.POrder[a];
                    if (porder.ContainsKey(u)){
                        var vOffset = porder.get_Item$$TKey(v);
                        var p = this.P[a];
                        p[vOffset - 1] = v;
                        p[vOffset] = u;
                        porder.set_Item$$TKey(v, vOffset - 1);
                        porder.set_Item$$TKey(u, vOffset);
                    }
                }
        },
        SwapToTheRight: function (layer, i){
            for (var j = i; j < layer.length - 1; j++)
                this.AdjacentSwapToTheRight(layer, j);
        },
        SwapToTheLeft: function (layer, i){
            for (var j = i - 1; j >= 0; j--)
                this.AdjacentSwapToTheRight(layer, j);
        },
        AdjacentSwapToTheRight: function (layer, i){
            var u = layer[i],v = layer[i + 1];
            var gain = this.SwapGain(u, v);
            if (gain > 0 || (gain == 0 && this.HeadOfTheCoin())){
                this.Swap(u, v);
                return;
            }
        },
        InitPSArraysForLayer: function (layer){
            for (var $i769 = 0,$l769 = layer.length,l = layer[$i769]; $i769 < $l769; $i769++, l = layer[$i769]){
                var $it769 = this.properLayeredGraph.Pred(l).GetEnumerator();
                while ($it769.MoveNext()){
                    var p = $it769.get_Current();
                    var so = this.SOrder[p];
                    var sHasNow = so.get_Count();
                    this.S[p][sHasNow] = l;
                    so.set_Item$$TKey(l, sHasNow);
                }
                var $it770 = this.properLayeredGraph.Succ(l).GetEnumerator();
                while ($it770.MoveNext()){
                    var s = $it770.get_Current();
                    var po = this.POrder[s];
                    var pHasNow = po.get_Count();
                    this.P[s][pHasNow] = l;
                    po.set_Item$$TKey(l, pHasNow);
                }
            }
        },
        UpdateSsContainingUV: function (u, v){
            if (this.P[u].length <= this.P[v].length)
                for (var $i772 = 0,$t772 = this.P[u],$l772 = $t772.length,a = $t772[$i772]; $i772 < $l772; $i772++, a = $t772[$i772]){
                    var sorder = this.SOrder[a];
                    if (sorder.ContainsKey(v)){
                        var vOffset = sorder.get_Item$$TKey(v);
                        var s = this.S[a];
                        s[vOffset - 1] = v;
                        s[vOffset] = u;
                        sorder.set_Item$$TKey(v, vOffset - 1);
                        sorder.set_Item$$TKey(u, vOffset);
                    }
                }
            else
                for (var $i773 = 0,$t773 = this.P[v],$l773 = $t773.length,a = $t773[$i773]; $i773 < $l773; $i773++, a = $t773[$i773]){
                    var sorder = this.SOrder[a];
                    if (sorder.ContainsKey(u)){
                        var vOffset = sorder.get_Item$$TKey(v);
                        var s = this.S[a];
                        s[vOffset - 1] = v;
                        s[vOffset] = u;
                        sorder.set_Item$$TKey(v, vOffset - 1);
                        sorder.set_Item$$TKey(u, vOffset);
                    }
                }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$AdjacentSwapsWithConstraints);
var Microsoft$Msagl$Layout$Layered$ConstrainedOrdering = {
    fullname: "Microsoft.Msagl.Layout.Layered.ConstrainedOrdering",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.MaxNumberOfNoGainSteps = 5;
            Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.ConstrainedVarWeight = 10000000;
            Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.PositionOverBaricenterWeight = 5;
        },
        ExistsShortMultiEdge: function (layering, multiedges){
            return System.Linq.Enumerable.Any$1$$IEnumerable$1$$Func$2(System.Collections.Generic.KeyValuePair$2.ctor, multiedges, function (multiedge){
                return multiedge.get_Value().get_Count() > 2 && layering[multiedge.get_Key().x] == 1 + layering[multiedge.get_Key().y];
            });
        },
        ExistsShortLabeledEdge: function (layering, edges){
            return System.Linq.Enumerable.Any$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Layout.Layered.IntEdge.ctor, edges, function (edge){
                return layering[edge.get_Source()] == layering[edge.get_Target()] + 1 && edge.get_Edge().get_Label() != null;
            });
        },
        CreateComponentRootsToComponentsMap: function (nodesToVerticalComponentsRoots){
            var d = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, System.Collections.Generic.List$1.ctor);
            var $it782 = nodesToVerticalComponentsRoots.GetEnumerator();
            while ($it782.MoveNext()){
                var kv = $it782.get_Current();
                var i = kv.get_Key();
                var root = kv.get_Value();
                var component;
                if (!(function (){
                    var $1 = {
                        Value: component
                    };
                    var $res = d.TryGetValue(root, $1);
                    component = $1.Value;
                    return $res;
                })()){
                    d.set_Item$$TKey(root, component = new System.Collections.Generic.List$1.ctor(System.Int32.ctor));
                }
                component.Add(i);
            }
            return d;
        },
        GetFromDictionaryOrIdentical: function (d, key){
            var i;
            if ((function (){
                var $1 = {
                    Value: i
                };
                var $res = d.TryGetValue(key, $1);
                i = $1.Value;
                return $res;
            })())
                return i;
            return key;
        },
        AddBlocksToLayer: function (collapsedSortedLayer, blockRootToList){
            var $yield = [];
            var $it791 = collapsedSortedLayer.GetEnumerator();
            while ($it791.MoveNext()){
                var i = $it791.get_Current();
                $yield.push(i);
                var list;
                if (blockRootToList != null && (function (){
                    var $1 = {
                        Value: list
                    };
                    var $res = blockRootToList.TryGetValue(i, $1);
                    list = $1.Value;
                    return $res;
                })()){
                    var $it792 = list.GetEnumerator();
                    while ($it792.MoveNext()){
                        var j = $it792.get_Current();
                        $yield.push(j);
                    }
                }
            }
            return $yield;
        },
        NodeToBlockRootSoftOnLayerInfo: function (layerInfo, node){
            var root;
            return (function (){
                var $1 = {
                    Value: root
                };
                var $res = layerInfo.nodeToBlockRoot.TryGetValue(node, $1);
                root = $1.Value;
                return $res;
            })() ? root : node;
        },
        AddGoalToKeepFlatEdgesShortOnBlockLevel: function (layerInfo, solver){
            if (layerInfo != null){
                var $it795 = layerInfo.flatEdges.GetEnumerator();
                while ($it795.MoveNext()){
                    var couple = $it795.get_Current();
                    var sourceBlockRoot = Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.NodeToBlockRootSoftOnLayerInfo(layerInfo, couple.get_Item1());
                    var targetBlockRoot = Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.NodeToBlockRootSoftOnLayerInfo(layerInfo, couple.get_Item2());
                    if (sourceBlockRoot != targetBlockRoot)
                        solver.AddGoalTwoVariablesAreClose$$Int32$$Int32(sourceBlockRoot, targetBlockRoot);
                }
            }
        },
        GetFixedBlockNode: function (blockRoot, layerInfo, sweepMode){
            if (sweepMode == Microsoft.Msagl.Layout.Layered.SweepMode.Starting)
                return -1;
            if (sweepMode == Microsoft.Msagl.Layout.Layered.SweepMode.ComingFromBelow)
                return Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.GetFixedBlockNodeFromBelow(blockRoot, layerInfo);
            return Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.GetFixedBlockNodeFromAbove(blockRoot, layerInfo);
        },
        GetFixedBlockNodeFromBelow: function (blockRoot, layerInfo){
            if (layerInfo.constrainedFromBelow.ContainsKey(blockRoot))
                return blockRoot;
            var $it796 = layerInfo.neigBlocks.get_Item$$TKey(blockRoot).GetEnumerator();
            while ($it796.MoveNext()){
                var v = $it796.get_Current();
                if (layerInfo.constrainedFromBelow.ContainsKey(v))
                    return v;
            }
            return -1;
        },
        GetFixedBlockNodeFromAbove: function (blockRoot, layerInfo){
            if (layerInfo.constrainedFromAbove.ContainsKey(blockRoot))
                return blockRoot;
            var $it797 = layerInfo.neigBlocks.get_Item$$TKey(blockRoot).GetEnumerator();
            while ($it797.MoveNext()){
                var v = $it797.get_Current();
                if (layerInfo.constrainedFromAbove.ContainsKey(v))
                    return v;
            }
            return -1;
        },
        NodeIsConstrainedBelow: function (v, layerInfo){
            if (layerInfo == null)
                return false;
            return layerInfo.constrainedFromBelow.ContainsKey(v);
        },
        NodeIsConstrainedAbove: function (v, layerInfo){
            if (layerInfo == null)
                return false;
            return layerInfo.constrainedFromAbove.ContainsKey(v);
        },
        BelongsToNeighbBlock: function (p, layerInfo){
            return layerInfo != null && (layerInfo.nodeToBlockRoot.ContainsKey(p) || layerInfo.neigBlocks.ContainsKey(p));
        },
        NodesAreConstrainedBelow: function (leftNode, rightNode, layerInfo){
            return Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.NodeIsConstrainedBelow(leftNode, layerInfo) && Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.NodeIsConstrainedBelow(rightNode, layerInfo);
        },
        NodesAreConstrainedAbove: function (leftNode, rightNode, layerInfo){
            return Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.NodeIsConstrainedAbove(leftNode, layerInfo) && Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.NodeIsConstrainedAbove(rightNode, layerInfo);
        },
        NodeIsConstrained: function (v, sweepMode, layerInfo){
            if (sweepMode == Microsoft.Msagl.Layout.Layered.SweepMode.Starting)
                return false;
            return sweepMode == Microsoft.Msagl.Layout.Layered.SweepMode.ComingFromAbove && Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.NodeIsConstrainedAbove(v, layerInfo) || sweepMode == Microsoft.Msagl.Layout.Layered.SweepMode.ComingFromBelow && Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.NodeIsConstrainedBelow(v, layerInfo);
        },
        CreateSolver: function (){
            return new Microsoft.Msagl.Core.ProjectionSolver.SolverShell.ctor();
        },
        TryGetBlockRoot: function (v, blockRoot, layerInfo){
            if (layerInfo.nodeToBlockRoot.TryGetValue(v, blockRoot))
                return true;
            if (layerInfo.neigBlocks.ContainsKey(v)){
                blockRoot.Value = v;
                return true;
            }
            return false;
        },
        VertConstrainedNodesOfLayer: function (layerInfo){
            var $yield = [];
            if (layerInfo != null){
                var $it800 = layerInfo.constrainedFromAbove.get_Keys().GetEnumerator();
                while ($it800.MoveNext()){
                    var v = $it800.get_Current();
                    $yield.push(v);
                }
                var $it801 = layerInfo.constrainedFromBelow.get_Keys().GetEnumerator();
                while ($it801.MoveNext()){
                    var v = $it801.get_Current();
                    $yield.push(v);
                }
            }
            return $yield;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (geomGraph, basicIntGraph, layering, nodeIdToIndex, database, settings){
            this.geometryGraph = null;
            this.intGraph = null;
            this.ProperLayeredGraph = null;
            this.initialLayering = null;
            this.layerInfos = null;
            this.LayerArrays = null;
            this.horizontalConstraints = null;
            this.numberOfNodesOfProperGraph = 0;
            this.database = null;
            this.xPositions = null;
            this.xPositionsClone = null;
            this.yetBestLayers = null;
            this.verticalEdges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Layout.Layered.IntEdge.ctor);
            this.adjSwapper = null;
            this.settings = null;
            this.numberOfLayers = -1;
            this.noGainSteps = 0;
            this._LayersAreDoubled = false;
            System.Object.ctor.call(this);
            this.settings = settings;
            this.horizontalConstraints = settings.get_HorizontalConstraints();
            this.horizontalConstraints.PrepareForOrdering(nodeIdToIndex, layering);
            this.geometryGraph = geomGraph;
            this.database = database;
            this.intGraph = basicIntGraph;
            this.initialLayering = layering;
            if (this.NeedToInsertLayers(layering)){
                for (var i = 0; i < layering.length; i++)
                    layering[i] *= 2;
                this.set_LayersAreDoubled(true);
                this.numberOfLayers = -1;
            }
            this.PrepareProperLayeredGraphAndFillLayerInfos();
            this.adjSwapper = new Microsoft.Msagl.Layout.Layered.AdjacentSwapsWithConstraints.ctor(this.LayerArrays, this.HasCrossWeights(), this.ProperLayeredGraph, this.layerInfos);
        },
        NumberOfLayers$$: "System.Int32",
        get_NumberOfLayers: function (){
            if (this.numberOfLayers > 0)
                return this.numberOfLayers;
            return this.numberOfLayers = System.Linq.Enumerable.Max$1$$IEnumerable$1$$Func$2(System.Int32.ctor, this.initialLayering, $CreateAnonymousDelegate(this, function (i){
                return i + 1;
            }));
        },
        NodeSeparation: function (){
            return this.settings.get_NodeSeparation();
        },
        GetNodeWidth: function (p){
            return this.database.anchors[p].get_Width();
        },
        LayersAreDoubled$$: "System.Boolean",
        get_LayersAreDoubled: function (){
            return this._LayersAreDoubled;
        },
        set_LayersAreDoubled: function (value){
            this._LayersAreDoubled = value;
        },
        NeedToInsertLayers: function (layering){
            return Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.ExistsShortLabeledEdge(layering, this.intGraph.get_Edges()) || Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.ExistsShortMultiEdge(layering, this.database.get_Multiedges());
        },
        Calculate: function (){
            this.AllocateXPositions();
            var originalGraph = As(this.intGraph.get_Nodes().get_Item$$Int32(0).get_GeometryParent(), Microsoft.Msagl.Core.Layout.GeometryGraph.ctor);
            (function (){
                var $1 = {
                    Value: this.database.anchors
                };
                var $res = Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.CalculateAnchorSizes(this.database, $1, this.ProperLayeredGraph, originalGraph, this.intGraph, this.settings);
                this.database.anchors = $1.Value;
                return $res;
            }).call(this);
            Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.CalcInitialYAnchorLocations(this.LayerArrays, 500, this.geometryGraph, this.database, this.intGraph, this.settings, this.get_LayersAreDoubled());
            this.Order();
        },
        CreateMeasure: function (){
            return new Microsoft.Msagl.Layout.Layered.ConstrainedOrderMeasure.ctor(Microsoft.Msagl.Layout.Layered.Ordering.GetCrossingsTotal(this.ProperLayeredGraph, this.LayerArrays));
        },
        GetDeviationFromConstraints: function (){
            return System.Linq.Enumerable.Sum$1$$IEnumerable$1$$Func$2(System.Tuple$2.ctor, this.horizontalConstraints.VerticalInts, $CreateAnonymousDelegate(this, function (c){
                return this.VerticalDeviationOfCouple(c);
            })) + System.Linq.Enumerable.Sum$1$$IEnumerable$1$$Func$2(System.Tuple$2.ctor, this.horizontalConstraints.LeftRighInts, $CreateAnonymousDelegate(this, function (c){
                return this.LeftRightConstraintDeviation(c);
            }));
        },
        LeftRightConstraintDeviation: function (couple){
            var l = this.XPosition(couple.get_Item1());
            var r = this.XPosition(couple.get_Item2());
            return System.Math.Max$$Double$$Double(0, l - r);
        },
        VerticalDeviationOfCouple: function (couple){
            return System.Math.Abs$$Double(this.XPosition(couple.get_Item1()) - this.XPosition(couple.get_Item2()));
        },
        HasCrossWeights: function (){
            return System.Linq.Enumerable.Any$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Layout.Layered.LayerEdge.ctor, this.ProperLayeredGraph.get_Edges(), $CreateAnonymousDelegate(this, function (le){
                return le.get_CrossingWeight() != 1;
            }));
        },
        AllocateXPositions: function (){
            this.xPositions = new Array(this.get_NumberOfLayers());
            for (var i = 0; i < this.get_NumberOfLayers(); i++)
                this.xPositions[i] = new Float64Array(this.LayerArrays.get_Layers()[i].length);
        },
        BlockWidth: function (blockRoot){
            return this.GetNodeWidth(blockRoot) + System.Linq.Enumerable.Sum$1$$IEnumerable$1$$Func$2(System.Int32.ctor, this.horizontalConstraints.BlockRootToBlock.get_Item$$TKey(blockRoot), $CreateAnonymousDelegate(this, function (l){
                return this.GetNodeWidth(l) + this.settings.get_NodeSeparation();
            }));
        },
        Order: function (){
            this.CreateInitialOrderInLayers();
            this.TryPushingOutStrangersFromHorizontalBlocks();
            var n = 5;
            var measure = null;
            while (n-- > 0 && this.noGainSteps <= 5){
                this.SetXPositions();
                var newMeasure = this.CreateMeasure();
                if (measure == null || Microsoft.Msagl.Layout.Layered.ConstrainedOrderMeasure.op_LessThan(newMeasure, measure)){
                    this.noGainSteps = 0;
                    (function (){
                        var $1 = {
                            Value: this.yetBestLayers
                        };
                        var $res = Microsoft.Msagl.Layout.Layered.Ordering.CloneLayers(this.LayerArrays.get_Layers(), $1);
                        this.yetBestLayers = $1.Value;
                        return $res;
                    }).call(this);
                    measure = newMeasure;
                }
                else {
                    this.noGainSteps++;
                    this.RestoreState();
                }
            }
        },
        SetXPositions: function (){
            var solver = this.InitSolverWithoutOrder();
            this.ImproveWithAdjacentSwaps();
            this.PutLayerNodeSeparationsIntoSolver(solver);
            solver.Solve();
            this.SortLayers(solver);
            for (var i = 0; i < this.LayerArrays.Y.length; i++)
                this.database.get_Anchors()[i].set_X(solver.GetVariableResolvedPosition(i));
        },
        InitSolverWithoutOrder: function (){
            var solver = Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.CreateSolver();
            this.InitSolverVars(solver);
            this.PutLeftRightConstraintsIntoSolver(solver);
            this.PutVerticalConstraintsIntoSolver(solver);
            this.AddGoalsToKeepProperEdgesShort(solver);
            this.AddGoalsToKeepFlatEdgesShort(solver);
            return solver;
        },
        SortLayers: function (solver){
            for (var i = 0; i < this.LayerArrays.get_Layers().length; i++)
                this.SortLayerBasedOnSolution(this.LayerArrays.get_Layers()[i], solver);
        },
        AddGoalsToKeepFlatEdgesShort: function (solver){
            for (var $i774 = 0,$t774 = this.layerInfos,$l774 = $t774.length,layerInfo = $t774[$i774]; $i774 < $l774; $i774++, layerInfo = $t774[$i774])
                Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.AddGoalToKeepFlatEdgesShortOnBlockLevel(layerInfo, solver);
        },
        InitSolverVars: function (solver){
            for (var i = 0; i < this.LayerArrays.Y.length; i++)
                solver.AddVariableWithIdealPosition$$Int32$$Double(i, 0);
        },
        AddGoalsToKeepProperEdgesShort: function (solver){
            var $it774 = this.ProperLayeredGraph.get_Edges().GetEnumerator();
            while ($it774.MoveNext()){
                var edge = $it774.get_Current();
                solver.AddGoalTwoVariablesAreClose$$Int32$$Int32$$Double(edge.get_Source(), edge.get_Target(), 5);
            }
        },
        PutVerticalConstraintsIntoSolver: function (solver){
            var $it775 = this.horizontalConstraints.VerticalInts.GetEnumerator();
            while ($it775.MoveNext()){
                var pair = $it775.get_Current();
                solver.AddGoalTwoVariablesAreClose$$Int32$$Int32$$Double(pair.get_Item1(), pair.get_Item2(), 10000000);
            }
        },
        PutLeftRightConstraintsIntoSolver: function (solver){
            var $it776 = this.horizontalConstraints.LeftRighInts.GetEnumerator();
            while ($it776.MoveNext()){
                var pair = $it776.get_Current();
                solver.AddLeftRightSeparationConstraint$$Int32$$Int32$$Double(pair.get_Item1(), pair.get_Item2(), this.SimpleGapBetweenTwoNodes(pair.get_Item1(), pair.get_Item2()));
            }
        },
        PutLayerNodeSeparationsIntoSolver: function (solver){
            for (var $i778 = 0,$t778 = this.LayerArrays.get_Layers(),$l778 = $t778.length,layer = $t778[$i778]; $i778 < $l778; $i778++, layer = $t778[$i778]){
                for (var i = 0; i < layer.length - 1; i++){
                    var l = layer[i];
                    var r = layer[i + 1];
                    solver.AddLeftRightSeparationConstraint$$Int32$$Int32$$Double(l, r, this.SimpleGapBetweenTwoNodes(l, r));
                }
            }
        },
        ImproveWithAdjacentSwaps: function (){
            this.adjSwapper.DoSwaps();
        },
        TryPushingOutStrangersFromHorizontalBlocks: function (){
        },
        CreateInitialOrderInLayers: function (){
            var nodesToVerticalComponentsRoots = this.CreateVerticalComponents();
            var liftedLeftRightRelations = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, this.LiftLeftRightRelationsToComponentRoots(nodesToVerticalComponentsRoots));
            var orderOfVerticalComponentRoots = Microsoft.Msagl.Core.GraphAlgorithms.TopologicalSort.GetOrderOnEdges$1(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, liftedLeftRightRelations);
            this.FillLayersWithVerticalComponentsOrder(orderOfVerticalComponentRoots, nodesToVerticalComponentsRoots);
            this.LayerArrays.UpdateXFromLayers();
        },
        FillLayersWithVerticalComponentsOrder: function (order, nodesToVerticalComponentsRoots){
            var componentRootsToComponents = Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.CreateComponentRootsToComponentsMap(nodesToVerticalComponentsRoots);
            var alreadyInLayers = new Array(this.LayerArrays.Y.length);
            var runninglayerCounts = new Int32Array(this.LayerArrays.get_Layers().length);
            for (var $i779 = 0,$l779 = order.length,vertCompRoot = order[$i779]; $i779 < $l779; $i779++, vertCompRoot = order[$i779])
                this.PutVerticalComponentIntoLayers(this.EnumerateVertComponent(componentRootsToComponents, vertCompRoot), runninglayerCounts, alreadyInLayers);
            for (var i = 0; i < this.ProperLayeredGraph.get_NodeCount(); i++)
                if (alreadyInLayers[i] == false)
                    this.AddVertToLayers(i, runninglayerCounts, alreadyInLayers);
        },
        EnumerateVertComponent: function (componentRootsToComponents, vertCompRoot){
            var $yield = [];
            var compList;
            if ((function (){
                var $1 = {
                    Value: compList
                };
                var $res = componentRootsToComponents.TryGetValue(vertCompRoot, $1);
                compList = $1.Value;
                return $res;
            }).call(this)){
                var $it779 = compList.GetEnumerator();
                while ($it779.MoveNext()){
                    var i = $it779.get_Current();
                    $yield.push(i);
                }
            }
            else
                $yield.push(vertCompRoot);
            return $yield;
        },
        PutVerticalComponentIntoLayers: function (vertComponent, runningLayerCounts, alreadyInLayers){
            var $it780 = vertComponent.GetEnumerator();
            while ($it780.MoveNext()){
                var i = $it780.get_Current();
                this.AddVertToLayers(i, runningLayerCounts, alreadyInLayers);
            }
        },
        AddVertToLayers: function (i, runningLayerCounts, alreadyInLayers){
            if (alreadyInLayers[i])
                return;
            var layerIndex = this.LayerArrays.Y[i];
            var xIndex = runningLayerCounts[layerIndex];
            var layer = this.LayerArrays.get_Layers()[layerIndex];
            layer[xIndex++] = i;
            alreadyInLayers[i] = true;
            var block;
            if ((function (){
                var $1 = {
                    Value: block
                };
                var $res = this.horizontalConstraints.BlockRootToBlock.TryGetValue(i, $1);
                block = $1.Value;
                return $res;
            }).call(this)){
                var $it781 = block.GetEnumerator();
                while ($it781.MoveNext()){
                    var v = $it781.get_Current();
                    if (alreadyInLayers[v])
                        continue;
                    layer[xIndex++] = v;
                    alreadyInLayers[v] = true;
                }
            }
            runningLayerCounts[layerIndex] = xIndex;
        },
        LiftLeftRightRelationsToComponentRoots: function (nodesToVerticalComponentsRoots){
            var $yield = [];
            var $it783 = this.horizontalConstraints.LeftRighInts.GetEnumerator();
            while ($it783.MoveNext()){
                var pair = $it783.get_Current();
                $yield.push(new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.GetFromDictionaryOrIdentical(nodesToVerticalComponentsRoots, pair.get_Item1()), Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.GetFromDictionaryOrIdentical(nodesToVerticalComponentsRoots, pair.get_Item2())));
            }
            var $it784 = this.horizontalConstraints.LeftRightIntNeibs.GetEnumerator();
            while ($it784.MoveNext()){
                var pair = $it784.get_Current();
                $yield.push(new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.GetFromDictionaryOrIdentical(nodesToVerticalComponentsRoots, pair.get_Item1()), Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.GetFromDictionaryOrIdentical(nodesToVerticalComponentsRoots, pair.get_Item2())));
            }
            return $yield;
        },
        CreateVerticalComponents: function (){
            var vertGraph = new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor$$IEnumerable$1(Microsoft.Msagl.Layout.Layered.IntEdge.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.Tuple$2.ctor, Microsoft.Msagl.Layout.Layered.IntEdge.ctor, this.horizontalConstraints.VerticalInts, $CreateAnonymousDelegate(this, function (pair){
                return new Microsoft.Msagl.Layout.Layered.IntEdge.ctor$$Int32$$Int32(pair.get_Item1(), pair.get_Item2());
            })));
            var verticalComponents = Microsoft.Msagl.Core.GraphAlgorithms.ConnectedComponentCalculator$1.GetComponents(vertGraph);
            var nodesToComponentRoots = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, System.Int32.ctor);
            var $it785 = verticalComponents.GetEnumerator();
            while ($it785.MoveNext()){
                var component = $it785.get_Current();
                var ca = System.Linq.Enumerable.ToArray$1(System.Int32.ctor, component);
                if (ca.length == 1)
                    continue;
                var componentRoot = -1;
                var $it786 = component.GetEnumerator();
                while ($it786.MoveNext()){
                    var j = $it786.get_Current();
                    if (componentRoot == -1)
                        componentRoot = j;
                    nodesToComponentRoots.set_Item$$TKey(j, componentRoot);
                }
            }
            return nodesToComponentRoots;
        },
        RestoreState: function (){
            this.LayerArrays.UpdateLayers(this.yetBestLayers);
        },
        AverageXPositions: function (){
            for (var i = 0; i < this.LayerArrays.get_Layers().length; i++){
                var layer = this.LayerArrays.get_Layers()[i];
                var xPos = this.xPositions[i];
                var xPosClone = this.xPositionsClone[i];
                for (var j = 0; j < layer.length; j++)
                    this.database.get_Anchors()[layer[j]].set_X((xPos[j] + xPosClone[j]) / 2);
            }
        },
        SwitchXPositions: function (){
            if (this.xPositionsClone == null)
                this.AllocateXPositionsClone();
            var xPositionsSaved = this.xPositions;
            this.xPositions = this.xPositionsClone;
            this.xPositionsClone = xPositionsSaved;
        },
        AllocateXPositionsClone: function (){
            this.xPositionsClone = new Array(this.xPositions.length);
            for (var i = 0; i < this.xPositions.length; i++)
                this.xPositionsClone[i] = new Float64Array(this.xPositions[i].length);
        },
        GetBaricenterAbove: function (v){
            var inEdgesCount = this.ProperLayeredGraph.InEdgesCount(v);
            System.Diagnostics.Debug.Assert$$Boolean(inEdgesCount > 0);
            return System.Linq.Enumerable.Sum$$IEnumerable$1$Double((System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Layout.Layered.LayerEdge.ctor, System.Double.ctor, this.ProperLayeredGraph.InEdges(v), $CreateAnonymousDelegate(this, function (edge){
                return this.XPosition(edge.get_Source());
            })))) / inEdgesCount;
        },
        XPosition: function (node){
            return this.database.get_Anchors()[node].get_X();
        },
        GetBaricenterBelow: function (v){
            var outEdgesCount = this.ProperLayeredGraph.OutEdgesCount(v);
            System.Diagnostics.Debug.Assert$$Boolean(outEdgesCount > 0);
            return System.Linq.Enumerable.Sum$$IEnumerable$1$Double((System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Layout.Layered.LayerEdge.ctor, System.Double.ctor, this.ProperLayeredGraph.OutEdges(v), $CreateAnonymousDelegate(this, function (edge){
                return this.XPosition(edge.get_Target());
            })))) / outEdgesCount;
        },
        SortLayerBasedOnSolution: function (layer, solver){
            var length = layer.length;
            var positions = new Float64Array(length);
            var k = 0;
            for (var $i788 = 0,$l788 = layer.length,v = layer[$i788]; $i788 < $l788; $i788++, v = layer[$i788])
                positions[k++] = solver.GetVariableResolvedPosition(v);
            System.Array.Sort$2$$TKey$Array$$TValue$Array(System.Double.ctor, System.Int32.ctor, positions, layer);
            var i = 0;
            for (var $i789 = 0,$l789 = layer.length,v = layer[$i789]; $i789 < $l789; $i789++, v = layer[$i789])
                this.LayerArrays.get_X()[v] = i++;
        },
        GetGapFromClonedXPositions: function (l, r){
            var layerIndex = this.LayerArrays.Y[l];
            var li = this.LayerArrays.get_X()[l];
            var ri = this.LayerArrays.get_X()[r];
            var layerXPositions = this.xPositionsClone[layerIndex];
            var gap = layerXPositions[ri] - layerXPositions[li];
            System.Diagnostics.Debug.Assert$$Boolean(gap > 0);
            return gap;
        },
        AddSeparationConstraintsForFlatEdges: function (layerInfo, solver){
            if (layerInfo != null){
                var $it789 = layerInfo.flatEdges.GetEnumerator();
                while ($it789.MoveNext()){
                    var p = $it789.get_Current();
                    var left,right;
                    if (this.LayerArrays.get_X()[p.get_Item1()] < this.LayerArrays.get_X()[p.get_Item2()]){
                        left = p.get_Item1();
                        right = p.get_Item2();
                    }
                    else {
                        left = p.get_Item2();
                        right = p.get_Item1();
                    }
                    if (left == right)
                        continue;
                    var gap = this.GetGap(left, right);
                    var $it790 = this.database.GetMultiedge$$Int32$$Int32(p.get_Item1(), p.get_Item2()).GetEnumerator();
                    while ($it790.MoveNext()){
                        var edge = $it790.get_Current();
                        solver.AddLeftRightSeparationConstraint$$Int32$$Int32$$Double(left, right, gap + this.NodeSeparation() + (edge.get_Edge().get_Label() != null ? edge.get_Edge().get_Label().get_Width() : 0));
                    }
                }
            }
        },
        ExtractPositionsFromSolver: function (layer, solver, positions){
            solver.Solve();
            for (var i = 0; i < layer.length; i++)
                this.database.get_Anchors()[layer[i]].set_X(positions[i] = solver.GetVariableResolvedPosition(layer[i]));
        },
        FillSolverWithoutKnowingLayerOrder: function (layer, layerInfo, solver, sweepMode){
            var $it793 = layer.GetEnumerator();
            while ($it793.MoveNext()){
                var v = $it793.get_Current();
                if (layerInfo.neigBlocks.ContainsKey(v)){
                    var blockNode = Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.GetFixedBlockNode(v, layerInfo, sweepMode);
                    if (blockNode != -1)
                        solver.AddVariableWithIdealPosition$$Int32$$Double$$Double(v, this.FixedNodePosition(blockNode, sweepMode), 10000000);
                    else {
                        var t = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(System.Int32.ctor, System.Linq.Enumerable.Concat$1(System.Int32.ctor, layerInfo.neigBlocks.get_Item$$TKey(v), new Int32Array([v])), $CreateAnonymousDelegate(this, function (u){
                            return this.IsConnectedToPrevLayer(u, sweepMode);
                        }));
                        if (System.Linq.Enumerable.Any$1$$IEnumerable$1(System.Int32.ctor, t)){
                            blockNode = System.Linq.Enumerable.First$1$$IEnumerable$1(System.Int32.ctor, t);
                            solver.AddVariableWithIdealPosition$$Int32$$Double(v, this.GetBaricenterOnPrevLayer(blockNode, sweepMode));
                        }
                    }
                }
                else if (!Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.BelongsToNeighbBlock(v, layerInfo)){
                    if (Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.NodeIsConstrained(v, sweepMode, layerInfo))
                        solver.AddVariableWithIdealPosition$$Int32$$Double$$Double(v, this.FixedNodePosition(v, sweepMode), 10000000);
                    else if (this.IsConnectedToPrevLayer(v, sweepMode))
                        solver.AddVariableWithIdealPosition$$Int32$$Double(v, this.GetBaricenterOnPrevLayer(v, sweepMode));
                }
            }
            Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.AddGoalToKeepFlatEdgesShortOnBlockLevel(layerInfo, solver);
            var $it794 = layerInfo.leftRight.GetEnumerator();
            while ($it794.MoveNext()){
                var p = $it794.get_Current();
                solver.AddLeftRightSeparationConstraint$$Int32$$Int32$$Double(p.get_Item1(), p.get_Item2(), this.GetGapBetweenBlockRoots(p.get_Item1(), p.get_Item2()));
            }
        },
        IsConnectedToPrevLayer: function (v, sweepMode){
            return sweepMode == Microsoft.Msagl.Layout.Layered.SweepMode.ComingFromAbove && this.ProperLayeredGraph.InEdgesCount(v) > 0 || sweepMode == Microsoft.Msagl.Layout.Layered.SweepMode.ComingFromBelow && this.ProperLayeredGraph.OutEdgesCount(v) > 0;
        },
        FixedNodePosition: function (v, sweepMode){
            System.Diagnostics.Debug.Assert$$Boolean(sweepMode != Microsoft.Msagl.Layout.Layered.SweepMode.Starting);
            var layerInfo = this.layerInfos[this.LayerArrays.Y[v]];
            return sweepMode == Microsoft.Msagl.Layout.Layered.SweepMode.ComingFromAbove ? this.XPosition(layerInfo.constrainedFromAbove.get_Item$$TKey(v)) : this.XPosition(layerInfo.constrainedFromBelow.get_Item$$TKey(v));
        },
        GetBaricenterOnPrevLayer: function (v, sweepMode){
            System.Diagnostics.Debug.Assert$$Boolean(sweepMode != Microsoft.Msagl.Layout.Layered.SweepMode.Starting);
            return sweepMode == Microsoft.Msagl.Layout.Layered.SweepMode.ComingFromAbove ? this.GetBaricenterAbove(v) : this.GetBaricenterBelow(v);
        },
        GetGapBetweenBlockRoots: function (leftBlockRoot, rightBlockRoot){
            var lw = this.GetBlockWidth(leftBlockRoot);
            var rw = this.GetNodeWidth(rightBlockRoot);
            return this.settings.get_NodeSeparation() + 0.5 * (lw + rw);
        },
        GetBlockWidth: function (leftBlockRoot){
            if (this.horizontalConstraints.BlockRootToBlock.ContainsKey(leftBlockRoot))
                return this.BlockWidth(leftBlockRoot);
            return this.GetNodeWidth(leftBlockRoot);
        },
        GetGap: function (leftNode, rightNode){
            var layerIndex = this.LayerArrays.Y[leftNode];
            var layerInfo = this.layerInfos[layerIndex];
            if (layerInfo == null)
                return this.SimpleGapBetweenTwoNodes(leftNode, rightNode);
            var gap = 0;
            if (Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.NodesAreConstrainedAbove(leftNode, rightNode, layerInfo))
                gap = this.GetGapFromNodeNodesConstrainedAbove(leftNode, rightNode, layerInfo, layerIndex);
            if (Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.NodesAreConstrainedBelow(leftNode, rightNode, layerInfo))
                gap = System.Math.Max$$Double$$Double(this.GetGapFromNodeNodesConstrainedBelow(leftNode, rightNode, layerInfo, layerIndex), gap);
            if (gap > 0)
                return gap;
            return this.SimpleGapBetweenTwoNodes(leftNode, rightNode);
        },
        GetGapFromNodeNodesConstrainedBelow: function (leftNode, rightNode, layerInfo, layerIndex){
            var gap = this.SimpleGapBetweenTwoNodes(leftNode, rightNode);
            leftNode = layerInfo.constrainedFromBelow.get_Item$$TKey(leftNode);
            rightNode = layerInfo.constrainedFromBelow.get_Item$$TKey(rightNode);
            layerIndex--;
            layerInfo = this.layerInfos[layerIndex];
            if (layerIndex > 0 && Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.NodesAreConstrainedBelow(leftNode, rightNode, layerInfo))
                return System.Math.Max$$Double$$Double(gap, this.GetGapFromNodeNodesConstrainedBelow(leftNode, rightNode, layerInfo, layerIndex));
            return System.Math.Max$$Double$$Double(gap, this.SimpleGapBetweenTwoNodes(leftNode, rightNode));
        },
        GetGapFromNodeNodesConstrainedAbove: function (leftNode, rightNode, layerInfo, layerIndex){
            var gap = this.SimpleGapBetweenTwoNodes(leftNode, rightNode);
            leftNode = layerInfo.constrainedFromAbove.get_Item$$TKey(leftNode);
            rightNode = layerInfo.constrainedFromAbove.get_Item$$TKey(rightNode);
            layerIndex++;
            layerInfo = this.layerInfos[layerIndex];
            if (layerIndex < this.LayerArrays.get_Layers().length - 1 && Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.NodesAreConstrainedAbove(leftNode, rightNode, layerInfo))
                return System.Math.Max$$Double$$Double(gap, this.GetGapFromNodeNodesConstrainedAbove(leftNode, rightNode, layerInfo, layerIndex));
            return System.Math.Max$$Double$$Double(gap, this.SimpleGapBetweenTwoNodes(leftNode, rightNode));
        },
        SimpleGapBetweenTwoNodes: function (leftNode, rightNode){
            return this.database.anchors[leftNode].get_RightAnchor() + this.NodeSeparation() + this.database.anchors[rightNode].get_LeftAnchor();
        },
        PrepareProperLayeredGraphAndFillLayerInfos: function (){
            this.layerInfos = new Array(this.get_NumberOfLayers());
            this.CreateProperLayeredGraph();
            this.CreateExtendedLayerArrays();
            this.FillBlockRootToBlock();
            this.FillLeftRightPairs();
            this.FillFlatEdges();
            this.FillAboveBelow();
            this.FillBlockRootToVertConstrainedNode();
        },
        FillBlockRootToVertConstrainedNode: function (){
            for (var $i799 = 0,$t799 = this.layerInfos,$l799 = $t799.length,layerInfo = $t799[$i799]; $i799 < $l799; $i799++, layerInfo = $t799[$i799]){
                var $it799 = Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.VertConstrainedNodesOfLayer(layerInfo).GetEnumerator();
                while ($it799.MoveNext()){
                    var v = $it799.get_Current();
                    var blockRoot;
                    if ((function (){
                        var $1 = {
                            Value: blockRoot
                        };
                        var $res = Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.TryGetBlockRoot(v, $1, layerInfo);
                        blockRoot = $1.Value;
                        return $res;
                    }).call(this))
                        layerInfo.blockRootToVertConstrainedNodeOfBlock.set_Item$$TKey(blockRoot, v);
                }
            }
        },
        CreateExtendedLayerArrays: function (){
            var layeringExt = new Int32Array(this.numberOfNodesOfProperGraph);
            System.Array.Copy(this.initialLayering, layeringExt, this.initialLayering.length);
            var $it802 = this.ProperLayeredGraph.BaseGraph.get_Edges().GetEnumerator();
            while ($it802.MoveNext()){
                var edge = $it802.get_Current();
                var ledges = edge.get_LayerEdges() instanceof Array || edge.get_LayerEdges() == null ? edge.get_LayerEdges() : (function (){
                    throw new Error("InvalidCastException");
                }
                ());
                if (ledges != null && ledges.length > 1){
                    var layerIndex = this.initialLayering[edge.get_Source()] - 1;
                    for (var i = 0; i < ledges.length - 1; i++)
                        layeringExt[ledges[i].get_Target()] = layerIndex--;
                }
            }
            this.LayerArrays = new Microsoft.Msagl.Layout.Layered.LayerArrays.ctor(layeringExt);
        },
        CreateProperLayeredGraph: function (){
            var edges = this.CreatePathEdgesOnIntGraph();
            var nodeCount = System.Math.Max$$Int32$$Int32(this.intGraph.get_NodeCount(), Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.VertexCount(edges));
            var baseGraph = (function (){
                var $v104 = new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$2.ctor$$IEnumerable$1$$Int32(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Layout.Layered.IntEdge.ctor, edges, nodeCount);
                $v104.set_Nodes(this.intGraph.get_Nodes());
                return $v104;
            }).call(this);
            this.ProperLayeredGraph = new Microsoft.Msagl.Layout.Layered.ProperLayeredGraph.ctor(baseGraph);
        },
        CreatePathEdgesOnIntGraph: function (){
            this.numberOfNodesOfProperGraph = this.intGraph.get_NodeCount();
            var ret = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Layout.Layered.IntEdge.ctor);
            var $it803 = this.intGraph.get_Edges().GetEnumerator();
            while ($it803.MoveNext()){
                var ie = $it803.get_Current();
                if (this.initialLayering[ie.get_Source()] > this.initialLayering[ie.get_Target()]){
                    this.CreateLayerEdgesUnderIntEdge(ie);
                    ret.Add(ie);
                    if (this.horizontalConstraints.VerticalInts.Contains$$T(new System.Tuple$2.ctor(System.Int32.ctor, System.Int32.ctor, ie.get_Source(), ie.get_Target())))
                        this.verticalEdges.Add(ie);
                }
            }
            return ret;
        },
        CreateLayerEdgesUnderIntEdge: function (ie){
            var source = ie.get_Source();
            var target = ie.get_Target();
            var span = Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.EdgeSpan(this.initialLayering, ie);
            ie.set_LayerEdges(new Array(span));
            System.Diagnostics.Debug.Assert$$Boolean(span > 0);
            if (span == 1)
                ie.get_LayerEdges().set_Item$$Int32(0, new Microsoft.Msagl.Layout.Layered.LayerEdge.ctor$$Int32$$Int32$$Int32(ie.get_Source(), ie.get_Target(), ie.get_CrossingWeight()));
            else {
                ie.get_LayerEdges().set_Item$$Int32(0, new Microsoft.Msagl.Layout.Layered.LayerEdge.ctor$$Int32$$Int32$$Int32(source, this.numberOfNodesOfProperGraph, ie.get_CrossingWeight()));
                for (var i = 0; i < span - 2; i++)
                    ie.get_LayerEdges().set_Item$$Int32(i + 1, new Microsoft.Msagl.Layout.Layered.LayerEdge.ctor$$Int32$$Int32$$Int32(this.numberOfNodesOfProperGraph++, this.numberOfNodesOfProperGraph, ie.get_CrossingWeight()));
                ie.get_LayerEdges().set_Item$$Int32(span - 1, new Microsoft.Msagl.Layout.Layered.LayerEdge.ctor$$Int32$$Int32$$Int32(this.numberOfNodesOfProperGraph++, target, ie.get_CrossingWeight()));
            }
        },
        FillAboveBelow: function (){
            var $it804 = this.verticalEdges.GetEnumerator();
            while ($it804.MoveNext()){
                var ie = $it804.get_Current();
                var $it805 = ie.get_LayerEdges().GetEnumerator();
                while ($it805.MoveNext()){
                    var le = $it805.get_Current();
                    var upper = le.get_Source();
                    var lower = le.get_Target();
                    this.RegisterAboveBelowOnConstrainedUpperLower(upper, lower);
                }
            }
            var $it806 = this.horizontalConstraints.VerticalInts.GetEnumerator();
            while ($it806.MoveNext()){
                var p = $it806.get_Current();
                this.RegisterAboveBelowOnConstrainedUpperLower(p.get_Item1(), p.get_Item2());
            }
        },
        RegisterAboveBelowOnConstrainedUpperLower: function (upper, lower){
            var topLayerInfo = this.GetOrCreateLayerInfo(this.LayerArrays.Y[upper]);
            var bottomLayerInfo = this.GetOrCreateLayerInfo(this.LayerArrays.Y[lower]);
            topLayerInfo.constrainedFromBelow.set_Item$$TKey(upper, lower);
            bottomLayerInfo.constrainedFromAbove.set_Item$$TKey(lower, upper);
        },
        FillFlatEdges: function (){
            var $it807 = this.intGraph.get_Edges().GetEnumerator();
            while ($it807.MoveNext()){
                var edge = $it807.get_Current();
                var l = this.initialLayering[edge.get_Source()];
                if (l == this.initialLayering[edge.get_Target()]){
                    this.GetOrCreateLayerInfo(l).flatEdges.Insert(new System.Tuple$2.ctor(System.Int32.ctor, System.Int32.ctor, edge.get_Source(), edge.get_Target()));
                }
            }
        },
        FillLeftRightPairs: function (){
            var $it808 = this.horizontalConstraints.LeftRighInts.GetEnumerator();
            while ($it808.MoveNext()){
                var p = $it808.get_Current();
                var layerInfo = this.GetOrCreateLayerInfo(this.initialLayering[p.get_Item1()]);
                layerInfo.leftRight.Insert(p);
            }
        },
        GetOrCreateLayerInfo: function (layerNumber){
            var layerInfo = (this.layerInfos[layerNumber] != null ? this.layerInfos[layerNumber] : (this.layerInfos[layerNumber] = new Microsoft.Msagl.Layout.Layered.LayerInfo.ctor()));
            return layerInfo;
        },
        FillBlockRootToBlock: function (){
            var $it809 = this.horizontalConstraints.BlockRootToBlock.GetEnumerator();
            while ($it809.MoveNext()){
                var p = $it809.get_Current();
                var layerInfo = this.GetOrCreateLayerInfo(this.initialLayering[p.get_Key()]);
                layerInfo.neigBlocks.set_Item$$TKey(p.get_Key(), p.get_Value());
                var $it810 = p.get_Value().GetEnumerator();
                while ($it810.MoveNext()){
                    var i = $it810.get_Current();
                    layerInfo.nodeToBlockRoot.set_Item$$TKey(i, p.get_Key());
                }
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$ConstrainedOrdering);
var Microsoft$Msagl$Layout$Layered$ConstrainedOrderMeasure = {
    fullname: "Microsoft.Msagl.Layout.Layered.ConstrainedOrderMeasure",
    baseTypeName: "System.Object",
    staticDefinition: {
        op_LessThan: function (a, b){
            return a.numberOfCrossings < b.numberOfCrossings;
        },
        op_GreaterThan: function (a, b){
            return Microsoft.Msagl.Layout.Layered.ConstrainedOrderMeasure.op_LessThan(b, a);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (numberOfCrossings){
            this.numberOfCrossings = 0;
            System.Object.ctor.call(this);
            this.numberOfCrossings = numberOfCrossings;
        },
        Perfect: function (){
            return this.numberOfCrossings == 0;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$ConstrainedOrderMeasure);
var Microsoft$Msagl$Layout$Layered$MetroMapOrdering = {
    fullname: "Microsoft.Msagl.Layout.Layered.MetroMapOrdering",
    baseTypeName: "System.Object",
    staticDefinition: {
        UpdateLayerArrays$$ProperLayeredGraph$$LayerArrays$$Dictionary$2$Int32$Point: function (properLayeredGraph, layerArrays, nodePositions){
            new Microsoft.Msagl.Layout.Layered.MetroMapOrdering.ctor(properLayeredGraph, layerArrays, nodePositions).UpdateLayerArrays();
        },
        UpdateLayerArrays$$ProperLayeredGraph$$LayerArrays: function (properLayeredGraph, layerArrays){
            var nodePositions = Microsoft.Msagl.Layout.Layered.MetroMapOrdering.BuildInitialNodePositions(properLayeredGraph, layerArrays);
            Microsoft.Msagl.Layout.Layered.MetroMapOrdering.UpdateLayerArrays$$ProperLayeredGraph$$LayerArrays$$Dictionary$2$Int32$Point(properLayeredGraph, layerArrays, nodePositions);
        },
        BuildInitialNodePositions: function (properLayeredGraph, layerArrays){
            var result = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor);
            for (var i = 0; i < layerArrays.get_Layers().length; i++){
                var prev = 0,curr = 0;
                while (curr < layerArrays.get_Layers()[i].length){
                    while (curr < layerArrays.get_Layers()[i].length && properLayeredGraph.IsVirtualNode(layerArrays.get_Layers()[i][curr]))
                        curr++;
                    for (var j = prev; j < curr; j++)
                        result.set_Item$$TKey(layerArrays.get_Layers()[i][j], new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(i, prev));
                    if (curr < layerArrays.get_Layers()[i].length)
                        result.set_Item$$TKey(layerArrays.get_Layers()[i][curr], new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(i, curr));
                    curr++;
                    prev = curr;
                }
            }
            return result;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (properLayeredGraph, layerArrays, nodePositions){
            this.layerArrays = null;
            this.nodePositions = null;
            this.properLayeredGraph = null;
            System.Object.ctor.call(this);
            this.properLayeredGraph = properLayeredGraph;
            this.layerArrays = layerArrays;
            this.nodePositions = nodePositions;
        },
        UpdateLayerArrays: function (){
            var ordering = this.CreateInitialOrdering();
            ordering = this.BuildOrdering(ordering);
            this.RestoreLayerArrays(ordering);
        },
        CreateInitialOrdering: function (){
            var initialOrdering = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Collections.Generic.List$1.ctor);
            for (var i = 0; i < this.layerArrays.get_Layers().length; i++)
                for (var j = 0; j < this.layerArrays.get_Layers()[i].length; j++){
                    var node = this.layerArrays.get_Layers()[i][j];
                    if (!initialOrdering.ContainsKey(this.nodePositions.get_Item$$TKey(node)))
                        initialOrdering.set_Item$$TKey(this.nodePositions.get_Item$$TKey(node), new System.Collections.Generic.List$1.ctor(System.Int32.ctor));
                    initialOrdering.get_Item$$TKey(this.nodePositions.get_Item$$TKey(node)).Add(node);
                }
            return initialOrdering;
        },
        BuildOrdering: function (initialOrdering){
            var result = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Collections.Generic.List$1.ctor);
            var reverseOrder = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, System.Int32.ctor);
            for (var i = 0; i < this.layerArrays.get_Layers().length; i++)
                for (var j = 0; j < this.layerArrays.get_Layers()[i].length; j++){
                    var node = this.layerArrays.get_Layers()[i][j];
                    if (result.ContainsKey(this.nodePositions.get_Item$$TKey(node)))
                        continue;
                    result.set_Item$$TKey(this.nodePositions.get_Item$$TKey(node), this.BuildNodeOrdering(initialOrdering.get_Item$$TKey(this.nodePositions.get_Item$$TKey(node)), reverseOrder));
                }
            return result;
        },
        BuildNodeOrdering: function (nodeOrdering, inverseToOrder){
            var result = nodeOrdering;
            result.Sort$$Comparison$1(this.Comparison(inverseToOrder));
            for (var i = 0; i < result.get_Count(); i++)
                inverseToOrder.set_Item$$TKey(result.get_Item$$Int32(i), i);
            return result;
        },
        Comparison: function (inverseToOrder){
            return $CreateAnonymousDelegate(this, function (node1, node2){
                System.Diagnostics.Debug.Assert$$Boolean(this.properLayeredGraph.IsVirtualNode(node1) && this.properLayeredGraph.IsVirtualNode(node2));
                var succ1 = System.Linq.Enumerable.ElementAt$1(System.Int32.ctor, this.properLayeredGraph.Succ(node1), 0);
                var succ2 = System.Linq.Enumerable.ElementAt$1(System.Int32.ctor, this.properLayeredGraph.Succ(node2), 0);
                var pred1 = System.Linq.Enumerable.ElementAt$1(System.Int32.ctor, this.properLayeredGraph.Pred(node1), 0);
                var pred2 = System.Linq.Enumerable.ElementAt$1(System.Int32.ctor, this.properLayeredGraph.Pred(node2), 0);
                var succPoint1 = this.nodePositions.get_Item$$TKey(succ1);
                var succPoint2 = this.nodePositions.get_Item$$TKey(succ2);
                var predPoint1 = this.nodePositions.get_Item$$TKey(pred1);
                var predPoint2 = this.nodePositions.get_Item$$TKey(pred2);
                if (Microsoft.Msagl.Core.Geometry.Point.op_Inequality(succPoint1, succPoint2)){
                    if (Microsoft.Msagl.Core.Geometry.Point.op_Inequality(predPoint1, predPoint2))
                        return predPoint1.CompareTo(predPoint2);
                    return succPoint1.CompareTo(succPoint2);
                }
                if (this.properLayeredGraph.IsVirtualNode(succ1)){
                    if (Microsoft.Msagl.Core.Geometry.Point.op_Inequality(predPoint1, predPoint2))
                        return predPoint1.CompareTo(predPoint2);
                    var o1 = inverseToOrder.get_Item$$TKey(succ1);
                    var o2 = inverseToOrder.get_Item$$TKey(succ2);
                    System.Diagnostics.Debug.Assert$$Boolean(o1 != -1 && o2 != -1);
                    return (o1.CompareTo$$Int32(o2));
                }
                while (Microsoft.Msagl.Core.Geometry.Point.op_Equality(this.nodePositions.get_Item$$TKey(pred1), this.nodePositions.get_Item$$TKey(pred2)) && this.properLayeredGraph.IsVirtualNode(pred1)){
                    pred1 = System.Linq.Enumerable.ElementAt$1(System.Int32.ctor, this.properLayeredGraph.Pred(pred1), 0);
                    pred2 = System.Linq.Enumerable.ElementAt$1(System.Int32.ctor, this.properLayeredGraph.Pred(pred2), 0);
                }
                if (Microsoft.Msagl.Core.Geometry.Point.op_Equality(this.nodePositions.get_Item$$TKey(pred1), this.nodePositions.get_Item$$TKey(pred2)))
                    return node1.CompareTo$$Int32(node2);
                return this.nodePositions.get_Item$$TKey(pred1).CompareTo(this.nodePositions.get_Item$$TKey(pred2));
            });
        },
        RestoreLayerArrays: function (ordering){
            for (var i = 0; i < this.layerArrays.get_Layers().length; i++){
                var pred = 0,tec = 0;
                while (tec < this.layerArrays.get_Layers()[i].length){
                    while (tec < this.layerArrays.get_Layers()[i].length && Microsoft.Msagl.Core.Geometry.Point.op_Equality(this.nodePositions.get_Item$$TKey(this.layerArrays.get_Layers()[i][pred]), this.nodePositions.get_Item$$TKey(this.layerArrays.get_Layers()[i][tec])))
                        tec++;
                    for (var j = pred; j < tec; j++)
                        this.layerArrays.get_Layers()[i][j] = ordering.get_Item$$TKey(this.nodePositions.get_Item$$TKey(this.layerArrays.get_Layers()[i][j])).get_Item$$Int32(j - pred);
                    pred = tec;
                }
            }
            this.layerArrays.UpdateXFromLayers();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$MetroMapOrdering);
var Microsoft$Msagl$Layout$Layered$EdgeComparerBySource = {
    fullname: "Microsoft.Msagl.Layout.Layered.EdgeComparerBySource",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IComparer$1"],
    Kind: "Class",
    definition: {
        ctor: function (X){
            this.X = null;
            System.Object.ctor.call(this);
            this.X = X;
        },
        Compare: function (a, b){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(a, "a");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(b, "b");
            var r = this.X[a.get_Source()] - this.X[b.get_Source()];
            if (r != 0)
                return r;
            return this.X[a.get_Target()] - this.X[b.get_Target()];
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$EdgeComparerBySource);
var Microsoft$Msagl$Layout$Layered$EdgeComparerByTarget = {
    fullname: "Microsoft.Msagl.Layout.Layered.EdgeComparerByTarget",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IComparer$1"],
    Kind: "Class",
    definition: {
        ctor: function (X){
            this.X = null;
            System.Object.ctor.call(this);
            this.X = X;
        },
        Compare: function (a, b){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(a, "a");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(b, "b");
            var r = this.X[a.get_Target()] - this.X[b.get_Target()];
            if (r != 0)
                return r;
            return this.X[a.get_Source()] - this.X[b.get_Source()];
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$EdgeComparerByTarget);
var Microsoft$Msagl$Core$ProjectionSolver$ISolverShell = {
    fullname: "Microsoft.Msagl.Core.ProjectionSolver.ISolverShell",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Interface"
};
JsTypes.push(Microsoft$Msagl$Core$ProjectionSolver$ISolverShell);
var Microsoft$Msagl$Layout$Layered$LayerInfo = {
    fullname: "Microsoft.Msagl.Layout.Layered.LayerInfo",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.leftRight = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(System.Tuple$2.ctor);
            this.flatEdges = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(System.Tuple$2.ctor);
            this.neigBlocks = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, System.Collections.Generic.List$1.ctor);
            this.constrainedFromAbove = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, System.Int32.ctor);
            this.constrainedFromBelow = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, System.Int32.ctor);
            this.nodeToBlockRoot = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, System.Int32.ctor);
            this.blockRootToVertConstrainedNodeOfBlock = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, System.Int32.ctor);
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$LayerInfo);
var Microsoft$Msagl$Core$ProjectionSolver$SolverShell = {
    fullname: "Microsoft.Msagl.Core.ProjectionSolver.SolverShell",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Core.ProjectionSolver.SolverShell.FixedVarWeight = 1000000000;
            Microsoft.Msagl.Core.ProjectionSolver.SolverShell.FailToAdjustEpsilon = 0.001;
        },
        Close: function (a, b){
            return System.Math.Abs$$Double(a - b) < 0.0005;
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Core.ProjectionSolver.ISolverShell"],
    Kind: "Class",
    definition: {
        ctor: function (){
            this.variables = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, Microsoft.Msagl.Core.ProjectionSolver.Variable.ctor);
            this.solver = null;
            this.solution = null;
            this.fixedVars = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, System.Double.ctor);
            System.Object.ctor.call(this);
            this.InitSolver();
        },
        AddVariableWithIdealPosition$$Int32$$Double$$Double: function (id, position, weight){
            this.variables.Add(id, this.solver.AddVariable$$Object$$Double$$Double(id, position, weight));
        },
        AddVariableWithIdealPosition$$Int32$$Double: function (id, position){
            this.AddVariableWithIdealPosition$$Int32$$Double$$Double(id, position, 1);
        },
        AddLeftRightSeparationConstraint$$Int32$$Int32$$Double$$Boolean: function (idLeft, idRight, gap, isEquality){
            var varLeft = this.GetVariable(idLeft);
            if (varLeft == null)
                return;
            var varRight = this.GetVariable(idRight);
            if (varRight == null)
                return;
            this.solver.AddConstraint$$Variable$$Variable$$Double$$Boolean(varLeft, varRight, gap, isEquality);
        },
        AddLeftRightSeparationConstraint$$Int32$$Int32$$Double: function (idLeft, idRight, gap){
            this.AddLeftRightSeparationConstraint$$Int32$$Int32$$Double$$Boolean(idLeft, idRight, gap, false);
        },
        AddGoalTwoVariablesAreClose$$Int32$$Int32$$Double: function (id1, id2, weight){
            var var1 = this.GetVariable(id1);
            if (var1 == null)
                return;
            var var2 = this.GetVariable(id2);
            if (var2 == null)
                return;
            this.solver.AddNeighborPair(var1, var2, weight);
        },
        AddGoalTwoVariablesAreClose$$Int32$$Int32: function (id1, id2){
            this.AddGoalTwoVariablesAreClose$$Int32$$Int32$$Double(id1, id2, 1);
        },
        GetVariable: function (i){
            var v;
            return (function (){
                var $1 = {
                    Value: v
                };
                var $res = this.variables.TryGetValue(i, $1);
                v = $1.Value;
                return $res;
            }).call(this) ? v : null;
        },
        Solve: function (){
            this.Solve$$Object(null);
        },
        Solve$$Object: function (parameters){
            var executionLimitExceeded;
            (function (){
                var $1 = {
                    Value: executionLimitExceeded
                };
                var $res = this.Solve$$Object$$Boolean(parameters, $1);
                executionLimitExceeded = $1.Value;
                return $res;
            }).call(this);
        },
        Solve$$Object$$Boolean: function (parameters, executionLimitExceeded){
            var fixedVarsMoved;
            do{
                this.solution = null;
                var solverParameters = null;
                if (null != parameters){
                    solverParameters = As(parameters, Microsoft.Msagl.Core.ProjectionSolver.Parameters.ctor);
                    if (solverParameters == null)
                        throw $CreateException(new System.ArgumentException.ctor$$String("parameters"), new Error());
                }
                this.solution = this.solver.Solve$$Parameters(solverParameters);
                executionLimitExceeded.Value = this.solution.get_ExecutionLimitExceeded();
                fixedVarsMoved = this.AdjustConstraintsForMovedFixedVars();
            }
            while (fixedVarsMoved && this.solution.get_ExecutionLimitExceeded() == false)
            return this.solution.get_ExecutionLimitExceeded() == false;
        },
        AdjustConstraintsForMovedFixedVars: function (){
            var movedFixedVars = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(System.Int32.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.Collections.Generic.KeyValuePair$2.ctor, System.Int32.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(System.Collections.Generic.KeyValuePair$2.ctor, this.fixedVars, $CreateAnonymousDelegate(this, function (kv){
                return !Microsoft.Msagl.Core.ProjectionSolver.SolverShell.Close(kv.get_Value(), this.GetVariableResolvedPosition(kv.get_Key()));
            })), $CreateAnonymousDelegate(this, function (p){
                return p.get_Key();
            })));
            if (movedFixedVars.get_Count() == 0)
                return false;
            return this.AdjustConstraintsForMovedFixedVarSet(movedFixedVars);
        },
        AdjustConstraintsForMovedFixedVarSet: function (movedFixedVars){
            while (movedFixedVars.get_Count() > 0){
                var fixedVar = System.Linq.Enumerable.First$1$$IEnumerable$1(System.Int32.ctor, movedFixedVars);
                if (!(function (){
                    var $1 = {
                        Value: movedFixedVars
                    };
                    var $res = this.AdjustSubtreeOfFixedVar(fixedVar, $1);
                    movedFixedVars = $1.Value;
                    return $res;
                }).call(this))
                    return false;
            }
            return true;
        },
        AdjustSubtreeOfFixedVar: function (fixedVar, movedFixedVars){
            var successInAdjusting;
            var neighbors = (function (){
                var $1 = {
                    Value: successInAdjusting
                };
                var $res = this.AdjustConstraintsOfNeighborsOfFixedVariable(fixedVar, $1);
                successInAdjusting = $1.Value;
                return $res;
            }).call(this);
            if (!successInAdjusting)
                return false;
            if (!System.Linq.Enumerable.Any$1$$IEnumerable$1(System.Int32.ctor, neighbors))
                return false;
            var $it811 = neighbors.GetEnumerator();
            while ($it811.MoveNext()){
                var i = $it811.get_Current();
                movedFixedVars.Value.Remove(i);
            }
            return true;
        },
        AdjustConstraintsOfNeighborsOfFixedVariable: function (fixedVar, successInAdjusing){
            var nbs = this.variables.get_Item$$TKey(fixedVar).get_Block().get_Variables();
            var currentSpan = new Microsoft.Msagl.Core.DataStructures.RealNumberSpan.ctor();
            var idealSpan = new Microsoft.Msagl.Core.DataStructures.RealNumberSpan.ctor();
            var scale = 1;
            var $it812 = nbs.GetEnumerator();
            while ($it812.MoveNext()){
                var u = $it812.get_Current();
                if (!this.fixedVars.ContainsKey(u.get_UserData()))
                    continue;
                currentSpan.AddValue(u.get_ActualPos());
                idealSpan.AddValue(u.get_DesiredPos());
                if (idealSpan.get_Length() > 0)
                    scale = System.Math.Max$$Double$$Double(scale, currentSpan.get_Length() / idealSpan.get_Length());
            }
            if (scale == 1)
                scale = 2;
            successInAdjusing.Value = this.FixActiveConstraints(nbs, scale);
            return System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.ProjectionSolver.Variable.ctor, System.Int32.ctor, nbs, $CreateAnonymousDelegate(this, function (u){
                return u.get_UserData();
            }));
        },
        FixActiveConstraints: function (neighbs, scale){
            var ret = false;
            var $it813 = System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(null, Microsoft.Msagl.Core.ProjectionSolver.Constraint.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(null, System.Linq.Enumerable.SelectMany$3$$IEnumerable$1$$Func$2$$Func$3(Microsoft.Msagl.Core.ProjectionSolver.Variable.ctor, Microsoft.Msagl.Core.ProjectionSolver.Constraint.ctor, null, neighbs, $CreateAnonymousDelegate(this, function (v){
                return v.get_LeftConstraints();
            }), $CreateAnonymousDelegate(this, function (v, c){
                return $CreateAnonymousObject({
                    v: v,
                    c: c
                });
            })), $CreateAnonymousDelegate(this, function ($$x0){
                return $$x0.get_c().get_IsActive();
            })), $CreateAnonymousDelegate(this, function ($$x1){
                return $$x1.get_c();
            })).GetEnumerator();
            while ($it813.MoveNext()){
                var c = $it813.get_Current();
                if (c.get_Gap() > 0.001)
                    ret = true;
                this.solver.SetConstraintUpdate(c, c.get_Gap() / scale);
            }
            return ret;
        },
        GetVariableResolvedPosition: function (id){
            var v = this.GetVariable(id);
            return v == null ? 0 : v.get_ActualPos();
        },
        InitSolver: function (){
            this.solver = new Microsoft.Msagl.Core.ProjectionSolver.Solver.ctor();
            this.variables.Clear();
        },
        AddFixedVariable: function (id, position){
            this.AddVariableWithIdealPosition$$Int32$$Double$$Double(id, position, 1000000000);
            this.fixedVars.set_Item$$TKey(id, position);
        },
        ContainsVariable: function (v){
            return this.variables.ContainsKey(v);
        },
        GetVariableIdealPosition: function (v){
            return this.variables.get_Item$$TKey(v).get_DesiredPos();
        },
        Solution$$: "System.Object",
        get_Solution: function (){
            return this.solution;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$ProjectionSolver$SolverShell);
var Microsoft$Msagl$Layout$Layered$SweepMode = {
    fullname: "Microsoft.Msagl.Layout.Layered.SweepMode",
    staticDefinition: {
        ComingFromBelow: 0,
        ComingFromAbove: 1,
        Starting: 2
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$SweepMode);
var Microsoft$Msagl$Core$Geometry$OverlapRemovalCluster = {
    fullname: "Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster",
    baseTypeName: "Microsoft.Msagl.Core.Geometry.OverlapRemovalNode",
    staticDefinition: {
        NumInternalNodes$$: "System.UInt32",
        get_NumInternalNodes: function (){
            return 3;
        },
        DefaultBorderWidth$$: "System.Double",
        get_DefaultBorderWidth: function (){
            return 0.001;
        },
        CalcBorderWidth: function (margin){
            if (margin > 0){
                return margin;
            }
            return Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.get_DefaultBorderWidth();
        },
        ProcessClusterHierarchy: function (root, worker){
            var stack = new System.Collections.Generic.Stack$1.ctor(Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ClusterItem.ctor);
            stack.Push(new Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ClusterItem.ctor(root));
            while (stack.get_Count() > 0){
                var item = stack.Peek();
                var prevStackCount = stack.get_Count();
                if (!item.ChildrenHaveBeenPushed){
                    item.ChildrenHaveBeenPushed = true;
                    var $it814 = item.Cluster.get_Clusters().GetEnumerator();
                    while ($it814.MoveNext()){
                        var childCluster = $it814.get_Current();
                        stack.Push(new Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ClusterItem.ctor(childCluster));
                    }
                    if (stack.get_Count() > prevStackCount){
                        continue;
                    }
                }
                System.Diagnostics.Debug.Assert$$Boolean$$String(stack.Peek() == item, "stack.Peek() should be \'item\'");
                stack.Pop();
                worker(item.Cluster);
            }
        },
        GetLeftConstraintNode: function (node){
            var cluster = As(node, Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ctor);
            return (null != cluster) ? cluster.get_RightBorderNode() : node;
        },
        GetRightConstraintNode: function (node){
            var cluster = As(node, Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ctor);
            return (null != cluster) ? cluster.get_LeftBorderNode() : node;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$UInt32$$OverlapRemovalCluster$$Object$$Double$$Double: function (id, parentCluster, userData, padding, paddingP){
            this.nodeList = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.ctor);
            this.clusterList = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ctor);
            this._TranslateChildren = false;
            this._LeftBorderNode = null;
            this._RightBorderNode = null;
            this._IsInSolver = false;
            this._OpenBorderInfo = new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor();
            this._CloseBorderInfo = new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor();
            this._OpenBorderInfoP = new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor();
            this._CloseBorderInfoP = new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor();
            this._MinimumSize = 0;
            this._MinimumSizeP = 0;
            this._NodePadding = 0;
            this._NodePaddingP = 0;
            this._ClusterPadding = 0;
            this._ClusterPaddingP = 0;
            this._ParentCluster = null;
            Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ctor$$UInt32$$OverlapRemovalCluster$$Object$$Double$$Double$$Double$$Double$$Double$$Double$$BorderInfo$$BorderInfo$$BorderInfo$$BorderInfo.call(this, id, parentCluster, userData, 0, 0, padding, paddingP, 0, 0, new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double(0), new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double(0), new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double(0), new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double(0));
        },
        IsEmpty$$: "System.Boolean",
        get_IsEmpty: function (){
            return 0 == this.nodeList.get_Count();
        },
        TranslateChildren$$: "System.Boolean",
        get_TranslateChildren: function (){
            return this._TranslateChildren;
        },
        set_TranslateChildren: function (value){
            this._TranslateChildren = value;
        },
        LeftBorderNode$$: "Microsoft.Msagl.Core.Geometry.OverlapRemovalNode",
        get_LeftBorderNode: function (){
            return this._LeftBorderNode;
        },
        set_LeftBorderNode: function (value){
            this._LeftBorderNode = value;
        },
        RightBorderNode$$: "Microsoft.Msagl.Core.Geometry.OverlapRemovalNode",
        get_RightBorderNode: function (){
            return this._RightBorderNode;
        },
        set_RightBorderNode: function (value){
            this._RightBorderNode = value;
        },
        IsInSolver$$: "System.Boolean",
        get_IsInSolver: function (){
            return this._IsInSolver;
        },
        set_IsInSolver: function (value){
            this._IsInSolver = value;
        },
        OpenBorderInfo$$: "Microsoft.Msagl.Core.Geometry.BorderInfo",
        get_OpenBorderInfo: function (){
            return this._OpenBorderInfo;
        },
        set_OpenBorderInfo: function (value){
            this._OpenBorderInfo = value;
        },
        CloseBorderInfo$$: "Microsoft.Msagl.Core.Geometry.BorderInfo",
        get_CloseBorderInfo: function (){
            return this._CloseBorderInfo;
        },
        set_CloseBorderInfo: function (value){
            this._CloseBorderInfo = value;
        },
        OpenBorderInfoP$$: "Microsoft.Msagl.Core.Geometry.BorderInfo",
        get_OpenBorderInfoP: function (){
            return this._OpenBorderInfoP;
        },
        set_OpenBorderInfoP: function (value){
            this._OpenBorderInfoP = value;
        },
        CloseBorderInfoP$$: "Microsoft.Msagl.Core.Geometry.BorderInfo",
        get_CloseBorderInfoP: function (){
            return this._CloseBorderInfoP;
        },
        set_CloseBorderInfoP: function (value){
            this._CloseBorderInfoP = value;
        },
        MinimumSize$$: "System.Double",
        get_MinimumSize: function (){
            return this._MinimumSize;
        },
        set_MinimumSize: function (value){
            this._MinimumSize = value;
        },
        MinimumSizeP$$: "System.Double",
        get_MinimumSizeP: function (){
            return this._MinimumSizeP;
        },
        set_MinimumSizeP: function (value){
            this._MinimumSizeP = value;
        },
        NodePadding$$: "System.Double",
        get_NodePadding: function (){
            return this._NodePadding;
        },
        set_NodePadding: function (value){
            this._NodePadding = value;
        },
        NodePaddingP$$: "System.Double",
        get_NodePaddingP: function (){
            return this._NodePaddingP;
        },
        set_NodePaddingP: function (value){
            this._NodePaddingP = value;
        },
        ClusterPadding$$: "System.Double",
        get_ClusterPadding: function (){
            return this._ClusterPadding;
        },
        set_ClusterPadding: function (value){
            this._ClusterPadding = value;
        },
        ClusterPaddingP$$: "System.Double",
        get_ClusterPaddingP: function (){
            return this._ClusterPaddingP;
        },
        set_ClusterPaddingP: function (value){
            this._ClusterPaddingP = value;
        },
        IsRootCluster$$: "System.Boolean",
        get_IsRootCluster: function (){
            return null == this.get_ParentCluster();
        },
        ParentCluster$$: "Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster",
        get_ParentCluster: function (){
            return this._ParentCluster;
        },
        set_ParentCluster: function (value){
            this._ParentCluster = value;
        },
        ctor$$UInt32$$OverlapRemovalCluster$$Object$$Double$$Double$$Double$$Double$$Double$$Double$$BorderInfo$$BorderInfo$$BorderInfo$$BorderInfo: function (id, parentCluster, userData, minSize, minSizeP, nodePadding, nodePaddingP, clusterPadding, clusterPaddingP, openBorderInfo, closeBorderInfo, openBorderInfoP, closeBorderInfoP){
            this.nodeList = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.ctor);
            this.clusterList = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ctor);
            this._TranslateChildren = false;
            this._LeftBorderNode = null;
            this._RightBorderNode = null;
            this._IsInSolver = false;
            this._OpenBorderInfo = new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor();
            this._CloseBorderInfo = new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor();
            this._OpenBorderInfoP = new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor();
            this._CloseBorderInfoP = new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor();
            this._MinimumSize = 0;
            this._MinimumSizeP = 0;
            this._NodePadding = 0;
            this._NodePaddingP = 0;
            this._ClusterPadding = 0;
            this._ClusterPaddingP = 0;
            this._ParentCluster = null;
            Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.ctor$$UInt32$$Object.call(this, id, userData);
            this.set_MinimumSize(minSize);
            this.set_MinimumSizeP(minSizeP);
            this.set_NodePadding(nodePadding);
            this.set_NodePaddingP(nodePaddingP);
            this.set_ClusterPadding(clusterPadding);
            this.set_ClusterPaddingP(clusterPaddingP);
            this.set_ParentCluster(parentCluster);
            this.set_OpenBorderInfo(openBorderInfo);
            this.get_OpenBorderInfo().EnsureWeight();
            this.set_CloseBorderInfo(closeBorderInfo);
            this.get_CloseBorderInfo().EnsureWeight();
            this.set_OpenBorderInfoP(openBorderInfoP);
            this.get_OpenBorderInfoP().EnsureWeight();
            this.set_CloseBorderInfoP(closeBorderInfoP);
            this.get_CloseBorderInfoP().EnsureWeight();
            this.CreateBorderNodes();
        },
        CreateBorderNodes: function (){
            if (!this.get_IsRootCluster()){
                var strNodeIdL = null,strNodeIdR = null;
                this.set_LeftBorderNode(new Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.ctor$$UInt32$$Object(this.get_Id() + 1, strNodeIdL));
                this.set_RightBorderNode(new Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.ctor$$UInt32$$Object(this.get_Id() + 2, strNodeIdR));
            }
        },
        Nodes$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Geometry.OverlapRemovalNode]]",
        get_Nodes: function (){
            return this.nodeList;
        },
        Clusters$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster]]",
        get_Clusters: function (){
            return this.clusterList;
        },
        toString: function (){
            return System.String.Format$$IFormatProvider$$String$$Object$Array(System.Globalization.CultureInfo.get_InvariantCulture(), "Cluster \'{0}\': id {1} p {2:F5} s {3:F5} pP {4:F5} sP {5:F5}", [this.get_UserDataString(), this.get_Id(), this.get_Position(), this.get_Size(), this.get_PositionP(), this.get_SizeP()]);
        },
        AddNode: function (newNode){
            this.nodeList.Add(newNode);
            var newCluster = As(newNode, Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ctor);
            if (null != newCluster){
                this.clusterList.Add(newCluster);
            }
        },
        AddEvents: function (node, events){
            events.Add(new Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.Event.ctor(true, node, node.get_OpenP() - (this.get_NodePaddingP() / 2)));
            events.Add(new Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.Event.ctor(false, node, node.get_CloseP() + (this.get_NodePaddingP() / 2)));
        },
        Generate: function (solver, parameters, isHorizontal){
            Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ProcessClusterHierarchy(this, $CreateAnonymousDelegate(this, function (cluster){
                cluster.set_IsInSolver(cluster.GenerateWorker(solver, parameters, isHorizontal));
            }));
            Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ProcessClusterHierarchy(this, $CreateAnonymousDelegate(this, function (cluster){
                cluster.SqueezeNonFixedBorderPositions();
            }));
        },
        SqueezeNonFixedBorderPositions: function (){
            if (this.get_IsEmpty() || this.get_IsRootCluster() || !this.get_IsInSolver()){
                return;
            }
            var leftBorderDesiredPos = this.get_LeftBorderNode().get_Position();
            var rightBorderDesiredPos = this.get_RightBorderNode().get_Position();
            if (!this.get_OpenBorderInfo().get_IsFixedPosition()){
                this.get_LeftBorderNode().get_Variable().set_DesiredPos(rightBorderDesiredPos);
            }
            if (!this.get_CloseBorderInfo().get_IsFixedPosition()){
                this.get_RightBorderNode().get_Variable().set_DesiredPos(leftBorderDesiredPos);
            }
        },
        GenerateWorker: function (solver, parameters, isHorizontal){
            var boundaryRect = (function (){
                var $v105 = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
                $v105.set_Left(1.79769313486232E+308);
                $v105.set_Right(-1.79769313486232E+308);
                $v105.set_Bottom(1.79769313486232E+308);
                $v105.set_Top(-1.79769313486232E+308);
                return $v105;
            }).call(this);
            if (this.get_IsEmpty()){
                return false;
            }
            var events = (function (){
                var $1 = {
                    Value: boundaryRect
                };
                var $res = this.CreateEvents(solver, $1);
                boundaryRect = $1.Value;
                return $res;
            }).call(this);
            if (0 == events.get_Count() && !this.get_TranslateChildren()){
                return false;
            }
            var leftBorderWidth = Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.get_DefaultBorderWidth();
            var rightBorderWidth = Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.get_DefaultBorderWidth();
            if (!this.get_IsRootCluster()){
                (function (){
                    var $1 = {
                        Value: leftBorderWidth
                    };
                    var $2 = {
                        Value: rightBorderWidth
                    };
                    var $res = this.CalculateBorderWidths(solver, events, boundaryRect, $1, $2);
                    leftBorderWidth = $1.Value;
                    rightBorderWidth = $2.Value;
                    return $res;
                }).call(this);
            }
            this.GenerateFromEvents(solver, parameters, events, isHorizontal);
            if (!this.get_IsRootCluster()){
                this.AdjustFixedBorderPositions(solver, leftBorderWidth, rightBorderWidth, isHorizontal);
            }
            return true;
        },
        CreateEvents: function (solver, boundaryRect){
            var events = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.Event.ctor);
            var cNodes = this.nodeList.get_Count();
            var leftBorderWidth = Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.CalcBorderWidth(this.get_OpenBorderInfo().get_InnerMargin());
            var rightBorderWidth = Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.CalcBorderWidth(this.get_CloseBorderInfo().get_InnerMargin());
            var openBorderWidth = Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.CalcBorderWidth(this.get_OpenBorderInfoP().get_InnerMargin());
            var closeBorderWidth = Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.CalcBorderWidth(this.get_CloseBorderInfoP().get_InnerMargin());
            for (var nodeIndex = 0; nodeIndex < cNodes; ++nodeIndex){
                var node = this.nodeList.get_Item$$Int32(nodeIndex);
                var cluster = As(node, Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ctor);
                if (null != cluster){
                    if (!cluster.get_IsInSolver()){
                        continue;
                    }
                }
                else {
                    node.CreateVariable(solver);
                }
                this.AddEvents(node, events);
                if (!this.get_IsRootCluster()){
                    var pad = node.get_Size() / 2 + this.get_ClusterPadding();
                    var padP = node.get_SizeP() / 2 + this.get_ClusterPaddingP();
                    var newLeft = node.get_Position() - pad - leftBorderWidth;
                    var newRight = node.get_Position() + pad + rightBorderWidth;
                    var newBottom = node.get_PositionP() - padP - openBorderWidth;
                    var newTop = node.get_PositionP() + padP + closeBorderWidth;
                    boundaryRect.Value.set_Left(System.Math.Min$$Double$$Double(boundaryRect.Value.get_Left(), newLeft));
                    boundaryRect.Value.set_Right(System.Math.Max$$Double$$Double(boundaryRect.Value.get_Right(), newRight));
                    boundaryRect.Value.set_Bottom(System.Math.Min$$Double$$Double(boundaryRect.Value.get_Bottom(), newBottom));
                    boundaryRect.Value.set_Top(System.Math.Max$$Double$$Double(boundaryRect.Value.get_Top(), newTop));
                }
            }
            if (!this.get_IsRootCluster()){
                var padMinSize = this.get_MinimumSize() - boundaryRect.Value.get_Width();
                if (padMinSize > 0){
                    boundaryRect.Value.PadWidth(padMinSize / 2);
                }
                var padMinSizeP = this.get_MinimumSizeP() - boundaryRect.Value.get_Height();
                if (padMinSizeP > 0){
                    boundaryRect.Value.PadHeight(padMinSizeP / 2);
                }
            }
            return events;
        },
        CalculateBorderWidths: function (solver, events, boundaryRect, leftBorderWidth, rightBorderWidth){
            leftBorderWidth.Value = Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.CalcBorderWidth(this.get_OpenBorderInfo().get_InnerMargin());
            rightBorderWidth.Value = Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.CalcBorderWidth(this.get_CloseBorderInfo().get_InnerMargin());
            this.set_Size(boundaryRect.get_Width());
            this.set_Position(boundaryRect.get_Center().get_X());
            this.set_SizeP(boundaryRect.get_Height());
            this.set_PositionP(boundaryRect.get_Center().get_Y());
            this.get_LeftBorderNode().set_Position(boundaryRect.get_Left() + (leftBorderWidth.Value / 2));
            this.get_LeftBorderNode().set_Size(leftBorderWidth.Value);
            this.get_LeftBorderNode().set_Weight(this.get_OpenBorderInfo().get_Weight());
            this.get_LeftBorderNode().set_PositionP(this.get_PositionP());
            this.get_LeftBorderNode().set_SizeP(this.get_SizeP());
            this.get_LeftBorderNode().CreateVariable(solver);
            this.AddEvents(this.get_LeftBorderNode(), events);
            this.get_RightBorderNode().set_Position(boundaryRect.get_Right() - (rightBorderWidth.Value / 2));
            this.get_RightBorderNode().set_Size(rightBorderWidth.Value);
            this.get_RightBorderNode().set_Weight(this.get_CloseBorderInfo().get_Weight());
            this.get_RightBorderNode().set_PositionP(this.get_PositionP());
            this.get_RightBorderNode().set_SizeP(this.get_SizeP());
            this.get_RightBorderNode().CreateVariable(solver);
            this.AddEvents(this.get_RightBorderNode(), events);
        },
        AdjustFixedBorderPositions: function (solver, leftBorderWidth, rightBorderWidth, isHorizontal){
            if (this.get_OpenBorderInfo().get_IsFixedPosition() && this.get_CloseBorderInfo().get_IsFixedPosition()){
                this.get_LeftBorderNode().UpdateDesiredPosition(this.get_OpenBorderInfo().get_FixedPosition() + (leftBorderWidth / 2));
                this.get_RightBorderNode().UpdateDesiredPosition(this.get_CloseBorderInfo().get_FixedPosition() - (rightBorderWidth / 2));
                this.set_Size(this.get_CloseBorderInfo().get_FixedPosition() - this.get_OpenBorderInfo().get_FixedPosition());
                this.set_Position(this.get_OpenBorderInfo().get_FixedPosition() + (this.get_Size() / 2));
            }
            else if (this.get_OpenBorderInfo().get_IsFixedPosition() || this.get_CloseBorderInfo().get_IsFixedPosition()){
                if (this.get_OpenBorderInfo().get_IsFixedPosition()){
                    this.get_LeftBorderNode().UpdateDesiredPosition(this.get_OpenBorderInfo().get_FixedPosition() + (leftBorderWidth / 2));
                    this.set_Position(this.get_OpenBorderInfo().get_FixedPosition() + (this.get_Size() / 2));
                }
                else {
                    this.get_RightBorderNode().UpdateDesiredPosition(this.get_CloseBorderInfo().get_FixedPosition() - (rightBorderWidth / 2));
                    this.set_Position(this.get_CloseBorderInfo().get_FixedPosition() - (this.get_Size() / 2));
                }
            }
            if (this.get_MinimumSize() > 0){
                var cst = solver.AddConstraint$$Variable$$Variable$$Double(this.get_LeftBorderNode().get_Variable(), this.get_RightBorderNode().get_Variable(), this.get_MinimumSize() - leftBorderWidth / 2 - rightBorderWidth / 2);
                System.Diagnostics.Debug.Assert$$Boolean$$String(null != cst, "Minimum Cluster size: unexpected null cst");
            }
            if (this.get_OpenBorderInfoP().get_IsFixedPosition() || this.get_CloseBorderInfoP().get_IsFixedPosition()){
                if (this.get_OpenBorderInfoP().get_IsFixedPosition() && this.get_CloseBorderInfoP().get_IsFixedPosition()){
                    this.set_SizeP(this.get_CloseBorderInfoP().get_FixedPosition() - this.get_OpenBorderInfoP().get_FixedPosition());
                    this.set_PositionP(this.get_OpenBorderInfoP().get_FixedPosition() + (this.get_SizeP() / 2));
                    if (this.get_SizeP() < 0){
                        this.set_SizeP(-this.get_SizeP());
                    }
                }
                else {
                    var curTopOuterBorder = this.get_PositionP() - (this.get_SizeP() / 2);
                    var curBottomOuterBorder = this.get_PositionP() + (this.get_SizeP() / 2);
                    if (this.get_OpenBorderInfoP().get_IsFixedPosition()){
                        if (isHorizontal){
                            this.set_PositionP(this.get_PositionP() + this.get_OpenBorderInfoP().get_FixedPosition() - curTopOuterBorder);
                        }
                        else {
                            this.set_SizeP(curBottomOuterBorder - this.get_OpenBorderInfoP().get_FixedPosition());
                            this.set_PositionP(this.get_OpenBorderInfoP().get_FixedPosition() + (this.get_SizeP() / 2));
                        }
                    }
                    else {
                        if (isHorizontal){
                            this.set_PositionP(this.get_PositionP() + this.get_CloseBorderInfoP().get_FixedPosition() - curBottomOuterBorder);
                        }
                        else {
                            this.set_SizeP(this.get_CloseBorderInfoP().get_FixedPosition() - curTopOuterBorder);
                            this.set_PositionP(curTopOuterBorder + (this.get_SizeP() / 2));
                        }
                    }
                }
                this.get_LeftBorderNode().set_PositionP(this.get_PositionP());
                this.get_LeftBorderNode().set_SizeP(this.get_SizeP());
                this.get_RightBorderNode().set_PositionP(this.get_PositionP());
                this.get_RightBorderNode().set_SizeP(this.get_SizeP());
            }
        },
        GenerateFromEvents: function (solver, parameters, events, isHorizontal){
            events.Sort();
            var scanLine = new Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ScanLine.ctor();
            var $it815 = events.GetEnumerator();
            while ($it815.MoveNext()){
                var evt = $it815.get_Current();
                var currentNode = evt.get_Node();
                if (evt.get_IsForOpen()){
                    scanLine.Insert(currentNode);
                    currentNode.set_LeftNeighbors(this.GetLeftNeighbours(parameters, scanLine, currentNode, isHorizontal));
                    currentNode.set_RightNeighbors(this.GetRightNeighbours(parameters, scanLine, currentNode, isHorizontal));
                    var numLeftNeighbors = currentNode.get_LeftNeighbors().get_Count();
                    var numRightNeighbors = currentNode.get_RightNeighbors().get_Count();
                    for (var ii = 0; ii < numLeftNeighbors; ++ii){
                        var leftNeighborNode = currentNode.get_LeftNeighbors().get_Item$$Int32(ii);
                        for (var jj = 0; jj < numRightNeighbors; ++jj){
                            var nodeToRemove = currentNode.get_RightNeighbors().get_Item$$Int32(jj);
                            if (leftNeighborNode.get_RightNeighbors().Remove(nodeToRemove)){
                            }
                        }
                        leftNeighborNode.get_RightNeighbors().Add(currentNode);
                    }
                    for (var ii = 0; ii < numRightNeighbors; ++ii){
                        var rightNeighborNode = currentNode.get_RightNeighbors().get_Item$$Int32(ii);
                        for (var jj = 0; jj < numLeftNeighbors; ++jj){
                            var nodeToRemove = currentNode.get_LeftNeighbors().get_Item$$Int32(jj);
                            if (rightNeighborNode.get_LeftNeighbors().Remove(nodeToRemove)){
                            }
                        }
                        rightNeighborNode.get_LeftNeighbors().Add(currentNode);
                    }
                }
                else {
                    if (null == currentNode.get_LeftNeighbors()){
                        System.Diagnostics.Debug.Assert$$Boolean$$String(null != currentNode.get_LeftNeighbors(), "LeftNeighbors should not be null for a Close event");
                        continue;
                    }
                    var currentLeftNode = Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.GetLeftConstraintNode(currentNode);
                    var currentRightNode = Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.GetRightConstraintNode(currentNode);
                    var cLeftNeighbours = currentNode.get_LeftNeighbors().get_Count();
                    for (var ii = 0; ii < cLeftNeighbours; ++ii){
                        var origLeftNeighborNode = currentNode.get_LeftNeighbors().get_Item$$Int32(ii);
                        origLeftNeighborNode.get_RightNeighbors().Remove(currentNode);
                        var leftNeighborNode = Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.GetLeftConstraintNode(origLeftNeighborNode);
                        System.Diagnostics.Debug.Assert$$Boolean$$String(leftNeighborNode.get_OpenP() == origLeftNeighborNode.get_OpenP(), "leftNeighborNode.OpenP must == origLeftNeighborNode.OpenP");
                        System.Diagnostics.Debug.Assert$$Boolean$$String(isHorizontal || ((currentNode.get_CloseP() + this.get_NodePaddingP() - leftNeighborNode.get_OpenP()) > (parameters.get_SolverParameters().get_GapTolerance() - 1E-06)), "LeftNeighbors: unexpected close/open overlap");
                        var p = leftNeighborNode == this.get_LeftBorderNode() || currentRightNode == this.get_RightBorderNode() ? this.get_ClusterPadding() : this.get_NodePadding();
                        var separation = ((leftNeighborNode.get_Size() + currentRightNode.get_Size()) / 2) + p;
                        if (this.get_TranslateChildren()){
                            separation = System.Math.Max$$Double$$Double(separation, currentRightNode.get_Position() - leftNeighborNode.get_Position());
                        }
                        var cst = solver.AddConstraint$$Variable$$Variable$$Double(leftNeighborNode.get_Variable(), currentRightNode.get_Variable(), separation);
                        System.Diagnostics.Debug.Assert$$Boolean$$String(null != cst, "LeftNeighbors: unexpected null cst");
                    }
                    var cRightNeighbours = currentNode.get_RightNeighbors().get_Count();
                    for (var ii = 0; ii < cRightNeighbours; ++ii){
                        var origRightNeighborNode = currentNode.get_RightNeighbors().get_Item$$Int32(ii);
                        origRightNeighborNode.get_LeftNeighbors().Remove(currentNode);
                        var rightNeighborNode = Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.GetRightConstraintNode(origRightNeighborNode);
                        System.Diagnostics.Debug.Assert$$Boolean$$String(isHorizontal || ((currentNode.get_CloseP() + this.get_NodePaddingP() - rightNeighborNode.get_OpenP()) > (parameters.get_SolverParameters().get_GapTolerance() - 1E-06)), "RightNeighbors: unexpected close/open overlap");
                        var p = currentLeftNode == this.get_LeftBorderNode() || rightNeighborNode == this.get_RightBorderNode() ? this.get_ClusterPadding() : this.get_NodePadding();
                        var separation = ((currentLeftNode.get_Size() + rightNeighborNode.get_Size()) / 2) + p;
                        if (this.get_TranslateChildren()){
                            separation = System.Math.Max$$Double$$Double(separation, rightNeighborNode.get_Position() - currentLeftNode.get_Position());
                        }
                        var cst = solver.AddConstraint$$Variable$$Variable$$Double(currentLeftNode.get_Variable(), rightNeighborNode.get_Variable(), separation);
                        System.Diagnostics.Debug.Assert$$Boolean$$String(null != cst, "RightNeighbors: unexpected null cst");
                    }
                    scanLine.Remove(currentNode);
                }
            }
        },
        GetLeftNeighbours: function (parameters, scanLine, currentNode, isHorizontal){
            var lstNeighbours = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.ctor);
            var nextNode = scanLine.NextLeft(currentNode);
            for (; null != nextNode; nextNode = scanLine.NextLeft(nextNode)){
                if (!this.AddNeighbour(parameters, currentNode, nextNode, lstNeighbours, true, isHorizontal)){
                    if (!nextNode.get_DeferredLeftNeighborToV()){
                        break;
                    }
                }
            }
            return lstNeighbours;
        },
        GetRightNeighbours: function (parameters, scanLine, currentNode, isHorizontal){
            var lstNeighbours = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.ctor);
            var nextNode = scanLine.NextRight(currentNode);
            for (; null != nextNode; nextNode = scanLine.NextRight(nextNode)){
                if (!this.AddNeighbour(parameters, currentNode, nextNode, lstNeighbours, false, isHorizontal)){
                    if (!nextNode.get_DeferredRightNeighborToV()){
                        break;
                    }
                }
            }
            return lstNeighbours;
        },
        AddNeighbour: function (parameters, currentNode, nextNode, neighbors, isLeftNeighbor, isHorizontal){
            System.Diagnostics.Debug.Assert$$Boolean$$String(currentNode != (isLeftNeighbor ? this.get_LeftBorderNode() : this.get_RightBorderNode()), "currentNode must != BorderNode");
            var overlap = Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.Overlap(currentNode, nextNode, this.get_NodePadding());
            if (overlap <= 0){
                if (!isHorizontal && (Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.OverlapP(currentNode, nextNode, this.get_NodePaddingP()) <= parameters.get_SolverParameters().get_GapTolerance())){
                    return true;
                }
                neighbors.Add(nextNode);
                return false;
            }
            if (isHorizontal){
                if (parameters.get_AllowDeferToVertical()){
                    var overlapP = Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.OverlapP(currentNode, nextNode, this.get_NodePaddingP());
                    var isOverlapping = parameters.get_ConsiderProportionalOverlap() ? overlap / (currentNode.get_Size() + nextNode.get_Size()) > overlapP / (currentNode.get_SizeP() + nextNode.get_SizeP()) : overlap > overlapP;
                    if (isOverlapping){
                        if ((currentNode != this.get_LeftBorderNode()) && (currentNode != this.get_RightBorderNode()) && (nextNode != this.get_LeftBorderNode()) && (nextNode != this.get_RightBorderNode())){
                            if (isLeftNeighbor){
                                currentNode.set_DeferredLeftNeighborToV(true);
                                nextNode.set_DeferredRightNeighborToV(true);
                            }
                            else {
                                currentNode.set_DeferredRightNeighborToV(true);
                                nextNode.set_DeferredLeftNeighborToV(true);
                            }
                            return true;
                        }
                    }
                }
            }
            else {
                if (Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.OverlapP(currentNode, nextNode, this.get_NodePaddingP()) <= parameters.get_SolverParameters().get_GapTolerance()){
                    return true;
                }
            }
            neighbors.Add(nextNode);
            return true;
        },
        UpdateFromVariable: function (){
            Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ProcessClusterHierarchy(this, $CreateAnonymousDelegate(this, function (cluster){
                cluster.UpdateFromVariableWorker();
            }));
        },
        UpdateFromVariableWorker: function (){
            if (!this.get_IsRootCluster()){
                if (this.get_IsEmpty() || (null == this.get_LeftBorderNode().get_Variable())){
                    return;
                }
                this.get_LeftBorderNode().UpdateFromVariable();
                this.get_RightBorderNode().UpdateFromVariable();
                var clusterLeft = this.get_LeftBorderNode().get_Position() - (this.get_LeftBorderNode().get_Size() / 2);
                var clusterRight = this.get_RightBorderNode().get_Position() + (this.get_RightBorderNode().get_Size() / 2);
                this.set_Size(clusterRight - clusterLeft);
                this.set_Position(clusterLeft + (this.get_Size() / 2));
            }
            var cNodes = this.nodeList.get_Count();
            for (var nodeIndex = 0; nodeIndex < cNodes; ++nodeIndex){
                var node = this.nodeList.get_Item$$Int32(nodeIndex);
                if (!(Is(node, Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ctor))){
                    node.UpdateFromVariable();
                }
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$OverlapRemovalCluster);
var Microsoft$Msagl$Core$Geometry$OverlapRemovalCluster$ClusterItem = {
    fullname: "Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ClusterItem",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (cluster){
            this.Cluster = null;
            this.ChildrenHaveBeenPushed = false;
            System.Object.ctor.call(this);
            this.Cluster = cluster;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$OverlapRemovalCluster$ClusterItem);
var Microsoft$Msagl$Core$Geometry$OverlapRemovalCluster$ClusterDelegate = {
    fullname: "Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ClusterDelegate",
    Kind: "Delegate",
    definition: {
        ctor: function (obj, func){
            System.MulticastDelegate.ctor.call(this, obj, func);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$OverlapRemovalCluster$ClusterDelegate);
var Microsoft$Msagl$Core$Geometry$OverlapRemovalCluster$Event = {
    fullname: "Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.Event",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.IComparable$1"],
    Kind: "Class",
    definition: {
        ctor: function (isForOpen, node, position){
            this._IsForOpen = false;
            this._Position = 0;
            this._Node = null;
            System.Object.ctor.call(this);
            this.set_IsForOpen(isForOpen);
            this.set_Node(node);
            this.set_Position(position);
        },
        IsForOpen$$: "System.Boolean",
        get_IsForOpen: function (){
            return this._IsForOpen;
        },
        set_IsForOpen: function (value){
            this._IsForOpen = value;
        },
        Position$$: "System.Double",
        get_Position: function (){
            return this._Position;
        },
        set_Position: function (value){
            this._Position = value;
        },
        Node$$: "Microsoft.Msagl.Core.Geometry.OverlapRemovalNode",
        get_Node: function (){
            return this._Node;
        },
        set_Node: function (value){
            this._Node = value;
        },
        toString: function (){
            return System.String.Format$$IFormatProvider$$String$$Object$Array(System.Globalization.CultureInfo.get_InvariantCulture(), "Event: pos {0:F5} {1} {2}", [this.get_Position(), this.get_IsForOpen() ? "open" : "close", this.get_Node()]);
        },
        CompareTo: function (other){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(other, "other");
            var cmp = 0;
            if (System.Math.Abs$$Double(this.get_Position() - other.get_Position()) > 1E-06){
                cmp = this.get_Position().CompareTo$$Double(other.get_Position());
            }
            if (0 == cmp){
                cmp = this.get_IsForOpen().CompareTo$$Boolean(other.get_IsForOpen());
                if (0 == cmp){
                    cmp = this.get_Node().get_Id().CompareTo$$UInt32(other.get_Node().get_Id());
                }
            }
            return cmp;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$OverlapRemovalCluster$Event);
var Microsoft$Msagl$Core$Geometry$OverlapRemovalCluster$ScanLine = {
    fullname: "Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ScanLine",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.nodeTree = new Microsoft.Msagl.Core.DataStructures.RbTree$1.ctor$$IComparer$1(Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.ctor, new Microsoft.Msagl.Core.Geometry.NodeComparer.ctor());
            System.Object.ctor.call(this);
        },
        Insert: function (node){
            System.Diagnostics.Debug.Assert$$Boolean$$String(null == this.nodeTree.Find$$T(node), "node already exists in the rbtree");
            this.nodeTree.Insert(node);
        },
        Remove: function (node){
            this.nodeTree.Remove(node);
        },
        NextLeft: function (node){
            var pred = this.nodeTree.Previous(this.nodeTree.Find$$T(node));
            return (null != pred) ? pred.Item : null;
        },
        NextRight: function (node){
            var succ = this.nodeTree.Next(this.nodeTree.Find$$T(node));
            return (null != succ) ? succ.Item : null;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$OverlapRemovalCluster$ScanLine);
var Microsoft$Msagl$Core$Geometry$OverlapRemovalGlobalConfiguration = {
    fullname: "Microsoft.Msagl.Core.Geometry.OverlapRemovalGlobalConfiguration",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Core.Geometry.OverlapRemovalGlobalConfiguration.ClusterDefaultFreeWeight = 1E-06;
            Microsoft.Msagl.Core.Geometry.OverlapRemovalGlobalConfiguration.ClusterDefaultFixedWeight = 100000000;
            Microsoft.Msagl.Core.Geometry.OverlapRemovalGlobalConfiguration.ClusterDefaultBorderWidth = 0.001;
            Microsoft.Msagl.Core.Geometry.OverlapRemovalGlobalConfiguration.EventComparisonEpsilon = 1E-06;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$OverlapRemovalGlobalConfiguration);
var Microsoft$Msagl$Core$Geometry$OverlapRemovalParameters = {
    fullname: "Microsoft.Msagl.Core.Geometry.OverlapRemovalParameters",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.ICloneable"],
    Kind: "Class",
    definition: {
        ctor: function (){
            this._AllowDeferToVertical = false;
            this._ConsiderProportionalOverlap = false;
            this._SolverParameters = null;
            Microsoft.Msagl.Core.Geometry.OverlapRemovalParameters.ctor$$Parameters.call(this, new Microsoft.Msagl.Core.ProjectionSolver.Parameters.ctor());
        },
        AllowDeferToVertical$$: "System.Boolean",
        get_AllowDeferToVertical: function (){
            return this._AllowDeferToVertical;
        },
        set_AllowDeferToVertical: function (value){
            this._AllowDeferToVertical = value;
        },
        ConsiderProportionalOverlap$$: "System.Boolean",
        get_ConsiderProportionalOverlap: function (){
            return this._ConsiderProportionalOverlap;
        },
        set_ConsiderProportionalOverlap: function (value){
            this._ConsiderProportionalOverlap = value;
        },
        SolverParameters$$: "Microsoft.Msagl.Core.ProjectionSolver.Parameters",
        get_SolverParameters: function (){
            return this._SolverParameters;
        },
        set_SolverParameters: function (value){
            this._SolverParameters = value;
        },
        ctor$$Parameters: function (solverParameters){
            this._AllowDeferToVertical = false;
            this._ConsiderProportionalOverlap = false;
            this._SolverParameters = null;
            System.Object.ctor.call(this);
            this.set_SolverParameters(solverParameters);
            this.set_AllowDeferToVertical(true);
        },
        ctor$$Boolean$$Parameters: function (allowDeferToVertical, solverParameters){
            this._AllowDeferToVertical = false;
            this._ConsiderProportionalOverlap = false;
            this._SolverParameters = null;
            System.Object.ctor.call(this);
            this.set_AllowDeferToVertical(allowDeferToVertical);
            this.set_SolverParameters(solverParameters);
        },
        Clone: function (){
            var newParams = Cast(this.MemberwiseClone(), Microsoft.Msagl.Core.Geometry.OverlapRemovalParameters.ctor);
            newParams.set_SolverParameters(Cast(this.get_SolverParameters().Clone(), Microsoft.Msagl.Core.ProjectionSolver.Parameters.ctor));
            return newParams;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$OverlapRemovalParameters);
var Microsoft$Msagl$DebugHelpers$ClusterWithChildLists = {
    fullname: "Microsoft.Msagl.DebugHelpers.ClusterWithChildLists",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (cl){
            this.ChildClusters = new System.Collections.Generic.List$1.ctor(System.String.ctor);
            this.ChildNodes = new System.Collections.Generic.List$1.ctor(System.String.ctor);
            this.Cluster = null;
            System.Object.ctor.call(this);
            this.Cluster = cl;
        },
        AddCluster: function (clusterIndex){
            this.ChildClusters.Add(clusterIndex);
        },
        AddNode: function (nodeId){
            this.ChildNodes.Add(nodeId);
        }
    }
};
JsTypes.push(Microsoft$Msagl$DebugHelpers$ClusterWithChildLists);
var Microsoft$Msagl$DebugHelpers$GeometryToken = {
    fullname: "Microsoft.Msagl.DebugHelpers.GeometryToken",
    staticDefinition: {
        Clusters: 0,
        Force: 1,
        Barycenter: 2,
        Cluster: 3,
        Width: 4,
        Height: 5,
        Label: 6,
        MsaglGeometryGraph: 7,
        Header: 8,
        AspectRatio: 9,
        Transform: 10,
        TransformElement: 11,
        NodeSeparation: 12,
        LayerSeparation: 13,
        Margins: 14,
        MinNodeHeight: 15,
        MinNodeWidth: 16,
        Nodes: 17,
        Edges: 18,
        Node: 19,
        Edge: 20,
        Id: 21,
        Padding: 22,
        ICurve: 23,
        Ellipse: 24,
        Curve: 25,
        LineSegment: 26,
        CubicBezierSegment: 27,
        AxisA: 28,
        AxisB: 29,
        Center: 30,
        Point: 31,
        XCoordinate: 32,
        YCoordinate: 33,
        SourceNodeId: 34,
        TargetNodeId: 35,
        LabelWidth: 36,
        LabelHeight: 37,
        LabelCenter: 38,
        LineWidth: 39,
        ArrowheadAtSource: 40,
        ArrowheadPosition: 41,
        ArrowheadAtTarget: 42,
        Weight: 43,
        Separation: 44,
        Start: 45,
        End: 46,
        B0: 47,
        B1: 48,
        B2: 49,
        B3: 50,
        UnderlyingPolyline: 51,
        UnderlyingPolylineIsNull: 52,
        PolylineSite: 53,
        SiteK: 54,
        SiteV: 55,
        ParStart: 56,
        ParEnd: 57,
        Reporting: 58,
        RandomSeedForOrdering: 59,
        NoGainStepsBound: 60,
        MaxNumberOfPassesInOrdering: 61,
        Demotion: 62,
        GroupSplit: 63,
        LabelCornersPreserveCoefficient: 64,
        SplineCalculationDuration: 65,
        BrandesThreshold: 66,
        LayoutAlgorithmSettings: 67,
        SugiyamaLayoutSettings: 68,
        MdsLayoutSettings: 69,
        RankingLayoutSetting: 70,
        LayoutAlgorithmType: 71,
        RepetitionCoefficientForOrdering: 72,
        Exponent: 73,
        IterationsWithMajorization: 74,
        PivotNumber: 75,
        RotationAngle: 76,
        ScaleX: 77,
        ScaleY: 78,
        OmegaX: 79,
        OmegaY: 80,
        EdgeRoutingMode: 81,
        UseSparseVisibilityGraph: 82,
        UseKdHull: 83,
        ClusterIndex: 84,
        ChildClusters: 85,
        ChildNodes: 86,
        RectangularBoundary: 87,
        Polyline: 88,
        Closed: 89,
        PolylinePoints: 90,
        CurveData: 91,
        Cx: 92,
        Cy: 93,
        Ry: 94,
        Rx: 95,
        ArrowheadPositionAtSource: 96,
        ArrowheadPositionAtTarget: 97,
        Polygon: 98,
        MsaglGeometryFile: 99,
        Error: 100,
        Rect: 101,
        X: 102,
        Y: 103,
        Points: 104,
        T: 105,
        S: 106,
        As: 107,
        At: 108,
        Graph: 109,
        Asl: 110,
        Atl: 111,
        RectangularClusterBoundary: 112,
        RightBorderInfo: 113,
        LeftBorderInfo: 114,
        BottomBorderInfo: 115,
        TopBorderInfo: 116,
        LeftMargin: 117,
        RightMargin: 118,
        BottomMargin: 119,
        TopMargin: 120,
        GenerateFixedConstraints: 121,
        GenerateFixedConstraintsDefault: 122,
        DefaultBottomMargin: 123,
        DefaultTopMargin: 124,
        DefaultRightMargin: 125,
        DefaultLeftMargin: 126,
        InnerMargin: 127,
        FixedPosition: 128,
        LgData: 129,
        SortedLgInfos: 130,
        LgNodeInfo: 131,
        Rail: 132,
        LgLevels: 133,
        LgNodeInfos: 134,
        Rank: 135,
        Level: 136,
        NodeCountOnLevel: 137,
        Rails: 138,
        Arrowhead: 139,
        CurveAttachmentPoint: 140,
        RailsPerEdge: 141,
        EdgeRails: 142,
        RailId: 143,
        EdgeId: 144,
        LgEdgeInfos: 145,
        LgEdgeInfo: 146,
        Zoomlevel: 147
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$DebugHelpers$GeometryToken);
var Microsoft$Msagl$Layout$Layered$ProperLayeredGraph = {
    fullname: "Microsoft.Msagl.Layout.Layered.ProperLayeredGraph",
    baseTypeName: "System.Object",
    staticDefinition: {
        ExistVirtualNodes: function (iCollection){
            var $it818 = iCollection.GetEnumerator();
            while ($it818.MoveNext()){
                var edge = $it818.get_Current();
                if (edge.get_LayerEdges() != null && edge.get_LayerEdges().get_Count() > 1)
                    return true;
            }
            return false;
        },
        LastEdge: function (e){
            return e.get_LayerEdges().get_Item$$Int32(e.get_LayerEdges().get_Count() - 1);
        },
        FirstEdge: function (e){
            return e.get_LayerEdges().get_Item$$Int32(0);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (intGraph){
            this.BaseGraph = null;
            this.virtualNodesToInEdges = null;
            this.virtualNodesToOutEdges = null;
            this.totalNumberOfNodes = 0;
            this.firstVirtualNode = 0;
            System.Object.ctor.call(this);
            this.Initialize(intGraph);
        },
        FirstVirtualNode$$: "System.Int32",
        get_FirstVirtualNode: function (){
            return this.firstVirtualNode;
        },
        Initialize: function (intGraph){
            this.BaseGraph = intGraph;
            if (this.BaseGraph.get_Edges().get_Count() > 0){
                var edgesGoingDown = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Layout.Layered.IntEdge.ctor, this.BaseGraph.get_Edges(), $CreateAnonymousDelegate(this, function (edge){
                    return edge.get_LayerEdges() != null;
                }));
                if (System.Linq.Enumerable.Any$1$$IEnumerable$1(Microsoft.Msagl.Layout.Layered.IntEdge.ctor, edgesGoingDown))
                    this.totalNumberOfNodes = System.Linq.Enumerable.Max$$IEnumerable$1$Int32((System.Linq.Enumerable.SelectMany$3$$IEnumerable$1$$Func$2$$Func$3(Microsoft.Msagl.Layout.Layered.IntEdge.ctor, Microsoft.Msagl.Layout.Layered.LayerEdge.ctor, System.Int32.ctor, edgesGoingDown, $CreateAnonymousDelegate(this, function (edge){
                        return edge.get_LayerEdges();
                    }), $CreateAnonymousDelegate(this, function (edge, layerEdge){
                        return System.Math.Max$$Int32$$Int32(layerEdge.get_Source(), layerEdge.get_Target()) + 1;
                    }))));
                else
                    this.totalNumberOfNodes = intGraph.get_NodeCount();
            }
            else
                this.totalNumberOfNodes = intGraph.get_NodeCount();
            if (Microsoft.Msagl.Layout.Layered.ProperLayeredGraph.ExistVirtualNodes(this.BaseGraph.get_Edges())){
                this.firstVirtualNode = System.Linq.Enumerable.Min$$IEnumerable$1$Int32((System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(null, System.Int32.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(null, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(null, null, System.Linq.Enumerable.SelectMany$3$$IEnumerable$1$$Func$2$$Func$3(null, Microsoft.Msagl.Layout.Layered.LayerEdge.ctor, null, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Layout.Layered.IntEdge.ctor, null, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Layout.Layered.IntEdge.ctor, this.BaseGraph.get_Edges(), $CreateAnonymousDelegate(this, function (edge){
                    return edge.get_LayerEdges() != null && edge.get_LayerEdges().get_Count() > 1;
                })), $CreateAnonymousDelegate(this, function (edge){
                    return $CreateAnonymousObject({
                        edge: edge,
                        source: edge.get_Source()
                    });
                })), $CreateAnonymousDelegate(this, function ($$x0){
                    return $$x0.get_edge().get_LayerEdges();
                }), $CreateAnonymousDelegate(this, function ($$x1, layerEdge){
                    return $CreateAnonymousObject({
                        $$x1: $$x1,
                        layerEdge: layerEdge
                    });
                })), $CreateAnonymousDelegate(this, function ($$x2){
                    return $CreateAnonymousObject({
                        $$x2: $$x2,
                        layerEdgeSource: $$x2.get_layerEdge().get_Source()
                    });
                })), $CreateAnonymousDelegate(this, function ($$x3){
                    return $$x3.get_$$x2().get_layerEdge().get_Source() != $$x3.get_$$x2().get_$$x1().get_source();
                })), $CreateAnonymousDelegate(this, function ($$x4){
                    return $$x4.get_layerEdgeSource();
                }))));
            }
            else {
                this.firstVirtualNode = this.BaseGraph.get_NodeCount();
                this.totalNumberOfNodes = this.BaseGraph.get_NodeCount();
            }
            this.virtualNodesToInEdges = new Array(this.totalNumberOfNodes - this.get_FirstVirtualNode());
            this.virtualNodesToOutEdges = new Array(this.totalNumberOfNodes - this.get_FirstVirtualNode());
            var $it816 = this.BaseGraph.get_Edges().GetEnumerator();
            while ($it816.MoveNext()){
                var e = $it816.get_Current();
                if (e.get_LayerSpan() > 0){
                    var $it817 = e.get_LayerEdges().GetEnumerator();
                    while ($it817.MoveNext()){
                        var le = $it817.get_Current();
                        if (le.get_Target() != e.get_Target())
                            this.virtualNodesToInEdges[le.get_Target() - this.get_FirstVirtualNode()] = le;
                        if (le.get_Source() != e.get_Source())
                            this.virtualNodesToOutEdges[le.get_Source() - this.get_FirstVirtualNode()] = le;
                    }
                }
            }
        },
        Edges$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Layout.Layered.LayerEdge]]",
        get_Edges: function (){
            var $yield = [];
            var $it819 = this.BaseGraph.get_Edges().GetEnumerator();
            while ($it819.MoveNext()){
                var ie = $it819.get_Current();
                if (ie.get_LayerSpan() > 0){
                    var $it820 = ie.get_LayerEdges().GetEnumerator();
                    while ($it820.MoveNext()){
                        var le = $it820.get_Current();
                        $yield.push(le);
                    }
                }
            }
            return $yield;
        },
        InEdges: function (node){
            var $yield = [];
            if (node < this.BaseGraph.get_NodeCount()){
                var $it821 = this.BaseGraph.InEdges(node).GetEnumerator();
                while ($it821.MoveNext()){
                    var e = $it821.get_Current();
                    if (e.get_Source() != e.get_Target() && e.get_LayerEdges() != null)
                        $yield.push(Microsoft.Msagl.Layout.Layered.ProperLayeredGraph.LastEdge(e));
                }
            }
            else if (node >= this.firstVirtualNode)
                $yield.push(this.InEdgeOfVirtualNode(node));
            return $yield;
        },
        InEdgeOfVirtualNode: function (node){
            return this.virtualNodesToInEdges[node - this.get_FirstVirtualNode()];
        },
        OutEdges: function (node){
            var $yield = [];
            if (node < this.BaseGraph.get_NodeCount()){
                var $it822 = this.BaseGraph.OutEdges(node).GetEnumerator();
                while ($it822.MoveNext()){
                    var e = $it822.get_Current();
                    if (e.get_Source() != e.get_Target() && e.get_LayerEdges() != null)
                        $yield.push(Microsoft.Msagl.Layout.Layered.ProperLayeredGraph.FirstEdge(e));
                }
            }
            else if (node >= this.get_FirstVirtualNode())
                $yield.push(this.OutEdgeOfVirtualNode(node));
            return $yield;
        },
        OutEdgeOfVirtualNode: function (node){
            return this.virtualNodesToOutEdges[node - this.get_FirstVirtualNode()];
        },
        InEdgesCount: function (node){
            return this.RealInEdgesCount(node);
        },
        RealInEdgesCount: function (node){
            return node < this.BaseGraph.get_NodeCount() ? System.Linq.Enumerable.Count$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Layout.Layered.IntEdge.ctor, this.BaseGraph.InEdges(node), $CreateAnonymousDelegate(this, function (e){
                return e.get_LayerEdges() != null;
            })) : 1;
        },
        OutEdgesCount: function (node){
            return this.RealOutEdgesCount(node);
        },
        RealOutEdgesCount: function (node){
            return node < this.BaseGraph.get_NodeCount() ? System.Linq.Enumerable.Count$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Layout.Layered.IntEdge.ctor, this.BaseGraph.OutEdges(node), $CreateAnonymousDelegate(this, function (l){
                return l.get_LayerEdges() != null;
            })) : 1;
        },
        NodeCount$$: "System.Int32",
        get_NodeCount: function (){
            return this.totalNumberOfNodes;
        },
        IsRealNode: function (node){
            return (node < this.BaseGraph.get_NodeCount());
        },
        IsVirtualNode: function (node){
            return !this.IsRealNode(node);
        },
        ReversedClone: function (){
            var reversedEdges = this.CreateReversedEdges();
            return new Microsoft.Msagl.Layout.Layered.ProperLayeredGraph.ctor(new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$2.ctor$$IEnumerable$1$$Int32(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Layout.Layered.IntEdge.ctor, reversedEdges, this.BaseGraph.get_NodeCount()));
        },
        CreateReversedEdges: function (){
            var ret = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Layout.Layered.IntEdge.ctor);
            var $it823 = this.BaseGraph.get_Edges().GetEnumerator();
            while ($it823.MoveNext()){
                var e = $it823.get_Current();
                if (!e.SelfEdge())
                    ret.Add(e.ReversedClone());
            }
            return ret;
        },
        Succ: function (node){
            var $yield = [];
            var $it824 = this.OutEdges(node).GetEnumerator();
            while ($it824.MoveNext()){
                var le = $it824.get_Current();
                $yield.push(le.get_Target());
            }
            return $yield;
        },
        Pred: function (node){
            var $yield = [];
            var $it825 = this.InEdges(node).GetEnumerator();
            while ($it825.MoveNext()){
                var le = $it825.get_Current();
                $yield.push(le.get_Source());
            }
            return $yield;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$ProperLayeredGraph);
var Microsoft$Msagl$Layout$Layered$LayerCalculator = {
    fullname: "Microsoft.Msagl.Layout.Layered.LayerCalculator",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Interface"
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$LayerCalculator);
var Microsoft$Msagl$Core$GraphAlgorithms$TopologicalSort = {
    fullname: "Microsoft.Msagl.Core.GraphAlgorithms.TopologicalSort",
    baseTypeName: "System.Object",
    staticDefinition: {
        GetOrder$1: function (TEdge, graph){
            var visited = new Array(graph.get_NodeCount());
            var sv = new System.Collections.Generic.Stack$1.ctor(System.Int32.ctor);
            var se = new System.Collections.Generic.Stack$1.ctor(System.Collections.Generic.IEnumerator$1.ctor);
            var order = new System.Collections.Generic.List$1.ctor(System.Int32.ctor);
            var en;
            for (var u = 0; u < graph.get_NodeCount(); u++){
                if (visited[u])
                    continue;
                var cu = u;
                visited[cu] = true;
                en = System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(TEdge, System.Int32.ctor, graph.OutEdges(u), function (e){
                    return e.get_Target();
                }).GetEnumerator();
                do{
                    while (en.MoveNext()){
                        var v = en.get_Current();
                        if (!visited[v]){
                            visited[v] = true;
                            sv.Push(cu);
                            se.Push(en);
                            cu = v;
                            en = System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(TEdge, System.Int32.ctor, graph.OutEdges(cu), function (e){
                                return e.get_Target();
                            }).GetEnumerator();
                        }
                    }
                    order.Add(cu);
                    if (sv.get_Count() > 0){
                        en = se.Pop();
                        cu = sv.Pop();
                    }
                    else
                        break;
                }
                while (true)
            }
            order.Reverse();
            return order.ToArray();
        },
        GetOrderOnEdges$1: function (TEdge, edges){
            var visited = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, System.Boolean.ctor);
            var graph = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, System.Collections.Generic.List$1.ctor);
            var $it826 = edges.GetEnumerator();
            while ($it826.MoveNext()){
                var e = $it826.get_Current();
                visited.set_Item$$TKey(e.get_Source(), (function ($p41){
                    visited.set_Item$$TKey(e.get_Target(), $p41);
                    return $p41;
                })(false));
                var x = e.get_Source();
                var list;
                if (!(function (){
                    var $1 = {
                        Value: list
                    };
                    var $res = graph.TryGetValue(x, $1);
                    list = $1.Value;
                    return $res;
                })()){
                    graph.set_Item$$TKey(x, list = new System.Collections.Generic.List$1.ctor(System.Int32.ctor));
                }
                list.Add(e.get_Target());
            }
            var sv = new System.Collections.Generic.Stack$1.ctor(System.Int32.ctor);
            var se = new System.Collections.Generic.Stack$1.ctor(System.Collections.Generic.IEnumerator$1.ctor);
            var order = new System.Collections.Generic.List$1.ctor(System.Int32.ctor);
            var en;
            for (var $i828 = 0,$t828 = System.Linq.Enumerable.ToArray$1(System.Int32.ctor, visited.get_Keys()),$l828 = $t828.length,u = $t828[$i828]; $i828 < $l828; $i828++, u = $t828[$i828]){
                if (visited.get_Item$$TKey(u))
                    continue;
                var cu = u;
                visited.set_Item$$TKey(cu, true);
                var glist;
                if (!(function (){
                    var $1 = {
                        Value: glist
                    };
                    var $res = graph.TryGetValue(u, $1);
                    glist = $1.Value;
                    return $res;
                })())
                    continue;
                if (glist == null)
                    continue;
                en = glist.GetEnumerator();
                do{
                    while (en.MoveNext()){
                        var v = en.get_Current();
                        if (!visited.get_Item$$TKey(v)){
                            visited.set_Item$$TKey(v, true);
                            var list;
                            if (!(function (){
                                var $1 = {
                                    Value: list
                                };
                                var $res = graph.TryGetValue(v, $1);
                                list = $1.Value;
                                return $res;
                            })()){
                                order.Add(v);
                                continue;
                            }
                            sv.Push(cu);
                            se.Push(en);
                            cu = v;
                            en = list.GetEnumerator();
                        }
                    }
                    order.Add(cu);
                    if (sv.get_Count() > 0){
                        en = se.Pop();
                        cu = sv.Pop();
                    }
                    else
                        break;
                }
                while (true)
            }
            order.Reverse();
            return order.ToArray();
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$GraphAlgorithms$TopologicalSort);
var Microsoft$Msagl$Layout$Layered$LongestPathLayering = {
    fullname: "Microsoft.Msagl.Layout.Layered.LongestPathLayering",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Layout.Layered.LayerCalculator"],
    Kind: "Class",
    definition: {
        ctor: function (graph){
            this.graph = null;
            System.Object.ctor.call(this);
            this.graph = graph;
        },
        GetLayers: function (){
            var topoOrder = Microsoft.Msagl.Layout.Layered.IntEdge.GetOrder(this.graph);
            var layering = new Int32Array(this.graph.get_NodeCount());
            var k = this.graph.get_NodeCount();
            while (k-- > 0){
                var v = topoOrder[k];
                var $it828 = this.graph.InEdges(v).GetEnumerator();
                while ($it828.MoveNext()){
                    var e = $it828.get_Current();
                    var u = e.get_Source();
                    var l = layering[v] + e.get_Separation();
                    if (layering[u] < l)
                        layering[u] = l;
                }
            }
            return layering;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$LongestPathLayering);
var Microsoft$Msagl$Layout$Layered$NetworkSimplex = {
    fullname: "Microsoft.Msagl.Layout.Layered.NetworkSimplex",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        },
        CreateGraphWithIEEdges: function (bg){
            var ieEdges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Layout.Layered.IntEdge.ctor);
            var $it829 = bg.get_Edges().GetEnumerator();
            while ($it829.MoveNext()){
                var e = $it829.get_Current();
                ieEdges.Add(new Microsoft.Msagl.Layout.Layered.NetworkEdge.ctor(e));
            }
            return new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor$$IEnumerable$1$$Int32(Microsoft.Msagl.Layout.Layered.IntEdge.ctor, ieEdges, bg.get_NodeCount());
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Layout.Layered.LayerCalculator"],
    Kind: "Class",
    definition: {
        ctor: function (graph, cancelToken){
            this.layers = null;
            this.lim = null;
            this.low = null;
            this.parent = null;
            this.leaves = new System.Collections.Generic.List$1.ctor(System.Int32.ctor);
            this.treeVertices = new System.Collections.Generic.List$1.ctor(System.Int32.ctor);
            this.inTree = null;
            this.random = new System.Random.ctor$$Int32(1);
            this.graph = null;
            this.NetworkCancelToken = null;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.graph = Microsoft.Msagl.Layout.Layered.NetworkSimplex.CreateGraphWithIEEdges(graph);
            this.inTree = new Array(graph.get_NodeCount());
            this.NetworkCancelToken = cancelToken;
        },
        GetLayers: function (){
            if (this.layers == null)
                this.Run$$CancelToken(this.NetworkCancelToken);
            return this.layers;
        },
        ShiftLayerToZero: function (){
            var minLayer = 2147483647;
            for (var $i831 = 0,$t831 = this.layers,$l831 = $t831.length,i = $t831[$i831]; $i831 < $l831; $i831++, i = $t831[$i831])
                if (i < minLayer)
                    minLayer = i;
            for (var i = 0; i < this.graph.get_NodeCount(); i++)
                this.layers[i] -= minLayer;
        },
        FeasibleTree: function (){
            this.InitLayer();
            while (this.TightTree() < this.graph.get_NodeCount()){
                var e = this.GetNonTreeEdgeIncidentToTheTreeWithMinimalAmountOfSlack();
                if (e == null)
                    break;
                var slack = this.Slack(e);
                if (slack == 0)
                    throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
                if (this.inTree[e.get_Source()])
                    slack = -slack;
                var $it831 = this.treeVertices.GetEnumerator();
                while ($it831.MoveNext()){
                    var i = $it831.get_Current();
                    this.layers[i] += slack;
                }
            }
            this.InitCutValues();
        },
        VertexSourceTargetVal: function (v, treeEdge){
            var s = treeEdge.get_Source();
            var t = treeEdge.get_Target();
            if (this.lim[s] > this.lim[t])if (this.lim[v] <= this.lim[t] && this.low[t] <= this.lim[v])
                return 0;
            else
                return 1;
            else if (this.lim[v] <= this.lim[s] && this.low[s] <= this.lim[v])
                return 1;
            else
                return 0;
        },
        IncidentEdges: function (v){
            return new Microsoft.Msagl.Layout.Layered.NetworkSimplex.IncEdges.ctor(v, this);
        },
        AllLowCutsHaveBeenDone: function (v){
            var $it832 = this.IncidentEdges(v).GetEnumerator();
            while ($it832.MoveNext()){
                var ie = $it832.get_Current();
                if (ie.inTree && ie.get_Cut() == 2147483647 && ie != this.parent[v])
                    return false;
            }
            return true;
        },
        EdgeSourceTargetVal: function (e, treeEdge){
            return this.VertexSourceTargetVal(e.get_Source(), treeEdge) - this.VertexSourceTargetVal(e.get_Target(), treeEdge);
        },
        InitCutValues: function (){
            this.InitLimLowAndParent();
            var front = new System.Collections.Generic.Stack$1.ctor(System.Int32.ctor);
            var $it833 = this.leaves.GetEnumerator();
            while ($it833.MoveNext()){
                var i = $it833.get_Current();
                front.Push(i);
            }
            var newFront = new System.Collections.Generic.Stack$1.ctor(System.Int32.ctor);
            while (front.get_Count() > 0){
                while (front.get_Count() > 0){
                    var w = front.Pop();
                    var cutEdge = this.parent[w];
                    if (cutEdge == null)
                        continue;
                    var cut = 0;
                    var $it834 = this.IncidentEdges(w).GetEnumerator();
                    while ($it834.MoveNext()){
                        var e = $it834.get_Current();
                        if (e.inTree == false){
                            var e0Val = this.EdgeSourceTargetVal(e, cutEdge);
                            if (e0Val != 0)
                                cut += e0Val * e.get_Weight();
                        }
                        else {
                            if (e == cutEdge)
                                cut += e.get_Weight();
                            else {
                                var impact = cutEdge.get_Source() == e.get_Target() || cutEdge.get_Target() == e.get_Source() ? 1 : -1;
                                var edgeContribution = this.EdgeContribution(e, w);
                                cut += edgeContribution * impact;
                            }
                        }
                    }
                    cutEdge.set_Cut(cut);
                    var v = cutEdge.get_Source() == w ? cutEdge.get_Target() : cutEdge.get_Source();
                    if (this.AllLowCutsHaveBeenDone(v))
                        newFront.Push(v);
                }
                var t = front;
                front = newFront;
                newFront = t;
            }
        },
        EdgeContribution: function (e, w){
            var ret = e.get_Cut() - e.get_Weight();
            var $it835 = this.IncidentEdges(w).GetEnumerator();
            while ($it835.MoveNext()){
                var ie = $it835.get_Current();
                if (ie.inTree == false){
                    var sign = this.EdgeSourceTargetVal(ie, e);
                    if (sign == -1)
                        ret += ie.get_Weight();
                    else if (sign == 1)
                        ret -= ie.get_Weight();
                }
            }
            return ret;
        },
        InitLimLowAndParent: function (){
            this.lim = new Int32Array(this.graph.get_NodeCount());
            this.low = new Int32Array(this.graph.get_NodeCount());
            this.parent = new Array(this.graph.get_NodeCount());
            var curLim = 1;
            var v = 0;
            (function (){
                var $1 = {
                    Value: curLim
                };
                var $2 = {
                    Value: v
                };
                var $res = this.InitLowLimParentAndLeavesOnSubtree($1, $2);
                curLim = $1.Value;
                v = $2.Value;
                return $res;
            }).call(this);
        },
        InitLowLimParentAndLeavesOnSubtree: function (curLim, v){
            var stack = new System.Collections.Generic.Stack$1.ctor(Microsoft.Msagl.Layout.Layered.NetworkSimplex.StackStruct.ctor);
            var outEnum = this.graph.OutEdges(v.Value).GetEnumerator();
            var inEnum = this.graph.InEdges(v.Value).GetEnumerator();
            stack.Push(new Microsoft.Msagl.Layout.Layered.NetworkSimplex.StackStruct.ctor$$Int32$$IEnumerator$$IEnumerator(v.Value, outEnum, inEnum));
            this.low[v.Value] = curLim.Value;
            while (stack.get_Count() > 0){
                var ss = stack.Pop();
                v.Value = ss.v;
                outEnum = ss.outEnum;
                inEnum = ss.inEnum;
                this.ProgressStep();
                var done;
                do{
                    done = true;
                    while (outEnum.MoveNext()){
                        var e = As(outEnum.get_Current(), Microsoft.Msagl.Layout.Layered.NetworkEdge.ctor);
                        if (!e.inTree || this.low[e.get_Target()] > 0)
                            continue;
                        stack.Push(new Microsoft.Msagl.Layout.Layered.NetworkSimplex.StackStruct.ctor$$Int32$$IEnumerator$$IEnumerator(v.Value, outEnum, inEnum));
                        v.Value = e.get_Target();
                        this.parent[v.Value] = e;
                        this.low[v.Value] = curLim.Value;
                        outEnum = this.graph.OutEdges(v.Value).GetEnumerator();
                        inEnum = this.graph.InEdges(v.Value).GetEnumerator();
                    }
                    while (inEnum.MoveNext()){
                        var e = As(inEnum.get_Current(), Microsoft.Msagl.Layout.Layered.NetworkEdge.ctor);
                        if (!e.inTree || this.low[e.get_Source()] > 0){
                            continue;
                        }
                        stack.Push(new Microsoft.Msagl.Layout.Layered.NetworkSimplex.StackStruct.ctor$$Int32$$IEnumerator$$IEnumerator(v.Value, outEnum, inEnum));
                        v.Value = e.get_Source();
                        this.low[v.Value] = curLim.Value;
                        this.parent[v.Value] = e;
                        outEnum = this.graph.OutEdges(v.Value).GetEnumerator();
                        inEnum = this.graph.InEdges(v.Value).GetEnumerator();
                        done = false;
                        break;
                    }
                }
                while (!done)
                this.lim[v.Value] = curLim.Value++;
                if (this.lim[v.Value] == this.low[v.Value])
                    this.leaves.Add(v.Value);
            }
        },
        UpdateLimLowLeavesAndParentsUnderNode: function (l){
            var llow = this.low[l];
            var llim = this.lim[l];
            this.leaves.Clear();
            for (var i = 0; i < this.graph.get_NodeCount(); i++){
                if (llow <= this.lim[i] && this.lim[i] <= llim)
                    this.low[i] = 0;
                else if (this.low[i] == this.lim[i])
                    this.leaves.Add(i);
            }
            var v = l;
            (function (){
                var $1 = {
                    Value: llow
                };
                var $2 = {
                    Value: v
                };
                var $res = this.InitLowLimParentAndLeavesOnSubtree($1, $2);
                llow = $1.Value;
                v = $2.Value;
                return $res;
            }).call(this);
        },
        Slack: function (e){
            var ret = this.layers[e.get_Source()] - this.layers[e.get_Target()] - e.get_Separation();
            return ret;
        },
        GetNonTreeEdgeIncidentToTheTreeWithMinimalAmountOfSlack: function (){
            var eret = null;
            var minSlack = 2147483647;
            var $it836 = this.treeVertices.GetEnumerator();
            while ($it836.MoveNext()){
                var v = $it836.get_Current();
                var $it837 = this.graph.OutEdges(v).GetEnumerator();
                while ($it837.MoveNext()){
                    var e = $it837.get_Current();
                    if (this.inTree[e.get_Source()] && this.inTree[e.get_Target()])
                        continue;
                    var slack = this.Slack(e);
                    if (slack < minSlack){
                        eret = e;
                        minSlack = slack;
                        if (slack == 1)
                            return e;
                    }
                }
                var $it838 = this.graph.InEdges(v).GetEnumerator();
                while ($it838.MoveNext()){
                    var e = $it838.get_Current();
                    if (this.inTree[e.get_Source()] && this.inTree[e.get_Target()])
                        continue;
                    var slack = this.Slack(e);
                    if (slack < minSlack){
                        eret = e;
                        minSlack = slack;
                        if (slack == 1)
                            return e;
                    }
                }
            }
            return As(eret, Microsoft.Msagl.Layout.Layered.NetworkEdge.ctor);
        },
        TightTree: function (){
            this.treeVertices.Clear();
            var $it839 = this.graph.get_Edges().GetEnumerator();
            while ($it839.MoveNext()){
                var ie = $it839.get_Current();
                ie.inTree = false;
            }
            for (var i = 1; i < this.inTree.length; i++)
                this.inTree[i] = false;
            this.inTree[0] = true;
            this.treeVertices.Add(0);
            var q = new System.Collections.Generic.Stack$1.ctor(System.Int32.ctor);
            q.Push(0);
            while (q.get_Count() > 0){
                var v = q.Pop();
                var $it840 = this.graph.OutEdges(v).GetEnumerator();
                while ($it840.MoveNext()){
                    var e = $it840.get_Current();
                    if (this.inTree[e.get_Target()])
                        continue;
                    if (this.layers[e.get_Source()] - this.layers[e.get_Target()] == e.get_Separation()){
                        q.Push(e.get_Target());
                        this.inTree[e.get_Target()] = true;
                        this.treeVertices.Add(e.get_Target());
                        e.inTree = true;
                    }
                }
                var $it841 = this.graph.InEdges(v).GetEnumerator();
                while ($it841.MoveNext()){
                    var e = $it841.get_Current();
                    if (this.inTree[e.get_Source()])
                        continue;
                    if (this.layers[e.get_Source()] - this.layers[e.get_Target()] == e.get_Separation()){
                        q.Push(e.get_Source());
                        this.inTree[e.get_Source()] = true;
                        this.treeVertices.Add(e.get_Source());
                        e.inTree = true;
                    }
                }
            }
            return this.treeVertices.get_Count();
        },
        LeaveEnterEdge: function (){
            var leavingEdge = null;
            var enteringEdge = null;
            var minCut = 0;
            var $it842 = this.graph.get_Edges().GetEnumerator();
            while ($it842.MoveNext()){
                var e = $it842.get_Current();
                if (e.inTree){
                    if (e.get_Cut() < minCut){
                        minCut = e.get_Cut();
                        leavingEdge = e;
                    }
                }
            }
            if (leavingEdge == null)
                return null;
            var continuation = false;
            var minSlack = 2147483647;
            var $it843 = this.graph.get_Edges().GetEnumerator();
            while ($it843.MoveNext()){
                var f = $it843.get_Current();
                var slack = this.Slack(f);
                if (f.inTree == false && this.EdgeSourceTargetVal(f, leavingEdge) == -1 && (slack < minSlack || (slack == minSlack && (continuation = (this.random.Next$$Int32(2) == 1))))){
                    minSlack = slack;
                    enteringEdge = f;
                    if (minSlack == 0 && !continuation)
                        break;
                    continuation = false;
                }
            }
            return new System.Tuple$2.ctor(Microsoft.Msagl.Layout.Layered.NetworkEdge.ctor, Microsoft.Msagl.Layout.Layered.NetworkEdge.ctor, leavingEdge, enteringEdge);
        },
        Exchange: function (e, f){
            var l = this.CommonPredecessorOfSourceAndTargetOfF(f);
            this.CreatePathForCutUpdates(e, f, l);
            this.UpdateLimLowLeavesAndParentsUnderNode(l);
            this.UpdateCuts(e);
            this.UpdateLayersUnderNode(l);
        },
        UpdateLayersUnderNode: function (l){
            var front = new System.Collections.Generic.Stack$1.ctor(System.Int32.ctor);
            front.Push(l);
            for (var i = 0; i < this.graph.get_NodeCount(); i++)
                if (this.low[l] <= this.lim[i] && this.lim[i] <= this.lim[l] && i != l)
                    this.layers[i] = 2147483647;
            while (front.get_Count() > 0){
                var u = front.Pop();
                var $it844 = this.graph.OutEdges(u).GetEnumerator();
                while ($it844.MoveNext()){
                    var oe = $it844.get_Current();
                    if (oe.inTree && this.layers[oe.get_Target()] == 2147483647){
                        this.layers[oe.get_Target()] = this.layers[u] - oe.get_Separation();
                        front.Push(oe.get_Target());
                    }
                }
                var $it845 = this.graph.InEdges(u).GetEnumerator();
                while ($it845.MoveNext()){
                    var ie = $it845.get_Current();
                    if (ie.inTree && this.layers[ie.get_Source()] == 2147483647){
                        this.layers[ie.get_Source()] = this.layers[u] + ie.get_Separation();
                        front.Push(ie.get_Source());
                    }
                }
            }
        },
        UpdateCuts: function (e){
            var front = new System.Collections.Generic.Stack$1.ctor(System.Int32.ctor);
            var newFront = new System.Collections.Generic.Stack$1.ctor(System.Int32.ctor);
            front.Push(e.get_Source());
            front.Push(e.get_Target());
            while (front.get_Count() > 0){
                while (front.get_Count() > 0){
                    var w = front.Pop();
                    this.ProgressStep();
                    var cutEdge = this.parent[w];
                    if (cutEdge == null)
                        continue;
                    if (cutEdge.get_Cut() != 2147483647)
                        continue;
                    var cut = 0;
                    var $it846 = this.IncidentEdges(w).GetEnumerator();
                    while ($it846.MoveNext()){
                        var ce = $it846.get_Current();
                        if (ce.inTree == false){
                            var e0Val = this.EdgeSourceTargetVal(ce, cutEdge);
                            if (e0Val != 0)
                                cut += e0Val * ce.get_Weight();
                        }
                        else {
                            if (ce == cutEdge)
                                cut += ce.get_Weight();
                            else {
                                var impact = cutEdge.get_Source() == ce.get_Target() || cutEdge.get_Target() == ce.get_Source() ? 1 : -1;
                                var edgeContribution = this.EdgeContribution(ce, w);
                                cut += edgeContribution * impact;
                            }
                        }
                    }
                    cutEdge.set_Cut(cut);
                    var u = cutEdge.get_Source() == w ? cutEdge.get_Target() : cutEdge.get_Source();
                    if (this.AllLowCutsHaveBeenDone(u))
                        newFront.Push(u);
                }
                var t = front;
                front = newFront;
                newFront = t;
            }
        },
        CreatePathForCutUpdates: function (e, f, l){
            var v = f.get_Target();
            while (v != l){
                var p = this.parent[v];
                p.set_Cut(2147483647);
                v = p.get_Source() == v ? p.get_Target() : p.get_Source();
            }
            f.set_Cut(2147483647);
            e.inTree = false;
            f.inTree = true;
        },
        CommonPredecessorOfSourceAndTargetOfF: function (f){
            var fMin,fmax;
            if (this.lim[f.get_Source()] < this.lim[f.get_Target()]){
                fMin = this.lim[f.get_Source()];
                fmax = this.lim[f.get_Target()];
            }
            else {
                fMin = this.lim[f.get_Target()];
                fmax = this.lim[f.get_Source()];
            }
            var l = f.get_Source();
            while ((this.low[l] <= fMin && fmax <= this.lim[l]) == false){
                var p = this.parent[l];
                p.set_Cut(2147483647);
                l = p.get_Source() == l ? p.get_Target() : p.get_Source();
            }
            return l;
        },
        InitLayer: function (){
            var lp = new Microsoft.Msagl.Layout.Layered.LongestPathLayering.ctor(this.graph);
            this.layers = lp.GetLayers();
        },
        RunInternal: function (){
            if (this.graph.get_Edges().get_Count() == 0 && this.graph.get_NodeCount() == 0)
                this.layers = new Int32Array(0);
            this.FeasibleTree();
            var leaveEnter;
            while ((leaveEnter = this.LeaveEnterEdge()) != null){
                this.ProgressStep();
                this.Exchange(leaveEnter.get_Item1(), leaveEnter.get_Item2());
            }
            this.ShiftLayerToZero();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$NetworkSimplex);
var Microsoft$Msagl$Layout$Layered$NetworkSimplex$StackStruct = {
    fullname: "Microsoft.Msagl.Layout.Layered.NetworkSimplex.StackStruct",
    baseTypeName: "System.ValueType",
    assemblyName: "Microsoft.Msagl",
    Kind: "Struct",
    definition: {
        ctor$$Int32$$IEnumerator$$IEnumerator: function (v, outEnum, inEnum){
            this.v = 0;
            this.outEnum = null;
            this.inEnum = null;
            System.ValueType.ctor.call(this);
            this.v = v;
            this.outEnum = outEnum;
            this.inEnum = inEnum;
        },
        ctor: function (){
            this.v = 0;
            this.outEnum = null;
            this.inEnum = null;
            System.ValueType.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$NetworkSimplex$StackStruct);
var Microsoft$Msagl$Layout$Layered$NetworkSimplex$IncEdges = {
    fullname: "Microsoft.Msagl.Layout.Layered.NetworkSimplex.IncEdges",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IEnumerable$1"],
    Kind: "Class",
    definition: {
        ctor: function (v, nw){
            this.v = 0;
            this.nw = null;
            System.Object.ctor.call(this);
            this.v = v;
            this.nw = nw;
        },
        GetEnumerator: function (){
            return new Microsoft.Msagl.Layout.Layered.NetworkSimplex.IncEdgeEnumerator.ctor(this.nw.graph.OutEdges(this.v).GetEnumerator(), this.nw.graph.InEdges(this.v).GetEnumerator());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$NetworkSimplex$IncEdges);
var Microsoft$Msagl$Layout$Layered$NetworkSimplex$IncEdgeEnumerator = {
    fullname: "Microsoft.Msagl.Layout.Layered.NetworkSimplex.IncEdgeEnumerator",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IEnumerator$1"],
    Kind: "Class",
    definition: {
        ctor: function (outEdges, inEdges){
            this.outEdges = null;
            this.inEdges = null;
            this.outIsActive = false;
            this.inIsActive = false;
            System.Object.ctor.call(this);
            this.outEdges = outEdges;
            this.inEdges = inEdges;
        },
        Dispose: function (){
            System.GC.SuppressFinalize(this);
        },
        MoveNext: function (){
            this.outIsActive = this.outEdges.MoveNext();
            if (!this.outIsActive)
                this.inIsActive = this.inEdges.MoveNext();
            return this.outIsActive || this.inIsActive;
        },
        Current$$: "Microsoft.Msagl.Layout.Layered.NetworkEdge",
        get_Current: function (){
            if (this.outIsActive)
                return As(this.outEdges.get_Current(), Microsoft.Msagl.Layout.Layered.NetworkEdge.ctor);
            if (this.inIsActive)
                return As(this.inEdges.get_Current(), Microsoft.Msagl.Layout.Layered.NetworkEdge.ctor);
            throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$NetworkSimplex$IncEdgeEnumerator);
var Microsoft$Msagl$Layout$Layered$Ordering = {
    fullname: "Microsoft.Msagl.Layout.Layered.Ordering",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Layout.Layered.Ordering.MaxNumberOfAdjacentExchanges = 50;
        },
        OrderLayers: function (graph, layerArrays, startOfVirtualNodes, balanceVirtualAndOriginalNodes, settings, cancelToken){
            var hasCrossWeight = false;
            var $it859 = graph.get_Edges().GetEnumerator();
            while ($it859.MoveNext()){
                var le = $it859.get_Current();
                if (le.get_CrossingWeight() != 1){
                    hasCrossWeight = true;
                    break;
                }
            }
            var o = new Microsoft.Msagl.Layout.Layered.Ordering.ctor(graph, true, layerArrays, startOfVirtualNodes, balanceVirtualAndOriginalNodes, hasCrossWeight, settings);
            o.Run$$CancelToken(cancelToken);
        },
        CloneLayers: function (layers, layerArraysCopy){
            if (layerArraysCopy.Value == null){
                layerArraysCopy.Value = layers.Clone() instanceof Array || layers.Clone() == null ? layers.Clone() : (function (){
                    throw new Error("InvalidCastException");
                }
                ());
                for (var i = 0; i < layers.length; i++)
                    layerArraysCopy.Value[i] = layers[i].Clone() instanceof Int32Array || layers[i].Clone() == null ? layers[i].Clone() : (function (){
                        throw new Error("InvalidCastException");
                    }
                    ());
            }
            else
                for (var i = 0; i < layers.length; i++)
                    layers[i].CopyTo(layerArraysCopy.Value[i], 0);
        },
        GetCrossingsTotal: function (properLayeredGraph, layerArrays){
            var x = 0;
            for (var i = 0; i < layerArrays.get_Layers().length - 1; i++)
                x += Microsoft.Msagl.Layout.Layered.Ordering.GetCrossingCountFromStrip(i, properLayeredGraph, layerArrays);
            return x;
        },
        GetCrossingCountFromStrip: function (bottom, properLayeredGraph, layerArrays){
            var topVerts = layerArrays.get_Layers()[bottom + 1];
            var bottomVerts = layerArrays.get_Layers()[bottom];
            if (bottomVerts.length <= topVerts.length)
                return Microsoft.Msagl.Layout.Layered.Ordering.GetCrossingCountFromStripWhenBottomLayerIsShorter(bottomVerts, properLayeredGraph, layerArrays);
            else
                return Microsoft.Msagl.Layout.Layered.Ordering.GetCrossingCountFromStripWhenTopLayerIsShorter(topVerts, bottomVerts, properLayeredGraph, layerArrays);
        },
        GetCrossingCountFromStripWhenTopLayerIsShorter: function (topVerts, bottomVerts, properLayeredGraph, layerArrays){
            var edges = Microsoft.Msagl.Layout.Layered.Ordering.EdgesOfStrip(bottomVerts, properLayeredGraph);
            System.Array.Sort$1$$T$Array$$IComparer$1(Microsoft.Msagl.Layout.Layered.LayerEdge.ctor, edges, new Microsoft.Msagl.Layout.Layered.EdgeComparerByTarget.ctor(layerArrays.get_X()));
            var n = 1;
            while (n < topVerts.length)
                n *= 2;
            var tree = new Int32Array(2 * n - 1);
            n--;
            var cc = 0;
            for (var $i867 = 0,$l867 = edges.length,edge = edges[$i867]; $i867 < $l867; $i867++, edge = edges[$i867]){
                var index = n + layerArrays.get_X()[edge.get_Source()];
                var ew = edge.get_CrossingWeight();
                tree[index] += ew;
                while (index > 0){
                    if (index % 2 != 0)
                        cc += ew * tree[index + 1];
                    index = ((index - 1) / 2) | 0;
                    tree[index] += ew;
                }
            }
            return cc;
        },
        GetCrossingCountFromStripWhenBottomLayerIsShorter: function (bottomVerts, properLayeredGraph, layerArrays){
            var edges = Microsoft.Msagl.Layout.Layered.Ordering.EdgesOfStrip(bottomVerts, properLayeredGraph);
            System.Array.Sort$1$$T$Array$$IComparer$1(Microsoft.Msagl.Layout.Layered.LayerEdge.ctor, edges, new Microsoft.Msagl.Layout.Layered.EdgeComparerBySource.ctor(layerArrays.get_X()));
            var n = 1;
            while (n < bottomVerts.length)
                n *= 2;
            var tree = new Int32Array(2 * n - 1);
            n--;
            var cc = 0;
            for (var $i868 = 0,$l868 = edges.length,edge = edges[$i868]; $i868 < $l868; $i868++, edge = edges[$i868]){
                var index = n + layerArrays.get_X()[edge.get_Target()];
                var ew = edge.get_CrossingWeight();
                tree[index] += ew;
                while (index > 0){
                    if (index % 2 != 0)
                        cc += ew * tree[index + 1];
                    index = ((index - 1) / 2) | 0;
                    tree[index] += ew;
                }
            }
            return cc;
        },
        EdgesOfStrip: function (bottomVerts, properLayeredGraph){
            var edges = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Layout.Layered.LayerEdge.ctor, (System.Linq.Enumerable.SelectMany$3$$IEnumerable$1$$Func$2$$Func$3(System.Int32.ctor, Microsoft.Msagl.Layout.Layered.LayerEdge.ctor, Microsoft.Msagl.Layout.Layered.LayerEdge.ctor, bottomVerts, function (v){
                return properLayeredGraph.InEdges(v);
            }, function (v, e){
                return e;
            })));
            return edges;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (graphPar, tryReverse, layerArraysParam, startOfVirtualNodes, balanceVirtualAndOrigNodes, hasCrossWeights, settings){
            this.predecessors = null;
            this.pOrder = null;
            this.successors = null;
            this.sOrder = null;
            this.inCrossingCount = null;
            this.outCrossingCount = null;
            this.balanceVirtAndOrigNodes = false;
            this.hasCrossWeights = false;
            this.layerArrays = null;
            this.layerArraysCopy = null;
            this.layering = null;
            this.layers = null;
            this.measure = null;
            this.nOfLayers = 0;
            this.optimalOriginalGroupSize = null;
            this.optimalVirtualGroupSize = null;
            this.properLayeredGraph = null;
            this.random = null;
            this.settings = null;
            this.startOfVirtNodes = 0;
            this.tryReverse = true;
            this.X = null;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.tryReverse = tryReverse;
            this.startOfVirtNodes = startOfVirtualNodes;
            this.layerArrays = layerArraysParam;
            this.layering = layerArraysParam.Y;
            this.nOfLayers = layerArraysParam.get_Layers().length;
            this.layers = layerArraysParam.get_Layers();
            this.balanceVirtAndOrigNodes = balanceVirtualAndOrigNodes;
            this.properLayeredGraph = graphPar;
            this.hasCrossWeights = hasCrossWeights;
            this.settings = settings;
            this.random = new System.Random.ctor$$Int32(this.get_SeedOfRandom());
        },
        HeadOfTheCoin: function (){
            return this.random.Next$$Int32(2) == 0;
        },
        AdjacentExchangeWithBalancingVirtOrigNodes: function (){
            this.InitArrays();
            var count = 0;
            var progress = true;
            while (progress && count++ < 50){
                progress = false;
                for (var i = 0; i < this.layers.length; i++)
                    progress = this.AdjExchangeLayerWithBalance(i) || progress;
                for (var i = this.layers.length - 2; i >= 0; i--)
                    progress = this.AdjExchangeLayerWithBalance(i) || progress;
            }
        },
        AdjacentExchange: function (){
            this.InitArrays();
            var count = 0;
            var progress = true;
            while (progress && count++ < 50){
                progress = false;
                for (var i = 0; i < this.layers.length; i++)
                    progress = this.AdjExchangeLayer(i) || progress;
                for (var i = this.layers.length - 2; i >= 0; i--)
                    progress = this.AdjExchangeLayer(i) || progress;
            }
        },
        AllocArrays: function (){
            var n = this.properLayeredGraph.get_NodeCount();
            this.predecessors = new Array(n);
            this.successors = new Array(n);
            this.pOrder = new Array(n);
            this.sOrder = new Array(n);
            if (this.hasCrossWeights){
                this.outCrossingCount = new Array(n);
                this.inCrossingCount = new Array(n);
            }
            for (var i = 0; i < n; i++){
                var count = this.properLayeredGraph.InEdgesCount(i);
                this.predecessors[i] = new Int32Array(count);
                if (this.hasCrossWeights){
                    var inCounts = this.inCrossingCount[i] = new System.Collections.Generic.Dictionary$2.ctor$$Int32(System.Int32.ctor, System.Int32.ctor, count);
                    var $it847 = this.properLayeredGraph.InEdges(i).GetEnumerator();
                    while ($it847.MoveNext()){
                        var le = $it847.get_Current();
                        inCounts.set_Item$$TKey(le.get_Source(), le.get_CrossingWeight());
                    }
                }
                this.pOrder[i] = new System.Collections.Generic.Dictionary$2.ctor$$Int32(System.Int32.ctor, System.Int32.ctor, count);
                count = this.properLayeredGraph.OutEdgesCount(i);
                this.successors[i] = new Int32Array(count);
                this.sOrder[i] = new System.Collections.Generic.Dictionary$2.ctor$$Int32(System.Int32.ctor, System.Int32.ctor, count);
                if (this.hasCrossWeights){
                    var outCounts = this.outCrossingCount[i] = new System.Collections.Generic.Dictionary$2.ctor$$Int32(System.Int32.ctor, System.Int32.ctor, count);
                    var $it848 = this.properLayeredGraph.OutEdges(i).GetEnumerator();
                    while ($it848.MoveNext()){
                        var le = $it848.get_Current();
                        outCounts.set_Item$$TKey(le.get_Target(), le.get_CrossingWeight());
                    }
                }
            }
        },
        InitArrays: function (){
            if (this.successors == null)
                this.AllocArrays();
            for (var i = 0; i < this.properLayeredGraph.get_NodeCount(); i++){
                this.pOrder[i].Clear();
                this.sOrder[i].Clear();
            }
            for (var $i850 = 0,$t850 = this.layers,$l850 = $t850.length,t = $t850[$i850]; $i850 < $l850; $i850++, t = $t850[$i850])
                this.InitPsArraysForLayer(t);
        },
        CalcPair: function (u, v, cuv, cvu){
            var su = this.successors[u],sv = this.successors[v],pu = this.predecessors[u],pv = this.predecessors[v];
            if (!this.hasCrossWeights){
                cuv.Value = this.CountOnArrays$$Int32$Array$$Int32$Array(su, sv) + this.CountOnArrays$$Int32$Array$$Int32$Array(pu, pv);
                cvu.Value = this.CountOnArrays$$Int32$Array$$Int32$Array(sv, su) + this.CountOnArrays$$Int32$Array$$Int32$Array(pv, pu);
            }
            else {
                var uOutCrossCounts = this.outCrossingCount[u];
                var vOutCrossCounts = this.outCrossingCount[v];
                var uInCrossCounts = this.inCrossingCount[u];
                var vInCrossCounts = this.inCrossingCount[v];
                cuv.Value = this.CountOnArrays$$Int32$Array$$Int32$Array$$Dictionary$2$Int32$Int32$$Dictionary$2$Int32$Int32(su, sv, uOutCrossCounts, vOutCrossCounts) + this.CountOnArrays$$Int32$Array$$Int32$Array$$Dictionary$2$Int32$Int32$$Dictionary$2$Int32$Int32(pu, pv, uInCrossCounts, vInCrossCounts);
                cvu.Value = this.CountOnArrays$$Int32$Array$$Int32$Array$$Dictionary$2$Int32$Int32$$Dictionary$2$Int32$Int32(sv, su, vOutCrossCounts, uOutCrossCounts) + this.CountOnArrays$$Int32$Array$$Int32$Array$$Dictionary$2$Int32$Int32$$Dictionary$2$Int32$Int32(pv, pu, vInCrossCounts, uInCrossCounts);
            }
        },
        InitPsArraysForLayer: function (layer){
            this.ProgressStep();
            for (var $i851 = 0,$l851 = layer.length,l = layer[$i851]; $i851 < $l851; $i851++, l = layer[$i851]){
                var $it851 = this.properLayeredGraph.Pred(l).GetEnumerator();
                while ($it851.MoveNext()){
                    var p = $it851.get_Current();
                    var so = this.sOrder[p];
                    var sHasNow = so.get_Count();
                    this.successors[p][sHasNow] = l;
                    so.set_Item$$TKey(l, sHasNow);
                }
                var $it852 = this.properLayeredGraph.Succ(l).GetEnumerator();
                while ($it852.MoveNext()){
                    var s = $it852.get_Current();
                    var po = this.pOrder[s];
                    var pHasNow = po.get_Count();
                    this.predecessors[s][pHasNow] = l;
                    po.set_Item$$TKey(l, pHasNow);
                }
            }
        },
        CountOnArrays$$Int32$Array$$Int32$Array: function (unbs, vnbs){
            var ret = 0;
            var vl = vnbs.length - 1;
            var j = -1;
            var vnbsSeenAlready = 0;
            for (var $i854 = 0,$l854 = unbs.length,uNeighbor = unbs[$i854]; $i854 < $l854; $i854++, uNeighbor = unbs[$i854]){
                var xu = this.X[uNeighbor];
                for (; j < vl && this.X[vnbs[j + 1]] < xu; j++)
                    vnbsSeenAlready++;
                ret += vnbsSeenAlready;
            }
            return ret;
        },
        CountOnArrays$$Int32$Array$$Int32$Array$$Dictionary$2$Int32$Int32$$Dictionary$2$Int32$Int32: function (unbs, vnbs, uCrossingCounts, vCrossingCount){
            var ret = 0;
            var vl = vnbs.length - 1;
            var j = -1;
            var vCrossingNumberSeenAlready = 0;
            for (var $i855 = 0,$l855 = unbs.length,uNeib = unbs[$i855]; $i855 < $l855; $i855++, uNeib = unbs[$i855]){
                var xu = this.X[uNeib];
                var vnb;
                for (; j < vl && this.X[vnb = vnbs[j + 1]] < xu; j++)
                    vCrossingNumberSeenAlready += vCrossingCount.get_Item$$TKey(vnb);
                ret += vCrossingNumberSeenAlready * uCrossingCounts.get_Item$$TKey(uNeib);
            }
            return ret;
        },
        AdjExchangeLayer: function (i){
            this.ProgressStep();
            var layer = this.layers[i];
            var gain = this.ExchangeWithGainWithNoDisturbance(layer);
            if (gain)
                return true;
            this.DisturbLayer(layer);
            return this.ExchangeWithGainWithNoDisturbance(layer);
        },
        AdjExchangeLayerWithBalance: function (i){
            this.ProgressStep();
            var layer = this.layers[i];
            var gain = this.ExchangeWithGainWithNoDisturbanceWithBalance(layer);
            if (gain)
                return true;
            this.DisturbLayerWithBalance(layer);
            return this.ExchangeWithGainWithNoDisturbanceWithBalance(layer);
        },
        Swap: function (u, v){
            var left = this.X[u];
            var right = this.X[v];
            var ln = this.layering[u];
            var layer = this.layers[ln];
            layer[left] = v;
            layer[right] = u;
            this.X[u] = right;
            this.X[v] = left;
            this.UpdateSsContainingUv(u, v);
            this.UpdatePsContainingUv(u, v);
        },
        UpdatePsContainingUv: function (u, v){
            if (this.successors[u].length <= this.successors[v].length)
                for (var $i856 = 0,$t856 = this.successors[u],$l856 = $t856.length,a = $t856[$i856]; $i856 < $l856; $i856++, a = $t856[$i856]){
                    var porder = this.pOrder[a];
                    if (porder.ContainsKey(v)){
                        var vOffset = porder.get_Item$$TKey(v);
                        var p = this.predecessors[a];
                        p[vOffset - 1] = v;
                        p[vOffset] = u;
                        porder.set_Item$$TKey(v, vOffset - 1);
                        porder.set_Item$$TKey(u, vOffset);
                    }
                }
            else
                for (var $i857 = 0,$t857 = this.successors[v],$l857 = $t857.length,a = $t857[$i857]; $i857 < $l857; $i857++, a = $t857[$i857]){
                    var porder = this.pOrder[a];
                    if (porder.ContainsKey(u)){
                        var vOffset = porder.get_Item$$TKey(v);
                        var p = this.predecessors[a];
                        p[vOffset - 1] = v;
                        p[vOffset] = u;
                        porder.set_Item$$TKey(v, vOffset - 1);
                        porder.set_Item$$TKey(u, vOffset);
                    }
                }
        },
        UpdateSsContainingUv: function (u, v){
            if (this.predecessors[u].length <= this.predecessors[v].length)
                for (var $i858 = 0,$t858 = this.predecessors[u],$l858 = $t858.length,a = $t858[$i858]; $i858 < $l858; $i858++, a = $t858[$i858]){
                    var sorder = this.sOrder[a];
                    if (sorder.ContainsKey(v)){
                        var vOffset = sorder.get_Item$$TKey(v);
                        var s = this.successors[a];
                        s[vOffset - 1] = v;
                        s[vOffset] = u;
                        sorder.set_Item$$TKey(v, vOffset - 1);
                        sorder.set_Item$$TKey(u, vOffset);
                    }
                }
            else
                for (var $i859 = 0,$t859 = this.predecessors[v],$l859 = $t859.length,a = $t859[$i859]; $i859 < $l859; $i859++, a = $t859[$i859]){
                    var sorder = this.sOrder[a];
                    if (sorder.ContainsKey(u)){
                        var vOffset = sorder.get_Item$$TKey(v);
                        var s = this.successors[a];
                        s[vOffset - 1] = v;
                        s[vOffset] = u;
                        sorder.set_Item$$TKey(v, vOffset - 1);
                        sorder.set_Item$$TKey(u, vOffset);
                    }
                }
        },
        DisturbLayer: function (layer){
            for (var i = 0; i < layer.length - 1; i++)
                this.AdjacentSwapToTheRight(layer, i);
        },
        DisturbLayerWithBalance: function (layer){
            for (var i = 0; i < layer.length - 1; i++)
                this.AdjacentSwapToTheRightWithBalance(layer, i);
        },
        ExchangeWithGainWithNoDisturbance: function (layer){
            var wasGain = false;
            var gain;
            do{
                gain = this.ExchangeWithGain(layer);
                wasGain = wasGain || gain;
            }
            while (gain)
            return wasGain;
        },
        ExchangeWithGainWithNoDisturbanceWithBalance: function (layer){
            var wasGain = false;
            var gain;
            do{
                gain = this.ExchangeWithGainWithBalance(layer);
                wasGain = wasGain || gain;
            }
            while (gain)
            return wasGain;
        },
        ExchangeWithGain: function (layer){
            for (var i = 0; i < layer.length - 1; i++)
                if (this.SwapWithGain(layer[i], layer[i + 1])){
                    this.SwapToTheLeft(layer, i);
                    this.SwapToTheRight(layer, i + 1);
                    return true;
                }
            return false;
        },
        ExchangeWithGainWithBalance: function (layer){
            for (var i = 0; i < layer.length - 1; i++)
                if (this.SwapWithGainWithBalance(layer[i], layer[i + 1])){
                    this.SwapToTheLeftWithBalance(layer, i);
                    this.SwapToTheRightWithBalance(layer, i + 1);
                    return true;
                }
            return false;
        },
        SwapToTheLeft: function (layer, i){
            for (var j = i - 1; j >= 0; j--)
                this.AdjacentSwapToTheRight(layer, j);
        },
        SwapToTheRight: function (layer, i){
            for (var j = i; j < layer.length - 1; j++)
                this.AdjacentSwapToTheRight(layer, j);
        },
        SwapToTheLeftWithBalance: function (layer, i){
            for (var j = i - 1; j >= 0; j--)
                this.AdjacentSwapToTheRightWithBalance(layer, j);
        },
        SwapToTheRightWithBalance: function (layer, i){
            for (var j = i; j < layer.length - 1; j++)
                this.AdjacentSwapToTheRightWithBalance(layer, j);
        },
        AdjacentSwapToTheRight: function (layer, i){
            var u = layer[i],v = layer[i + 1];
            var gain = this.SwapGain(u, v);
            if (gain > 0 || (gain == 0 && this.HeadOfTheCoin()))
                this.Swap(u, v);
        },
        AdjacentSwapToTheRightWithBalance: function (layer, i){
            var u = layer[i],v = layer[i + 1];
            var gain = this.SwapGainWithBalance(u, v);
            if (gain > 0 || (gain == 0 && this.HeadOfTheCoin()))
                this.Swap(u, v);
        },
        SwapGain: function (u, v){
            var cuv;
            var cvu;
            (function (){
                var $1 = {
                    Value: cuv
                };
                var $2 = {
                    Value: cvu
                };
                var $res = this.CalcPair(u, v, $1, $2);
                cuv = $1.Value;
                cvu = $2.Value;
                return $res;
            }).call(this);
            return cuv - cvu;
        },
        SwapGainWithBalance: function (u, v){
            var cuv;
            var cvu;
            (function (){
                var $1 = {
                    Value: cuv
                };
                var $2 = {
                    Value: cvu
                };
                var $res = this.CalcPair(u, v, $1, $2);
                cuv = $1.Value;
                cvu = $2.Value;
                return $res;
            }).call(this);
            var gain = cuv - cvu;
            if (gain != 0 && this.UvAreOfSameKind(u, v))
                return gain;
            return this.SwapGroupGain(u, v);
        },
        UvAreOfSameKind: function (u, v){
            return u < this.startOfVirtNodes && v < this.startOfVirtNodes || u >= this.startOfVirtNodes && v >= this.startOfVirtNodes;
        },
        SwapGroupGain: function (u, v){
            var layerIndex = this.layerArrays.Y[u];
            var layer = this.layers[layerIndex];
            if (this.NeighborsForbidTheSwap(u, v))
                return -1;
            var uPosition = this.X[u];
            var uIsSeparator;
            if (this.IsOriginal(u))
                uIsSeparator = this.optimalOriginalGroupSize[layerIndex] == 1;
            else
                uIsSeparator = this.optimalVirtualGroupSize[layerIndex] == 1;
            var delta = this.CalcDeltaBetweenGroupsToTheLeftAndToTheRightOfTheSeparator(layer, uIsSeparator ? uPosition : uPosition + 1, uIsSeparator ? u : v);
            if (uIsSeparator){
                if (delta < -1)
                    return 1;
                if (delta == -1)
                    return 0;
                return -1;
            }
            if (delta > 1)
                return 1;
            if (delta == 1)
                return 0;
            return -1;
        },
        NeighborsForbidTheSwap: function (u, v){
            return this.UpperNeighborsForbidTheSwap(u, v) || this.LowerNeighborsForbidTheSwap(u, v);
        },
        LowerNeighborsForbidTheSwap: function (u, v){
            var uCount,vCount;
            if (((uCount = this.properLayeredGraph.OutEdgesCount(u)) == 0) || ((vCount = this.properLayeredGraph.OutEdgesCount(v)) == 0))
                return false;
            return this.X[this.successors[u][uCount >> 1]] < this.X[this.successors[v][vCount >> 1]];
        },
        UpperNeighborsForbidTheSwap: function (u, v){
            var uCount = this.properLayeredGraph.InEdgesCount(u);
            var vCount = this.properLayeredGraph.InEdgesCount(v);
            if (uCount == 0 || vCount == 0)
                return false;
            return this.X[this.predecessors[u][uCount >> 1]] < this.X[this.predecessors[v][vCount >> 1]];
        },
        CalcDeltaBetweenGroupsToTheLeftAndToTheRightOfTheSeparator: function (layer, separatorPosition, separator){
            var kind = this.GetKindDelegate(separator);
            var leftGroupSize = 0;
            for (var i = separatorPosition - 1; i >= 0 && !kind(layer[i]); i--)
                leftGroupSize++;
            var rightGroupSize = 0;
            for (var i = separatorPosition + 1; i < layer.length && !kind(layer[i]); i++)
                rightGroupSize++;
            return leftGroupSize - rightGroupSize;
        },
        IsOriginal: function (v){
            return v < this.startOfVirtNodes;
        },
        IsVirtual: function (v){
            return v >= this.startOfVirtNodes;
        },
        GetKindDelegate: function (v){
            var kind = this.IsVirtual(v) ? $CreateDelegate(this, this.IsVirtual) : $CreateDelegate(this, this.IsOriginal);
            return kind;
        },
        SwapWithGain: function (u, v){
            var gain = this.SwapGain(u, v);
            if (gain > 0){
                this.Swap(u, v);
                return true;
            }
            return false;
        },
        SwapWithGainWithBalance: function (u, v){
            var gain = this.SwapGainWithBalance(u, v);
            if (gain > 0){
                this.Swap(u, v);
                return true;
            }
            return false;
        },
        NoGainStepsBound$$: "System.Int32",
        get_NoGainStepsBound: function (){
            return this.get_SugiyamaLayoutSettings().get_NoGainAdjacentSwapStepsBound() * this.get_SugiyamaLayoutSettings().get_RepetitionCoefficientForOrdering();
        },
        SugiyamaLayoutSettings$$: "Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings",
        get_SugiyamaLayoutSettings: function (){
            return this.settings;
        },
        SeedOfRandom$$: "System.Int32",
        get_SeedOfRandom: function (){
            return this.get_SugiyamaLayoutSettings().get_RandomSeedForOrdering();
        },
        MaxOfIterations$$: "System.Int32",
        get_MaxOfIterations: function (){
            return this.get_SugiyamaLayoutSettings().get_MaxNumberOfPassesInOrdering() * this.get_SugiyamaLayoutSettings().get_RepetitionCoefficientForOrdering();
        },
        RunInternal: function (){
            this.Calculate();
            if (this.tryReverse){
                var secondLayers = this.layerArrays.ReversedClone();
                var revOrdering = new Microsoft.Msagl.Layout.Layered.Ordering.ctor(this.properLayeredGraph.ReversedClone(), false, secondLayers, this.startOfVirtNodes, this.balanceVirtAndOrigNodes, this.hasCrossWeights, this.settings);
                revOrdering.Run();
                if (Microsoft.Msagl.Layout.Layered.OrderingMeasure.op_LessThan(revOrdering.measure, this.measure)){
                    for (var j = 0; j < this.nOfLayers; j++)
                        secondLayers.get_Layers()[j].CopyTo(this.layerArrays.get_Layers()[this.nOfLayers - 1 - j], 0);
                    this.layerArrays.UpdateXFromLayers();
                }
            }
        },
        Calculate: function (){
            this.Init();
            (function (){
                var $1 = {
                    Value: this.layerArraysCopy
                };
                var $res = Microsoft.Msagl.Layout.Layered.Ordering.CloneLayers(this.layers, $1);
                this.layerArraysCopy = $1.Value;
                return $res;
            }).call(this);
            var countOfNoGainSteps = 0;
            this.measure = new Microsoft.Msagl.Layout.Layered.OrderingMeasure.ctor(this.layerArraysCopy, Microsoft.Msagl.Layout.Layered.Ordering.GetCrossingsTotal(this.properLayeredGraph, this.layerArrays), this.startOfVirtNodes, this.optimalOriginalGroupSize, this.optimalVirtualGroupSize);
            for (var i = 0; i < this.get_MaxOfIterations() && countOfNoGainSteps < this.get_NoGainStepsBound() && !this.measure.IsPerfect(); i++){
                this.ProgressStep();
                var up = i % 2 == 0;
                this.LayerByLayerSweep(up);
                if (!this.balanceVirtAndOrigNodes)
                    this.AdjacentExchange();
                else
                    this.AdjacentExchangeWithBalancingVirtOrigNodes();
                var newMeasure = new Microsoft.Msagl.Layout.Layered.OrderingMeasure.ctor(this.layerArrays.get_Layers(), Microsoft.Msagl.Layout.Layered.Ordering.GetCrossingsTotal(this.properLayeredGraph, this.layerArrays), this.startOfVirtNodes, this.optimalOriginalGroupSize, this.optimalVirtualGroupSize);
                if (Microsoft.Msagl.Layout.Layered.OrderingMeasure.op_LessThan(this.measure, newMeasure)){
                    this.Restore();
                    countOfNoGainSteps++;
                }
                else if (Microsoft.Msagl.Layout.Layered.OrderingMeasure.op_LessThan(newMeasure, this.measure) || this.HeadOfTheCoin()){
                    countOfNoGainSteps = 0;
                    (function (){
                        var $1 = {
                            Value: this.layerArraysCopy
                        };
                        var $res = Microsoft.Msagl.Layout.Layered.Ordering.CloneLayers(this.layers, $1);
                        this.layerArraysCopy = $1.Value;
                        return $res;
                    }).call(this);
                    this.measure = newMeasure;
                }
            }
        },
        Restore: function (){
            this.layerArrays.UpdateLayers(this.layerArraysCopy);
        },
        LayerByLayerSweep: function (up){
            if (up){
                for (var i = 1; i < this.nOfLayers; i++)
                    this.SweepLayer(i, true);
            }
            else
                for (var i = this.nOfLayers - 2; i >= 0; i--)
                    this.SweepLayer(i, false);
        },
        SweepLayer: function (layer, upperLayer){
            this.ProgressStep();
            var l = this.layers[layer];
            var medianValues = new Float32Array(l.length);
            for (var i = 0; i < medianValues.length; i++)
                medianValues[i] = this.WMedian(l[i], upperLayer);
            this.Sort(layer, medianValues);
            var vertices = this.layerArrays.get_Layers()[layer];
            for (var i = 0; i < vertices.length; i++)
                this.layerArrays.get_X()[vertices[i]] = i;
        },
        Sort: function (layerToSort, medianValues){
            var s = new System.Collections.Generic.SortedDictionary$2.ctor(System.Single.ctor, System.Object.ctor);
            var vertices = this.layers[layerToSort];
            var i = 0;
            for (var $i861 = 0,$l861 = medianValues.length,m = medianValues[$i861]; $i861 < $l861; $i861++, m = medianValues[$i861]){
                var v = vertices[i++];
                if (m == -1)
                    continue;
                if (!s.ContainsKey(m))
                    s.set_Item$$TKey(m, v);
                else {
                    var o = s.get_Item$$TKey(m);
                    var al = As(o, System.Collections.Generic.List$1.ctor);
                    if (al != null){
                        if (this.HeadOfTheCoin())
                            al.Add(v);
                        else {
                            var j = this.random.Next$$Int32(al.get_Count());
                            var k = al.get_Item$$Int32(j);
                            al.set_Item$$Int32(j, v);
                            al.Add(k);
                        }
                    }
                    else {
                        var io = o;
                        al = new System.Collections.Generic.List$1.ctor(System.Int32.ctor);
                        s.set_Item$$TKey(m, al);
                        if (this.HeadOfTheCoin()){
                            al.Add(io);
                            al.Add(v);
                        }
                        else {
                            al.Add(v);
                            al.Add(io);
                        }
                    }
                }
            }
            var senum = s.GetEnumerator();
            for (i = 0; i < vertices.length;){
                if (medianValues[i] != -1){
                    senum.MoveNext();
                    var o = senum.get_Current().get_Value();
                    if (o.GetType() == Typeof(System.Int32.ctor))
                        vertices[i++] = o;
                    else {
                        var al = As(o, System.Collections.Generic.List$1.ctor);
                        var $it861 = al.GetEnumerator();
                        while ($it861.MoveNext()){
                            var v = $it861.get_Current();
                            while (medianValues[i] == -1)
                                i++;
                            vertices[i++] = v;
                        }
                    }
                }
                else
                    i++;
            }
        },
        WMedian: function (node, theMedianGoingDown){
            var edges;
            var p;
            if (theMedianGoingDown){
                edges = this.properLayeredGraph.OutEdges(node);
                p = this.properLayeredGraph.OutEdgesCount(node);
            }
            else {
                edges = this.properLayeredGraph.InEdges(node);
                p = this.properLayeredGraph.InEdgesCount(node);
            }
            if (p == 0)
                return -1;
            var parray = new Int32Array(p);
            var i = 0;
            if (theMedianGoingDown){
                var $it862 = edges.GetEnumerator();
                while ($it862.MoveNext()){
                    var e = $it862.get_Current();
                    parray[i++] = this.X[e.get_Target()];
                }
            }
            else {
                var $it863 = edges.GetEnumerator();
                while ($it863.MoveNext()){
                    var e = $it863.get_Current();
                    parray[i++] = this.X[e.get_Source()];
                }
            }
            System.Array.Sort$1$$T$Array(System.Int32.ctor, parray);
            var m = (p / 2) | 0;
            if (p % 2 == 1)
                return parray[m];
            if (p == 2)
                return 0.5 * (parray[0] + parray[1]);
            var left = parray[m - 1] - parray[0];
            var right = parray[p - 1] - parray[m];
            return (parray[m - 1] * left + parray[m] * right) / (left + right);
        },
        Init: function (){
            var counts = new Int32Array(this.nOfLayers);
            var q = new System.Collections.Generic.Stack$1.ctor(System.Int32.ctor);
            for (var i = 0; i < this.properLayeredGraph.get_NodeCount(); i++)
                if (this.properLayeredGraph.InEdgesCount(i) == 0)
                    q.Push(i);
            var visited = new Array(this.properLayeredGraph.get_NodeCount());
            while (q.get_Count() > 0){
                var u = q.Pop();
                var l = this.layerArrays.Y[u];
                this.layerArrays.get_Layers()[l][counts[l]] = u;
                this.layerArrays.get_X()[u] = counts[l];
                counts[l]++;
                var $it864 = this.properLayeredGraph.Succ(u).GetEnumerator();
                while ($it864.MoveNext()){
                    var v = $it864.get_Current();
                    if (!visited[v]){
                        visited[v] = true;
                        q.Push(v);
                    }
                }
            }
            this.X = this.layerArrays.get_X();
            if (this.balanceVirtAndOrigNodes)
                this.InitOptimalGroupSizes();
        },
        InitOptimalGroupSizes: function (){
            this.optimalOriginalGroupSize = new Float64Array(this.nOfLayers);
            this.optimalVirtualGroupSize = new Float64Array(this.nOfLayers);
            for (var i = 0; i < this.nOfLayers; i++)
                this.InitOptimalGroupSizesForLayer(i);
        },
        InitOptimalGroupSizesForLayer: function (i){
            var originals = 0;
            for (var $i866 = 0,$t866 = this.layers[i],$l866 = $t866.length,j = $t866[$i866]; $i866 < $l866; $i866++, j = $t866[$i866])
                if (j < this.startOfVirtNodes)
                    originals++;
            var virtuals = this.layers[i].length - originals;
            if (originals < virtuals){
                this.optimalOriginalGroupSize[i] = 1;
                this.optimalVirtualGroupSize[i] = virtuals / (originals + 1);
            }
            else {
                this.optimalVirtualGroupSize[i] = 1;
                this.optimalOriginalGroupSize[i] = originals / (virtuals + 1);
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$Ordering);
var Microsoft$Msagl$Layout$Layered$EdgePathsInserter = {
    fullname: "Microsoft.Msagl.Layout.Layered.EdgePathsInserter",
    baseTypeName: "System.Object",
    staticDefinition: {
        InsertPaths$$ProperLayeredGraph$$LayerArrays$$Database$$BasicGraph$2$Node$IntEdge: function (layeredGraph, la, db, intGraphP){
            var li = new Microsoft.Msagl.Layout.Layered.EdgePathsInserter.ctor(layeredGraph.Value, la.Value, db, intGraphP);
            li.InsertPaths();
            layeredGraph.Value = li.get_NLayeredGraph();
            la.Value = li.get_Nla();
        },
        GetTarget: function (currentVV, e, i, span){
            if (i < span - 1)
                return currentVV.Value;
            return e.get_Target();
        },
        GetSource: function (currentVV, e, i){
            if (i == 0)
                return e.get_Source();
            return currentVV.Value++;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (layeredGraph, la, database, intGraphP){
            this.database = null;
            this.intGraph = null;
            this.layeredGraph = null;
            this.nLayeredGraph = null;
            this.virtNodesToIntEdges = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, Microsoft.Msagl.Layout.Layered.IntEdge.ctor);
            this.la = null;
            this.nla = null;
            System.Object.ctor.call(this);
            this.la = la;
            this.database = database;
            this.layeredGraph = layeredGraph;
            this.intGraph = intGraphP;
        },
        NLayeredGraph$$: "Microsoft.Msagl.Layout.Layered.ProperLayeredGraph",
        get_NLayeredGraph: function (){
            return this.nLayeredGraph;
        },
        Nla$$: "Microsoft.Msagl.Layout.Layered.LayerArrays",
        get_Nla: function (){
            return this.nla;
        },
        NLayering$$: "System.Int32[]",
        get_NLayering: function (){
            return this.nla.Y;
        },
        InsertPaths: function (){
            this.CreateFullLayeredGraph();
            this.InitNewLayering();
            this.MapVirtualNodesToEdges();
            this.WidenOriginalLayers();
        },
        WidenOriginalLayers: function (){
            for (var i = 0; i < this.la.get_Layers().length; i++){
                var layer = this.nla.get_Layers()[i];
                var offset = 0;
                for (var $i869 = 0,$t869 = this.la.get_Layers()[i],$l869 = $t869.length,v = $t869[$i869]; $i869 < $l869; $i869++, v = $t869[$i869]){
                    var e;
                    (function (){
                        var $1 = {
                            Value: e
                        };
                        var $res = this.virtNodesToIntEdges.TryGetValue(v, $1);
                        e = $1.Value;
                        return $res;
                    }).call(this);
                    if (e != null){
                        var layerOffsetInTheEdge = this.get_NLayering()[e.get_Source()] - this.get_NLayering()[v];
                        var list = this.database.get_Multiedges().get_Item$$TKey(new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(e.get_Source(), e.get_Target()));
                        var $it869 = list.GetEnumerator();
                        while ($it869.MoveNext()){
                            var ie = $it869.get_Current();
                            if (!this.EdgeIsFlat(ie)){
                                if (ie != e){
                                    var u = ie.get_LayerEdges().get_Item$$Int32(layerOffsetInTheEdge).get_Source();
                                    layer[offset] = u;
                                    this.nla.get_X()[u] = offset++;
                                }
                                else {
                                    layer[offset] = v;
                                    this.nla.get_X()[v] = offset++;
                                }
                            }
                        }
                    }
                    else {
                        layer[offset] = v;
                        this.nla.get_X()[v] = offset++;
                    }
                }
            }
        },
        EdgeIsFlat: function (ie){
            return this.la.Y[ie.get_Source()] == this.la.Y[ie.get_Target()];
        },
        MapVirtualNodesToEdges: function (){
            var $it870 = this.database.get_RegularMultiedges().GetEnumerator();
            while ($it870.MoveNext()){
                var list = $it870.get_Current();
                var $it871 = list.GetEnumerator();
                while ($it871.MoveNext()){
                    var e = $it871.get_Current();
                    if (!this.EdgeIsFlat(e)){
                        var $it872 = e.get_LayerEdges().GetEnumerator();
                        while ($it872.MoveNext()){
                            var le = $it872.get_Current();
                            if (le.get_Target() != e.get_Target())
                                this.virtNodesToIntEdges.set_Item$$TKey(le.get_Target(), e);
                        }
                    }
                }
            }
        },
        CreateFullLayeredGraph: function (){
            var currentVV = this.layeredGraph.get_NodeCount();
            var $it873 = this.database.get_Multiedges().GetEnumerator();
            while ($it873.MoveNext()){
                var kv = $it873.get_Current();
                if (kv.get_Key().x != kv.get_Key().y){
                    var list = kv.get_Value();
                    var first = true;
                    var span = 0;
                    var $it874 = list.GetEnumerator();
                    while ($it874.MoveNext()){
                        var e = $it874.get_Current();
                        if (first){
                            first = false;
                            span = e.get_LayerSpan();
                        }
                        else {
                            e.set_LayerEdges(new Array(span));
                            if (span == 1)
                                e.get_LayerEdges().set_Item$$Int32(0, new Microsoft.Msagl.Layout.Layered.LayerEdge.ctor$$Int32$$Int32$$Int32(e.get_Source(), e.get_Target(), e.get_CrossingWeight()));
                            else {
                                for (var i = 0; i < span; i++){
                                    var source = (function (){
                                        var $1 = {
                                            Value: currentVV
                                        };
                                        var $res = Microsoft.Msagl.Layout.Layered.EdgePathsInserter.GetSource($1, e, i);
                                        currentVV = $1.Value;
                                        return $res;
                                    }).call(this);
                                    var target = (function (){
                                        var $1 = {
                                            Value: currentVV
                                        };
                                        var $res = Microsoft.Msagl.Layout.Layered.EdgePathsInserter.GetTarget($1, e, i, span);
                                        currentVV = $1.Value;
                                        return $res;
                                    }).call(this);
                                    e.get_LayerEdges().set_Item$$Int32(i, new Microsoft.Msagl.Layout.Layered.LayerEdge.ctor$$Int32$$Int32$$Int32(source, target, e.get_CrossingWeight()));
                                }
                            }
                        }
                        Microsoft.Msagl.Layout.Layered.LayerInserter.RegisterDontStepOnVertex(this.database, e);
                    }
                }
            }
            this.nLayeredGraph = new Microsoft.Msagl.Layout.Layered.ProperLayeredGraph.ctor(this.intGraph);
        },
        InitNewLayering: function (){
            this.nla = new Microsoft.Msagl.Layout.Layered.LayerArrays.ctor(new Int32Array(this.get_NLayeredGraph().get_NodeCount()));
            for (var i = 0; i < this.layeredGraph.get_NodeCount(); i++)
                this.get_NLayering()[i] = this.la.Y[i];
            var $it875 = this.database.get_Multiedges().GetEnumerator();
            while ($it875.MoveNext()){
                var kv = $it875.get_Current();
                if (kv.get_Key().get_First() != kv.get_Key().get_Second() && this.la.Y[kv.get_Key().get_First()] != this.la.Y[kv.get_Key().get_Second()]){
                    var layer = 0;
                    var first = true;
                    var list = kv.get_Value();
                    var $it876 = list.GetEnumerator();
                    while ($it876.MoveNext()){
                        var e = $it876.get_Current();
                        if (first){
                            first = false;
                            layer = this.la.Y[e.get_Source()];
                        }
                        var cl = layer - 1;
                        var $it877 = e.get_LayerEdges().GetEnumerator();
                        while ($it877.MoveNext()){
                            var le = $it877.get_Current();
                            this.get_NLayering()[le.get_Target()] = cl--;
                        }
                    }
                }
            }
            var newLayers = new Array(this.la.get_Layers().length);
            var counts = new Int32Array(newLayers.length);
            for (var $i879 = 0,$t879 = this.get_NLayering(),$l879 = $t879.length,l = $t879[$i879]; $i879 < $l879; $i879++, l = $t879[$i879])
                counts[l]++;
            for (var i = 0; i < counts.length; i++)
                newLayers[i] = new Int32Array(counts[i]);
            this.nla = new Microsoft.Msagl.Layout.Layered.LayerArrays.ctor(this.get_NLayering());
            this.nla.set_Layers(newLayers);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$EdgePathsInserter);
var Microsoft$Msagl$Layout$Layered$LayerInserter = {
    fullname: "Microsoft.Msagl.Layout.Layered.LayerInserter",
    baseTypeName: "System.Object",
    staticDefinition: {
        InsertLayers$$ProperLayeredGraph$$LayerArrays$$Database$$BasicGraph$2$Node$IntEdge: function (layeredGraph, la, db, intGraphP){
            var li = new Microsoft.Msagl.Layout.Layered.LayerInserter.ctor(layeredGraph.Value, la.Value, db, intGraphP);
            li.InsertLayers();
            layeredGraph.Value = li.get_NLayeredGraph();
            la.Value = li.get_Nla().DropEmptyLayers();
        },
        RegisterDontStepOnVertex: function (db, parent){
            if (db.get_Multiedges().get_Item$$TKey(new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(parent.get_Source(), parent.get_Target())).get_Count() > 1){
                var e = parent.get_LayerEdges().get_Item$$Int32((parent.get_LayerEdges().get_Count() / 2) | 0);
                db.get_MultipleMiddles().Insert(e.get_Source());
            }
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (layeredGraph, la, database, intGraphP){
            this.intGraph = null;
            this.database = null;
            this.layeredGraph = null;
            this.nLayeredGraph = null;
            this.virtNodesToIntEdges = null;
            this.la = null;
            this.nla = null;
            this.totalNodes = 0;
            System.Object.ctor.call(this);
            this.la = la;
            this.database = database;
            this.layeredGraph = layeredGraph;
            this.intGraph = intGraphP;
        },
        NLayeredGraph$$: "Microsoft.Msagl.Layout.Layered.ProperLayeredGraph",
        get_NLayeredGraph: function (){
            return this.nLayeredGraph;
        },
        Nla$$: "Microsoft.Msagl.Layout.Layered.LayerArrays",
        get_Nla: function (){
            return this.nla;
        },
        NLayering$$: "System.Int32[]",
        get_NLayering: function (){
            return this.nla.Y;
        },
        InsertLayers: function (){
            this.EditOldLayering();
            this.CreateFullLayeredGraph();
            this.InitNewLayering();
            this.MapVirtualNodesToEdges();
            this.FillUnsortedNewOddLayers();
            this.WidenOriginalLayers();
            this.SortNewOddLayers();
        },
        EditOldLayering: function (){
            var curVNode = this.intGraph.get_NodeCount();
            var $it879 = this.database.get_RegularMultiedges().GetEnumerator();
            while ($it879.MoveNext()){
                var list = $it879.get_Current();
                var span = 0;
                var e = list.get_Item$$Int32(0);
                span = e.get_LayerSpan() * 2;
                if (span > 0){
                    var $it880 = e.get_LayerEdges().GetEnumerator();
                    while ($it880.MoveNext()){
                        var le = $it880.get_Current();
                        if (le.get_Target() != e.get_Target()){
                            curVNode++;
                            this.UpdateOldLayer(curVNode++, le.get_Target());
                        }
                    }
                    curVNode += (span - 1) * (list.get_Count() - 1) + 1;
                }
            }
        },
        UpdateOldLayer: function (replacingNode, prevNode){
            var x = this.la.get_X()[prevNode];
            var y = this.la.Y[prevNode];
            var layer = this.la.get_Layers()[y];
            layer[x] = replacingNode;
        },
        WidenOriginalLayers: function (){
            for (var i = 0; i < this.la.get_Layers().length; i++){
                var layer = this.nla.get_Layers()[i * 2];
                var offset = 0;
                for (var $i882 = 0,$t882 = this.la.get_Layers()[i],$l882 = $t882.length,v = $t882[$i882]; $i882 < $l882; $i882++, v = $t882[$i882]){
                    var e = this.virtNodesToIntEdges[v];
                    if (e != null){
                        var layerOffsetInTheEdge = this.get_NLayering()[e.get_Source()] - this.get_NLayering()[v];
                        var list = this.database.get_Multiedges().get_Item$$TKey(new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(e.get_Source(), e.get_Target()));
                        var $it882 = list.GetEnumerator();
                        while ($it882.MoveNext()){
                            var ie = $it882.get_Current();
                            if (ie != e){
                                var u = ie.get_LayerEdges().get_Item$$Int32(layerOffsetInTheEdge).get_Source();
                                layer[offset] = u;
                                this.nla.get_X()[u] = offset++;
                            }
                            else {
                                layer[offset] = v;
                                this.nla.get_X()[v] = offset++;
                            }
                        }
                    }
                    else {
                        layer[offset] = v;
                        this.nla.get_X()[v] = offset++;
                    }
                }
            }
        },
        FillUnsortedNewOddLayers: function (){
            var c = new Int32Array(this.nla.get_Layers().length);
            for (var i = this.intGraph.get_NodeCount(); i < this.nLayeredGraph.get_NodeCount(); i++){
                var layer = this.get_NLayering()[i];
                if (layer % 2 == 1){
                    this.nla.get_Layers()[layer][c[layer]++] = i;
                }
            }
        },
        MapVirtualNodesToEdges: function (){
            this.virtNodesToIntEdges = new Array(this.get_NLayering().length);
            var $it883 = this.database.get_AllIntEdges().GetEnumerator();
            while ($it883.MoveNext()){
                var e = $it883.get_Current();
                if (e.get_Source() != e.get_Target() && e.get_LayerEdges() != null){
                    var $it884 = e.get_LayerEdges().GetEnumerator();
                    while ($it884.MoveNext()){
                        var le = $it884.get_Current();
                        if (le.get_Target() != e.get_Target())
                            this.virtNodesToIntEdges[le.get_Target()] = e;
                    }
                }
            }
        },
        CreateFullLayeredGraph: function (){
            this.totalNodes = this.intGraph.get_NodeCount();
            var $it885 = this.database.get_RegularMultiedges().GetEnumerator();
            while ($it885.MoveNext()){
                var list = $it885.get_Current();
                var span = 0;
                var first = true;
                var $it886 = list.GetEnumerator();
                while ($it886.MoveNext()){
                    var e = $it886.get_Current();
                    if (first){
                        first = false;
                        span = e.get_LayerSpan() * 2;
                    }
                    if (span > 0){
                        e.set_LayerEdges(new Array(span));
                        for (var i = 0; i < span; i++){
                            var source = (function (){
                                var $1 = {
                                    Value: this.totalNodes
                                };
                                var $res = Microsoft.Msagl.Layout.Layered.EdgePathsInserter.GetSource($1, e, i);
                                this.totalNodes = $1.Value;
                                return $res;
                            }).call(this);
                            var target = (function (){
                                var $1 = {
                                    Value: this.totalNodes
                                };
                                var $res = Microsoft.Msagl.Layout.Layered.EdgePathsInserter.GetTarget($1, e, i, span);
                                this.totalNodes = $1.Value;
                                return $res;
                            }).call(this);
                            e.get_LayerEdges().set_Item$$Int32(i, new Microsoft.Msagl.Layout.Layered.LayerEdge.ctor$$Int32$$Int32$$Int32(source, target, e.get_CrossingWeight()));
                        }
                        Microsoft.Msagl.Layout.Layered.LayerInserter.RegisterDontStepOnVertex(this.database, e);
                    }
                }
            }
            this.nLayeredGraph = new Microsoft.Msagl.Layout.Layered.ProperLayeredGraph.ctor(this.intGraph);
        },
        SortNewOddLayers: function (){
            for (var i = 1; i < this.nla.get_Layers().length; i += 2){
                var sd = new System.Collections.Generic.SortedDictionary$2.ctor(System.Int32.ctor, System.Object.ctor);
                var layer = this.nla.get_Layers()[i];
                for (var $i888 = 0,$l888 = layer.length,v = layer[$i888]; $i888 < $l888; $i888++, v = layer[$i888]){
                    var predecessor = -1;
                    var $it888 = this.nLayeredGraph.InEdges(v).GetEnumerator();
                    while ($it888.MoveNext()){
                        var ie = $it888.get_Current();
                        predecessor = ie.get_Source();
                    }
                    var successor = -1;
                    var $it889 = this.nLayeredGraph.OutEdges(v).GetEnumerator();
                    while ($it889.MoveNext()){
                        var ie = $it889.get_Current();
                        successor = ie.get_Target();
                    }
                    var x = this.nla.get_X()[predecessor] + this.nla.get_X()[successor];
                    if (sd.ContainsKey(x)){
                        var o = sd.get_Item$$TKey(x);
                        if (o.GetType() == Typeof(System.Int32.ctor)){
                            var l = new System.Collections.Generic.List$1.ctor(System.Int32.ctor);
                            l.Add(o);
                            l.Add(v);
                            sd.set_Item$$TKey(x, l);
                        }
                        else {
                            var l = As(o, System.Collections.Generic.List$1.ctor);
                            l.Add(v);
                        }
                    }
                    else
                        sd.set_Item$$TKey(x, v);
                }
                var c = 0;
                var $it890 = sd.get_Values().GetEnumerator();
                while ($it890.MoveNext()){
                    var v = $it890.get_Current();
                    if (v.GetType() == Typeof(System.Int32.ctor))
                        layer[c++] = v;
                    else {
                        var $it891 = As(v, System.Collections.Generic.List$1.ctor).GetEnumerator();
                        while ($it891.MoveNext()){
                            var k = $it891.get_Current();
                            layer[c++] = k;
                        }
                    }
                }
                for (var m = 0; m < layer.length; m++)
                    this.nla.get_X()[layer[m]] = m;
            }
        },
        InitNewLayering: function (){
            this.nla = new Microsoft.Msagl.Layout.Layered.LayerArrays.ctor(new Int32Array(this.totalNodes));
            for (var i = 0; i < this.layeredGraph.get_NodeCount(); i++)
                this.get_NLayering()[i] = this.la.Y[i] * 2;
            var $it892 = this.database.get_Multiedges().GetEnumerator();
            while ($it892.MoveNext()){
                var kv = $it892.get_Current();
                var ip = kv.get_Key();
                if (ip.get_First() != ip.get_Second() && this.la.Y[ip.get_First()] != this.la.Y[ip.get_Second()]){
                    var top = this.la.Y[ip.x] * 2;
                    var $it893 = kv.get_Value().GetEnumerator();
                    while ($it893.MoveNext()){
                        var e = $it893.get_Current();
                        var layer = top - 1;
                        var $it894 = e.get_LayerEdges().GetEnumerator();
                        while ($it894.MoveNext()){
                            var le = $it894.get_Current();
                            if (le.get_Target() != e.get_Target())
                                this.get_NLayering()[le.get_Target()] = layer--;
                        }
                    }
                }
            }
            var newLayers = new Array(2 * this.la.get_Layers().length - 1);
            var counts = new Int32Array(newLayers.length);
            for (var $i896 = 0,$t896 = this.get_NLayering(),$l896 = $t896.length,l = $t896[$i896]; $i896 < $l896; $i896++, l = $t896[$i896])
                counts[l]++;
            for (var i = 0; i < counts.length; i++)
                newLayers[i] = new Int32Array(counts[i]);
            this.nla = new Microsoft.Msagl.Layout.Layered.LayerArrays.ctor(this.get_NLayering());
            this.nla.set_Layers(newLayers);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$LayerInserter);
var Microsoft$Msagl$Layout$Layered$Balancing = {
    fullname: "Microsoft.Msagl.Layout.Layered.Balancing",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        },
        Balance: function (dag, layering, nodeCount, cancelObj){
            var b = new Microsoft.Msagl.Layout.Layered.Balancing.ctor(dag, layering, nodeCount);
            b.Run$$CancelToken(cancelObj);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (dag, layering, nodeCount){
            this.jumpers = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(System.Int32.ctor);
            this.possibleJumperFeasibleIntervals = null;
            this.vertsCounts = null;
            this.dag = null;
            this.layering = null;
            this.nodeCount = null;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.nodeCount = nodeCount;
            this.dag = dag;
            this.layering = layering;
            this.Init();
        },
        RunInternal: function (){
            while (this.jumpers.get_Count() > 0)
                this.Jump(this.ChooseJumper());
        },
        Init: function (){
            this.CalculateLayerCounts();
            this.InitJumpers();
        },
        Jump: function (jumper){
            this.ProgressStep();
            this.jumpers.Delete(jumper);
            var upLow = this.possibleJumperFeasibleIntervals.get_Item$$TKey(jumper);
            var jumperLayer,layerToJumpTo;
            if ((function (){
                var $1 = {
                    Value: jumperLayer
                };
                var $2 = {
                    Value: layerToJumpTo
                };
                var $res = this.CalcJumpInfo(upLow.x, upLow.y, jumper, $1, $2);
                jumperLayer = $1.Value;
                layerToJumpTo = $2.Value;
                return $res;
            }).call(this)){
                this.layering[jumper] = layerToJumpTo;
                var jumperCount = this.nodeCount[jumper];
                this.vertsCounts[jumperLayer] -= jumperCount;
                this.vertsCounts[layerToJumpTo] += jumperCount;
                this.UpdateRegionsForPossibleJumpersAndInsertJumpers(jumperLayer, jumper);
            }
        },
        IsJumper: function (v){
            return this.possibleJumperFeasibleIntervals.ContainsKey(v);
        },
        UpdateRegionsForPossibleJumpersAndInsertJumpers: function (jumperLayer, jumper){
            var neighborPossibleJumpers = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(System.Int32.ctor);
            var $it896 = new Microsoft.Msagl.Layout.Layered.Pred.ctor(this.dag, jumper).GetEnumerator();
            while ($it896.MoveNext()){
                var v = $it896.get_Current();
                if (this.IsJumper(v)){
                    this.CalculateRegionAndInsertJumper(v);
                    neighborPossibleJumpers.Insert(v);
                }
            }
            var $it897 = new Microsoft.Msagl.Layout.Layered.Succ.ctor(this.dag, jumper).GetEnumerator();
            while ($it897.MoveNext()){
                var v = $it897.get_Current();
                if (this.IsJumper(v)){
                    this.CalculateRegionAndInsertJumper(v);
                    neighborPossibleJumpers.Insert(v);
                }
            }
            var possibleJumpersToUpdate = new System.Collections.Generic.List$1.ctor(System.Int32.ctor);
            var $it898 = this.possibleJumperFeasibleIntervals.GetEnumerator();
            while ($it898.MoveNext()){
                var kv = $it898.get_Current();
                if (!neighborPossibleJumpers.Contains$$T(kv.get_Key()))if (kv.get_Value().x > jumperLayer && kv.get_Value().y < jumperLayer)
                    possibleJumpersToUpdate.Add(kv.get_Key());
            }
            var $it899 = possibleJumpersToUpdate.GetEnumerator();
            while ($it899.MoveNext()){
                var v = $it899.get_Current();
                this.CalculateRegionAndInsertJumper(v);
            }
        },
        InitJumpers: function (){
            var deltas = new Int32Array(this.dag.get_NodeCount());
            var $it900 = this.dag.get_Edges().GetEnumerator();
            while ($it900.MoveNext()){
                var ie = $it900.get_Current();
                deltas[ie.get_Source()] -= ie.get_Weight();
                deltas[ie.get_Target()] += ie.get_Weight();
            }
            this.possibleJumperFeasibleIntervals = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor);
            for (var i = 0; i < this.dag.get_NodeCount(); i++)
                if (deltas[i] == 0)
                    this.CalculateRegionAndInsertJumper(i);
        },
        CalculateRegionAndInsertJumper: function (i){
            var ip = new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(this.Up(i), this.Down(i));
            this.possibleJumperFeasibleIntervals.set_Item$$TKey(i, ip);
            this.InsertJumper(ip.x, ip.y, i);
        },
        InsertJumper: function (upLayer, lowLayer, jumper){
            var jumperLayer;
            var layerToJumpTo;
            if ((function (){
                var $1 = {
                    Value: jumperLayer
                };
                var $2 = {
                    Value: layerToJumpTo
                };
                var $res = this.CalcJumpInfo(upLayer, lowLayer, jumper, $1, $2);
                jumperLayer = $1.Value;
                layerToJumpTo = $2.Value;
                return $res;
            }).call(this))
                this.jumpers.Insert(jumper);
        },
        CalcJumpInfo: function (upLayer, lowLayer, jumper, jumperLayer, layerToJumpTo){
            jumperLayer.Value = this.layering[jumper];
            layerToJumpTo.Value = -1;
            var min = this.vertsCounts[jumperLayer.Value] - 2 * this.nodeCount[jumper];
            for (var i = upLayer - 1; i > jumperLayer.Value; i--)
                if (this.vertsCounts[i] < min){
                    min = this.vertsCounts[i];
                    layerToJumpTo.Value = i;
                }
            for (var i = jumperLayer.Value - 1; i > lowLayer; i--)
                if (this.vertsCounts[i] < min){
                    min = this.vertsCounts[i];
                    layerToJumpTo.Value = i;
                }
            return layerToJumpTo.Value != -1;
        },
        Up: function (i){
            var ret = 2147483647;
            var $it901 = this.dag.InEdges(i).GetEnumerator();
            while ($it901.MoveNext()){
                var ie = $it901.get_Current();
                var r = this.layering[ie.get_Source()] - ie.get_Separation() + 1;
                if (r < ret)
                    ret = r;
            }
            if (ret == 2147483647)
                ret = this.layering[i] + 1;
            return ret;
        },
        Down: function (i){
            var ret = -2147483647;
            var $it902 = this.dag.OutEdges(i).GetEnumerator();
            while ($it902.MoveNext()){
                var ie = $it902.get_Current();
                var r = this.layering[ie.get_Target()] + ie.get_Separation() - 1;
                if (r > ret)
                    ret = r;
            }
            if (ret == -2147483647)
                ret = this.layering[i] - 1;
            return ret;
        },
        CalculateLayerCounts: function (){
            this.vertsCounts = new Int32Array(System.Linq.Enumerable.Max$$IEnumerable$1$Int32(this.layering) + 1);
            for (var $i904 = 0,$t904 = this.layering,$l904 = $t904.length,r = $t904[$i904]; $i904 < $l904; $i904++, r = $t904[$i904])
                this.vertsCounts[r] += this.nodeCount[r];
        },
        ChooseJumper: function (){
            var $it904 = this.jumpers.GetEnumerator();
            while ($it904.MoveNext()){
                var jumper = $it904.get_Current();
                return jumper;
            }
            System.Diagnostics.Debug.Assert$$Boolean$$String(false, "there are no jumpers to choose");
            return 0;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$Balancing);
var Microsoft$Msagl$Core$GraphAlgorithms$BasicGraph$2 = {
    fullname: "Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$2",
    baseTypeName: "Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (TNode, TEdge){
            this.TNode = TNode;
            this.TEdge = TEdge;
            this.nodes = null;
            Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor.call(this, this.TEdge);
        },
        ctor$$IEnumerable$1: function (TNode, TEdge, edges){
            this.TNode = TNode;
            this.TEdge = TEdge;
            this.nodes = null;
            Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor$$IEnumerable$1$$Int32.call(this, this.TEdge, edges, Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.VertexCount(edges));
        },
        ctor$$IEnumerable$1$$Int32: function (TNode, TEdge, edges, numberOfVerts){
            this.TNode = TNode;
            this.TEdge = TEdge;
            this.nodes = null;
            Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor$$IEnumerable$1$$Int32.call(this, this.TEdge, edges, numberOfVerts);
        },
        Nodes$$: "System.Collections.Generic.IList`1[[`0]]",
        get_Nodes: function (){
            return this.nodes;
        },
        set_Nodes: function (value){
            this.nodes = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$GraphAlgorithms$BasicGraph$2);
var Microsoft$Msagl$Core$GraphAlgorithms$BasicGraph$1 = {
    fullname: "Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1",
    baseTypeName: "System.Object",
    staticDefinition: {
        FillArraySkippingTheEdge: function (edge, edgesToChange, newEdges){
            for (var i = 0,j = 0; i < edgesToChange.length; i++)
                if (edgesToChange[i] != edge)
                    newEdges[i - j] = edgesToChange[i];
                else
                    j = 1;
        },
        VertexCount: function (edges){
            var nov = 0;
            var $it905 = edges.GetEnumerator();
            while ($it905.MoveNext()){
                var ie = $it905.get_Current();
                if (ie.get_Source() >= nov)
                    nov = ie.get_Source() + 1;
                if (ie.get_Target() >= nov)
                    nov = ie.get_Target() + 1;
            }
            return nov;
        },
        Enqueue: function (enqueed, q, i){
            q.Enqueue(i);
            enqueed.Insert(i);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (TEdge){
            this.TEdge = TEdge;
            this.edges = null;
            this.inEdges = null;
            this.numberOfVertices = 0;
            this.outEdges = null;
            this.selfEdges = null;
            System.Object.ctor.call(this);
            this.SetEdges(new System.Collections.Generic.List$1.ctor(this.TEdge), 0);
        },
        ctor$$IEnumerable$1: function (TEdge, edges){
            this.TEdge = TEdge;
            this.edges = null;
            this.inEdges = null;
            this.numberOfVertices = 0;
            this.outEdges = null;
            this.selfEdges = null;
            Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor$$IEnumerable$1$$Int32.call(this, this.TEdge, edges, Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.VertexCount(edges));
        },
        ctor$$IEnumerable$1$$Int32: function (TEdge, edges, numberOfVerts){
            this.TEdge = TEdge;
            this.edges = null;
            this.inEdges = null;
            this.numberOfVertices = 0;
            this.outEdges = null;
            this.selfEdges = null;
            System.Object.ctor.call(this);
            this.SetEdges(edges, numberOfVerts);
        },
        NodeCount$$: "System.Int32",
        get_NodeCount: function (){
            return this.numberOfVertices;
        },
        Edges$$: "System.Collections.Generic.ICollection`1[[`0]]",
        get_Edges: function (){
            return this.edges;
        },
        RemoveEdge: function (edge){
            this.edges.Remove(edge);
            if (edge.get_Source() != edge.get_Target()){
                var edgesToChange = this.outEdges[edge.get_Source()];
                var newEdges = new Array(edgesToChange.length - 1);
                Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.FillArraySkippingTheEdge(edge, edgesToChange, newEdges);
                this.outEdges[edge.get_Source()] = newEdges;
                edgesToChange = this.inEdges[edge.get_Target()];
                newEdges = new Array(edgesToChange.length - 1);
                Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.FillArraySkippingTheEdge(edge, edgesToChange, newEdges);
                this.inEdges[edge.get_Target()] = newEdges;
            }
        },
        OutEdges: function (vertex){
            return this.outEdges[vertex];
        },
        SelfEdges: function (vertex){
            return this.selfEdges[vertex];
        },
        InEdges: function (vertex){
            return this.inEdges[vertex];
        },
        SetEdges: function (valEdges, nov){
            this.edges = (As(valEdges, System.Collections.Generic.List$1.ctor) != null ? As(valEdges, System.Collections.Generic.List$1.ctor) : new System.Collections.Generic.List$1.ctor$$IEnumerable$1(this.TEdge, valEdges));
            this.numberOfVertices = nov;
            var outEdgesCounts = new Int32Array(this.numberOfVertices);
            var inEdgesCounts = new Int32Array(this.numberOfVertices);
            var selfEdgesCounts = new Int32Array(this.numberOfVertices);
            this.outEdges = new Array(this.numberOfVertices);
            this.inEdges = new Array(this.numberOfVertices);
            this.selfEdges = new Array(this.numberOfVertices);
            var $it906 = this.edges.GetEnumerator();
            while ($it906.MoveNext()){
                var e = $it906.get_Current();
                if (e.get_Source() != e.get_Target()){
                    outEdgesCounts[e.get_Source()]++;
                    inEdgesCounts[e.get_Target()]++;
                }
                else {
                    selfEdgesCounts[e.get_Source()]++;
                }
            }
            for (var i = 0; i < this.numberOfVertices; i++){
                this.outEdges[i] = new Array(outEdgesCounts[i]);
                outEdgesCounts[i] = 0;
                this.inEdges[i] = new Array(inEdgesCounts[i]);
                inEdgesCounts[i] = 0;
                this.selfEdges[i] = new Array(selfEdgesCounts[i]);
                selfEdgesCounts[i] = 0;
            }
            var $it907 = this.edges.GetEnumerator();
            while ($it907.MoveNext()){
                var e = $it907.get_Current();
                var u = e.get_Source();
                var v = e.get_Target();
                if (u != v){
                    this.outEdges[u][outEdgesCounts[u]++] = e;
                    this.inEdges[v][inEdgesCounts[v]++] = e;
                }
                else
                    this.selfEdges[u][selfEdgesCounts[u]++] = e;
            }
        },
        InEdgesCount: function (node){
            return this.InEdges(node).get_Count();
        },
        OutEdgesCount: function (node){
            return this.OutEdges(node).get_Count();
        },
        AddEdge: function (e){
            this.get_Edges().Add(e);
            this.AddEdgeToInEdges(e, e.get_Target());
            this.AddEdgeToOutEdges(e, e.get_Source());
        },
        AddEdgeToOutEdges: function (e, source){
            var ies = this.outEdges[source];
            var nies = new Array(ies.length + 1);
            ies.CopyTo(nies, 1);
            nies[0] = e;
            this.outEdges[source] = nies;
        },
        AddEdgeToInEdges: function (e, target){
            var ies = this.inEdges[target];
            var nies = new Array(ies.length + 1);
            ies.CopyTo(nies, 1);
            nies[0] = e;
            this.inEdges[target] = nies;
        },
        NodesOfConnectedGraph: function (){
            var $yield = [];
            if (this.edges.get_Count() > 0){
                var enqueed = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(System.Int32.ctor);
                var q = new System.Collections.Generic.Queue$1.ctor(System.Int32.ctor);
                var i = this.edges.get_Item$$Int32(0).get_Source();
                Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.Enqueue(enqueed, q, i);
                $yield.push(i);
                while (q.get_Count() > 0){
                    i = q.Dequeue();
                    for (var $i909 = 0,$t909 = this.outEdges[i],$l909 = $t909.length,e = $t909[$i909]; $i909 < $l909; $i909++, e = $t909[$i909]){
                        var s = e.get_Target();
                        if (!enqueed.Contains$$T(s)){
                            Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.Enqueue(enqueed, q, s);
                            $yield.push(s);
                        }
                    }
                    for (var $i910 = 0,$t910 = this.inEdges[i],$l910 = $t910.length,e = $t910[$i910]; $i910 < $l910; $i910++, e = $t910[$i910]){
                        var s = e.get_Source();
                        if (!enqueed.Contains$$T(s)){
                            Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.Enqueue(enqueed, q, s);
                            $yield.push(s);
                        }
                    }
                }
            }
            return $yield;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$GraphAlgorithms$BasicGraph$1);
var Microsoft$Msagl$Layout$Layered$Database = {
    fullname: "Microsoft.Msagl.Layout.Layered.Database",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.multipleMiddles = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(System.Int32.ctor);
            this.multiedges = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, System.Collections.Generic.List$1.ctor);
            this.anchors = null;
            System.Object.ctor.call(this);
        },
        MultipleMiddles$$: "Microsoft.Msagl.Core.DataStructures.Set`1[[System.Int32]]",
        get_MultipleMiddles: function (){
            return this.multipleMiddles;
        },
        AllIntEdges$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Layout.Layered.IntEdge]]",
        get_AllIntEdges: function (){
            var $yield = [];
            var $it910 = this.get_Multiedges().get_Values().GetEnumerator();
            while ($it910.MoveNext()){
                var l = $it910.get_Current();
                var $it911 = l.GetEnumerator();
                while ($it911.MoveNext()){
                    var e = $it911.get_Current();
                    $yield.push(e);
                }
            }
            return $yield;
        },
        Anchors$$: "Microsoft.Msagl.Layout.Layered.Anchor[]",
        get_Anchors: function (){
            return this.anchors;
        },
        set_Anchors: function (value){
            this.anchors = value;
        },
        AddFeedbackSet: function (edges){
            var $it912 = edges.GetEnumerator();
            while ($it912.MoveNext()){
                var e = $it912.get_Current();
                var ip = new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(e.get_Source(), e.get_Target());
                var ipr = new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(e.get_Target(), e.get_Source());
                var listToShuffle = this.multiedges.get_Item$$TKey(ip);
                var $it913 = listToShuffle.GetEnumerator();
                while ($it913.MoveNext()){
                    var er = $it913.get_Current();
                    er.Revert();
                }
                if (this.multiedges.ContainsKey(ipr))
                    this.multiedges.get_Item$$TKey(ipr).AddRange(listToShuffle);
                else
                    this.multiedges.set_Item$$TKey(ipr, listToShuffle);
                this.multiedges.Remove(ip);
            }
        },
        RegularMultiedges$$: "System.Collections.Generic.IEnumerable`1[[System.Collections.Generic.List`1[[Microsoft.Msagl.Layout.Layered.IntEdge]]]]",
        get_RegularMultiedges: function (){
            var $yield = [];
            var $it914 = this.get_Multiedges().GetEnumerator();
            while ($it914.MoveNext()){
                var kv = $it914.get_Current();
                if (kv.get_Key().x != kv.get_Key().y)
                    $yield.push(kv.get_Value());
            }
            return $yield;
        },
        Multiedges$$: "System.Collections.Generic.Dictionary`2[[Microsoft.Msagl.Core.GraphAlgorithms.IntPair],[System.Collections.Generic.List`1[[Microsoft.Msagl.Layout.Layered.IntEdge]]]]",
        get_Multiedges: function (){
            return this.multiedges;
        },
        GetMultiedge$$Int32$$Int32: function (source, target){
            return this.GetMultiedge$$IntPair(new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(source, target));
        },
        GetMultiedge$$IntPair: function (ip){
            if (this.multiedges.ContainsKey(ip))
                return this.multiedges.get_Item$$TKey(ip);
            return new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Layout.Layered.IntEdge.ctor);
        },
        RegisterOriginalEdgeInMultiedges: function (edge){
            var ip = new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(edge.get_Source(), edge.get_Target());
            var o;
            if (this.multiedges.ContainsKey(ip) == false)
                this.multiedges.set_Item$$TKey(ip, o = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Layout.Layered.IntEdge.ctor));
            else
                o = this.multiedges.get_Item$$TKey(ip);
            o.Add(edge);
        },
        SkeletonEdges: function (){
            return System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.Collections.Generic.KeyValuePair$2.ctor, Microsoft.Msagl.Layout.Layered.IntEdge.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(System.Collections.Generic.KeyValuePair$2.ctor, this.get_Multiedges(), $CreateAnonymousDelegate(this, function (kv){
                return kv.get_Key().x != kv.get_Key().y;
            })), $CreateAnonymousDelegate(this, function (kv){
                return kv.get_Value().get_Item$$Int32(0);
            }));
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$Database);
var Microsoft$Msagl$Core$Layout$Edge = {
    fullname: "Microsoft.Msagl.Core.Layout.Edge",
    baseTypeName: "Microsoft.Msagl.Core.Layout.GeometryObject",
    staticDefinition: {
        RouteSelfEdge: function (boundaryCurve, howMuchToStickOut, smoothedPolyline){
            var w = boundaryCurve.get_BoundingBox().get_Width();
            var h = boundaryCurve.get_BoundingBox().get_Height();
            var center = boundaryCurve.get_BoundingBox().get_Center();
            var p0 = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(center.get_X() - w / 4, center.get_Y());
            var p1 = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(center.get_X() - w / 4, center.get_Y() - h / 2 - howMuchToStickOut);
            var p2 = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(center.get_X() + w / 4, center.get_Y() - h / 2 - howMuchToStickOut);
            var p3 = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(center.get_X() + w / 4, center.get_Y());
            smoothedPolyline.Value = Microsoft.Msagl.Core.Geometry.SmoothedPolyline.FromPoints([p0, p1, p2, p3]);
            return smoothedPolyline.Value.CreateCurve();
        },
        RouteSelfEdgeAtSide: function (boundaryCurve, howMuchToStickOut){
            var w = boundaryCurve.get_BoundingBox().get_Width();
            var h = boundaryCurve.get_BoundingBox().get_Height();
            var center = boundaryCurve.get_BoundingBox().get_Center();
            var p0 = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(center.get_X(), center.get_Y() - h / 4);
            var p1 = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(center.get_X() - w / 2 - howMuchToStickOut, center.get_Y() - h / 4);
            var p2 = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(center.get_X() - w / 2 - howMuchToStickOut, center.get_Y());
            var p3 = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(center.get_X() - w / 2 - howMuchToStickOut, center.get_Y() + h / 4);
            var p4 = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(center.get_X(), center.get_Y() + h / 4);
            var curve = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor();
            curve.AddSegment(new Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ctor(p0, p1, p1, p2));
            curve.AddSegment(new Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ctor(p2, p3, p3, p4));
            return curve;
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Core.Layout.ILabeledObject"],
    Kind: "Class",
    definition: {
        ctor$$Node$$Node$$Double$$Double$$Double: function (source, target, labelWidth, labelHeight, edgeThickness){
            this.labels = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Label.ctor);
            this.source = null;
            this.sourceAnchorNumber = 0;
            this.target = null;
            this.targetAnchorNumber = 0;
            this.length = 1;
            this.weight = 1;
            this.separation = 1;
            this.edgeGeometry = new Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor();
            this.BeforeLayoutChangeEvent = null;
            this._OriginalLabelWidth = 0;
            this._OriginalLabelHeight = 0;
            Microsoft.Msagl.Core.Layout.GeometryObject.ctor.call(this);
            this.source = source;
            this.target = target;
            if (labelWidth > 0)
                this.set_Label(new Microsoft.Msagl.Core.Layout.Label.ctor$$Double$$Double$$GeometryObject(labelWidth, labelHeight, this));
            this.set_LineWidth(edgeThickness);
        },
        SourcePort$$: "Microsoft.Msagl.Core.Layout.Port",
        get_SourcePort: function (){
            return this.get_EdgeGeometry().get_SourcePort();
        },
        set_SourcePort: function (value){
            this.get_EdgeGeometry().set_SourcePort(value);
        },
        TargetPort$$: "Microsoft.Msagl.Core.Layout.Port",
        get_TargetPort: function (){
            return this.get_EdgeGeometry().get_TargetPort();
        },
        set_TargetPort: function (value){
            this.get_EdgeGeometry().set_TargetPort(value);
        },
        Label$$: "Microsoft.Msagl.Core.Layout.Label",
        get_Label: function (){
            if (this.labels.get_Count() == 0)
                return null;
            return this.labels.get_Item$$Int32(0);
        },
        set_Label: function (value){
            if (this.labels.get_Count() == 0){
                this.labels.Add(value);
            }
            else {
                this.labels.set_Item$$Int32(0, value);
            }
        },
        Labels$$: "System.Collections.Generic.IList`1[[Microsoft.Msagl.Core.Layout.Label]]",
        get_Labels: function (){
            return this.labels;
        },
        Source$$: "Microsoft.Msagl.Core.Layout.Node",
        get_Source: function (){
            return this.source;
        },
        set_Source: function (value){
            this.source = value;
        },
        SourceAnchorNumber$$: "System.Int32",
        get_SourceAnchorNumber: function (){
            return this.sourceAnchorNumber;
        },
        set_SourceAnchorNumber: function (value){
            this.sourceAnchorNumber = value;
        },
        Target$$: "Microsoft.Msagl.Core.Layout.Node",
        get_Target: function (){
            return this.target;
        },
        set_Target: function (value){
            this.target = value;
        },
        TargetAnchorNumber$$: "System.Int32",
        get_TargetAnchorNumber: function (){
            return this.targetAnchorNumber;
        },
        set_TargetAnchorNumber: function (value){
            this.targetAnchorNumber = value;
        },
        OriginalLabelWidth$$: "System.Double",
        get_OriginalLabelWidth: function (){
            return this._OriginalLabelWidth;
        },
        set_OriginalLabelWidth: function (value){
            this._OriginalLabelWidth = value;
        },
        OriginalLabelHeight$$: "System.Double",
        get_OriginalLabelHeight: function (){
            return this._OriginalLabelHeight;
        },
        set_OriginalLabelHeight: function (value){
            this._OriginalLabelHeight = value;
        },
        ctor$$Node$$Node: function (source, target){
            this.labels = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Label.ctor);
            this.source = null;
            this.sourceAnchorNumber = 0;
            this.target = null;
            this.targetAnchorNumber = 0;
            this.length = 1;
            this.weight = 1;
            this.separation = 1;
            this.edgeGeometry = new Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor();
            this.BeforeLayoutChangeEvent = null;
            this._OriginalLabelWidth = 0;
            this._OriginalLabelHeight = 0;
            Microsoft.Msagl.Core.Layout.Edge.ctor$$Node$$Node$$Double$$Double$$Double.call(this, source, target, 0, 0, 1);
        },
        ctor: function (){
            this.labels = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Label.ctor);
            this.source = null;
            this.sourceAnchorNumber = 0;
            this.target = null;
            this.targetAnchorNumber = 0;
            this.length = 1;
            this.weight = 1;
            this.separation = 1;
            this.edgeGeometry = new Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor();
            this.BeforeLayoutChangeEvent = null;
            this._OriginalLabelWidth = 0;
            this._OriginalLabelHeight = 0;
            Microsoft.Msagl.Core.Layout.Edge.ctor$$Node$$Node.call(this, null, null);
        },
        LabelBBox$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_LabelBBox: function (){
            return this.get_Label().get_BoundingBox();
        },
        Length$$: "System.Double",
        get_Length: function (){
            return this.length;
        },
        set_Length: function (value){
            this.length = value;
        },
        Weight$$: "System.Int32",
        get_Weight: function (){
            return this.weight;
        },
        set_Weight: function (value){
            this.weight = value;
        },
        Separation$$: "System.Int32",
        get_Separation: function (){
            return this.separation;
        },
        set_Separation: function (value){
            this.separation = value;
        },
        toString: function (){
            return this.source + "->" + this.target;
        },
        LineWidth$$: "System.Double",
        get_LineWidth: function (){
            return this.get_EdgeGeometry().get_LineWidth();
        },
        set_LineWidth: function (value){
            this.get_EdgeGeometry().set_LineWidth(value);
        },
        BoundingBox$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_BoundingBox: function (){
            var rect = Microsoft.Msagl.Core.Geometry.Rectangle.CreateAnEmptyBox();
            if (this.get_UnderlyingPolyline() != null){
                var $it915 = this.get_UnderlyingPolyline().GetEnumerator();
                while ($it915.MoveNext()){
                    var p = $it915.get_Current();
                    rect.Add$$Point(p);
                }
            }
            if (this.get_Curve() != null)
                rect.Add$$Rectangle(this.get_Curve().get_BoundingBox());
            if (this.get_EdgeGeometry() != null){
                if (this.get_EdgeGeometry().get_SourceArrowhead() != null)
                    rect.Add$$Point(this.get_EdgeGeometry().get_SourceArrowhead().get_TipPosition());
                if (this.get_EdgeGeometry().get_TargetArrowhead() != null)
                    rect.Add$$Point(this.get_EdgeGeometry().get_TargetArrowhead().get_TipPosition());
            }
            var del = this.get_LineWidth();
            rect.set_Left(rect.get_Left() - del);
            rect.set_Top(rect.get_Top() + del);
            rect.set_Right(rect.get_Right() + del);
            rect.set_Bottom(rect.get_Bottom() - del);
            return rect;
        },
        set_BoundingBox: function (value){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        EdgeGeometry$$: "Microsoft.Msagl.Core.Layout.EdgeGeometry",
        get_EdgeGeometry: function (){
            return this.edgeGeometry;
        },
        set_EdgeGeometry: function (value){
            this.edgeGeometry = value;
        },
        UnderlyingPolyline$$: "Microsoft.Msagl.Core.Geometry.SmoothedPolyline",
        get_UnderlyingPolyline: function (){
            return this.edgeGeometry.get_SmoothedPolyline();
        },
        set_UnderlyingPolyline: function (value){
            this.edgeGeometry.set_SmoothedPolyline(value);
        },
        Curve$$: "Microsoft.Msagl.Core.Geometry.Curves.ICurve",
        get_Curve: function (){
            return this.edgeGeometry != null ? this.edgeGeometry.get_Curve() : null;
        },
        set_Curve: function (value){
            this.RaiseLayoutChangeEvent(value);
            this.edgeGeometry.set_Curve(value);
        },
        Transform: function (matrix){
            if (this.get_Curve() == null)
                return;
            this.set_Curve(this.get_Curve().Transform(matrix));
            if (this.get_UnderlyingPolyline() != null)
                for (var s = this.get_UnderlyingPolyline().get_HeadSite(),s0 = this.get_UnderlyingPolyline().get_HeadSite(); s != null; s = s.get_Next(), s0 = s0.get_Next())
                    s.set_Point(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(matrix, s.get_Point()));
            var sourceArrow = this.edgeGeometry.get_SourceArrowhead();
            if (sourceArrow != null)
                sourceArrow.set_TipPosition(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(matrix, sourceArrow.get_TipPosition()));
            var targetArrow = this.edgeGeometry.get_TargetArrowhead();
            if (targetArrow != null)
                targetArrow.set_TipPosition(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(matrix, targetArrow.get_TipPosition()));
            if (this.get_Label() != null)
                this.get_Label().set_Center(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(matrix, this.get_LabelBBox().get_Center()));
        },
        Translate: function (delta){
            if (this.get_EdgeGeometry() != null){
                this.get_EdgeGeometry().Translate(delta);
            }
            var $it916 = this.get_Labels().GetEnumerator();
            while ($it916.MoveNext()){
                var l = $it916.get_Current();
                l.Translate(delta);
            }
        },
        TransformRelativeTo: function (oldBounds, newBounds){
            if (this.get_EdgeGeometry() != null){
                var toOrigin = new Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.ctor$$Double$$Double$$Double$$Double$$Double$$Double(1, 0, -oldBounds.get_Left(), 0, 1, -oldBounds.get_Bottom());
                var scale = new Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.ctor$$Double$$Double$$Double$$Double$$Double$$Double(newBounds.get_Width() / oldBounds.get_Width(), 0, 0, 0, newBounds.get_Height() / oldBounds.get_Height(), 0);
                var toNewBounds = new Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.ctor$$Double$$Double$$Double$$Double$$Double$$Double(1, 0, newBounds.get_Left(), 0, 1, newBounds.get_Bottom());
                this.Transform(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$PlaneTransformation(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$PlaneTransformation(toNewBounds, scale), toOrigin));
            }
            var $it917 = this.get_Labels().GetEnumerator();
            while ($it917.MoveNext()){
                var l = $it917.get_Current();
                l.Translate(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(newBounds.get_LeftBottom(), oldBounds.get_LeftBottom()));
            }
        },
        ArrowheadAtSource$$: "System.Boolean",
        get_ArrowheadAtSource: function (){
            return this.get_EdgeGeometry() != null && this.get_EdgeGeometry().get_SourceArrowhead() != null;
        },
        ArrowheadAtTarget$$: "System.Boolean",
        get_ArrowheadAtTarget: function (){
            return this.get_EdgeGeometry() != null && this.get_EdgeGeometry().get_TargetArrowhead() != null;
        },
        RaiseLayoutChangeEvent: function (newValue){
            this.edgeGeometry.RaiseLayoutChangeEvent(newValue);
        },
        add_BeforeLayoutChangeEvent: function (value){
            this.edgeGeometry.add_LayoutChangeEvent(value);
        },
        remove_BeforeLayoutChangeEvent: function (value){
            this.edgeGeometry.remove_LayoutChangeEvent(value);
        },
        UnderCollapsedCluster: function (){
            return this.get_Source().UnderCollapsedCluster() || this.get_Target().UnderCollapsedCluster();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$Edge);
var Microsoft$Msagl$Layout$Layered$IntEdge = {
    fullname: "Microsoft.Msagl.Layout.Layered.IntEdge",
    baseTypeName: "System.Object",
    staticDefinition: {
        GetOrder: function (graph){
            var visited = new Array(graph.get_NodeCount());
            var sv = new System.Collections.Generic.Stack$1.ctor(System.Int32.ctor);
            var se = new System.Collections.Generic.Stack$1.ctor(System.Collections.Generic.IEnumerator$1.ctor);
            var order = new System.Collections.Generic.List$1.ctor(System.Int32.ctor);
            var en;
            for (var u = 0; u < graph.get_NodeCount(); u++){
                if (visited[u])
                    continue;
                var cu = u;
                visited[cu] = true;
                en = new Microsoft.Msagl.Layout.Layered.Succ.ctor(graph, u).GetEnumerator();
                do{
                    while (en.MoveNext()){
                        var v = en.get_Current();
                        if (!visited[v]){
                            visited[v] = true;
                            sv.Push(cu);
                            se.Push(en);
                            cu = v;
                            en = new Microsoft.Msagl.Layout.Layered.Succ.ctor(graph, cu).GetEnumerator();
                        }
                    }
                    order.Add(cu);
                    if (sv.get_Count() > 0){
                        en = se.Pop();
                        cu = sv.Pop();
                    }
                    else
                        break;
                }
                while (true)
            }
            order.Reverse();
            return order.ToArray();
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IEnumerable$1", "Microsoft.Msagl.Core.GraphAlgorithms.IEdge"],
    Kind: "Class",
    definition: {
        ctor$$Int32$$Int32: function (source, target){
            this.source = 0;
            this.target = 0;
            this.reversed = false;
            this._hashKey = null;
            this.weight = 1;
            this.crossingWeight = 1;
            this.separation = 0;
            this.layerEdges = null;
            this._IsVirtualEdge = false;
            this._Edge = null;
            System.Object.ctor.call(this);
            this.source = source;
            this.target = target;
            this.UpdateHashKey();
        },
        Source$$: "System.Int32",
        get_Source: function (){
            return this.source;
        },
        set_Source: function (value){
            this.source = value;
            this.UpdateHashKey();
        },
        Target$$: "System.Int32",
        get_Target: function (){
            return this.target;
        },
        set_Target: function (value){
            this.target = value;
            this.UpdateHashKey();
        },
        Reversed$$: "System.Boolean",
        get_Reversed: function (){
            return this.reversed;
        },
        IsVirtualEdge$$: "System.Boolean",
        get_IsVirtualEdge: function (){
            return this._IsVirtualEdge;
        },
        set_IsVirtualEdge: function (value){
            this._IsVirtualEdge = value;
        },
        HasLabel$$: "System.Boolean",
        get_HasLabel: function (){
            return this.get_Edge().get_Label() != null;
        },
        LabelWidth$$: "System.Double",
        get_LabelWidth: function (){
            return this.get_Edge().get_Label().get_Width();
        },
        LabelHeight$$: "System.Double",
        get_LabelHeight: function (){
            return this.get_Edge().get_Label().get_Height();
        },
        Revert: function (){
            var t = this.source;
            this.source = this.target;
            this.target = t;
            this.reversed = !this.reversed;
            this.UpdateHashKey();
        },
        Edge$$: "Microsoft.Msagl.Core.Layout.Edge",
        get_Edge: function (){
            return this._Edge;
        },
        set_Edge: function (value){
            this._Edge = value;
        },
        ctor$$Int32$$Int32$$Edge: function (source, target, edge){
            this.source = 0;
            this.target = 0;
            this.reversed = false;
            this._hashKey = null;
            this.weight = 1;
            this.crossingWeight = 1;
            this.separation = 0;
            this.layerEdges = null;
            this._IsVirtualEdge = false;
            this._Edge = null;
            System.Object.ctor.call(this);
            this.source = source;
            this.target = target;
            this.set_Edge(edge);
            if (edge != null){
                this.set_Separation(edge.get_Separation());
                this.set_Weight(edge.get_Weight());
            }
            this.UpdateHashKey();
        },
        Equals$$Object: function (obj){
            var ie = As(obj, Microsoft.Msagl.Layout.Layered.IntEdge.ctor);
            if (ie == null)
                return false;
            return ie.source == this.source && ie.target == this.target;
        },
        UpdateHashKey: function (){
            this._hashKey = "" + this.source + "," + this.target;
        },
        GetHashCode: function (){
            var hc = (this.source.GetHashCode()) | 0;
            return (((hc << 5 | hc >> 27) + this.target | 0)) | 0;
        },
        toString: function (){
            return "Edge(" + this.source + "->" + this.target + ")";
        },
        Curve$$: "Microsoft.Msagl.Core.Geometry.Curves.ICurve",
        get_Curve: function (){
            return this.get_Edge().get_Curve();
        },
        set_Curve: function (value){
            this.get_Edge().set_Curve(value);
        },
        UnderlyingPolyline$$: "Microsoft.Msagl.Core.Geometry.SmoothedPolyline",
        get_UnderlyingPolyline: function (){
            return this.get_Edge().get_UnderlyingPolyline();
        },
        set_UnderlyingPolyline: function (value){
            this.get_Edge().set_UnderlyingPolyline(value);
        },
        Weight$$: "System.Int32",
        get_Weight: function (){
            return this.weight;
        },
        set_Weight: function (value){
            this.weight = value;
        },
        CrossingWeight$$: "System.Int32",
        get_CrossingWeight: function (){
            return this.crossingWeight;
        },
        Separation$$: "System.Int32",
        get_Separation: function (){
            return this.separation;
        },
        set_Separation: function (value){
            this.separation = value;
        },
        LayerSpan$$: "System.Int32",
        get_LayerSpan: function (){
            return this.layerEdges != null ? this.layerEdges.length : 0;
        },
        LayerEdges$$: "System.Collections.Generic.IList`1[[Microsoft.Msagl.Layout.Layered.LayerEdge]]",
        get_LayerEdges: function (){
            return this.layerEdges;
        },
        set_LayerEdges: function (value){
            this.layerEdges = value instanceof Array || value == null ? value : (function (){
                throw new Error("InvalidCastException");
            }
            ());
        },
        SelfEdge: function (){
            return this.source == this.target;
        },
        ReversedClone: function (){
            var ret = new Microsoft.Msagl.Layout.Layered.IntEdge.ctor$$Int32$$Int32$$Edge(this.target, this.source, this.get_Edge());
            if (this.layerEdges != null){
                var len = this.layerEdges.length;
                ret.layerEdges = new Array(len);
                for (var i = 0; i < len; i++){
                    var le = this.layerEdges[len - 1 - i];
                    ret.layerEdges[i] = new Microsoft.Msagl.Layout.Layered.LayerEdge.ctor$$Int32$$Int32$$Int32(le.get_Target(), le.get_Source(), le.get_CrossingWeight());
                }
                ret.layerEdges[0].set_Source(this.target);
                ret.layerEdges[this.layerEdges.length - 1].set_Target(this.source);
            }
            ret.UpdateHashKey();
            return ret;
        },
        Item$$: "Microsoft.Msagl.Layout.Layered.LayerEdge",
        get_Item$$Int32: function (i){
            return this.layerEdges[i];
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this.layerEdges.length;
        },
        UpdateEdgeLabelPosition: function (anchors){
            if (this.get_Edge().get_Label() != null){
                var m = (this.layerEdges.length / 2) | 0;
                var layerEdge = this.layerEdges[m];
                Microsoft.Msagl.Layout.Layered.Routing.UpdateLabel(this.get_Edge(), anchors[layerEdge.get_Source()]);
            }
        },
        GetEnumerator: function (){
            var $yield = [];
            $yield.push(this.layerEdges[0].get_Source());
            for (var $i919 = 0,$t919 = this.layerEdges,$l919 = $t919.length,le = $t919[$i919]; $i919 < $l919; $i919++, le = $t919[$i919])
                $yield.push(le.get_Target());
            return $yield.GetEnumerator();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$IntEdge);
var Microsoft$Msagl$Core$GraphAlgorithms$IntPair = {
    fullname: "Microsoft.Msagl.Core.GraphAlgorithms.IntPair",
    baseTypeName: "System.Object",
    staticDefinition: {
        op_LessThan: function (pair0, pair1){
            if (pair0 != null && pair1 != null)
                return pair0.x < pair1.x || pair0.x == pair1.x && pair0.y < pair1.y;
            throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
        },
        op_GreaterThan: function (pair0, pair1){
            return Microsoft.Msagl.Core.GraphAlgorithms.IntPair.op_LessThan(pair1, pair0);
        },
        Compare: function (pair0, pair1){
            if (Microsoft.Msagl.Core.GraphAlgorithms.IntPair.op_LessThan(pair0, pair1))
                return 1;
            if (pair0 == pair1)
                return 0;
            return -1;
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Core.GraphAlgorithms.IEdge"],
    Kind: "Class",
    definition: {
        ctor: function (first, second){
            this.x = 0;
            this.y = 0;
            this._hashKey = null;
            System.Object.ctor.call(this);
            this.x = first;
            this.y = second;
            this.UpdateHashKey();
        },
        First$$: "System.Int32",
        get_First: function (){
            return this.x;
        },
        set_First: function (value){
            this.x = value;
            this.UpdateHashKey();
        },
        Second$$: "System.Int32",
        get_Second: function (){
            return this.y;
        },
        set_Second: function (value){
            this.y = value;
            this.UpdateHashKey();
        },
        Equals$$Object: function (obj){
            var other = As(obj, Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor);
            if (other == null)
                return false;
            return this.x == other.x && this.y == other.y;
        },
        UpdateHashKey: function (){
            this._hashKey = "" + this.x + "," + this.y;
        },
        GetHashCode: function (){
            var hc = (this.x.GetHashCode()) | 0;
            return (((hc << 5 | hc >> 27) + this.y | 0)) | 0;
        },
        toString: function (){
            return "(" + this.x + "," + this.y + ")";
        },
        Source$$: "System.Int32",
        get_Source: function (){
            return this.x;
        },
        set_Source: function (value){
            this.x = value;
            this.UpdateHashKey();
        },
        Target$$: "System.Int32",
        get_Target: function (){
            return this.y;
        },
        set_Target: function (value){
            this.y = value;
            this.UpdateHashKey();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$GraphAlgorithms$IntPair);
var Microsoft$Msagl$Layout$Layered$LayerArrays = {
    fullname: "Microsoft.Msagl.Layout.Layered.LayerArrays",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (verticesToLayers){
            this.Y = null;
            this.verticesToX = null;
            this.layers = null;
            System.Object.ctor.call(this);
            this.Initialize(verticesToLayers);
        },
        Initialize: function (verticesToLayers){
            this.Y = verticesToLayers;
            this.verticesToX = null;
            this.layers = null;
        },
        DropEmptyLayers: function (){
            var drop = new Int32Array(this.get_Layers().length);
            var dropVal = 0;
            for (var i = 0; i < this.get_Layers().length; i++){
                drop[i] = dropVal;
                if (this.get_Layers()[i].length == 0)
                    dropVal++;
            }
            if (dropVal == 0)
                return this;
            var ny = new Int32Array(this.Y.length);
            for (var i = 0; i < ny.length; i++)
                ny[i] = this.Y[i] - drop[this.Y[i]];
            var nls = new Array(this.layers.length - dropVal);
            for (var i = 0; i < this.layers.length; i++){
                if (this.layers[i].length > 0)
                    nls[i - drop[i]] = this.layers[i].Clone() instanceof Int32Array || this.layers[i].Clone() == null ? this.layers[i].Clone() : (function (){
                        throw new Error("InvalidCastException");
                    }
                    ());
            }
            var la = new Microsoft.Msagl.Layout.Layered.LayerArrays.ctor(ny);
            la.layers = nls;
            return la;
        },
        UpdateLayers: function (ulayers){
            if (this.layers == null)
                this.InitLayers();
            for (var i = 0; i < this.layers.length; i++)
                ulayers[i].CopyTo(this.layers[i], 0);
            this.UpdateXFromLayers();
        },
        UpdateXFromLayers: function (){
            if (this.layers == null)
                this.InitLayers();
            if (this.verticesToX == null)
                this.verticesToX = new Int32Array(this.Y.length);
            for (var $i920 = 0,$t920 = this.layers,$l920 = $t920.length,layer = $t920[$i920]; $i920 < $l920; $i920++, layer = $t920[$i920]){
                var i = 0;
                for (var $i921 = 0,$l921 = layer.length,v = layer[$i921]; $i921 < $l921; $i921++, v = layer[$i921])
                    this.verticesToX[v] = i++;
            }
        },
        X$$: "System.Int32[]",
        get_X: function (){
            if (this.verticesToX != null)
                return this.verticesToX;
            this.verticesToX = new Int32Array(this.Y.length);
            this.UpdateXFromLayers();
            return this.verticesToX;
        },
        ReversedClone: function (){
            var rv = new Int32Array(this.Y.length);
            var lastLayer = this.get_Layers().length - 1;
            for (var i = 0; i < this.Y.length; i++)
                rv[i] = lastLayer - this.Y[i];
            return new Microsoft.Msagl.Layout.Layered.LayerArrays.ctor(rv);
        },
        Layers$$: "System.Int32[][]",
        get_Layers: function (){
            if (this.layers != null)
                return this.layers;
            this.InitLayers();
            return this.layers;
        },
        set_Layers: function (value){
            this.layers = value;
        },
        InitLayers: function (){
            var nOfLayers = 0;
            for (var $i922 = 0,$t922 = this.Y,$l922 = $t922.length,l = $t922[$i922]; $i922 < $l922; $i922++, l = $t922[$i922])
                if (l + 1 > nOfLayers)
                    nOfLayers = l + 1;
            var counts = new Int32Array(nOfLayers);
            for (var $i923 = 0,$t923 = this.Y,$l923 = $t923.length,l = $t923[$i923]; $i923 < $l923; $i923++, l = $t923[$i923])
                counts[l]++;
            this.layers = new Array(nOfLayers);
            for (var i = 0; i < nOfLayers; i++){
                this.layers[i] = new Int32Array(counts[i]);
                counts[i] = 0;
            }
            for (var i = 0; i < this.Y.length; i++){
                var l = this.Y[i];
                this.layers[l][counts[l]++] = i;
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$LayerArrays);
var Microsoft$Msagl$Layout$Layered$SnapToGridByY = {
    fullname: "Microsoft.Msagl.Layout.Layered.SnapToGridByY",
    staticDefinition: {
        None: 0,
        Top: 1,
        Bottom: 2
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$SnapToGridByY);
var Microsoft$Msagl$Layout$Layered$SugiyamaLayoutSettings = {
    fullname: "Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings",
    baseTypeName: "Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings",
    staticDefinition: {
        CalculateLayout: function (msaglGraph, settings, cancelToken){
            var engine = new Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.ctor$$GeometryGraph$$SugiyamaLayoutSettings(msaglGraph, settings);
            engine.Run$$CancelToken(cancelToken);
            return engine;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.yLayerSep = 30;
            this.verticalConstraints = new Microsoft.Msagl.Layout.Layered.VerticalConstraintsForSugiyama.ctor();
            this.horizontalConstraints = new Microsoft.Msagl.Layout.Layered.HorizontalConstraintsForSugiyama.ctor();
            this.repetitionCoefficentForOrdering = 1;
            this.randomSeedForOrdering = 1;
            this.noGainStepsBound = 5;
            this.maxNumberOfPassesInOrdering = 24;
            this.groupSplit = 2;
            this.labelCornersPreserveCoefficient = 0.1;
            this.brandesThreshold = 600;
            this.minimalWidth = 0;
            this.minimalHeight = 0;
            this.minNodeHeight = 9;
            this.minNodeWidth = 13.5;
            this.transformation = Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.get_UnitTransformation();
            this.aspectRatio = 0;
            this.maxAspectRatioEccentricity = 5;
            this.snapToGridByY = Microsoft.Msagl.Layout.Layered.SnapToGridByY.None;
            this.gridSizeByY = 0;
            this.gridSizeByX = 0;
            this._LayeringOnly = false;
            this._FallbackLayoutSettings = null;
            Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings.ctor.call(this);
            this.get_EdgeRoutingSettings().set_EdgeRoutingMode(Microsoft.Msagl.Core.Routing.EdgeRoutingMode.SugiyamaSplines);
        },
        LayerSeparation$$: "System.Double",
        get_LayerSeparation: function (){
            return this.yLayerSep;
        },
        set_LayerSeparation: function (value){
            this.yLayerSep = System.Math.Max$$Double$$Double(10, value);
        },
        AddLeftRightConstraint: function (leftNode, rightNode){
            this.get_HorizontalConstraints().get_LeftRightConstraints().Insert(new System.Tuple$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Layout.Node.ctor, leftNode, rightNode));
        },
        RemoveLeftRightConstraint: function (leftNode, rightNode){
            this.get_HorizontalConstraints().get_LeftRightConstraints().Remove(new System.Tuple$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Layout.Node.ctor, leftNode, rightNode));
        },
        VerticalConstraints$$: "Microsoft.Msagl.Layout.Layered.VerticalConstraintsForSugiyama",
        get_VerticalConstraints: function (){
            return this.verticalConstraints;
        },
        HorizontalConstraints$$: "Microsoft.Msagl.Layout.Layered.HorizontalConstraintsForSugiyama",
        get_HorizontalConstraints: function (){
            return this.horizontalConstraints;
        },
        PinNodesToMaxLayer: function (nodes){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(nodes, "nodes");
            for (var i = 0; i < nodes.length; i++)
                this.get_VerticalConstraints().PinNodeToMaxLayer(nodes[i]);
        },
        PinNodesToMinLayer: function (nodes){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(nodes, "nodes");
            for (var i = 0; i < nodes.length; i++)
                this.get_VerticalConstraints().PinNodeToMinLayer(nodes[i]);
        },
        PinNodesToSameLayer: function (nodes){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(nodes, "nodes");
            for (var i = 1; i < nodes.length; i++)
                this.get_VerticalConstraints().get_SameLayerConstraints().Insert(new System.Tuple$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Layout.Node.ctor, nodes[0], nodes[i]));
        },
        AddSameLayerNeighbors$$Node$Array: function (neighbors){
            this.AddSameLayerNeighbors$$IEnumerable$1$Node(new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Node.ctor, neighbors));
        },
        AddSameLayerNeighbors$$IEnumerable$1$Node: function (neighbors){
            var neibs = new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Node.ctor, neighbors);
            this.get_HorizontalConstraints().AddSameLayerNeighbors(neibs);
            for (var i = 0; i < neibs.get_Count() - 1; i++)
                this.get_VerticalConstraints().get_SameLayerConstraints().Insert(new System.Tuple$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Layout.Node.ctor, neibs.get_Item$$Int32(i), neibs.get_Item$$Int32(i + 1)));
        },
        AddSameLayerNeighbors$$Node$$Node: function (leftNode, rightNode){
            this.get_HorizontalConstraints().AddSameLayerNeighborsPair(leftNode, rightNode);
            this.get_VerticalConstraints().get_SameLayerConstraints().Insert(new System.Tuple$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Layout.Node.ctor, leftNode, rightNode));
        },
        RemoveAllConstraints: function (){
            this.get_HorizontalConstraints().Clear();
            this.get_VerticalConstraints().Clear();
        },
        AddUpDownConstraint: function (upperNode, lowerNode){
            this.get_VerticalConstraints().get_UpDownConstraints().Insert(new System.Tuple$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Layout.Node.ctor, upperNode, lowerNode));
        },
        AddUpDownVerticalConstraint: function (upperNode, lowerNode){
            this.get_VerticalConstraints().get_UpDownConstraints().Insert(new System.Tuple$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Layout.Node.ctor, upperNode, lowerNode));
            this.get_HorizontalConstraints().get_UpDownVerticalConstraints().Insert(new System.Tuple$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Core.Layout.Node.ctor, upperNode, lowerNode));
        },
        AddUpDownVerticalConstraints: function (upDownNodes){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(upDownNodes, "upDownNodes");
            for (var i = 1; i < upDownNodes.length; i++)
                this.AddUpDownVerticalConstraint(upDownNodes[i - 1], upDownNodes[i]);
        },
        LayeringOnly$$: "System.Boolean",
        get_LayeringOnly: function (){
            return this._LayeringOnly;
        },
        set_LayeringOnly: function (value){
            this._LayeringOnly = value;
        },
        RepetitionCoefficientForOrdering$$: "System.Int32",
        get_RepetitionCoefficientForOrdering: function (){
            return this.repetitionCoefficentForOrdering;
        },
        set_RepetitionCoefficientForOrdering: function (value){
            this.repetitionCoefficentForOrdering = System.Math.Max$$Int32$$Int32(value, 1);
        },
        RandomSeedForOrdering$$: "System.Int32",
        get_RandomSeedForOrdering: function (){
            return this.randomSeedForOrdering;
        },
        set_RandomSeedForOrdering: function (value){
            this.randomSeedForOrdering = value;
        },
        NoGainAdjacentSwapStepsBound$$: "System.Int32",
        get_NoGainAdjacentSwapStepsBound: function (){
            return this.noGainStepsBound;
        },
        set_NoGainAdjacentSwapStepsBound: function (value){
            this.noGainStepsBound = value;
        },
        MaxNumberOfPassesInOrdering$$: "System.Int32",
        get_MaxNumberOfPassesInOrdering: function (){
            return this.maxNumberOfPassesInOrdering;
        },
        set_MaxNumberOfPassesInOrdering: function (value){
            this.maxNumberOfPassesInOrdering = value;
        },
        GroupSplit$$: "System.Int32",
        get_GroupSplit: function (){
            return this.groupSplit;
        },
        set_GroupSplit: function (value){
            this.groupSplit = value;
        },
        LabelCornersPreserveCoefficient$$: "System.Double",
        get_LabelCornersPreserveCoefficient: function (){
            return this.labelCornersPreserveCoefficient;
        },
        set_LabelCornersPreserveCoefficient: function (value){
            this.labelCornersPreserveCoefficient = value;
        },
        BrandesThreshold$$: "System.Int32",
        get_BrandesThreshold: function (){
            return this.brandesThreshold;
        },
        set_BrandesThreshold: function (value){
            this.brandesThreshold = value;
        },
        Clone: function (){
            return As(this.MemberwiseClone(), Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings.ctor);
        },
        MinimalWidth$$: "System.Double",
        get_MinimalWidth: function (){
            return this.minimalWidth;
        },
        set_MinimalWidth: function (value){
            this.minimalWidth = System.Math.Max$$Double$$Double(value, 0);
        },
        MinimalHeight$$: "System.Double",
        get_MinimalHeight: function (){
            return this.minimalHeight;
        },
        set_MinimalHeight: function (value){
            this.minimalHeight = System.Math.Max$$Double$$Double(value, 0);
        },
        MinNodeHeight$$: "System.Double",
        get_MinNodeHeight: function (){
            return this.minNodeHeight;
        },
        set_MinNodeHeight: function (value){
            this.minNodeHeight = System.Math.Max$$Double$$Double(0.4, value);
        },
        MinNodeWidth$$: "System.Double",
        get_MinNodeWidth: function (){
            return this.minNodeWidth;
        },
        set_MinNodeWidth: function (value){
            this.minNodeWidth = System.Math.Max$$Double$$Double(0.8, value);
        },
        Transformation$$: "Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation",
        get_Transformation: function (){
            return this.transformation;
        },
        set_Transformation: function (value){
            this.transformation = value;
        },
        AspectRatio$$: "System.Double",
        get_AspectRatio: function (){
            return this.aspectRatio;
        },
        set_AspectRatio: function (value){
            this.aspectRatio = value;
        },
        ActualLayerSeparation: function (layersAreDoubled){
            return layersAreDoubled ? this.get_LayerSeparation() / 2 : this.get_LayerSeparation();
        },
        MaxAspectRatioEccentricity$$: "System.Double",
        get_MaxAspectRatioEccentricity: function (){
            return this.maxAspectRatioEccentricity;
        },
        set_MaxAspectRatioEccentricity: function (value){
            this.maxAspectRatioEccentricity = value;
        },
        FallbackLayoutSettings$$: "Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings",
        get_FallbackLayoutSettings: function (){
            return this._FallbackLayoutSettings;
        },
        set_FallbackLayoutSettings: function (value){
            this._FallbackLayoutSettings = value;
        },
        SnapToGridByY$$: "Microsoft.Msagl.Layout.Layered.SnapToGridByY",
        get_SnapToGridByY: function (){
            return this.snapToGridByY;
        },
        set_SnapToGridByY: function (value){
            this.snapToGridByY = value;
        },
        GridSizeByY$$: "System.Double",
        get_GridSizeByY: function (){
            return this.gridSizeByY;
        },
        set_GridSizeByY: function (value){
            this.gridSizeByY = value;
        },
        GridSizeByX$$: "System.Double",
        get_GridSizeByX: function (){
            return this.gridSizeByX;
        },
        set_GridSizeByX: function (value){
            this.gridSizeByX = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$SugiyamaLayoutSettings);
var Microsoft$Msagl$Core$Layout$LayoutAlgorithmSettings = {
    fullname: "Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.edgeRoutingSettings = new Microsoft.Msagl.Core.Routing.EdgeRoutingSettings.ctor();
            this.packingAspectRatio = Microsoft.Msagl.Core.Geometry.PackingConstants.GoldenRatio;
            this.packingMethod = Microsoft.Msagl.Core.Layout.PackingMethod.Compact;
            this.nodeSeparation = 10;
            this.clusterMargin = 10;
            System.Object.ctor.call(this);
        },
        EdgeRoutingSettings$$: "Microsoft.Msagl.Core.Routing.EdgeRoutingSettings",
        get_EdgeRoutingSettings: function (){
            return this.edgeRoutingSettings;
        },
        set_EdgeRoutingSettings: function (value){
            this.edgeRoutingSettings = value;
        },
        PackingAspectRatio$$: "System.Double",
        get_PackingAspectRatio: function (){
            return this.packingAspectRatio;
        },
        set_PackingAspectRatio: function (value){
            this.packingAspectRatio = value;
        },
        PackingMethod$$: "Microsoft.Msagl.Core.Layout.PackingMethod",
        get_PackingMethod: function (){
            return this.packingMethod;
        },
        set_PackingMethod: function (value){
            this.packingMethod = value;
        },
        NodeSeparation$$: "System.Double",
        get_NodeSeparation: function (){
            return this.nodeSeparation;
        },
        set_NodeSeparation: function (value){
            this.nodeSeparation = value;
        },
        ClusterMargin$$: "System.Double",
        get_ClusterMargin: function (){
            return this.clusterMargin;
        },
        set_ClusterMargin: function (value){
            this.clusterMargin = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$LayoutAlgorithmSettings);
var Microsoft$Msagl$Core$Layout$Node = {
    fullname: "Microsoft.Msagl.Core.Layout.Node",
    baseTypeName: "Microsoft.Msagl.Core.Layout.GeometryObject",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.padding = 1;
            this.boundaryCurve = null;
            this.inEdges_ = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor);
            this.outEdges_ = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor);
            this.selfEdges_ = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor);
            this.clusterParents = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Cluster.ctor);
            this._DebugId = null;
            Microsoft.Msagl.Core.Layout.GeometryObject.ctor.call(this);
        },
        DebugId$$: "System.Object",
        get_DebugId: function (){
            return this._DebugId;
        },
        set_DebugId: function (value){
            this._DebugId = value;
        },
        Padding$$: "System.Double",
        get_Padding: function (){
            return this.padding;
        },
        set_Padding: function (value){
            this.padding = value;
        },
        BoundaryCurve$$: "Microsoft.Msagl.Core.Geometry.Curves.ICurve",
        get_BoundaryCurve: function (){
            return this.boundaryCurve;
        },
        set_BoundaryCurve: function (value){
            this.RaiseLayoutChangeEvent(value);
            this.boundaryCurve = value;
        },
        ctor$$ICurve: function (curve){
            this.padding = 1;
            this.boundaryCurve = null;
            this.inEdges_ = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor);
            this.outEdges_ = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor);
            this.selfEdges_ = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor);
            this.clusterParents = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Cluster.ctor);
            this._DebugId = null;
            Microsoft.Msagl.Core.Layout.GeometryObject.ctor.call(this);
            this.boundaryCurve = curve;
        },
        ctor$$ICurve$$Object: function (curve, userData){
            this.padding = 1;
            this.boundaryCurve = null;
            this.inEdges_ = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor);
            this.outEdges_ = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor);
            this.selfEdges_ = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor);
            this.clusterParents = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Cluster.ctor);
            this._DebugId = null;
            Microsoft.Msagl.Core.Layout.GeometryObject.ctor.call(this);
            this.boundaryCurve = curve;
            this.set_UserData(userData);
        },
        toString: function (){
            if (this.get_UserData() != null){
                var ret = this.get_UserData().toString();
                return ret;
            }
            return System.Object.commonPrototype.toString.call(this);
        },
        InEdges$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Layout.Edge]]",
        get_InEdges: function (){
            return this.inEdges_;
        },
        set_InEdges: function (value){
            this.inEdges_ = Cast(value, Microsoft.Msagl.Core.DataStructures.Set$1.ctor);
        },
        OutEdges$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Layout.Edge]]",
        get_OutEdges: function (){
            return this.outEdges_;
        },
        set_OutEdges: function (value){
            this.outEdges_ = Cast(value, Microsoft.Msagl.Core.DataStructures.Set$1.ctor);
        },
        SelfEdges$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Layout.Edge]]",
        get_SelfEdges: function (){
            return this.selfEdges_;
        },
        set_SelfEdges: function (value){
            this.selfEdges_ = Cast(value, Microsoft.Msagl.Core.DataStructures.Set$1.ctor);
        },
        ClusterParents$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Layout.Cluster]]",
        get_ClusterParents: function (){
            return this.clusterParents;
        },
        set_ClusterParents: function (value){
            this.clusterParents = Cast(value, System.Collections.Generic.List$1.ctor);
        },
        AllClusterAncestors$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Layout.Cluster]]",
        get_AllClusterAncestors: function (){
            var $yield = [];
            var parent = System.Linq.Enumerable.FirstOrDefault$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, this.get_ClusterParents());
            while (parent != null){
                $yield.push(parent);
                parent = System.Linq.Enumerable.FirstOrDefault$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, parent.get_ClusterParents());
            }
            return $yield;
        },
        AddClusterParent: function (parent){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(parent, "parent");
            System.Diagnostics.Debug.Assert$$Boolean(parent != this);
            this.clusterParents.Add(parent);
        },
        RemoveSelfEdge: function (edge){
            return this.selfEdges_.Remove(edge);
        },
        AddOutEdge: function (edge){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(edge, "edge");
            System.Diagnostics.Debug.Assert$$Boolean(edge.get_Source() != edge.get_Target());
            System.Diagnostics.Debug.Assert$$Boolean(edge.get_Source() == this);
            this.outEdges_.Insert(edge);
        },
        AddInEdge: function (edge){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(edge, "edge");
            System.Diagnostics.Debug.Assert$$Boolean(edge.get_Source() != edge.get_Target());
            System.Diagnostics.Debug.Assert$$Boolean(edge.get_Target() == this);
            this.inEdges_.Insert(edge);
        },
        AddSelfEdge: function (edge){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(edge, "edge");
            System.Diagnostics.Debug.Assert$$Boolean(edge.get_Target() == this && edge.get_Source() == this);
            this.selfEdges_.Insert(edge);
        },
        Edges$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Layout.Edge]]",
        get_Edges: function (){
            var $yield = [];
            var $it923 = this.outEdges_.GetEnumerator();
            while ($it923.MoveNext()){
                var e = $it923.get_Current();
                $yield.push(e);
            }
            var $it924 = this.inEdges_.GetEnumerator();
            while ($it924.MoveNext()){
                var e = $it924.get_Current();
                $yield.push(e);
            }
            var $it925 = this.selfEdges_.GetEnumerator();
            while ($it925.MoveNext()){
                var e = $it925.get_Current();
                $yield.push(e);
            }
            return $yield;
        },
        Center$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Center: function (){
            return this.get_BoundaryCurve().get_BoundingBox().get_Center();
        },
        set_Center: function (value){
            var del = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(value, this.get_Center());
            if (del.get_X() == 0 && del.get_Y() == 0)
                return;
            this.RaiseLayoutChangeEvent(value);
            this.get_BoundaryCurve().Translate(del);
        },
        FitBoundaryCurveToTarget: function (targetBounds){
            if (this.get_BoundaryCurve() != null){
                var rr = As(this.get_BoundaryCurve(), Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.ctor);
                if (rr == null){
                    System.Diagnostics.Debug.Assert$$Boolean(this.get_BoundaryCurve().get_BoundingBox().get_Width() > 0);
                    System.Diagnostics.Debug.Assert$$Boolean(this.get_BoundaryCurve().get_BoundingBox().get_Height() > 0);
                    var scaleX = targetBounds.get_Width() / this.get_BoundaryCurve().get_BoundingBox().get_Width();
                    var scaleY = targetBounds.get_Height() / this.get_BoundaryCurve().get_BoundingBox().get_Height();
                    this.get_BoundaryCurve().Translate(Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(this.get_BoundaryCurve().get_BoundingBox().get_LeftBottom()));
                    this.set_BoundaryCurve(this.get_BoundaryCurve().ScaleFromOrigin(scaleX, scaleY));
                    this.get_BoundaryCurve().Translate(targetBounds.get_LeftBottom());
                }
                else {
                    this.set_BoundaryCurve(rr.FitTo(targetBounds));
                }
                System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Rectangle$$Rectangle$$Double(this.get_BoundaryCurve().get_BoundingBox(), targetBounds, Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_UserDefinedTolerance()), "FitToBounds didn\'t succeed in scaling/translating to target bounds");
            }
        },
        BoundingBox$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_BoundingBox: function (){
            return this.get_BoundaryCurve() != null ? this.get_BoundaryCurve().get_BoundingBox() : Microsoft.Msagl.Core.Geometry.Rectangle.CreateAnEmptyBox();
        },
        set_BoundingBox: function (value){
            if (System.Math.Abs$$Double(value.get_Width() - this.get_Width()) < 0.01 && System.Math.Abs$$Double(value.get_Height() - this.get_Height()) < 0.01){
                this.set_Center(value.get_Center());
            }
            else {
                this.FitBoundaryCurveToTarget(value);
            }
        },
        Width$$: "System.Double",
        get_Width: function (){
            return this.get_BoundaryCurve().get_BoundingBox().get_Width();
        },
        Height$$: "System.Double",
        get_Height: function (){
            return this.get_BoundaryCurve().get_BoundingBox().get_Height();
        },
        Degree$$: "System.Int32",
        get_Degree: function (){
            return System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Edge.ctor, this.get_OutEdges()) + System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Edge.ctor, this.get_InEdges()) + System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Edge.ctor, this.get_SelfEdges());
        },
        RemoveInEdge: function (edge){
            return this.inEdges_.Remove(edge);
        },
        RemoveOutEdge: function (edge){
            return this.outEdges_.Remove(edge);
        },
        ClearEdges: function (){
            this.inEdges_.Clear();
            this.outEdges_.Clear();
        },
        Transform: function (transformation){
            this.set_BoundaryCurve(this.get_BoundaryCurve().Transform(transformation));
        },
        IsDescendantOf: function (cluster){
            var parents = new System.Collections.Generic.Queue$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Cluster.ctor, this.get_ClusterParents());
            while (parents.get_Count() > 0){
                var parent = parents.Dequeue();
                if (parent == cluster){
                    return true;
                }
                var $it926 = parent.get_ClusterParents().GetEnumerator();
                while ($it926.MoveNext()){
                    var grandParent = $it926.get_Current();
                    parents.Enqueue(grandParent);
                }
            }
            return false;
        },
        UnderCollapsedCluster: function (){
            return System.Linq.Enumerable.Any$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Cluster.ctor, this.get_ClusterParents(), $CreateAnonymousDelegate(this, function (c){
                return c.get_IsCollapsed();
            }));
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Layout$Node);
var Microsoft$Msagl$Layout$Layered$Anchor = {
    fullname: "Microsoft.Msagl.Layout.Layered.Anchor",
    baseTypeName: "System.Object",
    staticDefinition: {
        Pad: function (curve, padding){
            if (padding == 0)
                return curve;
            if (Microsoft.Msagl.Layout.Layered.Anchor.CurveIsConvex(curve)){
                return Microsoft.Msagl.Layout.Layered.Anchor.PadConvexCurve(curve, padding);
            }
            else
                return Microsoft.Msagl.Layout.Layered.Anchor.PadConvexCurve(Microsoft.Msagl.Core.Geometry.Curves.Curve.StandardRectBoundary(curve), padding);
        },
        PadCorner: function (poly, p0, p1, p2, padding){
            var a,b;
            var numberOfPoints = (function (){
                var $1 = {
                    Value: a
                };
                var $2 = {
                    Value: b
                };
                var $res = Microsoft.Msagl.Layout.Layered.Anchor.GetPaddedCorner(p0, p1, p2, $1, $2, padding);
                a = $1.Value;
                b = $2.Value;
                return $res;
            })();
            poly.AddPoint$$Point(a);
            if (numberOfPoints == 2)
                poly.AddPoint$$Point(b);
        },
        PadConvexCurve: function (poly, padding){
            var ret = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
            Microsoft.Msagl.Layout.Layered.Anchor.PadCorner(ret, poly.get_EndPoint().get_Prev(), poly.get_EndPoint(), poly.get_StartPoint(), padding);
            Microsoft.Msagl.Layout.Layered.Anchor.PadCorner(ret, poly.get_EndPoint(), poly.get_StartPoint(), poly.get_StartPoint().get_Next(), padding);
            for (var pp = poly.get_StartPoint(); pp.get_Next().get_Next() != null; pp = pp.get_Next())
                Microsoft.Msagl.Layout.Layered.Anchor.PadCorner(ret, pp, pp.get_Next(), pp.get_Next().get_Next(), padding);
            ret.set_Closed(true);
            return ret;
        },
        GetPaddedCorner: function (first, second, third, a, b, padding){
            var u = first.get_Point();
            var v = second.get_Point();
            var w = third.get_Point();
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(u, v, w) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise);
            var uvPerp = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v, u)).Rotate(1.5707963267949).Normalize();
            var l = Microsoft.Msagl.Core.Geometry.Point.op_Addition((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v, u)).Normalize(), (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v, w)).Normalize());
            if (l.get_Length() < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_IntersectionEpsilon()){
                a.Value = b.Value = Microsoft.Msagl.Core.Geometry.Point.op_Addition(v, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(padding, uvPerp));
                return 1;
            }
            var d = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(l.Normalize(), padding);
            var dp = d.Rotate(1.5707963267949);
            var xp = (padding - Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(d, uvPerp)) / (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(dp, uvPerp));
            a.Value = Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Addition(d, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(xp, dp)), v);
            b.Value = Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(d, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(xp, dp)), v);
            return 2;
        },
        CurveIsConvex: function (poly){
            var orientation = Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(poly.get_EndPoint().get_Point(), poly.get_StartPoint().get_Point(), poly.get_StartPoint().get_Next().get_Point());
            if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(poly.get_EndPoint().get_Prev().get_Point(), poly.get_EndPoint().get_Point(), poly.get_StartPoint().get_Point()) != orientation)
                return false;
            var pp = poly.get_StartPoint();
            while (pp.get_Next().get_Next() != null){
                if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(pp.get_Point(), pp.get_Next().get_Point(), pp.get_Next().get_Next().get_Point()) != orientation)
                    return false;
                pp = pp.get_Next();
            }
            return true;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$Double: function (labelCornersPreserveCoefficient){
            this.la = 0;
            this.ra = 0;
            this.ta = 0;
            this.ba = 0;
            this.labelCornersPreserveCoefficient = 0;
            this.node = null;
            this.x = 0;
            this.y = 0;
            this.alreadySitsOnASpline = false;
            this.labelIsToTheLeftOfTheSpline = false;
            this.labelIsToTheRightOfTheSpline = false;
            this.polygonalBoundary = null;
            this.padding = 0;
            System.Object.ctor.call(this);
            this.labelCornersPreserveCoefficient = labelCornersPreserveCoefficient;
        },
        toString: function (){
            return "la:ra " + this.la.ToString$$String$$IFormatProvider("#.##", System.Globalization.CultureInfo.get_InvariantCulture()) + " " + this.ra.ToString$$String$$IFormatProvider("#.##", System.Globalization.CultureInfo.get_InvariantCulture()) + " ta:ba " + this.ta.ToString$$String$$IFormatProvider("#.##", System.Globalization.CultureInfo.get_InvariantCulture()) + " " + this.ba.ToString$$String$$IFormatProvider("#.##", System.Globalization.CultureInfo.get_InvariantCulture()) + " x:y " + this.x.ToString$$String$$IFormatProvider("#.##", System.Globalization.CultureInfo.get_InvariantCulture()) + " " + this.y.ToString$$String$$IFormatProvider("#.##", System.Globalization.CultureInfo.get_InvariantCulture());
        },
        LeftAnchor$$: "System.Double",
        get_LeftAnchor: function (){
            return this.la;
        },
        set_LeftAnchor: function (value){
            this.la = System.Math.Max$$Double$$Double(value, 0);
        },
        RightAnchor$$: "System.Double",
        get_RightAnchor: function (){
            return this.ra;
        },
        set_RightAnchor: function (value){
            this.ra = System.Math.Max$$Double$$Double(value, 0);
        },
        TopAnchor$$: "System.Double",
        get_TopAnchor: function (){
            return this.ta;
        },
        set_TopAnchor: function (value){
            this.ta = System.Math.Max$$Double$$Double(value, 0);
        },
        BottomAnchor$$: "System.Double",
        get_BottomAnchor: function (){
            return this.ba;
        },
        set_BottomAnchor: function (value){
            this.ba = System.Math.Max$$Double$$Double(value, 0);
        },
        Left$$: "System.Double",
        get_Left: function (){
            return this.x - this.la;
        },
        Right$$: "System.Double",
        get_Right: function (){
            return this.x + this.ra;
        },
        Top$$: "System.Double",
        get_Top: function (){
            return this.y + this.ta;
        },
        set_Top: function (value){
            this.y += value - this.get_Top();
        },
        Bottom$$: "System.Double",
        get_Bottom: function (){
            return this.y - this.ba;
        },
        set_Bottom: function (value){
            this.y += value - this.get_Bottom();
        },
        LeftTop$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_LeftTop: function (){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.get_Left(), this.get_Top());
        },
        LeftBottom$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_LeftBottom: function (){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.get_Left(), this.get_Bottom());
        },
        RightBottom$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_RightBottom: function (){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.get_Right(), this.get_Bottom());
        },
        Node$$: "Microsoft.Msagl.Core.Layout.Node",
        get_Node: function (){
            return this.node;
        },
        set_Node: function (value){
            this.node = value;
            this.polygonalBoundary = null;
        },
        RightTop$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_RightTop: function (){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.get_Right(), this.get_Top());
        },
        ctor$$Double$$Double$$Double$$Double$$Node$$Double: function (leftAnchor, rightAnchor, topAnchor, bottomAnchor, node, labelCornersPreserveCoefficient){
            this.la = 0;
            this.ra = 0;
            this.ta = 0;
            this.ba = 0;
            this.labelCornersPreserveCoefficient = 0;
            this.node = null;
            this.x = 0;
            this.y = 0;
            this.alreadySitsOnASpline = false;
            this.labelIsToTheLeftOfTheSpline = false;
            this.labelIsToTheRightOfTheSpline = false;
            this.polygonalBoundary = null;
            this.padding = 0;
            System.Object.ctor.call(this);
            this.la = leftAnchor;
            this.ra = rightAnchor;
            this.ta = topAnchor;
            this.ba = bottomAnchor;
            this.set_Node(node);
            this.labelCornersPreserveCoefficient = labelCornersPreserveCoefficient;
        },
        X$$: "System.Double",
        get_X: function (){
            return this.x;
        },
        set_X: function (value){
            this.polygonalBoundary = null;
            this.x = value;
        },
        Y$$: "System.Double",
        get_Y: function (){
            return this.y;
        },
        set_Y: function (value){
            this.polygonalBoundary = null;
            this.y = value;
        },
        Origin$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Origin: function (){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.x, this.y);
        },
        AlreadySitsOnASpline$$: "System.Boolean",
        get_AlreadySitsOnASpline: function (){
            return this.alreadySitsOnASpline;
        },
        set_AlreadySitsOnASpline: function (value){
            this.alreadySitsOnASpline = value;
        },
        Width$$: "System.Double",
        get_Width: function (){
            return this.la + this.ra;
        },
        Height$$: "System.Double",
        get_Height: function (){
            return this.ta + this.ba;
        },
        RepresentsLabel$$: "System.Boolean",
        get_RepresentsLabel: function (){
            return this.get_LabelToTheRightOfAnchorCenter() || this.get_LabelToTheLeftOfAnchorCenter();
        },
        LabelToTheLeftOfAnchorCenter$$: "System.Boolean",
        get_LabelToTheLeftOfAnchorCenter: function (){
            return this.labelIsToTheLeftOfTheSpline;
        },
        set_LabelToTheLeftOfAnchorCenter: function (value){
            this.labelIsToTheLeftOfTheSpline = value;
        },
        LabelToTheRightOfAnchorCenter$$: "System.Boolean",
        get_LabelToTheRightOfAnchorCenter: function (){
            return this.labelIsToTheRightOfTheSpline;
        },
        set_LabelToTheRightOfAnchorCenter: function (value){
            this.labelIsToTheRightOfTheSpline = value;
        },
        HasLabel$$: "System.Boolean",
        get_HasLabel: function (){
            return this.get_LabelToTheRightOfAnchorCenter() || this.get_LabelToTheLeftOfAnchorCenter();
        },
        LabelWidth$$: "System.Double",
        get_LabelWidth: function (){
            if (this.get_LabelToTheLeftOfAnchorCenter())
                return this.get_LeftAnchor();
            if (this.get_LabelToTheRightOfAnchorCenter())
                return this.get_RightAnchor();
            throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
        },
        PolygonalBoundary$$: "Microsoft.Msagl.Core.Geometry.Curves.Polyline",
        get_PolygonalBoundary: function (){
            if (this.polygonalBoundary != null)
                return this.polygonalBoundary;
            return this.polygonalBoundary = Microsoft.Msagl.Layout.Layered.Anchor.Pad(this.CreatPolygonalBoundaryWithoutPadding(), this.get_Padding());
        },
        CreatPolygonalBoundaryWithoutPadding: function (){
            var ret;
            if (this.get_HasLabel())
                ret = this.get_LabelToTheLeftOfAnchorCenter() ? this.PolygonOnLeftLabel() : this.PolygonOnRightLabel();
            else if (this.get_NodeBoundary() == null)
                ret = this.StandardRectBoundary();
            else
                ret = Microsoft.Msagl.Core.Geometry.Curves.Curve.PolylineAroundClosedCurve(this.get_NodeBoundary());
            return ret;
        },
        StandardRectBoundary: function (){
            var poly = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
            poly.AddPoint$$Point(this.get_LeftTop());
            poly.AddPoint$$Point(this.get_RightTop());
            poly.AddPoint$$Point(this.get_RightBottom());
            poly.AddPoint$$Point(this.get_LeftBottom());
            poly.set_Closed(true);
            return poly;
        },
        PolygonOnLeftLabel: function (){
            var poly = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
            var t = this.get_Left() + (1 - this.labelCornersPreserveCoefficient) * this.get_LabelWidth();
            poly.AddPoint$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(t, this.get_Top()));
            poly.AddPoint$$Point(this.get_RightTop());
            poly.AddPoint$$Point(this.get_RightBottom());
            poly.AddPoint$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(t, this.get_Bottom()));
            poly.AddPoint$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.get_Left(), this.get_Y()));
            poly.set_Closed(true);
            return poly;
        },
        PolygonOnRightLabel: function (){
            var poly = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
            var t = this.get_Right() - (1 - this.labelCornersPreserveCoefficient) * this.get_LabelWidth();
            poly.AddPoint$$Double$$Double(t, this.get_Top());
            poly.AddPoint$$Double$$Double(this.get_Right(), this.get_Y());
            poly.AddPoint$$Double$$Double(t, this.get_Bottom());
            poly.AddPoint$$Double$$Double(this.get_Left(), this.get_Bottom());
            poly.AddPoint$$Double$$Double(this.get_Left(), this.get_Top());
            poly.set_Closed(true);
            return poly;
        },
        NodeBoundary$$: "Microsoft.Msagl.Core.Geometry.Curves.ICurve",
        get_NodeBoundary: function (){
            return this.get_Node() != null ? this.get_Node().get_BoundaryCurve() : null;
        },
        Padding$$: "System.Double",
        get_Padding: function (){
            return this.padding;
        },
        set_Padding: function (value){
            this.padding = value;
        },
        Move: function (p){
            this.set_X(this.get_X() + p.get_X());
            this.set_Y(this.get_Y() + p.get_Y());
        },
        MoveTo: function (p){
            this.set_X(p.get_X());
            this.set_Y(p.get_Y());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$Anchor);
var Microsoft$Msagl$Core$DataStructures$Set$1 = {
    fullname: "Microsoft.Msagl.Core.DataStructures.Set$1",
    baseTypeName: "System.MarshalByRefObject",
    staticDefinition: {
        op_Addition: function (set0, set1){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(set1, "set1");
            var ret = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(this.T, set0);
            var $it931 = set1.GetEnumerator();
            while ($it931.MoveNext()){
                var t = $it931.get_Current();
                ret.Insert(t);
            }
            return ret;
        },
        op_Subtraction: function (set0, set1){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(set1, "set1");
            var ret = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(this.T, set0);
            var $it932 = set1.GetEnumerator();
            while ($it932.MoveNext()){
                var t = $it932.get_Current();
                ret.Remove(t);
            }
            return ret;
        },
        op_Equality: function (set0, set1){
            if (set0 == null && set1 == null)
                return true;
            if (set0 == null && set1 != null)
                return false;
            if (set1 == null && set0 != null)
                return false;
            var $it933 = set0.GetEnumerator();
            while ($it933.MoveNext()){
                var t = $it933.get_Current();
                if (!set1.Contains$$T(t))
                    return false;
            }
            var $it934 = set1.GetEnumerator();
            while ($it934.MoveNext()){
                var t = $it934.get_Current();
                if (!set0.Contains$$T(t))
                    return false;
            }
            return true;
        },
        op_Inequality: function (set0, set1){
            return !(Microsoft.Msagl.Core.DataStructures.Set$1.op_Equality(set0, set1));
        },
        op_Multiply: function (set0, set1){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(set0, "set0");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(set1, "set1");
            return new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(this.T, set0.get_Count() < set1.get_Count() ? System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(this.T, set0, function (a){
                return set1.Contains$$T(a);
            }) : System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(this.T, set1, function (a){
                return set0.Contains$$T(a);
            }));
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.ICollection$1"],
    Kind: "Class",
    definition: {
        ctor$$IEnumerable$1: function (T, enumerableCollection){
            this.T = T;
            this.hashSet = new System.Collections.Generic.HashSet$1.ctor(this.T);
            System.MarshalByRefObject.ctor.call(this);
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(enumerableCollection, "enumerableCollection");
            var $it927 = enumerableCollection.GetEnumerator();
            while ($it927.MoveNext()){
                var j = $it927.get_Current();
                this.Insert(j);
            }
        },
        HashSet$$: "System.Collections.Generic.HashSet`1[[`0]]",
        get_HashSet: function (){
            return this.hashSet;
        },
        Insert: function (element){
            this.hashSet.Add(element);
        },
        Contains$$T: function (item){
            return this.hashSet.Contains(item);
        },
        Delete: function (item){
            this.hashSet.Remove(item);
        },
        Remove: function (item){
            return this.hashSet.Remove(item);
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this.hashSet.get_Count();
        },
        GetEnumerator: function (){
            return this.hashSet.GetEnumerator();
        },
        IsReadOnly$$: "System.Boolean",
        get_IsReadOnly: function (){
            return false;
        },
        CopyTo: function (array, arrayIndex){
            this.hashSet.CopyTo$$T$Array$$Int32(array, arrayIndex);
        },
        toString: function (){
            var r = "{";
            var i = 0;
            var $it928 = this.GetEnumerator();
            while ($it928.MoveNext()){
                var o = $it928.get_Current();
                r += o.toString();
                i++;
                if (i < this.get_Count())
                    r += ",";
            }
            r += "}";
            return r;
        },
        Clear: function (){
            this.hashSet.Clear();
        },
        Clone: function (){
            var ret = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(this.T);
            var $it929 = this.GetEnumerator();
            while ($it929.MoveNext()){
                var i = $it929.get_Current();
                ret.Insert(i);
            }
            return ret;
        },
        ctor: function (T){
            this.T = T;
            this.hashSet = new System.Collections.Generic.HashSet$1.ctor(this.T);
            System.MarshalByRefObject.ctor.call(this);
        },
        ToArray: function (type){
            var ret = System.Array.CreateInstance(type, this.get_Count());
            var i = 0;
            var $it930 = this.GetEnumerator();
            while ($it930.MoveNext()){
                var o = $it930.get_Current();
                ret.SetValue(o, i++);
            }
            return ret;
        },
        Equals$$Object: function (obj){
            var set = As(obj, Microsoft.Msagl.Core.DataStructures.Set$1.ctor);
            if (Microsoft.Msagl.Core.DataStructures.Set$1.op_Equality(set, null))
                return false;
            return Microsoft.Msagl.Core.DataStructures.Set$1.op_Equality(set, this);
        },
        GetHashCode: function (){
            var ret = 0;
            var $it935 = this.GetEnumerator();
            while ($it935.MoveNext()){
                var t = $it935.get_Current();
                ret |= t.GetHashCode();
            }
            return ret;
        },
        Add: function (set0, set1){
            return Microsoft.Msagl.Core.DataStructures.Set$1.op_Addition(set0, set1);
        },
        InsertRange: function (elements){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(elements, "elements");
            var $it936 = elements.GetEnumerator();
            while ($it936.MoveNext()){
                var element = $it936.get_Current();
                this.Insert(element);
            }
        },
        IsContained: function (otherSet){
            return System.Linq.Enumerable.All$1(this.T, this, $CreateAnonymousDelegate(this, function (p){
                return otherSet.Contains$$T(p);
            }));
        },
        Contains$$Set$1: function (otherSet){
            return System.Linq.Enumerable.All$1(this.T, otherSet, $CreateAnonymousDelegate(this, function (p){
                return this.Contains$$T(p);
            }));
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$DataStructures$Set$1);
var Microsoft$Msagl$Layout$Layered$LayerEdge = {
    fullname: "Microsoft.Msagl.Layout.Layered.LayerEdge",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$Int32$$Int32$$Int32$$Int32: function (source, target, crossingWeight, weight){
            this.Weight = 1;
            this.source = 0;
            this.target = 0;
            this.crossingWeight = 1;
            System.Object.ctor.call(this);
            this.set_Source(source);
            this.set_Target(target);
            this.crossingWeight = crossingWeight;
            this.Weight = weight;
        },
        ctor$$Int32$$Int32$$Int32: function (source, target, crossingWeight){
            this.Weight = 1;
            this.source = 0;
            this.target = 0;
            this.crossingWeight = 1;
            Microsoft.Msagl.Layout.Layered.LayerEdge.ctor$$Int32$$Int32$$Int32$$Int32.call(this, source, target, crossingWeight, 1);
        },
        Source$$: "System.Int32",
        get_Source: function (){
            return this.source;
        },
        set_Source: function (value){
            this.source = value;
        },
        Target$$: "System.Int32",
        get_Target: function (){
            return this.target;
        },
        set_Target: function (value){
            this.target = value;
        },
        Equals$$Object: function (obj){
            var ie = As(obj, Microsoft.Msagl.Layout.Layered.LayerEdge.ctor);
            return ie.source == this.source && ie.target == this.target;
        },
        GetHashCode: function (){
            var hc = (this.source.GetHashCode()) | 0;
            return (((hc << 5 | hc >> 27) + this.target | 0)) | 0;
        },
        CrossingWeight$$: "System.Int32",
        get_CrossingWeight: function (){
            return this.crossingWeight;
        },
        toString: function (){
            return System.String.Format$$IFormatProvider$$String$$Object$Array(System.Globalization.CultureInfo.get_InvariantCulture(), "{0}->{1}", [this.source, this.target]);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$LayerEdge);
var Microsoft$Msagl$Layout$Layered$SuccEnumerator = {
    fullname: "Microsoft.Msagl.Layout.Layered.SuccEnumerator",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IEnumerator$1"],
    Kind: "Class",
    definition: {
        ctor: function (edges){
            this.edges = null;
            System.Object.ctor.call(this);
            this.edges = edges;
        },
        Reset: function (){
            this.edges.Reset();
        },
        Dispose: function (){
            System.GC.SuppressFinalize(this);
        },
        MoveNext: function (){
            return this.edges.MoveNext();
        },
        Current$$: "System.Int32",
        get_Current: function (){
            return (Cast(this.edges.get_Current(), Microsoft.Msagl.Layout.Layered.IntEdge.ctor)).get_Target();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$SuccEnumerator);
var Microsoft$Msagl$Layout$Layered$PredEnumerator = {
    fullname: "Microsoft.Msagl.Layout.Layered.PredEnumerator",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IEnumerator$1"],
    Kind: "Class",
    definition: {
        ctor: function (edges){
            this.edges = null;
            System.Object.ctor.call(this);
            this.edges = edges;
        },
        Dispose: function (){
            System.GC.SuppressFinalize(this);
        },
        Reset: function (){
            this.edges.Reset();
        },
        Current$$: "System.Int32",
        get_Current: function (){
            return (Cast(this.edges.get_Current(), Microsoft.Msagl.Layout.Layered.IntEdge.ctor)).get_Source();
        },
        MoveNext: function (){
            return this.edges.MoveNext();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$PredEnumerator);
var Microsoft$Msagl$Layout$Layered$EmptyEnumerator = {
    fullname: "Microsoft.Msagl.Layout.Layered.EmptyEnumerator",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IEnumerator$1"],
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        },
        MoveNext: function (){
            return false;
        },
        Current$$: "System.Int32",
        get_Current: function (){
            return 0;
        },
        Dispose: function (){
            System.GC.SuppressFinalize(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$EmptyEnumerator);
var Microsoft$Msagl$Layout$Layered$Pred = {
    fullname: "Microsoft.Msagl.Layout.Layered.Pred",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IEnumerable$1"],
    Kind: "Class",
    definition: {
        ctor: function (g, v){
            this.graph = null;
            this.vert = 0;
            System.Object.ctor.call(this);
            this.graph = g;
            this.vert = v;
        },
        GetEnumerator: function (){
            var e = this.graph.InEdges(this.vert);
            if (e == null){
                return new Microsoft.Msagl.Layout.Layered.EmptyEnumerator.ctor();
            }
            else
                return new Microsoft.Msagl.Layout.Layered.PredEnumerator.ctor(e.GetEnumerator());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$Pred);
var Microsoft$Msagl$Layout$Layered$Succ = {
    fullname: "Microsoft.Msagl.Layout.Layered.Succ",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (g, v){
            this.graph = null;
            this.vert = 0;
            System.Object.ctor.call(this);
            this.graph = g;
            this.vert = v;
        },
        GetEnumerator: function (){
            return new Microsoft.Msagl.Layout.Layered.SuccEnumerator.ctor(this.graph.OutEdges(this.vert).GetEnumerator());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$Succ);
var Microsoft$Msagl$Layout$Layered$XLayoutGraph = {
    fullname: "Microsoft.Msagl.Layout.Layered.XLayoutGraph",
    baseTypeName: "Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (graph, layeredGraph, layerArrays, edges, nov){
            this.layeredGraph = null;
            this.layerArrays = null;
            this.virtualVerticesStart = 0;
            this.virtualVerticesEnd = 0;
            this.weightMultiplierOfOriginalOriginal = 1;
            this.weightMultOfOneVirtual = 3;
            this.weightMultiplierOfTwoVirtual = 8;
            Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor.call(this, Microsoft.Msagl.Layout.Layered.IntEdge.ctor);
            this.SetEdges(edges, nov);
            this.virtualVerticesStart = graph.get_NodeCount();
            this.virtualVerticesEnd = layeredGraph.get_NodeCount() - 1;
            this.layeredGraph = layeredGraph;
            this.layerArrays = layerArrays;
        },
        EdgeWeightMultiplier: function (edge){
            var s = edge.get_Source();
            var t = edge.get_Target();
            if (s < this.layeredGraph.get_NodeCount() && this.layerArrays.Y[s] == this.layerArrays.Y[t] && this.layerArrays.get_X()[s] == this.layerArrays.get_X()[t] + 1)
                return 0;
            var k = 0;
            System.Diagnostics.Debug.Assert$$Boolean(s >= this.layeredGraph.get_NodeCount());
            var s0 = -1,t0 = -1;
            var $it937 = this.OutEdges(s).GetEnumerator();
            while ($it937.MoveNext()){
                var intEdge = $it937.get_Current();
                if (s0 == -1)
                    s0 = intEdge.get_Target();
                else
                    t0 = intEdge.get_Target();
            }
            if (s0 >= this.virtualVerticesStart && s0 <= this.virtualVerticesEnd)
                k++;
            if (t0 >= this.virtualVerticesStart && t0 <= this.virtualVerticesEnd)
                k++;
            var ret = k == 0 ? this.weightMultiplierOfOriginalOriginal : (k == 1 ? this.weightMultOfOneVirtual : this.weightMultiplierOfTwoVirtual);
            return ret;
        },
        SetEdgeWeights: function (){
            var $it938 = this.get_Edges().GetEnumerator();
            while ($it938.MoveNext()){
                var intEdge = $it938.get_Current();
                intEdge.set_Weight(intEdge.get_Weight() * this.EdgeWeightMultiplier(intEdge));
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$XLayoutGraph);
var Microsoft$Msagl$Layout$Layered$OrderingMeasure = {
    fullname: "Microsoft.Msagl.Layout.Layered.OrderingMeasure",
    baseTypeName: "System.Object",
    staticDefinition: {
        op_LessThan: function (a, b){
            if (a.numberOfCrossings < b.numberOfCrossings)
                return true;
            if (a.numberOfCrossings > b.numberOfCrossings)
                return false;
            return a.layerGroupDisbalance | 0 < b.layerGroupDisbalance | 0;
        },
        op_GreaterThan: function (a, b){
            if (a.numberOfCrossings > b.numberOfCrossings)
                return true;
            if (a.numberOfCrossings < b.numberOfCrossings)
                return false;
            return a.layerGroupDisbalance | 0 > b.layerGroupDisbalance | 0;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (layerArraysPar, numOfCrossings, virtualVertexStart, optimalOriginalGroupSizePar, optimalVirtualGroupSizePar){
            this.numberOfCrossings = 0;
            this.layerGroupDisbalance = 0;
            this.la = null;
            this.virtVertexStart = 0;
            this.optimalOriginalGroupSize = null;
            this.optimalVirtualGroupSize = null;
            System.Object.ctor.call(this);
            this.numberOfCrossings = numOfCrossings;
            this.la = layerArraysPar;
            this.virtVertexStart = virtualVertexStart;
            this.optimalVirtualGroupSize = optimalVirtualGroupSizePar;
            this.optimalOriginalGroupSize = optimalOriginalGroupSizePar;
            if (this.optimalOriginalGroupSize != null)
                this.CalculateLayerGroupDisbalance();
        },
        CalculateLayerGroupDisbalance: function (){
            for (var i = 0; i < this.la.length; i++)
                this.layerGroupDisbalance += this.LayerGroupDisbalance(this.la[i], this.optimalOriginalGroupSize[i], this.optimalVirtualGroupSize[i]);
        },
        LayerGroupDisbalance: function (l, origGroupOptSize, virtGroupOptSize){
            if (origGroupOptSize == 1)
                return this.LayerGroupDisbalanceWithOrigSeparators(l, virtGroupOptSize);
            else
                return this.LayerGroupDisbalanceWithVirtSeparators(l, origGroupOptSize);
        },
        LayerGroupDisbalanceWithVirtSeparators: function (l, origGroupOptSize){
            var ret = 0;
            for (var i = 0; i < l.length;)
                ret += (function (){
                    var $1 = {
                        Value: i
                    };
                    var $res = this.CurrentOrigGroupDelta($1, l, origGroupOptSize);
                    i = $1.Value;
                    return $res;
                }).call(this);
            return ret;
        },
        CurrentOrigGroupDelta: function (i, l, origGroupOptSize){
            var groupSize = 0;
            var j = i.Value;
            for (; j < l.length && l[j] < this.virtVertexStart; j++)
                groupSize++;
            i.Value = j + 1;
            return System.Math.Abs$$Double(origGroupOptSize - groupSize);
        },
        LayerGroupDisbalanceWithOrigSeparators: function (l, virtGroupOptSize){
            var ret = 0;
            for (var i = 0; i < l.length;)
                ret += (function (){
                    var $1 = {
                        Value: i
                    };
                    var $res = this.CurrentVirtGroupDelta($1, l, virtGroupOptSize);
                    i = $1.Value;
                    return $res;
                }).call(this);
            return ret;
        },
        CurrentVirtGroupDelta: function (i, l, virtGroupOptSize){
            var groupSize = 0;
            var j = i.Value;
            for (; j < l.length && l[j] >= this.virtVertexStart; j++)
                groupSize++;
            i.Value = j + 1;
            return System.Math.Abs$$Double(virtGroupOptSize - groupSize);
        },
        IsPerfect: function (){
            return this.numberOfCrossings == 0 && this.layerGroupDisbalance == 0;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$OrderingMeasure);
var Microsoft$Msagl$Core$ProjectionSolver$Block = {
    fullname: "Microsoft.Msagl.Core.ProjectionSolver.Block",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (initialVariable, allConstraints){
            this.sumAd = 0;
            this.sumAb = 0;
            this.sumA2 = 0;
            this.constraintPath = null;
            this.pathTargetVariable = null;
            this.idDfDv = 0;
            this.allConstraints = null;
            this.dfDvDummyParentNode = null;
            this._Variables = null;
            this._ReferencePos = 0;
            this._Scale = 0;
            this._VectorIndex = 0;
            System.Object.ctor.call(this);
            this.set_Variables(new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.ProjectionSolver.Variable.ctor));
            if (null != initialVariable){
                this.AddVariable(initialVariable);
            }
            this.allConstraints = allConstraints;
        },
        Variables$$: "System.Collections.Generic.List`1[[Microsoft.Msagl.Core.ProjectionSolver.Variable]]",
        get_Variables: function (){
            return this._Variables;
        },
        set_Variables: function (value){
            this._Variables = value;
        },
        ReferencePos$$: "System.Double",
        get_ReferencePos: function (){
            return this._ReferencePos;
        },
        set_ReferencePos: function (value){
            this._ReferencePos = value;
        },
        Scale$$: "System.Double",
        get_Scale: function (){
            return this._Scale;
        },
        set_Scale: function (value){
            this._Scale = value;
        },
        VectorIndex$$: "System.Int32",
        get_VectorIndex: function (){
            return this._VectorIndex;
        },
        set_VectorIndex: function (value){
            this._VectorIndex = value;
        },
        toString: function (){
            return System.String.Format$$IFormatProvider$$String$$Object$Array(System.Globalization.CultureInfo.get_InvariantCulture(), "[Block: nvars = {0} refpos = {1:F5} scale = {2:F5}]", [this.get_Variables().get_Count(), this.get_ReferencePos(), this.get_Scale()]);
        },
        DebugVerifyFinalDfDvValue: function (dfdv, message){
            var divisor = System.Math.Max$$Double$$Double(this.sumAd, System.Math.Max$$Double$$Double(this.sumAb, this.sumA2));
            System.Diagnostics.Debug.Assert$$Boolean$$String((System.Math.Abs$$Double(dfdv) / divisor) < 0.001, message);
        },
        ComputeDfDv: function (initialVarToEval){
            System.Diagnostics.Debug.Assert$$Boolean$$String(0 != this.idDfDv, "idDfDv should not be 0");
            System.Diagnostics.Debug.Assert$$Boolean$$String(0 == this.allConstraints.DfDvStack.get_Count(), "Leftovers in ComputeDfDvStack");
            this.allConstraints.DfDvStack.Clear();
            var dummyConstraint = new Microsoft.Msagl.Core.ProjectionSolver.Constraint.ctor$$Variable(initialVarToEval);
            this.dfDvDummyParentNode = new Microsoft.Msagl.Core.ProjectionSolver.DfDvNode.ctor$$Constraint(dummyConstraint);
            var firstNode = this.GetDfDvNode(this.dfDvDummyParentNode, dummyConstraint, initialVarToEval, null);
            this.allConstraints.DfDvStack.Push(firstNode);
            for (; ;){
                var node = this.allConstraints.DfDvStack.Peek();
                var prevStackCount = this.allConstraints.DfDvStack.get_Count();
                if (!node.get_ChildrenHaveBeenPushed()){
                    node.set_ChildrenHaveBeenPushed(true);
                    for (var $i940 = 0,$t940 = node.get_VariableToEval().get_LeftConstraints(),$l940 = $t940.length,constraint = $t940[$i940]; $i940 < $l940; $i940++, constraint = $t940[$i940]){
                        System.Diagnostics.Debug.Assert$$Boolean$$String(!constraint.get_IsActive() || !(node.get_IsLeftToRight() && (constraint.get_Right() == node.get_VariableDoneEval())), "this cycle should not happen");
                        if (constraint.get_IsActive() && (constraint.get_Right() != node.get_VariableDoneEval())){
                            var childNode = this.GetDfDvNode(node, constraint, constraint.get_Right(), node.get_VariableToEval());
                            if (1 == constraint.get_Right().get_ActiveConstraintCount()){
                                this.ProcessDfDvLeafNodeDirectly(childNode);
                            }
                            else {
                                this.PushDfDvNode(childNode);
                            }
                        }
                    }
                    for (var $i941 = 0,$t941 = node.get_VariableToEval().get_RightConstraints(),$l941 = $t941.length,constraint = $t941[$i941]; $i941 < $l941; $i941++, constraint = $t941[$i941]){
                        System.Diagnostics.Debug.Assert$$Boolean$$String(!constraint.get_IsActive() || !(!node.get_IsLeftToRight() && (constraint.get_Left() == node.get_VariableDoneEval())), "this cycle should not happen");
                        if (constraint.get_IsActive() && (constraint.get_Left() != node.get_VariableDoneEval())){
                            var childNode = this.GetDfDvNode(node, constraint, constraint.get_Left(), node.get_VariableToEval());
                            if (1 == constraint.get_Left().get_ActiveConstraintCount()){
                                this.ProcessDfDvLeafNodeDirectly(childNode);
                            }
                            else {
                                this.PushDfDvNode(childNode);
                            }
                        }
                    }
                    if (this.allConstraints.DfDvStack.get_Count() > prevStackCount){
                        continue;
                    }
                }
                System.Diagnostics.Debug.Assert$$Boolean$$String(this.allConstraints.DfDvStack.Peek() == node, "DfDvStack.Peek() should be \'node\'");
                this.allConstraints.DfDvStack.Pop();
                this.ProcessDfDvLeafNode(node);
                if (node == firstNode){
                    System.Diagnostics.Debug.Assert$$Boolean$$String(0 == this.allConstraints.DfDvStack.get_Count(), "Leftovers in DfDvStack on completion of loop");
                    break;
                }
            }
            this.DebugVerifyFinalDfDvValue(dummyConstraint.get_Lagrangian() / 2, System.String.Format$$IFormatProvider$$String$$Object$Array(System.Globalization.CultureInfo.get_InvariantCulture(), "nonzero final ComputeDfDv value ({0})", [dummyConstraint.get_Lagrangian()]));
        },
        ProcessDfDvLeafNode: function (node){
            var dfdv = node.get_VariableToEval().get_DfDv();
            if (node.get_IsLeftToRight()){
                node.get_ConstraintToEval().set_Lagrangian(node.get_ConstraintToEval().get_Lagrangian() + dfdv);
                node.get_Parent().get_ConstraintToEval().set_Lagrangian(node.get_Parent().get_ConstraintToEval().get_Lagrangian() + node.get_ConstraintToEval().get_Lagrangian());
            }
            else {
                node.get_ConstraintToEval().set_Lagrangian(-(node.get_ConstraintToEval().get_Lagrangian() + dfdv));
                node.get_Parent().get_ConstraintToEval().set_Lagrangian(node.get_Parent().get_ConstraintToEval().get_Lagrangian() - node.get_ConstraintToEval().get_Lagrangian());
            }
            this.CheckForConstraintPathTarget(node);
            this.Debug_CheckForViolatedActiveConstraint(node.get_ConstraintToEval());
            this.allConstraints.RecycleDfDvNode(node);
        },
        Debug_CheckForViolatedActiveConstraint: function (constraint){
            if (constraint.get_Violation() > this.allConstraints.SolverParameters.get_GapTolerance()){
                System.Diagnostics.Debug.Assert$$Boolean$$String(false, "Violated active constraint should never be encountered");
            }
        },
        ProcessDfDvLeafNodeDirectly: function (node){
            this.Debug_MarkForCycleCheck(node.get_ConstraintToEval());
            this.ProcessDfDvLeafNode(node);
        },
        GetDfDvNode: function (parent, constraintToEval, variableToEval, variableDoneEval){
            var node = (this.allConstraints.DfDvRecycleStack.get_Count() > 0) ? this.allConstraints.DfDvRecycleStack.Pop().Set(parent, constraintToEval, variableToEval, variableDoneEval) : new Microsoft.Msagl.Core.ProjectionSolver.DfDvNode.ctor$$DfDvNode$$Constraint$$Variable$$Variable(parent, constraintToEval, variableToEval, variableDoneEval);
            node.set_Depth(node.get_Parent().get_Depth() + 1);
            if (this.allConstraints.MaxConstraintTreeDepth < node.get_Depth()){
                this.allConstraints.MaxConstraintTreeDepth = node.get_Depth();
            }
            return node;
        },
        PushDfDvNode: function (node){
            this.Debug_CycleCheck(node.get_ConstraintToEval());
            this.PushOnDfDvStack(node);
        },
        Debug_CycleCheck: function (constraint){
            System.Diagnostics.Debug.Assert$$Boolean$$String(this.idDfDv != constraint.get_IdDfDv(), "Cycle detected someplace other than null minLagrangian");
        },
        Debug_MarkForCycleCheck: function (constraint){
            constraint.set_IdDfDv(this.idDfDv);
        },
        AddVariableAndPushDfDvNode: function (lstVars, node){
            this.Debug_CycleCheck(node.get_ConstraintToEval());
            lstVars.Add(node.get_VariableToEval());
            this.PushOnDfDvStack(node);
        },
        PushOnDfDvStack: function (node){
            this.Debug_MarkForCycleCheck(node.get_ConstraintToEval());
            this.allConstraints.DfDvStack.Push(node);
        },
        CheckForConstraintPathTarget: function (node){
            if (this.pathTargetVariable == node.get_VariableToEval()){
                while (node.get_Parent() != this.dfDvDummyParentNode){
                    this.constraintPath.Add(new Microsoft.Msagl.Core.ProjectionSolver.Block.ConstraintDirectionPair.ctor$$Constraint$$Boolean(node.get_ConstraintToEval(), node.get_IsLeftToRight()));
                    node = node.get_Parent();
                }
                this.pathTargetVariable = null;
            }
        },
        Debug_ClearDfDv: function (forceFull){
            if (forceFull || (2147483647 == this.idDfDv)){
                this.idDfDv = 1;
                var numVariables = this.get_Variables().get_Count();
                for (var ii = 0; ii < numVariables; ++ii){
                    var variable = this.get_Variables().get_Item$$Int32(ii);
                    for (var $i942 = 0,$t942 = variable.get_LeftConstraints(),$l942 = $t942.length,constraint = $t942[$i942]; $i942 < $l942; $i942++, constraint = $t942[$i942]){
                        constraint.ClearDfDv();
                    }
                }
            }
            else {
                ++this.idDfDv;
            }
        },
        Expand: function (violatedConstraint){
            this.Debug_ClearDfDv(false);
            if (null == this.constraintPath){
                this.constraintPath = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.ProjectionSolver.Block.ConstraintDirectionPair.ctor);
            }
            this.constraintPath.Clear();
            this.pathTargetVariable = violatedConstraint.get_Right();
            this.ComputeDfDv(violatedConstraint.get_Left());
            var minLagrangianConstraint = null;
            if (this.constraintPath.get_Count() > 0){
                var $it942 = this.constraintPath.GetEnumerator();
                while ($it942.MoveNext()){
                    var pathItem = $it942.get_Current();
                    if (pathItem.IsForward && ((null == minLagrangianConstraint) || (pathItem.Constraint.get_Lagrangian() < minLagrangianConstraint.get_Lagrangian()))){
                        if (!pathItem.Constraint.get_IsEquality()){
                            minLagrangianConstraint = pathItem.Constraint;
                        }
                    }
                }
                if (null != minLagrangianConstraint){
                    this.allConstraints.DeactivateConstraint(minLagrangianConstraint);
                }
            }
            this.constraintPath.Clear();
            this.pathTargetVariable = null;
            if (null == minLagrangianConstraint){
                System.Diagnostics.Debug.Assert$$Boolean$$String(!violatedConstraint.get_IsUnsatisfiable(), "An already-unsatisfiable constraint should not have been attempted");
                violatedConstraint.set_IsUnsatisfiable(true);
                ++this.allConstraints.NumberOfUnsatisfiableConstraints;
                return;
            }
            var lstConnectedVars = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.ProjectionSolver.Variable.ctor);
            this.GetConnectedVariables(lstConnectedVars, violatedConstraint.get_Right(), violatedConstraint.get_Left());
            var violation = violatedConstraint.get_Violation();
            var cConnectedVars = lstConnectedVars.get_Count();
            for (var ii = 0; ii < cConnectedVars; ++ii){
                lstConnectedVars.get_Item$$Int32(ii).set_OffsetInBlock(lstConnectedVars.get_Item$$Int32(ii).get_OffsetInBlock() + violation);
            }
            this.allConstraints.ActivateConstraint(violatedConstraint);
            violatedConstraint.ClearDfDv();
            this.UpdateReferencePos();
        },
        Split: function (isQpsc){
            if (isQpsc){
                this.UpdateReferencePos();
            }
            if (this.get_Variables().get_Count() < 2){
                return null;
            }
            var minLagrangianConstraint = null;
            this.Debug_ClearDfDv(false);
            this.ComputeDfDv(this.get_Variables().get_Item$$Int32(0));
            var minLagrangian = this.allConstraints.SolverParameters.get_Advanced().get_MinSplitLagrangianThreshold();
            var numVars = this.get_Variables().get_Count();
            for (var ii = 0; ii < numVars; ++ii){
                for (var $i944 = 0,$t944 = this.get_Variables().get_Item$$Int32(ii).get_LeftConstraints(),$l944 = $t944.length,constraint = $t944[$i944]; $i944 < $l944; $i944++, constraint = $t944[$i944]){
                    if (constraint.get_IsActive() && !constraint.get_IsEquality() && (constraint.get_Lagrangian() < minLagrangian)){
                        System.Diagnostics.Debug.Assert$$Boolean$$String(constraint.get_IdDfDv() == this.idDfDv, "stale constraint.Lagrangian");
                        minLagrangianConstraint = constraint;
                        minLagrangian = constraint.get_Lagrangian();
                    }
                }
            }
            if (null == minLagrangianConstraint){
                return null;
            }
            return this.SplitOnConstraint(minLagrangianConstraint);
        },
        SplitOnConstraint: function (constraintToSplit){
            this.allConstraints.DeactivateConstraint(constraintToSplit);
            var newSplitBlock = new Microsoft.Msagl.Core.ProjectionSolver.Block.ctor(null, this.allConstraints);
            this.DebugVerifyBlockConnectivity();
            this.TransferConnectedVariables(newSplitBlock, constraintToSplit.get_Right(), constraintToSplit.get_Left());
            if (newSplitBlock.get_Variables().get_Count() > 0){
                this.UpdateReferencePos();
                newSplitBlock.UpdateReferencePos();
                this.DebugVerifyBlockConnectivity();
                newSplitBlock.DebugVerifyBlockConnectivity();
            }
            else {
                newSplitBlock = null;
            }
            return newSplitBlock;
        },
        DebugVerifyBlockConnectivity: function (){
            var $it944 = this.get_Variables().GetEnumerator();
            while ($it944.MoveNext()){
                var v = $it944.get_Current();
                for (var $i946 = 0,$t946 = v.get_LeftConstraints(),$l946 = $t946.length,c = $t946[$i946]; $i946 < $l946; $i946++, c = $t946[$i946]){
                    System.Diagnostics.Debug.Assert$$Boolean$$String(!c.get_IsActive() || (c.get_Left().get_Block() == c.get_Right().get_Block()), "LeftConstraint outside of Block");
                }
                for (var $i947 = 0,$t947 = v.get_RightConstraints(),$l947 = $t947.length,c = $t947[$i947]; $i947 < $l947; $i947++, c = $t947[$i947]){
                    System.Diagnostics.Debug.Assert$$Boolean$$String(!c.get_IsActive() || (c.get_Left().get_Block() == c.get_Right().get_Block()), "RightConstraint outside of Block");
                }
            }
        },
        DebugVerifyReferencePos: function (){
        },
        AddVariable: function (variable){
            this.get_Variables().Add(variable);
            variable.set_Block(this);
            if (1 == this.get_Variables().get_Count()){
                this.set_Scale(variable.get_Scale());
                this.set_ReferencePos(variable.get_ActualPos());
                this.sumAd = variable.get_ActualPos() * variable.get_Weight();
                this.sumAb = 0;
                this.sumA2 = variable.get_Weight();
                variable.set_OffsetInBlock(0);
            }
            else {
                this.AddVariableToBlockSums(variable);
            }
        },
        UpdateReferencePos: function (){
            this.set_Scale(this.get_Variables().get_Item$$Int32(0).get_Scale());
            this.sumAd = 0;
            this.sumAb = 0;
            this.sumA2 = 0;
            var numVars = this.get_Variables().get_Count();
            for (var ii = 0; ii < numVars; ++ii){
                this.AddVariableToBlockSums(this.get_Variables().get_Item$$Int32(ii));
            }
            this.UpdateReferencePosFromSums();
        },
        AddVariableToBlockSums: function (variable){
            var a = this.get_Scale() / variable.get_Scale();
            var b = variable.get_OffsetInBlock() / variable.get_Scale();
            var aw = a * variable.get_Weight();
            this.sumAd += aw * variable.get_DesiredPos();
            this.sumAb += aw * b;
            this.sumA2 += aw * a;
        },
        UpdateReferencePosFromSums: function (){
            if (System.Double.IsInfinity(this.sumAd) || System.Double.IsInfinity(this.sumAb) || System.Double.IsInfinity(this.sumA2)){
                throw $CreateException(new System.OverflowException.ctor$$String("Block Reference Position component is infinite"), new Error());
            }
            this.set_ReferencePos((this.sumAd - this.sumAb) / this.sumA2);
            this.UpdateVariablePositions();
        },
        UpdateVariablePositions: function (){
            var scaledReferencePos = this.get_Scale() * this.get_ReferencePos();
            var numVars = this.get_Variables().get_Count();
            for (var ii = 0; ii < numVars; ++ii){
                var v = this.get_Variables().get_Item$$Int32(ii);
                v.set_ActualPos((scaledReferencePos + v.get_OffsetInBlock()) / v.get_Scale());
            }
        },
        GetConnectedVariables: function (lstVars, varToEval, varDoneEval){
            this.Debug_ClearDfDv(false);
            this.RecurseGetConnectedVariables(lstVars, varToEval, varDoneEval);
        },
        RecurseGetConnectedVariables: function (lstVars, initialVarToEval, initialVarDoneEval){
            System.Diagnostics.Debug.Assert$$Boolean$$String(0 == this.allConstraints.DfDvStack.get_Count(), "Leftovers in ComputeDfDvStack");
            this.allConstraints.DfDvStack.Clear();
            System.Diagnostics.Debug.Assert$$Boolean$$String(0 == lstVars.get_Count(), "Leftovers in lstVars");
            var dummyConstraint = new Microsoft.Msagl.Core.ProjectionSolver.Constraint.ctor$$Variable(initialVarToEval);
            this.dfDvDummyParentNode = new Microsoft.Msagl.Core.ProjectionSolver.DfDvNode.ctor$$Constraint(dummyConstraint);
            this.allConstraints.DfDvStack.Push(this.GetDfDvNode(this.dfDvDummyParentNode, dummyConstraint, initialVarToEval, initialVarDoneEval));
            lstVars.Add(initialVarToEval);
            while (this.allConstraints.DfDvStack.get_Count() > 0){
                var node = this.allConstraints.DfDvStack.Peek();
                var prevStackCount = this.allConstraints.DfDvStack.get_Count();
                if (!node.get_ChildrenHaveBeenPushed()){
                    node.set_ChildrenHaveBeenPushed(true);
                    for (var $i948 = 0,$t948 = node.get_VariableToEval().get_LeftConstraints(),$l948 = $t948.length,constraint = $t948[$i948]; $i948 < $l948; $i948++, constraint = $t948[$i948]){
                        if (constraint.get_IsActive() && (constraint.get_Right() != node.get_VariableDoneEval())){
                            if (1 == constraint.get_Right().get_ActiveConstraintCount()){
                                this.Debug_CycleCheck(constraint);
                                this.Debug_MarkForCycleCheck(constraint);
                                lstVars.Add(constraint.get_Right());
                            }
                            else {
                                this.AddVariableAndPushDfDvNode(lstVars, this.GetDfDvNode(node, constraint, constraint.get_Right(), node.get_VariableToEval()));
                            }
                        }
                    }
                    for (var $i949 = 0,$t949 = node.get_VariableToEval().get_RightConstraints(),$l949 = $t949.length,constraint = $t949[$i949]; $i949 < $l949; $i949++, constraint = $t949[$i949]){
                        if (constraint.get_IsActive() && (constraint.get_Left() != node.get_VariableDoneEval())){
                            if (1 == constraint.get_Left().get_ActiveConstraintCount()){
                                this.Debug_CycleCheck(constraint);
                                this.Debug_MarkForCycleCheck(constraint);
                                lstVars.Add(constraint.get_Left());
                            }
                            else {
                                this.AddVariableAndPushDfDvNode(lstVars, this.GetDfDvNode(node, constraint, constraint.get_Left(), node.get_VariableToEval()));
                            }
                        }
                    }
                }
                if (this.allConstraints.DfDvStack.get_Count() > prevStackCount){
                    continue;
                }
                System.Diagnostics.Debug.Assert$$Boolean$$String(this.allConstraints.DfDvStack.Peek() == node, "DfDvStack.Peek() should be \'node\'");
                this.allConstraints.RecycleDfDvNode(this.allConstraints.DfDvStack.Pop());
            }
        },
        TransferConnectedVariables: function (newSplitBlock, varToEval, varDoneEval){
            this.GetConnectedVariables(newSplitBlock.get_Variables(), varToEval, varDoneEval);
            var numVarsToMove = newSplitBlock.get_Variables().get_Count();
            newSplitBlock.Debug_ClearDfDv(true);
            for (var moveIndex = 0; moveIndex < numVarsToMove; ++moveIndex){
                newSplitBlock.get_Variables().get_Item$$Int32(moveIndex).set_Block(newSplitBlock);
            }
            var lastKeepIndex = this.get_Variables().get_Count() - 1;
            for (var currentIndex = this.get_Variables().get_Count() - 1; currentIndex >= 0; --currentIndex){
                var currentVariable = this.get_Variables().get_Item$$Int32(currentIndex);
                if (currentVariable.get_Block() == newSplitBlock){
                    if (currentIndex < lastKeepIndex){
                        this.get_Variables().set_Item$$Int32(currentIndex, this.get_Variables().get_Item$$Int32(lastKeepIndex));
                    }
                    --lastKeepIndex;
                }
            }
            System.Diagnostics.Debug.Assert$$Boolean$$String(numVarsToMove == this.get_Variables().get_Count() - lastKeepIndex - 1, "variable should not be found twice (probable cycle-detection problem");
            this.get_Variables().RemoveRange(lastKeepIndex + 1, this.get_Variables().get_Count() - lastKeepIndex - 1);
            if (0 == this.get_Variables().get_Count()){
                for (var moveIndex = 0; moveIndex < numVarsToMove; ++moveIndex){
                    var variableToMove = newSplitBlock.get_Variables().get_Item$$Int32(moveIndex);
                    this.get_Variables().Add(variableToMove);
                    variableToMove.set_Block(this);
                }
                newSplitBlock.get_Variables().Clear();
            }
        },
        Debug_PostMerge: function (blockFrom){
            if (blockFrom.idDfDv > this.idDfDv){
                this.idDfDv = blockFrom.idDfDv;
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$ProjectionSolver$Block);
var Microsoft$Msagl$Core$ProjectionSolver$Block$ConstraintDirectionPair = {
    fullname: "Microsoft.Msagl.Core.ProjectionSolver.Block.ConstraintDirectionPair",
    baseTypeName: "System.ValueType",
    assemblyName: "Microsoft.Msagl",
    Kind: "Struct",
    definition: {
        ctor$$Constraint$$Boolean: function (constraint, isLeftToRight){
            this.Constraint = null;
            this.IsForward = false;
            System.ValueType.ctor.call(this);
            this.Constraint = constraint;
            this.IsForward = isLeftToRight;
        },
        ctor: function (){
            this.Constraint = null;
            this.IsForward = false;
            System.ValueType.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$ProjectionSolver$Block$ConstraintDirectionPair);
var Microsoft$Msagl$Core$ProjectionSolver$BlockVector = {
    fullname: "Microsoft.Msagl.Core.ProjectionSolver.BlockVector",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this._Vector = null;
            System.Object.ctor.call(this);
            this.set_Vector(new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.ProjectionSolver.Block.ctor));
        },
        Vector$$: "System.Collections.Generic.List`1[[Microsoft.Msagl.Core.ProjectionSolver.Block]]",
        get_Vector: function (){
            return this._Vector;
        },
        set_Vector: function (value){
            this._Vector = value;
        },
        IsEmpty$$: "System.Boolean",
        get_IsEmpty: function (){
            return 0 == this.get_Vector().get_Count();
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this.get_Vector().get_Count();
        },
        Item$$: "Microsoft.Msagl.Core.ProjectionSolver.Block",
        get_Item$$Int32: function (index){
            return this.get_Vector().get_Item$$Int32(index);
        },
        Add: function (block){
            block.set_VectorIndex(this.get_Vector().get_Count());
            this.get_Vector().Add(block);
            System.Diagnostics.Debug.Assert$$Boolean$$String(this.get_Vector().get_Item$$Int32(block.get_VectorIndex()) == block, "Inconsistent block.VectorIndex");
        },
        Remove: function (block){
            System.Diagnostics.Debug.Assert$$Boolean$$String(this.get_Vector().get_Item$$Int32(block.get_VectorIndex()) == block, "Inconsistent block.VectorIndex");
            var swapBlock = this.get_Vector().get_Item$$Int32(this.get_Vector().get_Count() - 1);
            this.get_Vector().set_Item$$Int32(block.get_VectorIndex(), swapBlock);
            swapBlock.set_VectorIndex(block.get_VectorIndex());
            this.get_Vector().RemoveAt(this.get_Vector().get_Count() - 1);
            System.Diagnostics.Debug.Assert$$Boolean$$String((0 == this.get_Vector().get_Count()) || (block == swapBlock) || (this.get_Vector().get_Item$$Int32(swapBlock.get_VectorIndex()) == swapBlock), "Inconsistent swapBlock.VectorIndex");
            System.Diagnostics.Debug.Assert$$Boolean$$String((0 == this.get_Vector().get_Count()) || (this.get_Vector().get_Item$$Int32(this.get_Vector().get_Count() - 1).get_VectorIndex() == (this.get_Vector().get_Count() - 1)), "Inconsistent finalBlock.VectorIndex");
        },
        Debug_AssertConsistency: function (){
            for (var ii = 0; ii < this.get_Vector().get_Count(); ++ii){
                System.Diagnostics.Debug.Assert$$Boolean$$String(ii == this.get_Vector().get_Item$$Int32(ii).get_VectorIndex(), "Inconsistent Vector[ii].VectorIndex");
            }
        },
        toString: function (){
            return this.get_Vector().toString();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$ProjectionSolver$BlockVector);
var Microsoft$Msagl$Core$ProjectionSolver$Constraint = {
    fullname: "Microsoft.Msagl.Core.ProjectionSolver.Constraint",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.IComparable$1"],
    Kind: "Class",
    definition: {
        ctor$$Variable$$Variable$$Double$$Boolean: function (left, right, gap, isEquality){
            this._Left = null;
            this._Right = null;
            this._Gap = 0;
            this._IsEquality = false;
            this._Lagrangian = 0;
            this._IsActive = false;
            this._IdDfDv = 0;
            this._IsUnsatisfiable = false;
            this._VectorIndex = 0;
            System.Object.ctor.call(this);
            this.set_Left(left);
            this.set_Right(right);
            this.set_Gap(gap);
            this.set_IsEquality(isEquality);
            this.set_Lagrangian(0);
            this.set_IsActive(false);
        },
        Left$$: "Microsoft.Msagl.Core.ProjectionSolver.Variable",
        get_Left: function (){
            return this._Left;
        },
        set_Left: function (value){
            this._Left = value;
        },
        Right$$: "Microsoft.Msagl.Core.ProjectionSolver.Variable",
        get_Right: function (){
            return this._Right;
        },
        set_Right: function (value){
            this._Right = value;
        },
        Gap$$: "System.Double",
        get_Gap: function (){
            return this._Gap;
        },
        set_Gap: function (value){
            this._Gap = value;
        },
        IsEquality$$: "System.Boolean",
        get_IsEquality: function (){
            return this._IsEquality;
        },
        set_IsEquality: function (value){
            this._IsEquality = value;
        },
        Lagrangian$$: "System.Double",
        get_Lagrangian: function (){
            return this._Lagrangian;
        },
        set_Lagrangian: function (value){
            this._Lagrangian = value;
        },
        IsActive$$: "System.Boolean",
        get_IsActive: function (){
            return this._IsActive;
        },
        set_IsActive: function (value){
            this._IsActive = value;
        },
        IdDfDv$$: "System.Int32",
        get_IdDfDv: function (){
            return this._IdDfDv;
        },
        set_IdDfDv: function (value){
            this._IdDfDv = value;
        },
        IsUnsatisfiable$$: "System.Boolean",
        get_IsUnsatisfiable: function (){
            return this._IsUnsatisfiable;
        },
        set_IsUnsatisfiable: function (value){
            this._IsUnsatisfiable = value;
        },
        VectorIndex$$: "System.Int32",
        get_VectorIndex: function (){
            return this._VectorIndex;
        },
        set_VectorIndex: function (value){
            this._VectorIndex = value;
        },
        SetActiveState: function (activeState, newVectorIndex){
            System.Diagnostics.Debug.Assert$$Boolean$$String(this.get_IsActive() != activeState, "Constraint is already set to activationState");
            this.set_IsActive(activeState);
            this.set_VectorIndex(newVectorIndex);
            if (this.get_IsActive()){
                this.get_Left().set_ActiveConstraintCount(this.get_Left().get_ActiveConstraintCount() + 1);
                this.get_Right().set_ActiveConstraintCount(this.get_Right().get_ActiveConstraintCount() + 1);
            }
            else {
                this.get_Left().set_ActiveConstraintCount(this.get_Left().get_ActiveConstraintCount() - 1);
                this.get_Right().set_ActiveConstraintCount(this.get_Right().get_ActiveConstraintCount() - 1);
            }
        },
        SetVectorIndex: function (vectorIndex){
            this.set_VectorIndex(vectorIndex);
        },
        Reinitialize: function (){
            this.set_IsActive(false);
            this.set_IsUnsatisfiable(false);
            this.ClearDfDv();
        },
        UpdateGap: function (newGap){
            this.set_Gap(newGap);
        },
        ctor$$Variable: function (variable){
            this._Left = null;
            this._Right = null;
            this._Gap = 0;
            this._IsEquality = false;
            this._Lagrangian = 0;
            this._IsActive = false;
            this._IdDfDv = 0;
            this._IsUnsatisfiable = false;
            this._VectorIndex = 0;
            System.Object.ctor.call(this);
            this.set_Left((function ($p42){
                this.set_Right($p42);
                return $p42;
            }).call(this, variable));
        },
        IsDummy$$: "System.Boolean",
        get_IsDummy: function (){
            return this.get_Left() == this.get_Right();
        },
        toString: function (){
            return System.String.Format$$IFormatProvider$$String$$Object$Array(System.Globalization.CultureInfo.get_InvariantCulture(), "  Cst: [{0}] [{1}] {2} {3:F5} vio {4:F5} Lm {5:F5}/{6:F5} {7}actv", [this.get_Left(), this.get_Right(), this.get_IsEquality() ? "==" : ">=", this.get_Gap(), this.get_Violation(), this.get_Lagrangian(), this.get_Lagrangian() * 2, this.get_IsActive() ? "+" : (this.get_IsUnsatisfiable() ? "!" : "-")]);
        },
        Violation$$: "System.Double",
        get_Violation: function (){
            return (this.get_Left().get_ActualPos() * this.get_Left().get_Scale()) + this.get_Gap() - (this.get_Right().get_ActualPos() * this.get_Right().get_Scale());
        },
        ClearDfDv: function (){
            this.set_IdDfDv(0);
            this.set_Lagrangian(0);
        },
        CompareTo: function (other){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(other, "other");
            var cmp = this.get_Left().CompareTo(other.get_Left());
            if (0 == cmp){
                cmp = this.get_Right().CompareTo(other.get_Right());
            }
            if (0 == cmp){
                cmp = this.get_Gap().CompareTo$$Double(other.get_Gap());
            }
            return cmp;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$ProjectionSolver$Constraint);
var Microsoft$Msagl$Core$ProjectionSolver$ConstraintVector = {
    fullname: "Microsoft.Msagl.Core.ProjectionSolver.ConstraintVector",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.nextConstraintIndex = 0;
            this.firstActiveConstraintIndex = 0;
            this.SolverParameters = null;
            this.DfDvStack = new System.Collections.Generic.Stack$1.ctor(Microsoft.Msagl.Core.ProjectionSolver.DfDvNode.ctor);
            this.DfDvRecycleStack = new System.Collections.Generic.Stack$1.ctor(Microsoft.Msagl.Core.ProjectionSolver.DfDvNode.ctor);
            this.MaxConstraintTreeDepth = 0;
            this.NumberOfUnsatisfiableConstraints = 0;
            this._Vector = null;
            System.Object.ctor.call(this);
        },
        Vector$$: "Microsoft.Msagl.Core.ProjectionSolver.Constraint[]",
        get_Vector: function (){
            return this._Vector;
        },
        set_Vector: function (value){
            this._Vector = value;
        },
        IsEmpty$$: "System.Boolean",
        get_IsEmpty: function (){
            return null == this.get_Vector();
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this.get_IsEmpty() ? 0 : this.get_Vector().length;
        },
        Create: function (numConstraints){
            this.set_Vector(new Array(numConstraints));
            this.firstActiveConstraintIndex = numConstraints;
        },
        Add: function (constraint){
            System.Diagnostics.Debug.Assert$$Boolean$$String(!constraint.get_IsActive(), "Constraint should not be active");
            constraint.SetVectorIndex(this.nextConstraintIndex);
            this.get_Vector()[this.nextConstraintIndex++] = constraint;
        },
        ActivateConstraint: function (constraint){
            System.Diagnostics.Debug.Assert$$Boolean$$String(!constraint.get_IsActive(), "Constraint is already active");
            System.Diagnostics.Debug.Assert$$Boolean$$String(this.firstActiveConstraintIndex > 0, "All constraints are already active");
            --this.firstActiveConstraintIndex;
            System.Diagnostics.Debug.Assert$$Boolean$$String(!this.get_Vector()[this.firstActiveConstraintIndex].get_IsActive(), "Constraint in inactive region is active");
            this.SwapConstraint(constraint);
        },
        DeactivateConstraint: function (constraint){
            System.Diagnostics.Debug.Assert$$Boolean$$String(constraint.get_IsActive(), "Constraint is not active");
            System.Diagnostics.Debug.Assert$$Boolean$$String(this.firstActiveConstraintIndex < this.get_Vector().length, "All constraints are already inactive");
            System.Diagnostics.Debug.Assert$$Boolean$$String(this.get_Vector()[this.firstActiveConstraintIndex].get_IsActive(), "Constraint in active region is not active");
            this.SwapConstraint(constraint);
            ++this.firstActiveConstraintIndex;
        },
        SwapConstraint: function (constraint){
            var swapConstraint = this.get_Vector()[this.firstActiveConstraintIndex];
            swapConstraint.SetVectorIndex(constraint.get_VectorIndex());
            this.get_Vector()[constraint.get_VectorIndex()] = swapConstraint;
            this.get_Vector()[this.firstActiveConstraintIndex] = constraint;
            constraint.SetActiveState(!constraint.get_IsActive(), this.firstActiveConstraintIndex);
        },
        Reinitialize: function (){
            if (null == this.get_Vector()){
                return;
            }
            for (var $i950 = 0,$t950 = this.get_Vector(),$l950 = $t950.length,constraint = $t950[$i950]; $i950 < $l950; $i950++, constraint = $t950[$i950]){
                constraint.Reinitialize();
            }
            this.firstActiveConstraintIndex = this.get_Vector().length;
        },
        Debug_AssertIsFull: function (){
            System.Diagnostics.Debug.Assert$$Boolean$$String(this.get_Vector().length == this.nextConstraintIndex, "AllConstraints.Vector is not full");
            this.Debug_AssertConsistency();
        },
        Debug_AssertConsistency: function (){
            for (var ii = 0; ii < this.get_Vector().length; ++ii){
                var constraint = this.get_Vector()[ii];
                System.Diagnostics.Debug.Assert$$Boolean$$String(constraint.get_VectorIndex() == ii, "Inconsistent constraint.VectorIndex");
                if (constraint.get_IsActive()){
                    System.Diagnostics.Debug.Assert$$Boolean$$String(constraint.get_VectorIndex() >= this.firstActiveConstraintIndex, "Active constraint is in Inactive region");
                }
                else {
                    System.Diagnostics.Debug.Assert$$Boolean$$String(constraint.get_VectorIndex() < this.firstActiveConstraintIndex, "Inactive constraint is in Active region");
                }
            }
        },
        RecycleDfDvNode: function (node){
            if (this.DfDvRecycleStack.get_Count() < 1024){
                this.DfDvRecycleStack.Push(node);
            }
        },
        toString: function (){
            return this.get_Vector().toString();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$ProjectionSolver$ConstraintVector);
var Microsoft$Msagl$Core$ProjectionSolver$DfDvNode = {
    fullname: "Microsoft.Msagl.Core.ProjectionSolver.DfDvNode",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$DfDvNode$$Constraint$$Variable$$Variable: function (parent, constraintToEval, variableToEval, variableDoneEval){
            this._Parent = null;
            this._ConstraintToEval = null;
            this._VariableToEval = null;
            this._VariableDoneEval = null;
            this._Depth = 0;
            this._ChildrenHaveBeenPushed = false;
            System.Object.ctor.call(this);
            this.Set(parent, constraintToEval, variableToEval, variableDoneEval);
        },
        Parent$$: "Microsoft.Msagl.Core.ProjectionSolver.DfDvNode",
        get_Parent: function (){
            return this._Parent;
        },
        set_Parent: function (value){
            this._Parent = value;
        },
        ConstraintToEval$$: "Microsoft.Msagl.Core.ProjectionSolver.Constraint",
        get_ConstraintToEval: function (){
            return this._ConstraintToEval;
        },
        set_ConstraintToEval: function (value){
            this._ConstraintToEval = value;
        },
        VariableToEval$$: "Microsoft.Msagl.Core.ProjectionSolver.Variable",
        get_VariableToEval: function (){
            return this._VariableToEval;
        },
        set_VariableToEval: function (value){
            this._VariableToEval = value;
        },
        VariableDoneEval$$: "Microsoft.Msagl.Core.ProjectionSolver.Variable",
        get_VariableDoneEval: function (){
            return this._VariableDoneEval;
        },
        set_VariableDoneEval: function (value){
            this._VariableDoneEval = value;
        },
        Depth$$: "System.Int32",
        get_Depth: function (){
            return this._Depth;
        },
        set_Depth: function (value){
            this._Depth = value;
        },
        ChildrenHaveBeenPushed$$: "System.Boolean",
        get_ChildrenHaveBeenPushed: function (){
            return this._ChildrenHaveBeenPushed;
        },
        set_ChildrenHaveBeenPushed: function (value){
            this._ChildrenHaveBeenPushed = value;
        },
        ctor$$Constraint: function (dummyConstraint){
            this._Parent = null;
            this._ConstraintToEval = null;
            this._VariableToEval = null;
            this._VariableDoneEval = null;
            this._Depth = 0;
            this._ChildrenHaveBeenPushed = false;
            System.Object.ctor.call(this);
            this.set_ConstraintToEval(dummyConstraint);
            this.set_Depth(-1);
        },
        Set: function (parent, constraintToEval, variableToEval, variableDoneEval){
            this.set_Parent(parent);
            this.set_ConstraintToEval(constraintToEval);
            this.set_VariableToEval(variableToEval);
            this.set_VariableDoneEval(variableDoneEval);
            this.set_Depth(0);
            this.set_ChildrenHaveBeenPushed(false);
            constraintToEval.set_Lagrangian(0);
            return this;
        },
        IsLeftToRight$$: "System.Boolean",
        get_IsLeftToRight: function (){
            return this.get_VariableToEval() == this.get_ConstraintToEval().get_Right();
        },
        toString: function (){
            return System.String.Format$$IFormatProvider$$String$$Object$Array(System.Globalization.CultureInfo.get_InvariantCulture(), "{0} {1}{2} - {3}{4} ({5})", ["", this.get_IsLeftToRight() ? "" : "*", this.get_ConstraintToEval().get_Left().get_Name(), this.get_IsLeftToRight() ? "*" : "", this.get_ConstraintToEval().get_Right().get_Name(), this.get_Depth()]);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$ProjectionSolver$DfDvNode);
var Microsoft$Msagl$Core$ProjectionSolver$GlobalConfiguration = {
    fullname: "Microsoft.Msagl.Core.ProjectionSolver.GlobalConfiguration",
    baseTypeName: "System.ValueType",
    assemblyName: "Microsoft.Msagl",
    Kind: "Struct",
    definition: {
        ctor: function (){
            System.ValueType.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$ProjectionSolver$GlobalConfiguration);
var Microsoft$Msagl$Core$ProjectionSolver$Parameters = {
    fullname: "Microsoft.Msagl.Core.ProjectionSolver.Parameters",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.ICloneable"],
    Kind: "Class",
    definition: {
        ctor: function (){
            this._GapTolerance = 0;
            this._QpscConvergenceEpsilon = 0;
            this._QpscConvergenceQuotient = 0;
            this._OuterProjectIterationsLimit = 0;
            this._InnerProjectIterationsLimit = 0;
            this._TimeLimit = 0;
            this._Advanced = null;
            System.Object.ctor.call(this);
            this.set_GapTolerance(0.0001);
            this.set_QpscConvergenceEpsilon(1E-05);
            this.set_QpscConvergenceQuotient(1E-06);
            this.set_OuterProjectIterationsLimit(-1);
            this.set_InnerProjectIterationsLimit(-1);
            this.set_TimeLimit(-1);
            this.set_Advanced(new Microsoft.Msagl.Core.ProjectionSolver.AdvancedParameters.ctor());
        },
        GapTolerance$$: "System.Double",
        get_GapTolerance: function (){
            return this._GapTolerance;
        },
        set_GapTolerance: function (value){
            this._GapTolerance = value;
        },
        QpscConvergenceEpsilon$$: "System.Double",
        get_QpscConvergenceEpsilon: function (){
            return this._QpscConvergenceEpsilon;
        },
        set_QpscConvergenceEpsilon: function (value){
            this._QpscConvergenceEpsilon = value;
        },
        QpscConvergenceQuotient$$: "System.Double",
        get_QpscConvergenceQuotient: function (){
            return this._QpscConvergenceQuotient;
        },
        set_QpscConvergenceQuotient: function (value){
            this._QpscConvergenceQuotient = value;
        },
        OuterProjectIterationsLimit$$: "System.Int32",
        get_OuterProjectIterationsLimit: function (){
            return this._OuterProjectIterationsLimit;
        },
        set_OuterProjectIterationsLimit: function (value){
            this._OuterProjectIterationsLimit = value;
        },
        InnerProjectIterationsLimit$$: "System.Int32",
        get_InnerProjectIterationsLimit: function (){
            return this._InnerProjectIterationsLimit;
        },
        set_InnerProjectIterationsLimit: function (value){
            this._InnerProjectIterationsLimit = value;
        },
        TimeLimit$$: "System.Int32",
        get_TimeLimit: function (){
            return this._TimeLimit;
        },
        set_TimeLimit: function (value){
            this._TimeLimit = value;
        },
        Advanced$$: "Microsoft.Msagl.Core.ProjectionSolver.AdvancedParameters",
        get_Advanced: function (){
            return this._Advanced;
        },
        set_Advanced: function (value){
            this._Advanced = value;
        },
        Clone: function (){
            var newParams = Cast(this.MemberwiseClone(), Microsoft.Msagl.Core.ProjectionSolver.Parameters.ctor);
            newParams.set_Advanced(Cast(this.get_Advanced().Clone(), Microsoft.Msagl.Core.ProjectionSolver.AdvancedParameters.ctor));
            return newParams;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$ProjectionSolver$Parameters);
var Microsoft$Msagl$Core$ProjectionSolver$AdvancedParameters = {
    fullname: "Microsoft.Msagl.Core.ProjectionSolver.AdvancedParameters",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.ICloneable"],
    Kind: "Class",
    definition: {
        ctor: function (){
            this._ForceQpsc = false;
            this._ScaleInQpsc = false;
            this._MinSplitLagrangianThreshold = 0;
            this._UseViolationCache = false;
            this._ViolationCacheMinBlocksDivisor = 0;
            this._ViolationCacheMinBlocksCount = 0;
            System.Object.ctor.call(this);
            this.set_ForceQpsc(false);
            this.set_ScaleInQpsc(true);
            this.set_MinSplitLagrangianThreshold(-1E-07);
            this.set_UseViolationCache(true);
            this.set_ViolationCacheMinBlocksDivisor(10);
            this.set_ViolationCacheMinBlocksCount(100);
        },
        ForceQpsc$$: "System.Boolean",
        get_ForceQpsc: function (){
            return this._ForceQpsc;
        },
        set_ForceQpsc: function (value){
            this._ForceQpsc = value;
        },
        ScaleInQpsc$$: "System.Boolean",
        get_ScaleInQpsc: function (){
            return this._ScaleInQpsc;
        },
        set_ScaleInQpsc: function (value){
            this._ScaleInQpsc = value;
        },
        MinSplitLagrangianThreshold$$: "System.Double",
        get_MinSplitLagrangianThreshold: function (){
            return this._MinSplitLagrangianThreshold;
        },
        set_MinSplitLagrangianThreshold: function (value){
            this._MinSplitLagrangianThreshold = value;
        },
        UseViolationCache$$: "System.Boolean",
        get_UseViolationCache: function (){
            return this._UseViolationCache;
        },
        set_UseViolationCache: function (value){
            this._UseViolationCache = value;
        },
        ViolationCacheMinBlocksDivisor$$: "System.Int32",
        get_ViolationCacheMinBlocksDivisor: function (){
            return this._ViolationCacheMinBlocksDivisor;
        },
        set_ViolationCacheMinBlocksDivisor: function (value){
            this._ViolationCacheMinBlocksDivisor = value;
        },
        ViolationCacheMinBlocksCount$$: "System.Int32",
        get_ViolationCacheMinBlocksCount: function (){
            return this._ViolationCacheMinBlocksCount;
        },
        set_ViolationCacheMinBlocksCount: function (value){
            this._ViolationCacheMinBlocksCount = value;
        },
        Clone: function (){
            return this.MemberwiseClone();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$ProjectionSolver$AdvancedParameters);
var Microsoft$Msagl$Core$ProjectionSolver$Qpsc = {
    fullname: "Microsoft.Msagl.Core.ProjectionSolver.Qpsc",
    baseTypeName: "System.Object",
    staticDefinition: {
        VectorVectorMultiply: function (lhs, rhs){
            var sum = 0;
            for (var ii = 0; ii < lhs.length; ++ii){
                sum += lhs[ii] * rhs[ii];
            }
            return sum;
        },
        VectorVectorAdd: function (lhs, rhs, result){
            for (var ii = 0; ii < lhs.length; ++ii){
                result[ii] = lhs[ii] + rhs[ii];
            }
        },
        VectorVectorSubtract: function (lhs, rhs, result){
            for (var ii = 0; ii < lhs.length; ++ii){
                result[ii] = lhs[ii] - rhs[ii];
            }
        },
        VectorScaledVectorSubtract: function (lhs, scale, rhs, result){
            for (var ii = 0; ii < lhs.length; ++ii){
                result[ii] = lhs[ii] - (scale * rhs[ii]);
            }
        },
        VectorCopy: function (dest, src){
            for (var ii = 0; ii < src.length; ++ii){
                dest[ii] = src[ii];
            }
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (solverParameters, cVariables){
            this.solverParameters = null;
            this.matrixQ = null;
            this.vectorWiDi = null;
            this.vectorQpscVars = null;
            this.newMatrixRow = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.ProjectionSolver.Qpsc.MatrixCell.ctor);
            this.gradientVector = null;
            this.vectorQg = null;
            this.vectorPrevY = null;
            this.vectorCurY = null;
            this.isFirstProjectCall = false;
            this.previousFunctionValue = 1.79769313486232E+308;
            System.Object.ctor.call(this);
            this.solverParameters = solverParameters;
            this.matrixQ = new Array(cVariables);
            this.vectorWiDi = new Float64Array(cVariables);
            this.vectorQpscVars = new Array(cVariables);
            this.gradientVector = new Float64Array(cVariables);
            this.vectorQg = new Float64Array(cVariables);
            this.vectorPrevY = new Float64Array(cVariables);
            this.vectorCurY = new Float64Array(cVariables);
        },
        AddVariable: function (variable){
            System.Diagnostics.Debug.Assert$$Boolean$$String((null == this.matrixQ[variable.get_Ordinal()]) && (null == this.vectorQpscVars[variable.get_Ordinal()].Variable), "variable.Ordinal already exists");
            this.isFirstProjectCall = true;
            this.vectorWiDi[variable.get_Ordinal()] = -2 * variable.get_Weight() * variable.get_DesiredPos();
            this.vectorPrevY[variable.get_Ordinal()] = variable.get_Weight();
            if (null != variable.get_Neighbors()){
                var $it950 = variable.get_Neighbors().GetEnumerator();
                while ($it950.MoveNext()){
                    var neighborWeightPair = $it950.get_Current();
                    System.Diagnostics.Debug.Assert$$Boolean$$String(neighborWeightPair.get_Neighbor().get_Ordinal() != variable.get_Ordinal(), "self-neighbors are not allowed");
                    this.vectorPrevY[variable.get_Ordinal()] += neighborWeightPair.get_Weight();
                    this.vectorPrevY[neighborWeightPair.get_Neighbor().get_Ordinal()] -= neighborWeightPair.get_Weight();
                }
            }
            for (var ii = 0; ii < this.vectorPrevY.length; ++ii){
                if (0 != this.vectorPrevY[ii]){
                    System.Diagnostics.Debug.Assert$$Boolean$$String((ii == variable.get_Ordinal()) == (this.vectorPrevY[ii] > 0), "Diagonal must be > 0.0");
                    this.newMatrixRow.Add(new Microsoft.Msagl.Core.ProjectionSolver.Qpsc.MatrixCell.ctor$$Double$$UInt32(this.vectorPrevY[ii] * 2, ii));
                    this.vectorPrevY[ii] = 0;
                }
            }
            this.matrixQ[variable.get_Ordinal()] = this.newMatrixRow.ToArray();
            this.newMatrixRow.Clear();
            this.vectorQpscVars[variable.get_Ordinal()] = new Microsoft.Msagl.Core.ProjectionSolver.Qpsc.QpscVar.ctor$$Variable(variable);
            variable.set_Weight(1);
        },
        VariablesComplete: function (){
            for (var $i952 = 0,$t952 = this.vectorQpscVars,$l952 = $t952.length,qvar = $t952[$i952]; $i952 < $l952; $i952++, qvar = $t952[$i952]){
                var variable = qvar.Variable;
                for (var $i953 = 0,$t953 = this.matrixQ[variable.get_Ordinal()],$l953 = $t953.length,cell = $t953[$i953]; $i953 < $l953; $i953++, cell = $t953[$i953]){
                    if (cell.Column == variable.get_Ordinal()){
                        if (this.solverParameters.get_Advanced().get_ScaleInQpsc()){
                            variable.set_Scale(1 / System.Math.Sqrt(System.Math.Abs$$Double(cell.Value)));
                            if (System.Double.IsInfinity(variable.get_Scale())){
                                variable.set_Scale(1);
                            }
                            variable.set_ActualPos(variable.get_ActualPos() / variable.get_Scale());
                            this.vectorWiDi[variable.get_Ordinal()] *= variable.get_Scale();
                        }
                        this.vectorCurY[variable.get_Ordinal()] = variable.get_ActualPos();
                        variable.set_DesiredPos(variable.get_ActualPos());
                    }
                }
            }
            if (!this.solverParameters.get_Advanced().get_ScaleInQpsc()){
                return;
            }
            for (var rowNum = 0; rowNum < this.matrixQ.length; ++rowNum){
                var row = this.matrixQ[rowNum];
                for (var sparseCol = 0; sparseCol < row.length; ++sparseCol){
                    if (row[sparseCol].Column == rowNum){
                        row[sparseCol].Value = 1;
                    }
                    else {
                        row[sparseCol].Value *= this.vectorQpscVars[rowNum].Variable.get_Scale() * this.vectorQpscVars[row[sparseCol].Column].Variable.get_Scale();
                    }
                }
            }
        },
        PreProject: function (){
            if (this.isFirstProjectCall){
                for (var $i954 = 0,$t954 = this.vectorQpscVars,$l954 = $t954.length,qvar = $t954[$i954]; $i954 < $l954; $i954++, qvar = $t954[$i954]){
                    this.vectorCurY[qvar.Variable.get_Ordinal()] = qvar.Variable.get_ActualPos();
                }
            }
            this.MatrixVectorMultiply(this.vectorCurY, this.gradientVector);
            if (this.HasConverged()){
                return false;
            }
            Microsoft.Msagl.Core.ProjectionSolver.Qpsc.VectorVectorAdd(this.gradientVector, this.vectorWiDi, this.gradientVector);
            var alphaNumerator = Microsoft.Msagl.Core.ProjectionSolver.Qpsc.VectorVectorMultiply(this.gradientVector, this.gradientVector);
            var alphaDenominator = 0;
            if (0 != alphaNumerator){
                this.MatrixVectorMultiply(this.gradientVector, this.vectorQg);
                alphaDenominator = Microsoft.Msagl.Core.ProjectionSolver.Qpsc.VectorVectorMultiply(this.vectorQg, this.gradientVector);
            }
            if (0 == alphaDenominator){
                return false;
            }
            var alpha = alphaNumerator / alphaDenominator;
            Microsoft.Msagl.Core.ProjectionSolver.Qpsc.VectorCopy(this.vectorPrevY, this.vectorCurY);
            Microsoft.Msagl.Core.ProjectionSolver.Qpsc.VectorScaledVectorSubtract(this.vectorPrevY, alpha, this.gradientVector, this.vectorCurY);
            for (var ii = 0; ii < this.vectorCurY.length; ++ii){
                this.vectorQpscVars[ii].Variable.set_DesiredPos(this.vectorCurY[ii]);
            }
            return true;
        },
        PostProject: function (){
            for (var $i955 = 0,$t955 = this.vectorQpscVars,$l955 = $t955.length,qvar = $t955[$i955]; $i955 < $l955; $i955++, qvar = $t955[$i955]){
                this.vectorCurY[qvar.Variable.get_Ordinal()] = qvar.Variable.get_ActualPos();
            }
            Microsoft.Msagl.Core.ProjectionSolver.Qpsc.VectorVectorSubtract(this.vectorPrevY, this.vectorCurY, this.vectorCurY);
            var betaNumerator = Microsoft.Msagl.Core.ProjectionSolver.Qpsc.VectorVectorMultiply(this.gradientVector, this.vectorCurY);
            var beta = 0;
            if (0 != betaNumerator){
                this.MatrixVectorMultiply(this.vectorCurY, this.vectorQg);
                var betaDenominator = Microsoft.Msagl.Core.ProjectionSolver.Qpsc.VectorVectorMultiply(this.vectorQg, this.vectorCurY);
                beta = (0 == betaDenominator) ? 1 : (betaNumerator / betaDenominator);
                if (beta > 1){
                    beta = 1;
                }
                else if (beta < 0){
                    beta = 0;
                }
            }
            Microsoft.Msagl.Core.ProjectionSolver.Qpsc.VectorScaledVectorSubtract(this.vectorPrevY, beta, this.vectorCurY, this.vectorCurY);
            this.isFirstProjectCall = false;
            return beta > 0;
        },
        QpscComplete: function (){
            for (var $i956 = 0,$t956 = this.vectorQpscVars,$l956 = $t956.length,qvar = $t956[$i956]; $i956 < $l956; $i956++, qvar = $t956[$i956]){
                qvar.Variable.set_Weight(qvar.OrigWeight);
                qvar.Variable.set_DesiredPos(qvar.OrigDesiredPos);
                if (this.solverParameters.get_Advanced().get_ScaleInQpsc()){
                    qvar.Variable.set_ActualPos(qvar.Variable.get_ActualPos() * qvar.Variable.get_Scale());
                    qvar.Variable.set_Scale(qvar.OrigScale);
                }
            }
            return this.previousFunctionValue;
        },
        HasConverged: function (){
            var currentFunctionValue = this.GetFunctionValue(this.vectorCurY);
            var fConverged = false;
            if (!this.isFirstProjectCall){
                var diff = (this.previousFunctionValue - currentFunctionValue);
                var quotient = 0;
                if (diff != 0){
                    var divisor = (0 != this.previousFunctionValue) ? this.previousFunctionValue : currentFunctionValue;
                    quotient = System.Math.Abs$$Double(diff / divisor);
                }
                if ((System.Math.Abs$$Double(diff) < this.solverParameters.get_QpscConvergenceEpsilon()) || (System.Math.Abs$$Double(quotient) < this.solverParameters.get_QpscConvergenceQuotient())){
                    fConverged = true;
                }
            }
            this.previousFunctionValue = currentFunctionValue;
            return fConverged;
        },
        GetFunctionValue: function (positions){
            var value = Microsoft.Msagl.Core.ProjectionSolver.Qpsc.VectorVectorMultiply(this.gradientVector, positions) / 2;
            return value + Microsoft.Msagl.Core.ProjectionSolver.Qpsc.VectorVectorMultiply(this.vectorWiDi, positions);
        },
        MatrixVectorMultiply: function (rhs, result){
            var rowIndex = 0;
            for (var $i957 = 0,$t957 = this.matrixQ,$l957 = $t957.length,row = $t957[$i957]; $i957 < $l957; $i957++, row = $t957[$i957]){
                var sum = 0;
                for (var $i958 = 0,$l958 = row.length,cell = row[$i958]; $i958 < $l958; $i958++, cell = row[$i958]){
                    sum += cell.Value * rhs[cell.Column];
                }
                result[rowIndex++] = sum;
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$ProjectionSolver$Qpsc);
var Microsoft$Msagl$Core$ProjectionSolver$Qpsc$MatrixCell = {
    fullname: "Microsoft.Msagl.Core.ProjectionSolver.Qpsc.MatrixCell",
    baseTypeName: "System.ValueType",
    assemblyName: "Microsoft.Msagl",
    Kind: "Struct",
    definition: {
        ctor$$Double$$UInt32: function (w, index){
            this.Value = 0;
            this.Column = 0;
            System.ValueType.ctor.call(this);
            this.Value = w;
            this.Column = index;
        },
        ctor: function (){
            this.Value = 0;
            this.Column = 0;
            System.ValueType.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$ProjectionSolver$Qpsc$MatrixCell);
var Microsoft$Msagl$Core$ProjectionSolver$Qpsc$QpscVar = {
    fullname: "Microsoft.Msagl.Core.ProjectionSolver.Qpsc.QpscVar",
    baseTypeName: "System.ValueType",
    assemblyName: "Microsoft.Msagl",
    Kind: "Struct",
    definition: {
        ctor$$Variable: function (v){
            this.Variable = null;
            this.OrigWeight = 0;
            this.OrigScale = 0;
            this.OrigDesiredPos = 0;
            System.ValueType.ctor.call(this);
            this.Variable = v;
            this.OrigWeight = v.get_Weight();
            this.OrigScale = v.get_Scale();
            this.OrigDesiredPos = this.Variable.get_DesiredPos();
        },
        ctor: function (){
            this.Variable = null;
            this.OrigWeight = 0;
            this.OrigScale = 0;
            this.OrigDesiredPos = 0;
            System.ValueType.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$ProjectionSolver$Qpsc$QpscVar);
var Microsoft$Msagl$Core$ProjectionSolver$Solution = {
    fullname: "Microsoft.Msagl.Core.ProjectionSolver.Solution",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.ICloneable"],
    Kind: "Class",
    definition: {
        ctor: function (){
            this._NumberOfUnsatisfiableConstraints = 0;
            this._OuterProjectIterations = 0;
            this._InnerProjectIterationsTotal = 0;
            this._MinInnerProjectIterations = 0;
            this._MaxInnerProjectIterations = 0;
            this._MaxConstraintTreeDepth = 0;
            this._GoalFunctionValue = 0;
            this._AlgorithmUsed = Microsoft.Msagl.Core.ProjectionSolver.SolverAlgorithm.ProjectOnly;
            this._TimeLimitExceeded = false;
            this._OuterProjectIterationsLimitExceeded = false;
            this._InnerProjectIterationsLimitExceeded = false;
            System.Object.ctor.call(this);
        },
        NumberOfUnsatisfiableConstraints$$: "System.Int32",
        get_NumberOfUnsatisfiableConstraints: function (){
            return this._NumberOfUnsatisfiableConstraints;
        },
        set_NumberOfUnsatisfiableConstraints: function (value){
            this._NumberOfUnsatisfiableConstraints = value;
        },
        OuterProjectIterations$$: "System.Int32",
        get_OuterProjectIterations: function (){
            return this._OuterProjectIterations;
        },
        set_OuterProjectIterations: function (value){
            this._OuterProjectIterations = value;
        },
        InnerProjectIterationsTotal$$: "System.Int64",
        get_InnerProjectIterationsTotal: function (){
            return this._InnerProjectIterationsTotal;
        },
        set_InnerProjectIterationsTotal: function (value){
            this._InnerProjectIterationsTotal = value;
        },
        MinInnerProjectIterations$$: "System.Int32",
        get_MinInnerProjectIterations: function (){
            return this._MinInnerProjectIterations;
        },
        set_MinInnerProjectIterations: function (value){
            this._MinInnerProjectIterations = value;
        },
        MaxInnerProjectIterations$$: "System.Int32",
        get_MaxInnerProjectIterations: function (){
            return this._MaxInnerProjectIterations;
        },
        set_MaxInnerProjectIterations: function (value){
            this._MaxInnerProjectIterations = value;
        },
        MaxConstraintTreeDepth$$: "System.Int32",
        get_MaxConstraintTreeDepth: function (){
            return this._MaxConstraintTreeDepth;
        },
        set_MaxConstraintTreeDepth: function (value){
            this._MaxConstraintTreeDepth = value;
        },
        GoalFunctionValue$$: "System.Double",
        get_GoalFunctionValue: function (){
            return this._GoalFunctionValue;
        },
        set_GoalFunctionValue: function (value){
            this._GoalFunctionValue = value;
        },
        AlgorithmUsed$$: "Microsoft.Msagl.Core.ProjectionSolver.SolverAlgorithm",
        get_AlgorithmUsed: function (){
            return this._AlgorithmUsed;
        },
        set_AlgorithmUsed: function (value){
            this._AlgorithmUsed = value;
        },
        TimeLimitExceeded$$: "System.Boolean",
        get_TimeLimitExceeded: function (){
            return this._TimeLimitExceeded;
        },
        set_TimeLimitExceeded: function (value){
            this._TimeLimitExceeded = value;
        },
        OuterProjectIterationsLimitExceeded$$: "System.Boolean",
        get_OuterProjectIterationsLimitExceeded: function (){
            return this._OuterProjectIterationsLimitExceeded;
        },
        set_OuterProjectIterationsLimitExceeded: function (value){
            this._OuterProjectIterationsLimitExceeded = value;
        },
        InnerProjectIterationsLimitExceeded$$: "System.Boolean",
        get_InnerProjectIterationsLimitExceeded: function (){
            return this._InnerProjectIterationsLimitExceeded;
        },
        set_InnerProjectIterationsLimitExceeded: function (value){
            this._InnerProjectIterationsLimitExceeded = value;
        },
        ExecutionLimitExceeded$$: "System.Boolean",
        get_ExecutionLimitExceeded: function (){
            return this.get_TimeLimitExceeded() || this.get_OuterProjectIterationsLimitExceeded() || this.get_InnerProjectIterationsLimitExceeded();
        },
        Clone: function (){
            return this.MemberwiseClone();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$ProjectionSolver$Solution);
var Microsoft$Msagl$Core$ProjectionSolver$Solver = {
    fullname: "Microsoft.Msagl.Core.ProjectionSolver.Solver",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.allBlocks = new Microsoft.Msagl.Core.ProjectionSolver.BlockVector.ctor();
            this.allConstraints = new Microsoft.Msagl.Core.ProjectionSolver.ConstraintVector.ctor();
            this.numberOfConstraints = 0;
            this.numberOfVariables = 0;
            this.equalityConstraints = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.ProjectionSolver.Constraint.ctor);
            this.loadedVariablesAndConstraintLists = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.ProjectionSolver.Variable.ctor, Microsoft.Msagl.Core.ProjectionSolver.Solver.ConstraintListForVariable.ctor);
            this.emptyConstraintList = new Array(0);
            this.updatedConstraints = new System.Collections.Generic.List$1.ctor(System.Collections.Generic.KeyValuePair$2.ctor);
            this.violationCache = new Microsoft.Msagl.Core.ProjectionSolver.ViolationCache.ctor();
            this.lastModifiedBlock = null;
            this.violationCacheMinBlockCutoff = 0;
            this.hasNeighbourPairs = false;
            this.nextVariableOrdinal = 0;
            this.solverParams = new Microsoft.Msagl.Core.ProjectionSolver.Parameters.ctor();
            this.solverSolution = new Microsoft.Msagl.Core.ProjectionSolver.Solution.ctor();
            this.timeoutStopwatch = null;
            System.Object.ctor.call(this);
        },
        IsQpsc$$: "System.Boolean",
        get_IsQpsc: function (){
            return this.hasNeighbourPairs || this.solverParams.get_Advanced().get_ForceQpsc();
        },
        AddVariable$$Object$$Double: function (userData, desiredPos){
            return this.AddVariable$$Object$$Double$$Double$$Double(userData, desiredPos, 1, 1);
        },
        AddVariable$$Object$$Double$$Double: function (userData, desiredPos, weight){
            return this.AddVariable$$Object$$Double$$Double$$Double(userData, desiredPos, weight, 1);
        },
        AddVariable$$Object$$Double$$Double$$Double: function (userData, desiredPos, weight, scale){
            if (!this.allConstraints.get_IsEmpty()){
                throw $CreateException(new System.InvalidOperationException.ctor$$String("Cannot add Variables or Constraints once Solve() has been called"), new Error());
            }
            var varNew = new Microsoft.Msagl.Core.ProjectionSolver.Variable.ctor(this.nextVariableOrdinal++, userData, desiredPos, weight, scale);
            var block = new Microsoft.Msagl.Core.ProjectionSolver.Block.ctor(varNew, this.allConstraints);
            varNew.set_Block(block);
            this.allBlocks.Add(block);
            ++this.numberOfVariables;
            this.loadedVariablesAndConstraintLists.set_Item$$TKey(varNew, new Microsoft.Msagl.Core.ProjectionSolver.Solver.ConstraintListForVariable.ctor$$List$1$Constraint$$Int32(new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.ProjectionSolver.Constraint.ctor), 0));
            return varNew;
        },
        UpdateVariables: function (){
            var $it958 = this.allBlocks.get_Vector().GetEnumerator();
            while ($it958.MoveNext()){
                var block = $it958.get_Current();
                block.UpdateReferencePos();
            }
        },
        Variables$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.ProjectionSolver.Variable]]",
        get_Variables: function (){
            return System.Linq.Enumerable.SelectMany$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.ProjectionSolver.Block.ctor, Microsoft.Msagl.Core.ProjectionSolver.Variable.ctor, this.allBlocks.get_Vector(), $CreateAnonymousDelegate(this, function (block){
                return block.get_Variables();
            }));
        },
        VariableCount$$: "System.Int32",
        get_VariableCount: function (){
            return this.numberOfVariables;
        },
        Constraints$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.ProjectionSolver.Constraint]]",
        get_Constraints: function (){
            var $yield = [];
            if (!this.allConstraints.get_IsEmpty()){
                for (var $i960 = 0,$t960 = this.allConstraints.get_Vector(),$l960 = $t960.length,constraint = $t960[$i960]; $i960 < $l960; $i960++, constraint = $t960[$i960]){
                    $yield.push(constraint);
                }
            }
            else {
                var $it960 = this.loadedVariablesAndConstraintLists.get_Keys().GetEnumerator();
                while ($it960.MoveNext()){
                    var variable = $it960.get_Current();
                    var constraintsForVar = this.loadedVariablesAndConstraintLists.get_Item$$TKey(variable);
                    if (null != constraintsForVar.Constraints){
                        var numConstraints = constraintsForVar.Constraints.get_Count();
                        for (var ii = 0; ii < numConstraints; ++ii){
                            var constraint = constraintsForVar.Constraints.get_Item$$Int32(ii);
                            if (variable == constraint.get_Left()){
                                $yield.push(constraint);
                            }
                        }
                    }
                }
            }
            return $yield;
        },
        ConstraintCount$$: "System.Int32",
        get_ConstraintCount: function (){
            return this.numberOfConstraints;
        },
        AddEqualityConstraint: function (left, right, gap){
            return this.AddConstraint$$Variable$$Variable$$Double$$Boolean(left, right, gap, true);
        },
        AddConstraint$$Variable$$Variable$$Double$$Boolean: function (left, right, gap, isEquality){
            if (!this.allConstraints.get_IsEmpty()){
                throw $CreateException(new System.InvalidOperationException.ctor$$String("Cannot add Variables or Constraints once Solve() has been called"), new Error());
            }
            if (left == right){
                throw $CreateException(new System.ArgumentException.ctor$$String("Cannot add a constraint between a variable and itself"), new Error());
            }
            var constraintsForLeftVar = this.loadedVariablesAndConstraintLists.get_Item$$TKey(left);
            var constraintsForRightVar = this.loadedVariablesAndConstraintLists.get_Item$$TKey(right);
            var constraint = new Microsoft.Msagl.Core.ProjectionSolver.Constraint.ctor$$Variable$$Variable$$Double$$Boolean(left, right, gap, isEquality);
            this.loadedVariablesAndConstraintLists.set_Item$$TKey(left, new Microsoft.Msagl.Core.ProjectionSolver.Solver.ConstraintListForVariable.ctor$$List$1$Constraint$$Int32(constraintsForLeftVar.Constraints, constraintsForLeftVar.NumberOfLeftConstraints + 1));
            constraintsForLeftVar.Constraints.Add(constraint);
            constraintsForRightVar.Constraints.Add(constraint);
            ++this.numberOfConstraints;
            if (isEquality){
                this.equalityConstraints.Add(constraint);
            }
            return constraint;
        },
        AddConstraint$$Variable$$Variable$$Double: function (left, right, gap){
            return this.AddConstraint$$Variable$$Variable$$Double$$Boolean(left, right, gap, false);
        },
        SetConstraintUpdate: function (constraint, gap){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(constraint, "constraint");
            if (gap != constraint.get_Gap()){
                this.updatedConstraints.Add(new System.Collections.Generic.KeyValuePair$2.ctor$$TKey$$TValue(Microsoft.Msagl.Core.ProjectionSolver.Constraint.ctor, System.Double.ctor, constraint, gap));
            }
        },
        AddNeighborPair: function (variable1, variable2, relationshipWeight){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(variable1, "variable1");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(variable2, "variable2");
            if ((relationshipWeight <= 0) || System.Double.IsNaN(relationshipWeight) || System.Double.IsInfinity(relationshipWeight)){
                throw $CreateException(new System.ArgumentOutOfRangeException.ctor$$String$$String("relationshipWeight", "Invalid Neighbor Weight"), new Error());
            }
            if (variable1 == variable2){
                throw $CreateException(new System.InvalidOperationException.ctor$$String("Cannot make a Variable a neighbor of itself"), new Error());
            }
            variable1.AddNeighbor(variable2, relationshipWeight);
            variable2.AddNeighbor(variable1, relationshipWeight);
            this.hasNeighbourPairs = true;
        },
        Solve: function (){
            return this.Solve$$Parameters(null);
        },
        Solve$$Parameters: function (solverParameters){
            if (null != solverParameters){
                this.solverParams = Cast(solverParameters.Clone(), Microsoft.Msagl.Core.ProjectionSolver.Parameters.ctor);
            }
            if (this.solverParams.get_OuterProjectIterationsLimit() < 0){
                this.solverParams.set_OuterProjectIterationsLimit(100 * (((System.Math.Log$$Double$$Double(this.numberOfVariables, 2)) | 0) + 1));
            }
            if (this.solverParams.get_InnerProjectIterationsLimit() < 0){
                this.solverParams.set_InnerProjectIterationsLimit((this.numberOfConstraints * 2) + (100 * (((System.Math.Log$$Double$$Double(this.numberOfConstraints, 2)) | 0) + 1)));
            }
            var isReSolve = !this.allConstraints.get_IsEmpty();
            this.CheckForUpdatedConstraints();
            this.solverSolution = (function (){
                var $v106 = new Microsoft.Msagl.Core.ProjectionSolver.Solution.ctor();
                $v106.set_MinInnerProjectIterations(2147483647);
                return $v106;
            }).call(this);
            this.allConstraints.MaxConstraintTreeDepth = 0;
            this.allConstraints.SolverParameters = this.solverParams;
            if (0 == this.numberOfConstraints){
                if (!this.get_IsQpsc()){
                    return Cast(this.solverSolution.Clone(), Microsoft.Msagl.Core.ProjectionSolver.Solution.ctor);
                }
            }
            else if (!isReSolve){
                this.SetupConstraints();
            }
            this.allConstraints.NumberOfUnsatisfiableConstraints = 0;
            this.MergeEqualityConstraints();
            if (this.solverParams.get_TimeLimit() > 0){
                this.timeoutStopwatch = new System.Diagnostics.Stopwatch.ctor();
                this.timeoutStopwatch.Start();
            }
            if (this.get_IsQpsc()){
                this.SolveQpsc();
            }
            else {
                this.SolveByStandaloneProject();
                this.CalculateStandaloneProjectGoalFunctionValue();
            }
            if (this.solverSolution.get_MinInnerProjectIterations() > this.solverSolution.get_MaxInnerProjectIterations()){
                this.solverSolution.set_MinInnerProjectIterations(this.solverSolution.get_MaxInnerProjectIterations());
            }
            this.solverSolution.set_NumberOfUnsatisfiableConstraints(this.allConstraints.NumberOfUnsatisfiableConstraints);
            this.solverSolution.set_MaxConstraintTreeDepth(this.allConstraints.MaxConstraintTreeDepth);
            return Cast(this.solverSolution.Clone(), Microsoft.Msagl.Core.ProjectionSolver.Solution.ctor);
        },
        CheckForUpdatedConstraints: function (){
            if (0 == this.updatedConstraints.get_Count()){
                return;
            }
            System.Diagnostics.Debug.Assert$$Boolean$$String(!this.allConstraints.get_IsEmpty(), "Cannot have updated constraints if AllConstraints is empty.");
            var mustReinitializeBlocks = this.get_IsQpsc();
            var $it961 = this.updatedConstraints.GetEnumerator();
            while ($it961.MoveNext()){
                var kvpUpdate = $it961.get_Current();
                var constraint = kvpUpdate.get_Key();
                constraint.UpdateGap(kvpUpdate.get_Value());
                if (!mustReinitializeBlocks && !constraint.get_IsEquality()){
                    this.SplitOnConstraintIfActive(constraint);
                    continue;
                }
                mustReinitializeBlocks = true;
            }
            this.updatedConstraints.Clear();
            if (mustReinitializeBlocks){
                this.ReinitializeBlocks();
            }
        },
        SplitOnConstraintIfActive: function (constraint){
            if (constraint.get_IsActive()){
                var newSplitBlock = constraint.get_Left().get_Block().SplitOnConstraint(constraint);
                if (null != newSplitBlock){
                    this.allBlocks.Add(newSplitBlock);
                }
            }
        },
        SetupConstraints: function (){
            this.allConstraints.Create(this.numberOfConstraints);
            var $it962 = this.loadedVariablesAndConstraintLists.get_Keys().GetEnumerator();
            while ($it962.MoveNext()){
                var variable = $it962.get_Current();
                var constraintsForVar = this.loadedVariablesAndConstraintLists.get_Item$$TKey(variable);
                var constraints = constraintsForVar.Constraints;
                var numAllConstraints = 0;
                var numLeftConstraints = 0;
                var numRightConstraints = 0;
                if (null != constraints){
                    numAllConstraints = constraints.get_Count();
                    numLeftConstraints = constraintsForVar.NumberOfLeftConstraints;
                    numRightConstraints = numAllConstraints - numLeftConstraints;
                }
                var leftConstraints = this.emptyConstraintList;
                if (0 != numLeftConstraints){
                    leftConstraints = new Array(numLeftConstraints);
                }
                var rightConstraints = this.emptyConstraintList;
                if (0 != numRightConstraints){
                    rightConstraints = new Array(numRightConstraints);
                }
                variable.SetConstraints(leftConstraints, rightConstraints);
                var leftConstraintIndex = 0;
                var rightConstraintIndex = 0;
                for (var loadedConstraintIndex = 0; loadedConstraintIndex < numAllConstraints; ++loadedConstraintIndex){
                    var loadedConstraint = constraints.get_Item$$Int32(loadedConstraintIndex);
                    if (variable == loadedConstraint.get_Left()){
                        leftConstraints[leftConstraintIndex++] = loadedConstraint;
                    }
                    else {
                        rightConstraints[rightConstraintIndex++] = loadedConstraint;
                    }
                }
                System.Diagnostics.Debug.Assert$$Boolean$$String(leftConstraintIndex == numLeftConstraints, "leftConstraintIndex must == numLeftConstraints");
                System.Diagnostics.Debug.Assert$$Boolean$$String(rightConstraintIndex == numRightConstraints, "rightConstraintIndex must == numRightConstraints");
                for (var $i964 = 0,$t964 = variable.get_LeftConstraints(),$l964 = $t964.length,constraint = $t964[$i964]; $i964 < $l964; $i964++, constraint = $t964[$i964]){
                    this.allConstraints.Add(constraint);
                }
            }
            this.allConstraints.Debug_AssertIsFull();
            this.loadedVariablesAndConstraintLists.Clear();
            this.loadedVariablesAndConstraintLists = null;
            this.violationCacheMinBlockCutoff = 2147483647;
            if (this.solverParams.get_Advanced().get_UseViolationCache() && (this.solverParams.get_Advanced().get_ViolationCacheMinBlocksDivisor() > 0)){
                this.violationCacheMinBlockCutoff = System.Math.Min$$Int32$$Int32((this.allBlocks.get_Count() / this.solverParams.get_Advanced().get_ViolationCacheMinBlocksDivisor()) | 0, this.solverParams.get_Advanced().get_ViolationCacheMinBlocksCount());
            }
        },
        SolveByStandaloneProject: function (){
            for (; ;){
                var violationsFound;
                if (!(function (){
                    var $1 = {
                        Value: violationsFound
                    };
                    var $res = this.RunProject($1);
                    violationsFound = $1.Value;
                    return $res;
                }).call(this)){
                    return;
                }
                if (!this.SplitBlocks()){
                    break;
                }
            }
        },
        RunProject: function (violationsFound){
            this.solverSolution.set_OuterProjectIterations(this.solverSolution.get_OuterProjectIterations() + 1);
            violationsFound.Value = this.Project();
            return !this.CheckForLimitsExceeded();
        },
        CheckForLimitsExceeded: function (){
            if (null != this.timeoutStopwatch){
                if (this.timeoutStopwatch.get_ElapsedMilliseconds() >= this.solverParams.get_TimeLimit()){
                    this.solverSolution.set_TimeLimitExceeded(true);
                    return true;
                }
            }
            if (this.solverParams.get_OuterProjectIterationsLimit() > 0){
                if (this.solverSolution.get_OuterProjectIterations() >= this.solverParams.get_OuterProjectIterationsLimit()){
                    this.solverSolution.set_OuterProjectIterationsLimitExceeded(true);
                    return true;
                }
            }
            if (this.solverSolution.get_InnerProjectIterationsLimitExceeded()){
                return true;
            }
            return false;
        },
        CalculateStandaloneProjectGoalFunctionValue: function (){
            this.solverSolution.set_GoalFunctionValue(0);
            var numBlocks = this.allBlocks.get_Count();
            for (var ii = 0; ii < numBlocks; ++ii){
                var block = this.allBlocks.get_Item$$Int32(ii);
                var numVars = block.get_Variables().get_Count();
                for (var jj = 0; jj < numVars; ++jj){
                    var variable = block.get_Variables().get_Item$$Int32(jj);
                    this.solverSolution.set_GoalFunctionValue(this.solverSolution.get_GoalFunctionValue() + variable.get_Weight() * variable.get_ActualPos() * variable.get_ActualPos());
                    this.solverSolution.set_GoalFunctionValue(this.solverSolution.get_GoalFunctionValue() - 2 * variable.get_Weight() * variable.get_DesiredPos() * variable.get_ActualPos());
                }
            }
        },
        SolveQpsc: function (){
            this.solverSolution.set_AlgorithmUsed(this.solverParams.get_Advanced().get_ScaleInQpsc() ? Microsoft.Msagl.Core.ProjectionSolver.SolverAlgorithm.QpscWithScaling : Microsoft.Msagl.Core.ProjectionSolver.SolverAlgorithm.QpscWithoutScaling);
            if (!this.QpscMakeFeasible()){
                return;
            }
            var qpsc = new Microsoft.Msagl.Core.ProjectionSolver.Qpsc.ctor(this.solverParams, this.numberOfVariables);
            var $it964 = this.allBlocks.get_Vector().GetEnumerator();
            while ($it964.MoveNext()){
                var block = $it964.get_Current();
                var $it965 = block.get_Variables().GetEnumerator();
                while ($it965.MoveNext()){
                    var variable = $it965.get_Current();
                    qpsc.AddVariable(variable);
                }
            }
            qpsc.VariablesComplete();
            this.ReinitializeBlocks();
            this.MergeEqualityConstraints();
            this.VerifyConstraintsAreFeasible();
            var foundSplit = false;
            var foundViolation = false;
            for (; ;){
                if (!qpsc.PreProject() && !foundSplit && !foundViolation){
                    break;
                }
                foundSplit = this.SplitBlocks();
                if (!(function (){
                    var $1 = {
                        Value: foundViolation
                    };
                    var $res = this.RunProject($1);
                    foundViolation = $1.Value;
                    return $res;
                }).call(this)){
                    break;
                }
                if (!qpsc.PostProject() && !foundSplit && !foundViolation){
                    break;
                }
            }
            this.solverSolution.set_GoalFunctionValue(qpsc.QpscComplete());
        },
        QpscMakeFeasible: function (){
            var foundViolation;
            return (function (){
                var $1 = {
                    Value: foundViolation
                };
                var $res = this.RunProject($1);
                foundViolation = $1.Value;
                return $res;
            }).call(this);
        },
        VerifyConstraintsAreFeasible: function (){
        },
        ReinitializeBlocks: function (){
            var oldBlocks = this.allBlocks.get_Vector().ToArray();
            this.allBlocks.get_Vector().Clear();
            for (var $i967 = 0,$l967 = oldBlocks.length,oldBlock = oldBlocks[$i967]; $i967 < $l967; $i967++, oldBlock = oldBlocks[$i967]){
                var $it967 = oldBlock.get_Variables().GetEnumerator();
                while ($it967.MoveNext()){
                    var variable = $it967.get_Current();
                    variable.Reinitialize();
                    var newBlock = new Microsoft.Msagl.Core.ProjectionSolver.Block.ctor(variable, this.allConstraints);
                    this.allBlocks.Add(newBlock);
                }
            }
            this.allConstraints.Reinitialize();
            this.violationCache.Clear();
        },
        MergeEqualityConstraints: function (){
            var $it968 = this.equalityConstraints.GetEnumerator();
            while ($it968.MoveNext()){
                var constraint = $it968.get_Current();
                if (constraint.get_Left().get_Block() == constraint.get_Right().get_Block()){
                    if (System.Math.Abs$$Double(constraint.get_Violation()) > this.solverParams.get_GapTolerance()){
                        constraint.set_IsUnsatisfiable(true);
                        ++this.allConstraints.NumberOfUnsatisfiableConstraints;
                    }
                    continue;
                }
                this.MergeBlocks(constraint);
            }
        },
        Project: function (){
            if (0 == this.numberOfConstraints){
                return false;
            }
            this.violationCache.Clear();
            this.lastModifiedBlock = null;
            var useViolationCache = this.allBlocks.get_Count() > this.violationCacheMinBlockCutoff;
            var cIterations = 1;
            var maxViolation;
            var maxViolatedConstraint = (function (){
                var $1 = {
                    Value: maxViolation
                };
                var $res = this.GetMaxViolatedConstraint($1, useViolationCache);
                maxViolation = $1.Value;
                return $res;
            }).call(this);
            if (null == maxViolatedConstraint){
                return false;
            }
            while (null != maxViolatedConstraint){
                System.Diagnostics.Debug.Assert$$Boolean$$String(!maxViolatedConstraint.get_IsUnsatisfiable(), "maxViolatedConstraint should not be unsatisfiable");
                System.Diagnostics.Debug.Assert$$Boolean$$String(!maxViolatedConstraint.get_IsEquality(), "maxViolatedConstraint should not be equality");
                if (maxViolatedConstraint.get_Left().get_Block() == maxViolatedConstraint.get_Right().get_Block()){
                    maxViolatedConstraint.get_Left().get_Block().Expand(maxViolatedConstraint);
                    if (maxViolatedConstraint.get_IsUnsatisfiable()){
                        this.violationCache.Clear();
                    }
                    this.lastModifiedBlock = maxViolatedConstraint.get_Left().get_Block();
                }
                else {
                    this.lastModifiedBlock = this.MergeBlocks(maxViolatedConstraint);
                }
                if (this.solverParams.get_InnerProjectIterationsLimit() > 0){
                    if (cIterations >= this.solverParams.get_InnerProjectIterationsLimit()){
                        this.solverSolution.set_InnerProjectIterationsLimitExceeded(true);
                        break;
                    }
                }
                useViolationCache = this.allBlocks.get_Count() > this.violationCacheMinBlockCutoff;
                if (!useViolationCache){
                    this.violationCache.Clear();
                }
                ++cIterations;
                maxViolatedConstraint = (function (){
                    var $1 = {
                        Value: maxViolation
                    };
                    var $res = this.GetMaxViolatedConstraint($1, useViolationCache);
                    maxViolation = $1.Value;
                    return $res;
                }).call(this);
            }
            this.solverSolution.set_InnerProjectIterationsTotal(this.solverSolution.get_InnerProjectIterationsTotal() + cIterations);
            if (this.solverSolution.get_MaxInnerProjectIterations() < cIterations){
                this.solverSolution.set_MaxInnerProjectIterations(cIterations);
            }
            if (this.solverSolution.get_MinInnerProjectIterations() > cIterations){
                this.solverSolution.set_MinInnerProjectIterations(cIterations);
            }
            this.allConstraints.Debug_AssertConsistency();
            return true;
        },
        MergeBlocks: function (violatedConstraint){
            var blockTo = violatedConstraint.get_Left().get_Block();
            var blockFrom = violatedConstraint.get_Right().get_Block();
            System.Diagnostics.Debug.Assert$$Boolean$$String(blockTo != blockFrom, "Merging of constraints in the same block is not allowed");
            var distance = violatedConstraint.get_Left().get_OffsetInBlock() + violatedConstraint.get_Gap() - violatedConstraint.get_Right().get_OffsetInBlock();
            if (blockFrom.get_Variables().get_Count() > blockTo.get_Variables().get_Count()){
                blockTo = violatedConstraint.get_Right().get_Block();
                blockFrom = violatedConstraint.get_Left().get_Block();
                distance = -distance;
            }
            var numVars = blockFrom.get_Variables().get_Count();
            for (var ii = 0; ii < numVars; ++ii){
                var variable = blockFrom.get_Variables().get_Item$$Int32(ii);
                variable.set_OffsetInBlock(variable.get_OffsetInBlock() + distance);
                blockTo.AddVariable(variable);
            }
            blockTo.UpdateReferencePosFromSums();
            blockTo.DebugVerifyReferencePos();
            blockTo.Debug_PostMerge(blockFrom);
            this.allConstraints.ActivateConstraint(violatedConstraint);
            this.allBlocks.Remove(blockFrom);
            return blockTo;
        },
        SplitBlocks: function (){
            var newBlocks = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.ProjectionSolver.Block.ctor);
            var numBlocks = this.allBlocks.get_Count();
            for (var ii = 0; ii < numBlocks; ++ii){
                var block = this.allBlocks.get_Item$$Int32(ii);
                System.Diagnostics.Debug.Assert$$Boolean$$String(0 != block.get_Variables().get_Count(), "block must have nonzero variable count");
                var newSplitBlock = block.Split(this.get_IsQpsc());
                if (null != newSplitBlock){
                    newBlocks.Add(newSplitBlock);
                }
            }
            var numNewBlocks = newBlocks.get_Count();
            for (var ii = 0; ii < numNewBlocks; ++ii){
                var block = newBlocks.get_Item$$Int32(ii);
                this.allBlocks.Add(block);
            }
            return (0 != newBlocks.get_Count());
        },
        GetMaxViolatedConstraint: function (maxViolation, useViolationCache){
            maxViolation.Value = this.solverParams.get_GapTolerance();
            var maxViolatedConstraint = this.SearchViolationCache(maxViolation.Value);
            if (null != maxViolatedConstraint){
                return maxViolatedConstraint;
            }
            return this.SearchAllConstraints(maxViolation.Value, useViolationCache);
        },
        SearchViolationCache: function (maxViolation){
            var maxViolatedConstraint = null;
            if ((null != this.lastModifiedBlock) && (this.lastModifiedBlock.get_Variables().get_Count() < (this.numberOfVariables >> 1)) && this.violationCache.FilterBlock(this.lastModifiedBlock)){
                var numVarsInBlock = this.lastModifiedBlock.get_Variables().get_Count();
                for (var variableIndex = 0; variableIndex < numVarsInBlock; ++variableIndex){
                    var variable = this.lastModifiedBlock.get_Variables().get_Item$$Int32(variableIndex);
                    for (var $i970 = 0,$t970 = variable.get_LeftConstraints(),$l970 = $t970.length,constraint = $t970[$i970]; $i970 < $l970; $i970++, constraint = $t970[$i970]){
                        if (!constraint.get_IsActive() && !constraint.get_IsUnsatisfiable()){
                            var violation = (constraint.get_Left().get_ActualPos() * constraint.get_Left().get_Scale()) + constraint.get_Gap() - (constraint.get_Right().get_ActualPos() * constraint.get_Right().get_Scale());
                            System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(constraint.get_Violation(), violation), "LeftConstraints: constraint.Violation must == violation");
                            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Greater(violation, maxViolation)){
                                if ((null != maxViolatedConstraint) && (maxViolation > this.violationCache.get_LowViolation())){
                                    this.violationCache.Insert(maxViolatedConstraint, maxViolation);
                                }
                                maxViolation = constraint.get_Violation();
                                maxViolatedConstraint = constraint;
                            }
                        }
                    }
                    for (var $i971 = 0,$t971 = variable.get_RightConstraints(),$l971 = $t971.length,constraint = $t971[$i971]; $i971 < $l971; $i971++, constraint = $t971[$i971]){
                        if (!constraint.get_IsActive() && !constraint.get_IsUnsatisfiable() && (constraint.get_Left().get_Block() != this.lastModifiedBlock)){
                            var violation = (constraint.get_Left().get_ActualPos() * constraint.get_Left().get_Scale()) + constraint.get_Gap() - (constraint.get_Right().get_ActualPos() * constraint.get_Right().get_Scale());
                            System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(constraint.get_Violation(), violation), "LeftConstraints: constraint.Violation must == violation");
                            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Greater(violation, maxViolation)){
                                if ((null != maxViolatedConstraint) && (maxViolation > this.violationCache.get_LowViolation())){
                                    this.violationCache.Insert(maxViolatedConstraint, maxViolation);
                                }
                                maxViolation = violation;
                                maxViolatedConstraint = constraint;
                            }
                        }
                    }
                }
                var cachedConstraint = this.violationCache.FindIfGreater(maxViolation);
                if (null != cachedConstraint){
                    if ((null != maxViolatedConstraint) && (maxViolation > this.violationCache.get_LowViolation())){
                        this.violationCache.Insert(maxViolatedConstraint, maxViolation);
                    }
                    maxViolatedConstraint = cachedConstraint;
                }
            }
            return maxViolatedConstraint;
        },
        SearchAllConstraints: function (maxViolation, useViolationCache){
            var maxViolatedConstraint = null;
            this.violationCache.Clear();
            for (var $i972 = 0,$t972 = this.allConstraints.get_Vector(),$l972 = $t972.length,constraint = $t972[$i972]; $i972 < $l972; $i972++, constraint = $t972[$i972]){
                if (constraint.get_IsActive()){
                    break;
                }
                if (constraint.get_IsUnsatisfiable()){
                    continue;
                }
                var violation = (constraint.get_Left().get_ActualPos() * constraint.get_Left().get_Scale()) + constraint.get_Gap() - (constraint.get_Right().get_ActualPos() * constraint.get_Right().get_Scale());
                System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(constraint.get_Violation(), violation), "constraint.Violation must == violation");
                var cacheInsertConstraint = null;
                var cacheInsertViolation = 0;
                if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Greater(violation, maxViolation)){
                    if (maxViolation > this.violationCache.get_LowViolation()){
                        cacheInsertConstraint = maxViolatedConstraint;
                        cacheInsertViolation = maxViolation;
                    }
                    maxViolation = violation;
                    maxViolatedConstraint = constraint;
                }
                if (useViolationCache){
                    if ((null == cacheInsertConstraint) && (constraint != maxViolatedConstraint) && (!this.violationCache.get_IsFull() || (violation > this.violationCache.get_LowViolation()))){
                        cacheInsertConstraint = constraint;
                        cacheInsertViolation = violation;
                    }
                    if ((null != cacheInsertConstraint) && (cacheInsertViolation > this.violationCache.get_LowViolation())){
                        this.violationCache.Insert(cacheInsertConstraint, cacheInsertViolation);
                    }
                }
            }
            return maxViolatedConstraint;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$ProjectionSolver$Solver);
var Microsoft$Msagl$Core$ProjectionSolver$Solver$ConstraintListForVariable = {
    fullname: "Microsoft.Msagl.Core.ProjectionSolver.Solver.ConstraintListForVariable",
    baseTypeName: "System.ValueType",
    assemblyName: "Microsoft.Msagl",
    Kind: "Struct",
    definition: {
        ctor$$List$1$Constraint$$Int32: function (constraints, numberOfLeftConstraints){
            this.Constraints = null;
            this.NumberOfLeftConstraints = 0;
            System.ValueType.ctor.call(this);
            this.Constraints = constraints;
            this.NumberOfLeftConstraints = numberOfLeftConstraints;
        },
        ctor: function (){
            this.Constraints = null;
            this.NumberOfLeftConstraints = 0;
            System.ValueType.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$ProjectionSolver$Solver$ConstraintListForVariable);
var Microsoft$Msagl$Core$ProjectionSolver$Variable = {
    fullname: "Microsoft.Msagl.Core.ProjectionSolver.Variable",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.IComparable$1"],
    Kind: "Class",
    definition: {
        ctor: function (ordinal, userData, desiredPos, weight, scale){
            this.activeConstraintCount = 0;
            this._UserData = null;
            this._DesiredPos = 0;
            this._Weight = 0;
            this._Scale = 0;
            this._ActualPos = 0;
            this._OffsetInBlock = 0;
            this._Block = null;
            this._Ordinal = 0;
            this._LeftConstraints = null;
            this._RightConstraints = null;
            this._Neighbors = null;
            System.Object.ctor.call(this);
            if (weight <= 0){
                throw $CreateException(new System.ArgumentOutOfRangeException.ctor$$String$$String("weight", "Variable Weight must be greater than zero"), new Error());
            }
            if (scale <= 0){
                throw $CreateException(new System.ArgumentOutOfRangeException.ctor$$String$$String("scale", "Variable Scale must be greater than zero"), new Error());
            }
            var check = desiredPos * weight;
            if (System.Double.IsInfinity(check) || System.Double.IsNaN(check)){
                throw $CreateException(new System.ArgumentOutOfRangeException.ctor$$String$$String("desiredPos", "Invalid Variable DesiredPosition * Weight"), new Error());
            }
            check = desiredPos * scale;
            if (System.Double.IsInfinity(check) || System.Double.IsNaN(check)){
                throw $CreateException(new System.ArgumentOutOfRangeException.ctor$$String$$String("desiredPos", "Invalid Variable DesiredPosition * Scale"), new Error());
            }
            this.set_Ordinal(ordinal);
            this.set_UserData(userData);
            this.set_DesiredPos(desiredPos);
            this.set_Weight(weight);
            this.set_Scale(scale);
            this.set_OffsetInBlock(0);
            this.set_ActualPos(this.get_DesiredPos());
        },
        UserData$$: "System.Object",
        get_UserData: function (){
            return this._UserData;
        },
        set_UserData: function (value){
            this._UserData = value;
        },
        DesiredPos$$: "System.Double",
        get_DesiredPos: function (){
            return this._DesiredPos;
        },
        set_DesiredPos: function (value){
            this._DesiredPos = value;
        },
        Weight$$: "System.Double",
        get_Weight: function (){
            return this._Weight;
        },
        set_Weight: function (value){
            this._Weight = value;
        },
        Scale$$: "System.Double",
        get_Scale: function (){
            return this._Scale;
        },
        set_Scale: function (value){
            this._Scale = value;
        },
        ActualPos$$: "System.Double",
        get_ActualPos: function (){
            return this._ActualPos;
        },
        set_ActualPos: function (value){
            this._ActualPos = value;
        },
        DfDv$$: "System.Double",
        get_DfDv: function (){
            return (2 * this.get_Weight() * (this.get_ActualPos() - this.get_DesiredPos())) / this.get_Scale();
        },
        OffsetInBlock$$: "System.Double",
        get_OffsetInBlock: function (){
            return this._OffsetInBlock;
        },
        set_OffsetInBlock: function (value){
            this._OffsetInBlock = value;
        },
        Block$$: "Microsoft.Msagl.Core.ProjectionSolver.Block",
        get_Block: function (){
            return this._Block;
        },
        set_Block: function (value){
            this._Block = value;
        },
        Ordinal$$: "System.UInt32",
        get_Ordinal: function (){
            return this._Ordinal;
        },
        set_Ordinal: function (value){
            this._Ordinal = value;
        },
        LeftConstraints$$: "Microsoft.Msagl.Core.ProjectionSolver.Constraint[]",
        get_LeftConstraints: function (){
            return this._LeftConstraints;
        },
        set_LeftConstraints: function (value){
            this._LeftConstraints = value;
        },
        RightConstraints$$: "Microsoft.Msagl.Core.ProjectionSolver.Constraint[]",
        get_RightConstraints: function (){
            return this._RightConstraints;
        },
        set_RightConstraints: function (value){
            this._RightConstraints = value;
        },
        ActiveConstraintCount$$: "System.Int32",
        get_ActiveConstraintCount: function (){
            return this.activeConstraintCount;
        },
        set_ActiveConstraintCount: function (value){
            System.Diagnostics.Debug.Assert$$Boolean$$String(value >= 0, "ActiveConstraintCount must be >= 0");
            this.activeConstraintCount = value;
        },
        Neighbors$$: "System.Collections.Generic.List`1[[Microsoft.Msagl.Core.ProjectionSolver.Variable+NeighborAndWeight]]",
        get_Neighbors: function (){
            return this._Neighbors;
        },
        set_Neighbors: function (value){
            this._Neighbors = value;
        },
        Reinitialize: function (){
            this.set_ActiveConstraintCount(0);
            this.set_OffsetInBlock(0);
            this.set_ActualPos(this.get_DesiredPos());
        },
        AddNeighbor: function (neighbor, weight){
            if (null == this.get_Neighbors()){
                this.set_Neighbors(new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.ProjectionSolver.Variable.NeighborAndWeight.ctor));
            }
            this.get_Neighbors().Add(new Microsoft.Msagl.Core.ProjectionSolver.Variable.NeighborAndWeight.ctor$$Variable$$Double(neighbor, weight));
        },
        toString: function (){
            return System.String.Format$$IFormatProvider$$String$$Object$Array(System.Globalization.CultureInfo.get_InvariantCulture(), "{0} {1:F5} ({2:F5}) {3:F5} {4:F5}", [this.get_Name(), this.get_ActualPos(), this.get_DesiredPos(), this.get_Weight(), this.get_Scale()]);
        },
        Name$$: "System.String",
        get_Name: function (){
            return (null == this.get_UserData()) ? "-0-" : this.get_UserData().toString();
        },
        SetConstraints: function (leftConstraints, rightConstraints){
            this.set_LeftConstraints(leftConstraints);
            this.set_RightConstraints(rightConstraints);
        },
        CompareTo: function (other){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(other, "other");
            return this.get_Ordinal().CompareTo$$UInt32(other.get_Ordinal());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$ProjectionSolver$Variable);
var Microsoft$Msagl$Core$ProjectionSolver$Variable$NeighborAndWeight = {
    fullname: "Microsoft.Msagl.Core.ProjectionSolver.Variable.NeighborAndWeight",
    baseTypeName: "System.ValueType",
    assemblyName: "Microsoft.Msagl",
    Kind: "Struct",
    definition: {
        ctor$$Variable$$Double: function (neighbor, weight){
            this._Neighbor = null;
            this._Weight = 0;
            Microsoft.Msagl.Core.ProjectionSolver.Variable.NeighborAndWeight.ctor.call(this);
            this.set_Neighbor(neighbor);
            this.set_Weight(weight);
        },
        Neighbor$$: "Microsoft.Msagl.Core.ProjectionSolver.Variable",
        get_Neighbor: function (){
            return this._Neighbor;
        },
        set_Neighbor: function (value){
            this._Neighbor = value;
        },
        Weight$$: "System.Double",
        get_Weight: function (){
            return this._Weight;
        },
        set_Weight: function (value){
            this._Weight = value;
        },
        ctor: function (){
            this._Neighbor = null;
            this._Weight = 0;
            System.ValueType.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$ProjectionSolver$Variable$NeighborAndWeight);
var Microsoft$Msagl$Core$ProjectionSolver$ViolationCache = {
    fullname: "Microsoft.Msagl.Core.ProjectionSolver.ViolationCache",
    baseTypeName: "System.ValueType",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Core.ProjectionSolver.ViolationCache.MaxConstraints = 20;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Struct",
    definition: {
        ctor: function (){
            this.constraints = null;
            this.numConstraints = 0;
            this._LowViolation = 0;
            System.ValueType.ctor.call(this);
        },
        LowViolation$$: "System.Double",
        get_LowViolation: function (){
            return this._LowViolation;
        },
        set_LowViolation: function (value){
            this._LowViolation = value;
        },
        IsFull$$: "System.Boolean",
        get_IsFull: function (){
            return this.numConstraints == 20;
        },
        Clear: function (){
            this.set_LowViolation(0);
            this.numConstraints = 0;
            if (null == this.constraints){
                this.constraints = new Array(20);
            }
        },
        FilterBlock: function (blockToFilter){
            this.set_LowViolation(1.79769313486232E+308);
            var fRet = this.numConstraints > 0;
            for (var ii = this.numConstraints - 1; ii >= 0; --ii){
                var constraint = this.constraints[ii];
                if ((constraint.get_Left().get_Block() == blockToFilter) || (constraint.get_Right().get_Block() == blockToFilter) || constraint.get_IsActive() || constraint.get_IsUnsatisfiable()){
                    if (ii < (this.numConstraints - 1)){
                        this.constraints[ii] = this.constraints[this.numConstraints - 1];
                    }
                    --this.numConstraints;
                }
                else {
                    var violation = (constraint.get_Left().get_ActualPos() * constraint.get_Left().get_Scale()) + constraint.get_Gap() - (constraint.get_Right().get_ActualPos() * constraint.get_Right().get_Scale());
                    System.Diagnostics.Debug.Assert$$Boolean$$String(constraint.get_Violation() == violation, "LeftConstraints: constraint.Violation must == violation");
                    if (violation < this.get_LowViolation()){
                        this.set_LowViolation(violation);
                    }
                }
            }
            if (0 == this.numConstraints){
                this.set_LowViolation(0);
            }
            return fRet;
        },
        FindIfGreater: function (targetViolation){
            var maxViolatedConstraint = null;
            for (var ii = 0; ii < this.numConstraints; ++ii){
                var constraint = this.constraints[ii];
                var violation = (constraint.get_Left().get_ActualPos() * constraint.get_Left().get_Scale()) + constraint.get_Gap() - (constraint.get_Right().get_ActualPos() * constraint.get_Right().get_Scale());
                System.Diagnostics.Debug.Assert$$Boolean$$String(constraint.get_Violation() == violation, "constraint.Violation must == violation");
                if (violation > targetViolation){
                    targetViolation = violation;
                    maxViolatedConstraint = constraint;
                }
            }
            return maxViolatedConstraint;
        },
        Insert: function (constraintToInsert, insertViolation){
            System.Diagnostics.Debug.Assert$$Boolean$$String(constraintToInsert.get_Violation() > this.get_LowViolation(), "constraintToInsert.Violation must be > LowViolation");
            System.Diagnostics.Debug.Assert$$Boolean$$String(constraintToInsert.get_Violation() == insertViolation, "constraintToInsert.Violation must == insertViolation");
            var indexOfLowestViolation = 0;
            var lowViolation = insertViolation;
            var nextLowViolation = insertViolation;
            for (var ii = 0; ii < this.numConstraints; ++ii){
                var constraint = this.constraints[ii];
                var cacheViolation = (constraint.get_Left().get_ActualPos() * constraint.get_Left().get_Scale()) + constraint.get_Gap() - (constraint.get_Right().get_ActualPos() * constraint.get_Right().get_Scale());
                System.Diagnostics.Debug.Assert$$Boolean$$String(constraint.get_Violation() == cacheViolation, "constraint.Violation must == cacheViolation");
                if (cacheViolation < lowViolation){
                    nextLowViolation = lowViolation;
                    indexOfLowestViolation = ii;
                    lowViolation = cacheViolation;
                }
                else if (cacheViolation < nextLowViolation){
                    nextLowViolation = cacheViolation;
                }
            }
            if (!this.get_IsFull()){
                this.constraints[this.numConstraints++] = constraintToInsert;
                if (this.get_IsFull()){
                    this.set_LowViolation(lowViolation);
                }
            }
            else {
                this.constraints[indexOfLowestViolation] = constraintToInsert;
                this.set_LowViolation(nextLowViolation);
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$ProjectionSolver$ViolationCache);
var Microsoft$Msagl$Core$Geometry$ConstraintGenerator = {
    fullname: "Microsoft.Msagl.Core.Geometry.ConstraintGenerator",
    baseTypeName: "System.Object",
    staticDefinition: {
        DefaultPadding$$: "System.Double",
        get_DefaultPadding: function (){
            return 7;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$Boolean: function (isHorizontal){
            this.clusterHierarchies = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ctor);
            this.nextNodeId = 0;
            this._Padding = 0;
            this._PaddingP = 0;
            this._ClusterPadding = 0;
            this._ClusterPaddingP = 0;
            this._IsHorizontal = false;
            Microsoft.Msagl.Core.Geometry.ConstraintGenerator.ctor$$Boolean$$Double$$Double.call(this, isHorizontal, Microsoft.Msagl.Core.Geometry.ConstraintGenerator.get_DefaultPadding(), Microsoft.Msagl.Core.Geometry.ConstraintGenerator.get_DefaultPadding());
        },
        ClusterHierarchies$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster]]",
        get_ClusterHierarchies: function (){
            return this.clusterHierarchies;
        },
        DefaultClusterHierarchy$$: "Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster",
        get_DefaultClusterHierarchy: function (){
            return this.clusterHierarchies.get_Item$$Int32(0);
        },
        Padding$$: "System.Double",
        get_Padding: function (){
            return this._Padding;
        },
        set_Padding: function (value){
            this._Padding = value;
        },
        PaddingP$$: "System.Double",
        get_PaddingP: function (){
            return this._PaddingP;
        },
        set_PaddingP: function (value){
            this._PaddingP = value;
        },
        ClusterPadding$$: "System.Double",
        get_ClusterPadding: function (){
            return this._ClusterPadding;
        },
        set_ClusterPadding: function (value){
            this._ClusterPadding = value;
        },
        ClusterPaddingP$$: "System.Double",
        get_ClusterPaddingP: function (){
            return this._ClusterPaddingP;
        },
        set_ClusterPaddingP: function (value){
            this._ClusterPaddingP = value;
        },
        IsHorizontal$$: "System.Boolean",
        get_IsHorizontal: function (){
            return this._IsHorizontal;
        },
        set_IsHorizontal: function (value){
            this._IsHorizontal = value;
        },
        ctor$$Boolean$$Double$$Double$$Double$$Double: function (isHorizontal, padding, paddingP, clusterPadding, clusterPaddingP){
            this.clusterHierarchies = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ctor);
            this.nextNodeId = 0;
            this._Padding = 0;
            this._PaddingP = 0;
            this._ClusterPadding = 0;
            this._ClusterPaddingP = 0;
            this._IsHorizontal = false;
            System.Object.ctor.call(this);
            Microsoft.Msagl.Core.ValidateArg.IsPositive(padding, "padding");
            this.set_IsHorizontal(isHorizontal);
            this.set_Padding(padding);
            this.set_PaddingP(paddingP);
            this.set_ClusterPadding(clusterPadding);
            this.set_ClusterPaddingP(clusterPaddingP);
            this.clusterHierarchies.Add(new Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ctor$$UInt32$$OverlapRemovalCluster$$Object$$Double$$Double(0, null, 0, this.get_Padding(), this.get_PaddingP()));
            this.nextNodeId += Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.get_NumInternalNodes();
        },
        ctor$$Boolean$$Double$$Double: function (isHorizontal, padding, paddingP){
            this.clusterHierarchies = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ctor);
            this.nextNodeId = 0;
            this._Padding = 0;
            this._PaddingP = 0;
            this._ClusterPadding = 0;
            this._ClusterPaddingP = 0;
            this._IsHorizontal = false;
            Microsoft.Msagl.Core.Geometry.ConstraintGenerator.ctor$$Boolean$$Double$$Double$$Double$$Double.call(this, isHorizontal, padding, paddingP, padding, paddingP);
        },
        AddNode: function (initialCluster, userData, position, positionP, size, sizeP, weight){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(initialCluster, "initialCluster");
            System.Diagnostics.Debug.Assert$$Boolean$$String(null != initialCluster, "initialCluster must not be null");
            var nodNew = new Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.ctor$$UInt32$$Object$$Double$$Double$$Double$$Double$$Double(this.nextNodeId++, userData, position, positionP, size, sizeP, weight);
            initialCluster.AddNode(nodNew);
            return nodNew;
        },
        AddCluster$$OverlapRemovalCluster$$Object$$BorderInfo$$BorderInfo$$BorderInfo$$BorderInfo: function (parentCluster, userData, openBorderInfo, closeBorderInfo, openBorderInfoP, closeBorderInfoP){
            return this.AddCluster$$OverlapRemovalCluster$$Object$$Double$$Double$$BorderInfo$$BorderInfo$$BorderInfo$$BorderInfo(parentCluster, userData, 0, 0, openBorderInfo, closeBorderInfo, openBorderInfoP, closeBorderInfoP);
        },
        AddCluster$$OverlapRemovalCluster$$Object$$Double$$Double$$BorderInfo$$BorderInfo$$BorderInfo$$BorderInfo: function (parentCluster, userData, minimumSize, minimumSizeP, openBorderInfo, closeBorderInfo, openBorderInfoP, closeBorderInfoP){
            var newCluster = new Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ctor$$UInt32$$OverlapRemovalCluster$$Object$$Double$$Double$$Double$$Double$$Double$$Double$$BorderInfo$$BorderInfo$$BorderInfo$$BorderInfo(this.nextNodeId, parentCluster, userData, minimumSize, minimumSizeP, this.get_Padding(), this.get_PaddingP(), this.get_ClusterPadding(), this.get_ClusterPaddingP(), openBorderInfo, closeBorderInfo, openBorderInfoP, closeBorderInfoP);
            this.nextNodeId += Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.get_NumInternalNodes();
            if (null == parentCluster){
                this.clusterHierarchies.Add(newCluster);
            }
            else {
                parentCluster.AddNode(newCluster);
            }
            return newCluster;
        },
        AddCluster$$OverlapRemovalCluster$$Object: function (parentCluster, userData){
            return this.AddCluster$$OverlapRemovalCluster$$Object$$BorderInfo$$BorderInfo$$BorderInfo$$BorderInfo(parentCluster, userData, new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double(0), new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double(0), new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double(0), new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double(0));
        },
        AddCluster$$OverlapRemovalCluster$$Object$$Double$$Double: function (parentCluster, userData, minimumSize, minimumSizeP){
            return this.AddCluster$$OverlapRemovalCluster$$Object$$Double$$Double$$BorderInfo$$BorderInfo$$BorderInfo$$BorderInfo(parentCluster, userData, minimumSize, minimumSizeP, new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double(0), new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double(0), new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double(0), new Microsoft.Msagl.Core.Geometry.BorderInfo.ctor$$Double(0));
        },
        AddNodeToCluster: function (cluster, node){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(cluster, "cluster");
            if (Is(node, Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ctor)){
                throw $CreateException(new System.InvalidOperationException.ctor$$String("Argument \'node\' must not be a Cluster"), new Error());
            }
            cluster.AddNode(node);
        },
        Generate: function (solver, parameters){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(solver, "solver");
            if (null == parameters){
                parameters = new Microsoft.Msagl.Core.Geometry.OverlapRemovalParameters.ctor();
            }
            var $it972 = this.clusterHierarchies.GetEnumerator();
            while ($it972.MoveNext()){
                var cluster = $it972.get_Current();
                cluster.Generate(solver, parameters, this.get_IsHorizontal());
            }
            solver.UpdateVariables();
        },
        Solve: function (solver, parameters, doGenerate){
            if (null == solver){
                solver = new Microsoft.Msagl.Core.ProjectionSolver.Solver.ctor();
            }
            if (null == parameters){
                parameters = new Microsoft.Msagl.Core.Geometry.OverlapRemovalParameters.ctor();
            }
            if (doGenerate){
                this.Generate(solver, parameters);
            }
            var solverSolution = solver.Solve$$Parameters(parameters.get_SolverParameters());
            var $it973 = this.clusterHierarchies.GetEnumerator();
            while ($it973.MoveNext()){
                var cluster = $it973.get_Current();
                cluster.UpdateFromVariable();
            }
            return solverSolution;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$ConstraintGenerator);
var Microsoft$Msagl$Core$Geometry$OverlapRemovalNode = {
    fullname: "Microsoft.Msagl.Core.Geometry.OverlapRemovalNode",
    baseTypeName: "System.Object",
    staticDefinition: {
        Overlap: function (n1, n2, padding){
            return ((n1.get_Size() + n2.get_Size()) / 2) + padding - System.Math.Abs$$Double(n1.get_Position() - n2.get_Position());
        },
        OverlapP: function (n1, n2, paddingP){
            return ((n1.get_SizeP() + n2.get_SizeP()) / 2) + paddingP - System.Math.Abs$$Double(n1.get_PositionP() - n2.get_PositionP());
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.IComparable$1", "System.IComparable"],
    Kind: "Class",
    definition: {
        ctor$$UInt32$$Object$$Double$$Double$$Double$$Double$$Double: function (id, userData, position, positionP, size, sizeP, weight){
            this._UserData = null;
            this._Variable = null;
            this._LeftNeighbors = null;
            this._RightNeighbors = null;
            this._DeferredLeftNeighborToV = false;
            this._DeferredRightNeighborToV = false;
            this._Position = 0;
            this._PositionP = 0;
            this._Size = 0;
            this._SizeP = 0;
            this._Weight = 0;
            this._Id = 0;
            System.Object.ctor.call(this);
            Microsoft.Msagl.Core.ValidateArg.IsPositive(size, "size");
            Microsoft.Msagl.Core.ValidateArg.IsPositive(size, "sizeP");
            Microsoft.Msagl.Core.ValidateArg.IsPositive(weight, "weight");
            if (weight <= 0){
                throw $CreateException(new System.ArgumentOutOfRangeException.ctor$$String$$String("weight", "Invalid node properties"), new Error());
            }
            var dblCheck = (System.Math.Abs$$Double(position) + size) * weight;
            if (System.Double.IsInfinity(dblCheck) || System.Double.IsNaN(dblCheck)){
                throw $CreateException(new System.ArgumentOutOfRangeException.ctor$$String$$String("position", "Invalid node properties"), new Error());
            }
            dblCheck = (System.Math.Abs$$Double(positionP) + sizeP) * weight;
            if (System.Double.IsInfinity(dblCheck) || System.Double.IsNaN(dblCheck)){
                throw $CreateException(new System.ArgumentOutOfRangeException.ctor$$String$$String("positionP", "Invalid node properties"), new Error());
            }
            this.set_Id(id);
            this.set_UserData(userData);
            this.set_Position(position);
            this.set_PositionP(positionP);
            this.set_Size(size);
            this.set_SizeP(sizeP);
            this.set_Weight(weight);
        },
        UserData$$: "System.Object",
        get_UserData: function (){
            return this._UserData;
        },
        set_UserData: function (value){
            this._UserData = value;
        },
        UserDataString$$: "System.String",
        get_UserDataString: function (){
            return (null == this.get_UserData()) ? "-0-" : this.get_UserData().toString();
        },
        Variable$$: "Microsoft.Msagl.Core.ProjectionSolver.Variable",
        get_Variable: function (){
            return this._Variable;
        },
        set_Variable: function (value){
            this._Variable = value;
        },
        LeftNeighbors$$: "System.Collections.Generic.List`1[[Microsoft.Msagl.Core.Geometry.OverlapRemovalNode]]",
        get_LeftNeighbors: function (){
            return this._LeftNeighbors;
        },
        set_LeftNeighbors: function (value){
            this._LeftNeighbors = value;
        },
        RightNeighbors$$: "System.Collections.Generic.List`1[[Microsoft.Msagl.Core.Geometry.OverlapRemovalNode]]",
        get_RightNeighbors: function (){
            return this._RightNeighbors;
        },
        set_RightNeighbors: function (value){
            this._RightNeighbors = value;
        },
        DeferredLeftNeighborToV$$: "System.Boolean",
        get_DeferredLeftNeighborToV: function (){
            return this._DeferredLeftNeighborToV;
        },
        set_DeferredLeftNeighborToV: function (value){
            this._DeferredLeftNeighborToV = value;
        },
        DeferredRightNeighborToV$$: "System.Boolean",
        get_DeferredRightNeighborToV: function (){
            return this._DeferredRightNeighborToV;
        },
        set_DeferredRightNeighborToV: function (value){
            this._DeferredRightNeighborToV = value;
        },
        Position$$: "System.Double",
        get_Position: function (){
            return this._Position;
        },
        set_Position: function (value){
            this._Position = value;
        },
        PositionP$$: "System.Double",
        get_PositionP: function (){
            return this._PositionP;
        },
        set_PositionP: function (value){
            this._PositionP = value;
        },
        Size$$: "System.Double",
        get_Size: function (){
            return this._Size;
        },
        set_Size: function (value){
            this._Size = value;
        },
        SizeP$$: "System.Double",
        get_SizeP: function (){
            return this._SizeP;
        },
        set_SizeP: function (value){
            this._SizeP = value;
        },
        Open$$: "System.Double",
        get_Open: function (){
            return this.get_Position() - (this.get_Size() / 2);
        },
        Close$$: "System.Double",
        get_Close: function (){
            return this.get_Position() + (this.get_Size() / 2);
        },
        OpenP$$: "System.Double",
        get_OpenP: function (){
            return this.get_PositionP() - (this.get_SizeP() / 2);
        },
        CloseP$$: "System.Double",
        get_CloseP: function (){
            return this.get_PositionP() + (this.get_SizeP() / 2);
        },
        Weight$$: "System.Double",
        get_Weight: function (){
            return this._Weight;
        },
        set_Weight: function (value){
            this._Weight = value;
        },
        Id$$: "System.UInt32",
        get_Id: function (){
            return this._Id;
        },
        set_Id: function (value){
            this._Id = value;
        },
        ctor$$UInt32$$Object: function (id, userData){
            this._UserData = null;
            this._Variable = null;
            this._LeftNeighbors = null;
            this._RightNeighbors = null;
            this._DeferredLeftNeighborToV = false;
            this._DeferredRightNeighborToV = false;
            this._Position = 0;
            this._PositionP = 0;
            this._Size = 0;
            this._SizeP = 0;
            this._Weight = 0;
            this._Id = 0;
            Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.ctor$$UInt32$$Object$$Double$$Double$$Double$$Double$$Double.call(this, id, userData, 0, 0, 0, 0, Microsoft.Msagl.Core.Geometry.BorderInfo.get_DefaultFreeWeight());
        },
        CreateVariable: function (solver){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(solver, "solver");
            if (null == this.get_Variable()){
                this.set_Variable(solver.AddVariable$$Object$$Double$$Double(this, this.get_Position(), this.get_Weight()));
            }
            else {
                this.UpdateDesiredPosition(this.get_Position());
            }
        },
        UpdateFromVariable: function (){
            if (null != this.get_Variable()){
                this.set_Position(this.get_Variable().get_ActualPos());
                this.set_Variable(null);
            }
        },
        UpdateDesiredPosition: function (newPosition){
            this.set_Position(newPosition);
            this.get_Variable().set_DesiredPos(newPosition);
        },
        toString: function (){
            return System.String.Format$$IFormatProvider$$String$$Object$Array(System.Globalization.CultureInfo.get_InvariantCulture(), "Nod \'{0}\': id {1} p {2:F5} s {3:F5} pP {4:F5} sP {5:F5}", [this.get_UserDataString(), this.get_Id(), this.get_Position(), this.get_Size(), this.get_PositionP(), this.get_SizeP()]);
        },
        CompareTo$$OverlapRemovalNode: function (other){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(other, "other");
            var cmp = this.get_Position().CompareTo$$Double(other.get_Position());
            if (0 == cmp){
                cmp = this.get_Id().CompareTo$$UInt32(other.get_Id());
            }
            return cmp;
        },
        CompareTo$$Object: function (obj){
            var rhs = As(obj, Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.ctor);
            if (null == rhs){
                throw $CreateException(new System.InvalidOperationException.ctor$$String("Argument \'obj\' must be a Node"), new Error());
            }
            return this.CompareTo$$OverlapRemovalNode(rhs);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$OverlapRemovalNode);
var Microsoft$Msagl$Core$Geometry$NodeComparer = {
    fullname: "Microsoft.Msagl.Core.Geometry.NodeComparer",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IComparer$1"],
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        },
        Compare: function (lhs, rhs){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(lhs, "lhs");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(rhs, "rhs");
            return lhs.CompareTo$$OverlapRemovalNode(rhs);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$NodeComparer);
var Microsoft$Msagl$Routing$Rectilinear$Nudging$SegWithIndex = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.Nudging.SegWithIndex",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (pts, i){
            this.Points = null;
            this.I = 0;
            this._hashKey = null;
            System.Object.ctor.call(this);
            System.Diagnostics.Debug.Assert$$Boolean(i < pts.length && i >= 0);
            this.Points = pts;
            this.I = i;
            this.UpdateHashKey();
        },
        Start$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Start: function (){
            return this.Points[this.I];
        },
        End$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_End: function (){
            return this.Points[this.I + 1];
        },
        Equals$$Object: function (obj){
            var other = Cast(obj, Microsoft.Msagl.Routing.Rectilinear.Nudging.SegWithIndex.ctor);
            return other.Points == this.Points && other.I == this.I;
        },
        GetHashCode: function (){
            return (this.Points.GetHashCode() * 397) ^ this.I;
        },
        UpdateHashKey: function (){
            this._hashKey = this.GetHashCode().toString();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$Nudging$SegWithIndex);
var Microsoft$Msagl$Routing$Rectilinear$Nudging$StaircaseRemover = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.Nudging.StaircaseRemover",
    baseTypeName: "System.Object",
    staticDefinition: {
        RemoveStaircases: function (paths, hierarchyOfObstacles){
            var r = new Microsoft.Msagl.Routing.Rectilinear.Nudging.StaircaseRemover.ctor(paths, hierarchyOfObstacles);
            r.Calculate();
        },
        GetFlippedPoint: function (pts, offset){
            var horiz = Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(pts[offset].get_Y(), pts[offset + 1].get_Y());
            return horiz ? new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(pts[offset + 4].get_X(), pts[offset].get_Y()) : new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(pts[offset].get_X(), pts[offset + 4].get_Y());
        },
        IsCrossing: function (ls, rTree, segsToIgnore){
            return System.Linq.Enumerable.Any$1$$IEnumerable$1(Microsoft.Msagl.Routing.Rectilinear.Nudging.SegWithIndex.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.Nudging.SegWithIndex.ctor, rTree.GetAllIntersecting(ls.get_BoundingBox()), function (seg){
                return !System.Linq.Enumerable.Contains$1$$IEnumerable$1$$TSource(Microsoft.Msagl.Routing.Rectilinear.Nudging.SegWithIndex.ctor, segsToIgnore, seg);
            }));
        },
        Rect: function (seg){
            return new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(seg.get_Start(), seg.get_End());
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (paths, hierarchyOfObstacles){
            this.segTree = new Microsoft.Msagl.Core.Geometry.RTree$1.ctor(Microsoft.Msagl.Routing.Rectilinear.Nudging.SegWithIndex.ctor);
            this.crossedOutPaths = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.ctor);
            this._Paths = null;
            this._HierarchyOfObstacles = null;
            System.Object.ctor.call(this);
            this.set_HierarchyOfObstacles(new Microsoft.Msagl.Core.Geometry.RTree$1.ctor$$RectangleNode$1(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, hierarchyOfObstacles));
            this.set_Paths(paths);
        },
        Paths$$: "System.Collections.Generic.List`1[[Microsoft.Msagl.Routing.Rectilinear.Nudging.Path]]",
        get_Paths: function (){
            return this._Paths;
        },
        set_Paths: function (value){
            this._Paths = value;
        },
        HierarchyOfObstacles$$: "Microsoft.Msagl.Core.Geometry.RTree`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]",
        get_HierarchyOfObstacles: function (){
            return this._HierarchyOfObstacles;
        },
        set_HierarchyOfObstacles: function (value){
            this._HierarchyOfObstacles = value;
        },
        Calculate: function (){
            this.InitHierarchies();
            var success;
            do{
                success = false;
                var $it974 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.ctor, this.get_Paths(), $CreateAnonymousDelegate(this, function (p){
                    return !this.crossedOutPaths.Contains$$T(p);
                })).GetEnumerator();
                while ($it974.MoveNext()){
                    var path = $it974.get_Current();
                    success |= this.ProcessPath(path);
                }
            }
            while (success)
        },
        ProcessPath: function (path){
            var pts = path.get_PathPoints() instanceof Array || path.get_PathPoints() == null ? path.get_PathPoints() : (function (){
                throw new Error("InvalidCastException");
            }
            ());
            var canHaveStaircase;
            if ((function (){
                var $1 = {
                    Value: pts
                };
                var $2 = {
                    Value: canHaveStaircase
                };
                var $res = this.ProcessPoints($1, $2);
                pts = $1.Value;
                canHaveStaircase = $2.Value;
                return $res;
            }).call(this)){
                path.set_PathPoints(pts);
                return true;
            }
            if (!canHaveStaircase)
                this.crossedOutPaths.Insert(path);
            return false;
        },
        ProcessPoints: function (pts, canHaveStaircase){
            var staircaseStart = this.FindStaircaseStart(pts.Value, canHaveStaircase);
            if (staircaseStart < 0)
                return false;
            pts.Value = this.RemoveStaircase$$Point$Array$$Int32(pts.Value, staircaseStart);
            return true;
        },
        FindStaircaseStart: function (pts, canHaveStaircase){
            canHaveStaircase.Value = false;
            if (pts.length < 5)
                return -1;
            var segs = [new Microsoft.Msagl.Routing.Rectilinear.Nudging.SegWithIndex.ctor(pts, 0), new Microsoft.Msagl.Routing.Rectilinear.Nudging.SegWithIndex.ctor(pts, 1), new Microsoft.Msagl.Routing.Rectilinear.Nudging.SegWithIndex.ctor(pts, 2), new Microsoft.Msagl.Routing.Rectilinear.Nudging.SegWithIndex.ctor(pts, 3)];
            var segToReplace = 0;
            for (var i = 0; ;){
                var canHaveStaircaseAtI;
                if ((function (){
                    var $1 = {
                        Value: canHaveStaircaseAtI
                    };
                    var $res = this.IsStaircase(pts, i, segs, $1);
                    canHaveStaircaseAtI = $1.Value;
                    return $res;
                }).call(this)){
                    canHaveStaircase.Value = true;
                    return i;
                }
                canHaveStaircase.Value = canHaveStaircase.Value || canHaveStaircaseAtI;
                i++;
                if (pts.length < i + 5)
                    return -1;
                segs[segToReplace] = new Microsoft.Msagl.Routing.Rectilinear.Nudging.SegWithIndex.ctor(pts, i + 3);
                segToReplace += 1;
                segToReplace %= 4;
            }
        },
        Crossing: function (a, b, segsToIgnore){
            return Microsoft.Msagl.Routing.Rectilinear.Nudging.StaircaseRemover.IsCrossing(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(a, b), this.segTree, segsToIgnore);
        },
        IntersectObstacleHierarchy$$Point$$Point$$Point: function (a, b, c){
            return this.IntersectObstacleHierarchy$$LineSegment(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(a, b)) || this.IntersectObstacleHierarchy$$LineSegment(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(b, c));
        },
        IntersectObstacleHierarchy$$LineSegment: function (ls){
            return System.Linq.Enumerable.Any$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, this.get_HierarchyOfObstacles().GetAllIntersecting(ls.get_BoundingBox()), $CreateAnonymousDelegate(this, function (poly){
                return Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveIntersectionOne(ls, poly, false) != null;
            }));
        },
        IsStaircase: function (pts, offset, segsToIgnore, canHaveStaircaseAtI){
            var a = pts[offset];
            var b = pts[offset + 1];
            var c = pts[offset + 2];
            var d = pts[offset + 3];
            var f = pts[offset + 4];
            canHaveStaircaseAtI.Value = false;
            if (Microsoft.Msagl.Core.Geometry.CompassVector.DirectionsFromPointToPoint(a, b) != Microsoft.Msagl.Core.Geometry.CompassVector.DirectionsFromPointToPoint(c, d) || Microsoft.Msagl.Core.Geometry.CompassVector.DirectionsFromPointToPoint(b, c) != Microsoft.Msagl.Core.Geometry.CompassVector.DirectionsFromPointToPoint(d, f))
                return false;
            c = Microsoft.Msagl.Routing.Rectilinear.Nudging.StaircaseRemover.GetFlippedPoint(pts, offset);
            if (this.IntersectObstacleHierarchy$$Point$$Point$$Point(b, c, d))
                return false;
            canHaveStaircaseAtI.Value = true;
            return !this.Crossing(b, c, segsToIgnore);
        },
        RemoveStaircase$$Point$Array$$Int32: function (pts, staircaseStart){
            var a = pts[staircaseStart];
            var b = pts[staircaseStart + 1];
            var horiz = System.Math.Abs$$Double(a.get_Y() - b.get_Y()) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon / 2;
            return this.RemoveStaircase$$Point$Array$$Int32$$Boolean(pts, staircaseStart, horiz);
        },
        RemoveStaircase$$Point$Array$$Int32$$Boolean: function (pts, staircaseStart, horiz){
            this.RemoveSegs(pts);
            var ret = new Array(pts.length - 2);
            System.Array.Copy(pts, ret, staircaseStart + 1);
            var a = pts[staircaseStart + 1];
            var c = pts[staircaseStart + 3];
            ret[staircaseStart + 1] = horiz ? new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(c.get_X(), a.get_Y()) : new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(a.get_X(), c.get_Y());
            System.Array.Copy(pts, staircaseStart + 4, ret, staircaseStart + 2, ret.length - staircaseStart - 2);
            this.InsertNewSegs(ret, staircaseStart);
            return ret;
        },
        RemoveSegs: function (pts){
            for (var i = 0; i < pts.length - 1; i++)
                this.RemoveSeg(new Microsoft.Msagl.Routing.Rectilinear.Nudging.SegWithIndex.ctor(pts, i));
        },
        RemoveSeg: function (seg){
            this.segTree.Remove(Microsoft.Msagl.Routing.Rectilinear.Nudging.StaircaseRemover.Rect(seg), seg);
        },
        InsertNewSegs: function (pts, staircaseStart){
            this.InsSeg(pts, staircaseStart);
            this.InsSeg(pts, staircaseStart + 1);
        },
        InitHierarchies: function (){
            var $it975 = this.get_Paths().GetEnumerator();
            while ($it975.MoveNext()){
                var path = $it975.get_Current();
                this.InsertPathSegs(path);
            }
        },
        InsertPathSegs: function (path){
            this.InsertSegs(path.get_PathPoints() instanceof Array || path.get_PathPoints() == null ? path.get_PathPoints() : (function (){
                throw new Error("InvalidCastException");
            }
            ()));
        },
        InsertSegs: function (pts){
            for (var i = 0; i < pts.length - 1; i++)
                this.InsSeg(pts, i);
        },
        InsSeg: function (pts, i){
            var seg = new Microsoft.Msagl.Routing.Rectilinear.Nudging.SegWithIndex.ctor(pts, i);
            this.segTree.Add$$Rectangle$$TData(Microsoft.Msagl.Routing.Rectilinear.Nudging.StaircaseRemover.Rect(seg), seg);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$Nudging$StaircaseRemover);
var Microsoft$Msagl$Routing$Rectilinear$GroupBoundaryCrossing = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.GroupBoundaryCrossing",
    baseTypeName: "System.Object",
    staticDefinition: {
        BoundaryWidth$$: "System.Double",
        get_BoundaryWidth: function (){
            return Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (group, dirToInside){
            this._Group = null;
            this._DirectionToInside = Microsoft.Msagl.Core.Geometry.Directions.None;
            System.Object.ctor.call(this);
            System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Core.Geometry.CompassVector.IsPureDirection$$Directions(dirToInside), "Impure direction");
            this.set_Group(group);
            this.set_DirectionToInside(dirToInside);
        },
        Group$$: "Microsoft.Msagl.Routing.Rectilinear.Obstacle",
        get_Group: function (){
            return this._Group;
        },
        set_Group: function (value){
            this._Group = value;
        },
        DirectionToInside$$: "Microsoft.Msagl.Core.Geometry.Directions",
        get_DirectionToInside: function (){
            return this._DirectionToInside;
        },
        set_DirectionToInside: function (value){
            this._DirectionToInside = value;
        },
        GetInteriorVertexPoint: function (outerVertex){
            return Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Addition(outerVertex, (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(Microsoft.Msagl.Core.Geometry.CompassVector.ToPoint$$Directions(this.get_DirectionToInside()), Microsoft.Msagl.Routing.Rectilinear.GroupBoundaryCrossing.get_BoundaryWidth()))));
        },
        toString: function (){
            return System.String.Format$$IFormatProvider$$String$$Object$Array(System.Globalization.CultureInfo.get_InvariantCulture(), "{0} {1}", [this.get_DirectionToInside(), this.get_Group()]);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$GroupBoundaryCrossing);
var Microsoft$Msagl$Routing$Rectilinear$GroupBoundaryCrossingMap = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.GroupBoundaryCrossingMap",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.pointCrossingMap = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Collections.Generic.List$1.ctor);
            this.pointList = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            System.Object.ctor.call(this);
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this.pointCrossingMap.get_Count();
        },
        AddIntersection: function (intersection, group, dirToInside){
            var crossings;
            if (!(function (){
                var $1 = {
                    Value: crossings
                };
                var $res = this.pointCrossingMap.TryGetValue(intersection, $1);
                crossings = $1.Value;
                return $res;
            }).call(this)){
                crossings = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Rectilinear.GroupBoundaryCrossing.ctor);
                this.pointCrossingMap.set_Item$$TKey(intersection, crossings);
            }
            var crossingsCount = crossings.get_Count();
            for (var ii = 0; ii < crossingsCount; ++ii){
                var crossing = crossings.get_Item$$Int32(ii);
                if (crossing.get_Group() == group){
                    System.Diagnostics.Debug.Assert$$Boolean$$String(dirToInside == crossing.get_DirectionToInside(), "Mismatched dirToInside");
                    return crossing;
                }
            }
            var newCrossing = new Microsoft.Msagl.Routing.Rectilinear.GroupBoundaryCrossing.ctor(group, dirToInside);
            crossings.Add(newCrossing);
            return newCrossing;
        },
        GetCrossings: function (intersection){
            var crossings;
            (function (){
                var $1 = {
                    Value: crossings
                };
                var $res = this.pointCrossingMap.TryGetValue(intersection, $1);
                crossings = $1.Value;
                return $res;
            }).call(this);
            return crossings;
        },
        Clear: function (){
            this.pointCrossingMap.Clear();
        },
        GetOrderedListBetween: function (start, end){
            if (0 == this.pointCrossingMap.get_Count()){
                return null;
            }
            if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Point$$Point(start, end) > 0){
                var temp = start;
                start = end;
                end = temp;
            }
            this.pointList.Clear();
            var $it976 = this.pointCrossingMap.get_Keys().GetEnumerator();
            while ($it976.MoveNext()){
                var intersection = $it976.get_Current();
                if ((Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Point$$Point(intersection, start) >= 0) && (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Point$$Point(intersection, end) <= 0)){
                    this.pointList.Add(intersection);
                }
            }
            this.pointList.Sort();
            var pointAndCrossingList = new Microsoft.Msagl.Routing.Rectilinear.PointAndCrossingsList.ctor();
            var numCrossings = this.pointList.get_Count();
            for (var ii = 0; ii < numCrossings; ++ii){
                var intersect = this.pointList.get_Item$$Int32(ii);
                pointAndCrossingList.Add(intersect, this.pointCrossingMap.get_Item$$TKey(intersect));
            }
            return pointAndCrossingList;
        },
        toString: function (){
            return System.String.Format$$IFormatProvider$$String$$Object$Array(System.Globalization.CultureInfo.get_InvariantCulture(), "{0}", [this.pointCrossingMap.get_Count()]);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$GroupBoundaryCrossingMap);
var Microsoft$Msagl$Routing$Rectilinear$PointAndCrossings = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.PointAndCrossings",
    baseTypeName: "System.ValueType",
    assemblyName: "Microsoft.Msagl",
    Kind: "Struct",
    definition: {
        ctor$$Point$$List$1$GroupBoundaryCrossing: function (loc, crossings){
            this._Location = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._Crossings = null;
            Microsoft.Msagl.Routing.Rectilinear.PointAndCrossings.ctor.call(this);
            this.set_Location(loc);
            this.set_Crossings(crossings);
        },
        Location$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Location: function (){
            return this._Location;
        },
        set_Location: function (value){
            this._Location = value;
        },
        Crossings$$: "System.Collections.Generic.List`1[[Microsoft.Msagl.Routing.Rectilinear.GroupBoundaryCrossing]]",
        get_Crossings: function (){
            return this._Crossings;
        },
        set_Crossings: function (value){
            this._Crossings = value;
        },
        ctor: function (){
            this._Location = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._Crossings = null;
            System.ValueType.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$PointAndCrossings);
var Microsoft$Msagl$Routing$Rectilinear$PointAndCrossingsList = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.PointAndCrossingsList",
    baseTypeName: "System.Object",
    staticDefinition: {
        ToCrossingArray: function (crossings, dirToInside){
            var numInDir = 0;
            var crossingsCount = crossings.get_Count();
            for (var ii = 0; ii < crossingsCount; ++ii){
                if (crossings.get_Item$$Int32(ii).get_DirectionToInside() == dirToInside){
                    ++numInDir;
                }
            }
            if (0 == numInDir){
                return null;
            }
            var vector = new Array(numInDir);
            var jj = 0;
            for (var ii = 0; ii < crossingsCount; ++ii){
                if (crossings.get_Item$$Int32(ii).get_DirectionToInside() == dirToInside){
                    vector[jj++] = crossings.get_Item$$Int32(ii);
                }
            }
            return vector;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.index = 0;
            this._ListOfPointsAndCrossings = null;
            System.Object.ctor.call(this);
            this.set_ListOfPointsAndCrossings(new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Rectilinear.PointAndCrossings.ctor));
        },
        ListOfPointsAndCrossings$$: "System.Collections.Generic.List`1[[Microsoft.Msagl.Routing.Rectilinear.PointAndCrossings]]",
        get_ListOfPointsAndCrossings: function (){
            return this._ListOfPointsAndCrossings;
        },
        set_ListOfPointsAndCrossings: function (value){
            this._ListOfPointsAndCrossings = value;
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this.get_ListOfPointsAndCrossings().get_Count();
        },
        Add: function (intersect, crossings){
            this.get_ListOfPointsAndCrossings().Add(new Microsoft.Msagl.Routing.Rectilinear.PointAndCrossings.ctor$$Point$$List$1$GroupBoundaryCrossing(intersect, crossings));
        },
        Pop: function (){
            System.Diagnostics.Debug.Assert$$Boolean$$String(this.index < this.get_ListOfPointsAndCrossings().get_Count(), "Unexpected call to Next()");
            return this.get_ListOfPointsAndCrossings().get_Item$$Int32(this.index++);
        },
        CurrentIsBeforeOrAt: function (comparand){
            if (this.index >= this.get_ListOfPointsAndCrossings().get_Count()){
                return false;
            }
            return Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Point$$Point(this.get_ListOfPointsAndCrossings().get_Item$$Int32(this.index).get_Location(), comparand) <= 0;
        },
        First$$: "Microsoft.Msagl.Routing.Rectilinear.PointAndCrossings",
        get_First: function (){
            return this.get_ListOfPointsAndCrossings().get_Item$$Int32(0);
        },
        Last$$: "Microsoft.Msagl.Routing.Rectilinear.PointAndCrossings",
        get_Last: function (){
            return this.get_ListOfPointsAndCrossings().get_Item$$Int32(this.get_ListOfPointsAndCrossings().get_Count() - 1);
        },
        Reset: function (){
            this.index = 0;
        },
        MergeFrom: function (other){
            this.Reset();
            if ((null == other) || (0 == other.get_ListOfPointsAndCrossings().get_Count())){
                return;
            }
            if (0 == this.get_ListOfPointsAndCrossings().get_Count()){
                this.get_ListOfPointsAndCrossings().AddRange(other.get_ListOfPointsAndCrossings());
            }
            if (null == this.get_ListOfPointsAndCrossings()){
                this.set_ListOfPointsAndCrossings(new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Microsoft.Msagl.Routing.Rectilinear.PointAndCrossings.ctor, other.get_ListOfPointsAndCrossings()));
                return;
            }
            var thisIndex = 0,thisMax = this.get_ListOfPointsAndCrossings().get_Count();
            var otherIndex = 0,otherMax = other.get_ListOfPointsAndCrossings().get_Count();
            var newCrossingsList = new System.Collections.Generic.List$1.ctor$$Int32(Microsoft.Msagl.Routing.Rectilinear.PointAndCrossings.ctor, this.get_ListOfPointsAndCrossings().get_Count());
            while ((thisIndex < thisMax) || (otherIndex < otherMax)){
                if (thisIndex >= thisMax){
                    newCrossingsList.Add(other.get_ListOfPointsAndCrossings().get_Item$$Int32(otherIndex++));
                    continue;
                }
                if (otherIndex >= otherMax){
                    newCrossingsList.Add(this.get_ListOfPointsAndCrossings().get_Item$$Int32(thisIndex++));
                    continue;
                }
                var thisPac = this.get_ListOfPointsAndCrossings().get_Item$$Int32(thisIndex);
                var otherPac = other.get_ListOfPointsAndCrossings().get_Item$$Int32(otherIndex);
                var cmp = Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Point$$Point(thisPac.get_Location(), otherPac.get_Location());
                if (0 == cmp){
                    newCrossingsList.Add(thisPac);
                    ++thisIndex;
                    ++otherIndex;
                }
                else if (-1 == cmp){
                    newCrossingsList.Add(thisPac);
                    ++thisIndex;
                }
                else {
                    newCrossingsList.Add(otherPac);
                    ++otherIndex;
                }
            }
            this.set_ListOfPointsAndCrossings(newCrossingsList);
        },
        Trim: function (start, end){
            this.Reset();
            if ((null == this.get_ListOfPointsAndCrossings()) || (0 == this.get_ListOfPointsAndCrossings().get_Count())){
                return;
            }
            this.set_ListOfPointsAndCrossings(new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Microsoft.Msagl.Routing.Rectilinear.PointAndCrossings.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.PointAndCrossings.ctor, this.get_ListOfPointsAndCrossings(), $CreateAnonymousDelegate(this, function (pair){
                return (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Point$$Point(pair.get_Location(), start) >= 0) && (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Point$$Point(pair.get_Location(), end) <= 0);
            }))));
        },
        toString: function (){
            return System.String.Format$$IFormatProvider$$String$$Object$Array(System.Globalization.CultureInfo.get_InvariantCulture(), "{0} [{1}]", [this.get_ListOfPointsAndCrossings().get_Count(), this.index]);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$PointAndCrossingsList);
var Microsoft$Msagl$Routing$Rectilinear$ObstacleTree = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.ObstacleTree",
    baseTypeName: "System.Object",
    staticDefinition: {
        CalculateHierarchy: function (obstacles){
            var rectNodes = System.Linq.Enumerable.ToList$1(Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor, Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, obstacles, function (obs){
                return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor, obs, obs.get_VisibilityBoundingBox());
            }));
            return Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnListOfNodes(rectNodes);
        },
        FirstRectangleContainsACornerOfTheOther: function (a, b){
            return a.Contains$$Point(b.get_LeftBottom()) || a.Contains$$Point(b.get_LeftTop()) || a.Contains$$Point(b.get_RightTop()) || a.Contains$$Point(b.get_RightBottom());
        },
        FirstPolylineStartIsInsideSecondPolyline: function (first, second){
            return Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(first.get_Start(), second) != Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside;
        },
        ResolveGroupAndGroupOverlap: function (a, b){
            if (!b.get_IsGroup()){
                return false;
            }
            if (a.get_VisibilityPolyline().get_BoundingBox().get_Area() > b.get_VisibilityPolyline().get_BoundingBox().get_Area()){
                Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.ResolveGroupAndObstacleOverlap(a, b);
            }
            else {
                Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.ResolveGroupAndObstacleOverlap(b, a);
            }
            return true;
        },
        ResolveGroupAndObstacleOverlap: function (group, obstacle){
            var loosePolyline = obstacle.get_LooseVisibilityPolyline();
            Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.GrowGroupAroundLoosePolyline(group, loosePolyline);
            var aIsInsideB,bIsInsideA;
            while ((function (){
                var $1 = {
                    Value: aIsInsideB
                };
                var $2 = {
                    Value: bIsInsideA
                };
                var $res = Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.ObstaclesIntersect(obstacle, group, $1, $2);
                aIsInsideB = $1.Value;
                bIsInsideA = $2.Value;
                return $res;
            })() || !aIsInsideB){
                loosePolyline = Microsoft.Msagl.Routing.Rectilinear.Obstacle.CreateLoosePolyline(loosePolyline);
                Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.GrowGroupAroundLoosePolyline(group, loosePolyline);
            }
            return;
        },
        GrowGroupAroundLoosePolyline: function (group, loosePolyline){
            var points = System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, group.get_VisibilityPolyline(), function (p){
                return p;
            }), System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, loosePolyline, function (p){
                return p;
            }));
            group.SetConvexHull(new Microsoft.Msagl.Routing.Rectilinear.OverlapConvexHull.ctor(Microsoft.Msagl.Core.Geometry.ConvexHull.CreateConvexHullAsClosedPolyline(points), [group]));
        },
        ObstaclesIntersect: function (a, b, aIsInsideB, bIsInsideA){
            if (Microsoft.Msagl.Core.Geometry.Curves.Curve.CurvesIntersect(a.get_VisibilityPolyline(), b.get_VisibilityPolyline())){
                aIsInsideB.Value = false;
                bIsInsideA.Value = false;
                return true;
            }
            aIsInsideB.Value = Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.FirstPolylineStartIsInsideSecondPolyline(a.get_VisibilityPolyline(), b.get_VisibilityPolyline());
            bIsInsideA.Value = !aIsInsideB.Value && Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.FirstPolylineStartIsInsideSecondPolyline(b.get_VisibilityPolyline(), a.get_VisibilityPolyline());
            if (a.get_IsRectangle() && b.get_IsRectangle()){
                return false;
            }
            if (Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.ObstaclesAreCloseEnoughToBeConsideredTouching(a, b, aIsInsideB.Value, bIsInsideA.Value)){
                aIsInsideB.Value = false;
                bIsInsideA.Value = false;
                return true;
            }
            return false;
        },
        ObstaclesAreCloseEnoughToBeConsideredTouching: function (a, b, aIsInsideB, bIsInsideA){
            if (!aIsInsideB && !bIsInsideA){
                return Microsoft.Msagl.Core.Geometry.Curves.Curve.CurvesIntersect(a.get_LooseVisibilityPolyline(), b.get_VisibilityPolyline());
            }
            var innerLoosePolyline = aIsInsideB ? a.get_LooseVisibilityPolyline() : b.get_LooseVisibilityPolyline();
            var outerPolyline = aIsInsideB ? b.get_VisibilityPolyline() : a.get_VisibilityPolyline();
            var $it985 = innerLoosePolyline.GetEnumerator();
            while ($it985.MoveNext()){
                var innerPoint = $it985.get_Current();
                if (Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(innerPoint, outerPolyline) == Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside){
                    var outerParamPoint = Microsoft.Msagl.Core.Geometry.Curves.Curve.ClosestPoint(outerPolyline, innerPoint);
                    if (!Microsoft.Msagl.Core.Geometry.ApproximateComparer.CloseIntersections(innerPoint, outerParamPoint)){
                        return true;
                    }
                }
            }
            return false;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.AncestorSets = null;
            this.SpatialAncestorsAdjusted = false;
            this.shapeIdToObstacleMap = null;
            this.CurrentGroupBoundaryCrossingMap = new Microsoft.Msagl.Routing.Rectilinear.GroupBoundaryCrossingMap.ctor();
            this.allObstacles = null;
            this.overlapPairs = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor);
            this.hasOverlaps = false;
            this.lookupIntPair = new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(-1, -1);
            this.insideHitTestIgnoreObstacle1 = null;
            this.insideHitTestIgnoreObstacle2 = null;
            this.insideHitTestScanDirection = null;
            this.restrictedIntersectionTestSegment = null;
            this.currentRestrictedRay = null;
            this.wantGroupCrossings = false;
            this.stopAtGroups = false;
            this.restrictedRayLengthSquared = 0;
            this._Root = null;
            System.Object.ctor.call(this);
        },
        Root$$: "Microsoft.Msagl.Core.Geometry.RectangleNode`1[[Microsoft.Msagl.Routing.Rectilinear.Obstacle]]",
        get_Root: function (){
            return this._Root;
        },
        set_Root: function (value){
            this._Root = value;
        },
        GraphBox$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_GraphBox: function (){
            return this.get_Root().get_Rectangle();
        },
        Init: function (obstacles, ancestorSets, idToObstacleMap){
            this.CreateObstacleListAndOrdinals(obstacles);
            this.AncestorSets = ancestorSets;
            this.CreateRoot();
            this.shapeIdToObstacleMap = idToObstacleMap;
        },
        CreateObstacleListAndOrdinals: function (obstacles){
            this.allObstacles = System.Linq.Enumerable.ToList$1(Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor, obstacles);
            var scanlineOrdinal = 10;
            var $it977 = this.allObstacles.GetEnumerator();
            while ($it977.MoveNext()){
                var obstacle = $it977.get_Current();
                obstacle.set_Ordinal(scanlineOrdinal++);
            }
        },
        OrdinalToObstacle: function (index){
            System.Diagnostics.Debug.Assert$$Boolean$$String(index >= 10, "index too small");
            System.Diagnostics.Debug.Assert$$Boolean$$String(index < this.allObstacles.get_Count() + 10, "index too large");
            return this.allObstacles.get_Item$$Int32(index - 10);
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this.shapeIdToObstacleMap.get_Count();
        },
        CreateRoot: function (){
            this.set_Root(Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.CalculateHierarchy(this.GetAllObstacles()));
            if (!this.OverlapsExist()){
                return;
            }
            this.AccreteClumps();
            this.AccreteConvexHulls();
            this.GrowGroupsToAccommodateOverlaps();
            this.set_Root(Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.CalculateHierarchy(System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor, this.GetAllObstacles(), $CreateAnonymousDelegate(this, function (obs){
                return obs.get_IsPrimaryObstacle();
            }))));
        },
        OverlapsExist: function (){
            if (this.get_Root() == null){
                return false;
            }
            Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$1$$RectangleNode$1$$RectangleNode$1$$Action$2(Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor, this.get_Root(), this.get_Root(), $CreateDelegate(this, this.CheckForInitialOverlaps));
            return this.hasOverlaps;
        },
        OverlapPairAlreadyFound: function (a, b){
            this.lookupIntPair.x = b.get_Ordinal();
            this.lookupIntPair.y = a.get_Ordinal();
            return this.overlapPairs.Contains$$T(this.lookupIntPair);
        },
        CheckForInitialOverlaps: function (a, b){
            if (this.hasOverlaps){
                return;
            }
            var aIsInsideB,bIsInsideA;
            if ((function (){
                var $1 = {
                    Value: aIsInsideB
                };
                var $2 = {
                    Value: bIsInsideA
                };
                var $res = Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.ObstaclesIntersect(a, b, $1, $2);
                aIsInsideB = $1.Value;
                bIsInsideA = $2.Value;
                return $res;
            }).call(this)){
                this.hasOverlaps = true;
                return;
            }
            if (!aIsInsideB && !bIsInsideA){
                return;
            }
            if (a.get_IsGroup() && b.get_IsGroup()){
                return;
            }
            if ((a.get_IsGroup() && bIsInsideA) || (b.get_IsGroup() && aIsInsideB)){
                return;
            }
            this.hasOverlaps = true;
        },
        AccreteClumps: function (){
            this.AccumulateObstaclesForClumps();
            if (this.overlapPairs.get_Count() == 0){
                return;
            }
            this.CreateClumps();
        },
        AccreteConvexHulls: function (){
            for (; ;){
                this.AccumulateObstaclesForConvexHulls();
                if (!this.CreateConvexHulls()){
                    return;
                }
            }
        },
        AccumulateObstaclesForClumps: function (){
            this.overlapPairs.Clear();
            var rectangularObstacles = Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.CalculateHierarchy(System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor, this.GetAllObstacles(), $CreateAnonymousDelegate(this, function (obs){
                return !obs.get_IsGroup() && obs.get_IsRectangle();
            })));
            if (rectangularObstacles == null){
                return;
            }
            Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$1$$RectangleNode$1$$RectangleNode$1$$Action$2(Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor, rectangularObstacles, rectangularObstacles, $CreateDelegate(this, this.EvaluateOverlappedPairForClump));
        },
        EvaluateOverlappedPairForClump: function (a, b){
            System.Diagnostics.Debug.Assert$$Boolean$$String(!a.get_IsGroup() && !b.get_IsGroup(), "Groups should not come here");
            System.Diagnostics.Debug.Assert$$Boolean$$String(a.get_IsRectangle() && b.get_IsRectangle(), "Only rectangles should come here");
            if ((a == b) || this.OverlapPairAlreadyFound(a, b)){
                return;
            }
            var aIsInsideB,bIsInsideA;
            if (!(function (){
                var $1 = {
                    Value: aIsInsideB
                };
                var $2 = {
                    Value: bIsInsideA
                };
                var $res = Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.ObstaclesIntersect(a, b, $1, $2);
                aIsInsideB = $1.Value;
                bIsInsideA = $2.Value;
                return $res;
            }).call(this) && !aIsInsideB && !bIsInsideA){
                return;
            }
            this.overlapPairs.Insert(new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(a.get_Ordinal(), b.get_Ordinal()));
        },
        AccumulateObstaclesForConvexHulls: function (){
            this.overlapPairs.Clear();
            var allPrimaryNonGroupObstacles = Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.CalculateHierarchy(System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor, this.GetAllObstacles(), $CreateAnonymousDelegate(this, function (obs){
                return obs.get_IsPrimaryObstacle() && !obs.get_IsGroup();
            })));
            if (allPrimaryNonGroupObstacles == null){
                return;
            }
            Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$1$$RectangleNode$1$$RectangleNode$1$$Action$2(Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor, allPrimaryNonGroupObstacles, allPrimaryNonGroupObstacles, $CreateDelegate(this, this.EvaluateOverlappedPairForConvexHull));
        },
        EvaluateOverlappedPairForConvexHull: function (a, b){
            System.Diagnostics.Debug.Assert$$Boolean$$String(!a.get_IsGroup() && !b.get_IsGroup(), "Groups should not come here");
            if ((a == b) || this.OverlapPairAlreadyFound(a, b)){
                return;
            }
            var aIsInsideB,bIsInsideA;
            if (!(function (){
                var $1 = {
                    Value: aIsInsideB
                };
                var $2 = {
                    Value: bIsInsideA
                };
                var $res = Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.ObstaclesIntersect(a, b, $1, $2);
                aIsInsideB = $1.Value;
                bIsInsideA = $2.Value;
                return $res;
            }).call(this) && !aIsInsideB && !bIsInsideA){
                return;
            }
            if (!a.get_IsInConvexHull() && !b.get_IsInConvexHull()){
                if (a.get_IsRectangle() && b.get_IsRectangle()){
                    return;
                }
            }
            this.overlapPairs.Insert(new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(a.get_Ordinal(), b.get_Ordinal()));
            this.AddClumpToConvexHull(a);
            this.AddClumpToConvexHull(b);
            this.AddConvexHullToConvexHull(a);
            this.AddConvexHullToConvexHull(b);
        },
        GrowGroupsToAccommodateOverlaps: function (){
            for (; ;){
                this.AccumulateObstaclesForGroupOverlaps();
                if (!this.GrowGroupsToResolveOverlaps()){
                    return;
                }
            }
        },
        AccumulateObstaclesForGroupOverlaps: function (){
            var groupObstacles = Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.CalculateHierarchy(System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor, this.GetAllObstacles(), $CreateAnonymousDelegate(this, function (obs){
                return obs.get_IsGroup();
            })));
            var allPrimaryObstacles = Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.CalculateHierarchy(System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor, this.GetAllObstacles(), $CreateAnonymousDelegate(this, function (obs){
                return obs.get_IsPrimaryObstacle();
            })));
            if ((groupObstacles == null) || (allPrimaryObstacles == null)){
                return;
            }
            Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$1$$RectangleNode$1$$RectangleNode$1$$Action$2(Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor, groupObstacles, allPrimaryObstacles, $CreateDelegate(this, this.EvaluateOverlappedPairForGroup));
        },
        EvaluateOverlappedPairForGroup: function (a, b){
            System.Diagnostics.Debug.Assert$$Boolean$$String(a.get_IsGroup(), "Inconsistency in overlapping group enumeration");
            if ((a == b) || this.OverlapPairAlreadyFound(a, b)){
                return;
            }
            var aIsInsideB,bIsInsideA;
            var curvesIntersect = (function (){
                var $1 = {
                    Value: aIsInsideB
                };
                var $2 = {
                    Value: bIsInsideA
                };
                var $res = Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.ObstaclesIntersect(a, b, $1, $2);
                aIsInsideB = $1.Value;
                bIsInsideA = $2.Value;
                return $res;
            }).call(this);
            if (!curvesIntersect && !aIsInsideB && !bIsInsideA){
                return;
            }
            if (a.get_IsRectangle() && b.get_IsRectangle()){
                if (!b.get_IsGroup()){
                    if (aIsInsideB || Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.FirstRectangleContainsACornerOfTheOther(b.get_VisibilityBoundingBox(), a.get_VisibilityBoundingBox())){
                        b.set_OverlapsGroupCorner(true);
                    }
                }
                return;
            }
            if (!curvesIntersect){
                if (b.get_IsGroup() || bIsInsideA){
                    return;
                }
            }
            this.overlapPairs.Insert(new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(a.get_Ordinal(), b.get_Ordinal()));
        },
        AddClumpToConvexHull: function (obstacle){
            if (obstacle.get_IsOverlapped()){
                var $it978 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor, obstacle.get_Clump(), $CreateAnonymousDelegate(this, function (sib){
                    return sib.get_Ordinal() != obstacle.get_Ordinal();
                })).GetEnumerator();
                while ($it978.MoveNext()){
                    var sibling = $it978.get_Current();
                    this.overlapPairs.Insert(new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(obstacle.get_Ordinal(), sibling.get_Ordinal()));
                }
                obstacle.get_Clump().Clear();
            }
        },
        AddConvexHullToConvexHull: function (obstacle){
            if (obstacle.get_IsInConvexHull()){
                var $it979 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor, obstacle.get_ConvexHull().get_Obstacles(), $CreateAnonymousDelegate(this, function (sib){
                    return sib.get_Ordinal() != obstacle.get_Ordinal();
                })).GetEnumerator();
                while ($it979.MoveNext()){
                    var sibling = $it979.get_Current();
                    this.overlapPairs.Insert(new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(obstacle.get_Ordinal(), sibling.get_Ordinal()));
                }
                obstacle.get_ConvexHull().get_Obstacles().Clear();
            }
        },
        CreateClumps: function (){
            var graph = new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, this.overlapPairs);
            var connectedComponents = Microsoft.Msagl.Core.GraphAlgorithms.ConnectedComponentCalculator$1.GetComponents(graph);
            var $it980 = connectedComponents.GetEnumerator();
            while ($it980.MoveNext()){
                var component = $it980.get_Current();
                if (System.Linq.Enumerable.Count$1$$IEnumerable$1(System.Int32.ctor, component) == 1){
                    continue;
                }
                var clump = new Microsoft.Msagl.Routing.Rectilinear.Clump.ctor(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.Int32.ctor, Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor, component, $CreateDelegate(this, this.OrdinalToObstacle)));
                var $it981 = clump.GetEnumerator();
                while ($it981.MoveNext()){
                    var obstacle = $it981.get_Current();
                    obstacle.set_Clump(clump);
                }
            }
        },
        CreateConvexHulls: function (){
            var found = false;
            var graph = new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, this.overlapPairs);
            var connectedComponents = Microsoft.Msagl.Core.GraphAlgorithms.ConnectedComponentCalculator$1.GetComponents(graph);
            var $it982 = connectedComponents.GetEnumerator();
            while ($it982.MoveNext()){
                var component = $it982.get_Current();
                if (System.Linq.Enumerable.Count$1$$IEnumerable$1(System.Int32.ctor, component) == 1){
                    continue;
                }
                found = true;
                var obstacles = System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.Int32.ctor, Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor, component, $CreateDelegate(this, this.OrdinalToObstacle));
                var points = System.Linq.Enumerable.SelectMany$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, obstacles, $CreateAnonymousDelegate(this, function (obs){
                    return obs.get_VisibilityPolyline();
                }));
                var och = new Microsoft.Msagl.Routing.Rectilinear.OverlapConvexHull.ctor(Microsoft.Msagl.Core.Geometry.ConvexHull.CreateConvexHullAsClosedPolyline(points), obstacles);
                var $it983 = obstacles.GetEnumerator();
                while ($it983.MoveNext()){
                    var obstacle = $it983.get_Current();
                    obstacle.SetConvexHull(och);
                }
            }
            return found;
        },
        GrowGroupsToResolveOverlaps: function (){
            var found = false;
            var $it984 = this.overlapPairs.GetEnumerator();
            while ($it984.MoveNext()){
                var pair = $it984.get_Current();
                found = true;
                var a = this.OrdinalToObstacle(pair.get_First());
                var b = this.OrdinalToObstacle(pair.get_Second());
                if (!Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.ResolveGroupAndGroupOverlap(a, b)){
                    Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.ResolveGroupAndObstacleOverlap(a, b);
                }
            }
            this.overlapPairs.Clear();
            return found;
        },
        AdjustSpatialAncestors: function (){
            if (this.SpatialAncestorsAdjusted){
                return false;
            }
            var $it986 = this.GetAllGroups().GetEnumerator();
            while ($it986.MoveNext()){
                var group = $it986.get_Current();
                var groupBox = group.get_VisibilityBoundingBox();
                var $it987 = this.get_Root().GetNodeItemsIntersectingRectangle(groupBox).GetEnumerator();
                while ($it987.MoveNext()){
                    var obstacle = $it987.get_Current();
                    if ((obstacle != group) && Microsoft.Msagl.Core.Geometry.Curves.Curve.ClosedCurveInteriorsIntersect(obstacle.get_VisibilityPolyline(), group.get_VisibilityPolyline())){
                        if (obstacle.get_IsInConvexHull()){
                            System.Diagnostics.Debug.Assert$$Boolean$$String(obstacle.get_IsPrimaryObstacle(), "Only primary obstacles should be in the hierarchy");
                            var $it988 = obstacle.get_ConvexHull().get_Obstacles().GetEnumerator();
                            while ($it988.MoveNext()){
                                var sibling = $it988.get_Current();
                                this.AncestorSets.get_Item$$TKey(sibling.get_InputShape()).Insert(group.get_InputShape());
                            }
                        }
                        this.AncestorSets.get_Item$$TKey(obstacle.get_InputShape()).Insert(group.get_InputShape());
                    }
                }
            }
            var nonSpatialGroups = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Shape.ctor);
            var $it989 = this.get_Root().GetAllLeaves().GetEnumerator();
            while ($it989.MoveNext()){
                var child = $it989.get_Current();
                var childBox = child.get_VisibilityBoundingBox();
                nonSpatialGroups.AddRange(System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, this.AncestorSets.get_Item$$TKey(child.get_InputShape()), $CreateAnonymousDelegate(this, function (anc){
                    return !childBox.Intersects(this.shapeIdToObstacleMap.get_Item$$TKey(anc).get_VisibilityBoundingBox());
                })));
                var $it990 = nonSpatialGroups.GetEnumerator();
                while ($it990.MoveNext()){
                    var group = $it990.get_Current();
                    this.AncestorSets.get_Item$$TKey(child.get_InputShape()).Remove(group);
                }
                nonSpatialGroups.Clear();
            }
            this.SpatialAncestorsAdjusted = true;
            return true;
        },
        GetAllGroups: function (){
            return System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor, this.GetAllObstacles(), $CreateAnonymousDelegate(this, function (obs){
                return obs.get_IsGroup();
            }));
        },
        Clear: function (){
            this.set_Root(null);
            this.AncestorSets = null;
        },
        CreateMaxVisibilitySegment: function (startPoint, dir, pacList){
            var graphBoxBorderIntersect = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.RectangleBorderIntersect(this.get_GraphBox(), startPoint, dir);
            if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(startPoint, graphBoxBorderIntersect) == Microsoft.Msagl.Core.Geometry.Directions.None){
                pacList.Value = null;
                return new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(startPoint, startPoint);
            }
            var segment = this.RestrictSegmentWithObstacles(startPoint, graphBoxBorderIntersect);
            pacList.Value = this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(segment.get_Start(), segment.get_End());
            return segment;
        },
        GetAllObstacles: function (){
            return this.allObstacles;
        },
        GetAllPrimaryObstacles: function (){
            return this.get_Root().GetAllLeaves();
        },
        IntersectionIsInsideAnotherObstacle: function (sideObstacle, eventObstacle, intersect, scanDirection){
            this.insideHitTestIgnoreObstacle1 = eventObstacle;
            this.insideHitTestIgnoreObstacle2 = sideObstacle;
            this.insideHitTestScanDirection = scanDirection;
            var obstacleNode = this.get_Root().FirstHitNode$$Point$$Func$3(intersect, $CreateDelegate(this, this.InsideObstacleHitTest));
            return (null != obstacleNode);
        },
        PointIsInsideAnObstacle$$Point$$Directions: function (intersect, direction){
            return this.PointIsInsideAnObstacle$$Point$$ScanDirection(intersect, Microsoft.Msagl.Routing.Rectilinear.ScanDirection.GetInstance(direction));
        },
        PointIsInsideAnObstacle$$Point$$ScanDirection: function (intersect, scanDirection){
            this.insideHitTestIgnoreObstacle1 = null;
            this.insideHitTestIgnoreObstacle2 = null;
            this.insideHitTestScanDirection = scanDirection;
            var obstacleNode = this.get_Root().FirstHitNode$$Point$$Func$3(intersect, $CreateDelegate(this, this.InsideObstacleHitTest));
            return (null != obstacleNode);
        },
        InsideObstacleHitTest: function (location, obstacle){
            if ((obstacle == this.insideHitTestIgnoreObstacle1) || (obstacle == this.insideHitTestIgnoreObstacle2)){
                return Microsoft.Msagl.Core.Geometry.HitTestBehavior.Continue;
            }
            if (obstacle.get_IsGroup()){
                return Microsoft.Msagl.Core.Geometry.HitTestBehavior.Continue;
            }
            if (!Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.PointIsInRectangleInterior(location, obstacle.get_VisibilityBoundingBox())){
                return Microsoft.Msagl.Core.Geometry.HitTestBehavior.Continue;
            }
            var high = Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.RectangleBorderIntersect(obstacle.get_VisibilityBoundingBox(), location, this.insideHitTestScanDirection.get_Direction()), this.insideHitTestScanDirection.get_DirectionAsPoint());
            var low = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.RectangleBorderIntersect(obstacle.get_VisibilityBoundingBox(), location, this.insideHitTestScanDirection.get_OppositeDirection()), this.insideHitTestScanDirection.get_DirectionAsPoint());
            var testSeg = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(low, high);
            var xxs = Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(testSeg, obstacle.get_VisibilityPolyline(), true);
            if (2 == xxs.get_Count()){
                var firstInt = Microsoft.Msagl.Routing.Rectilinear.SpliceUtility.RawIntersection(xxs.get_Item$$Int32(0), location);
                var secondInt = Microsoft.Msagl.Routing.Rectilinear.SpliceUtility.RawIntersection(xxs.get_Item$$Int32(1), location);
                if (!Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(location, firstInt) && !Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(location, secondInt) && (location.CompareTo(firstInt) != location.CompareTo(secondInt))){
                    System.Diagnostics.Debug.Assert$$Boolean$$String(testSeg == xxs.get_Item$$Int32(0).get_Segment0(), "incorrect parameter ordering to GetAllIntersections");
                    if (!Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(System.Math.Floor$$Double(xxs.get_Item$$Int32(0).get_Par1()), System.Math.Floor$$Double(xxs.get_Item$$Int32(1).get_Par1()))){
                        return Microsoft.Msagl.Core.Geometry.HitTestBehavior.Stop;
                    }
                }
            }
            return Microsoft.Msagl.Core.Geometry.HitTestBehavior.Continue;
        },
        SegmentCrossesAnObstacle: function (startPoint, endPoint){
            this.stopAtGroups = true;
            this.wantGroupCrossings = false;
            var obstacleIntersectSeg = this.RestrictSegmentPrivate(startPoint, endPoint);
            return !Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(obstacleIntersectSeg.get_End(), endPoint);
        },
        SegmentCrossesANonGroupObstacle: function (startPoint, endPoint){
            this.stopAtGroups = false;
            this.wantGroupCrossings = false;
            var obstacleIntersectSeg = this.RestrictSegmentPrivate(startPoint, endPoint);
            return !Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(obstacleIntersectSeg.get_End(), endPoint);
        },
        RestrictSegmentWithObstacles: function (startPoint, endPoint){
            this.stopAtGroups = false;
            this.wantGroupCrossings = true;
            return this.RestrictSegmentPrivate(startPoint, endPoint);
        },
        RestrictSegmentPrivate: function (startPoint, endPoint){
            this.GetRestrictedIntersectionTestSegment(startPoint, endPoint);
            this.currentRestrictedRay = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(startPoint, endPoint);
            this.restrictedRayLengthSquared = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(startPoint, endPoint)).get_LengthSquared();
            this.CurrentGroupBoundaryCrossingMap.Clear();
            this.RecurseRestrictRayWithObstacles(this.get_Root());
            return this.currentRestrictedRay;
        },
        GetRestrictedIntersectionTestSegment: function (startPoint, endPoint){
            var segDir = Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$Point$$Point(startPoint, endPoint);
            var startX = (Microsoft.Msagl.Core.Geometry.Directions.West == segDir) ? this.get_GraphBox().get_Right() : ((Microsoft.Msagl.Core.Geometry.Directions.East == segDir) ? this.get_GraphBox().get_Left() : startPoint.get_X());
            var endX = (Microsoft.Msagl.Core.Geometry.Directions.West == segDir) ? this.get_GraphBox().get_Left() : ((Microsoft.Msagl.Core.Geometry.Directions.East == segDir) ? this.get_GraphBox().get_Right() : endPoint.get_X());
            var startY = (Microsoft.Msagl.Core.Geometry.Directions.South == segDir) ? this.get_GraphBox().get_Top() * 2 : ((Microsoft.Msagl.Core.Geometry.Directions.North == segDir) ? this.get_GraphBox().get_Bottom() : startPoint.get_Y());
            var endY = (Microsoft.Msagl.Core.Geometry.Directions.South == segDir) ? this.get_GraphBox().get_Bottom() : ((Microsoft.Msagl.Core.Geometry.Directions.North == segDir) ? this.get_GraphBox().get_Top() : startPoint.get_Y());
            this.restrictedIntersectionTestSegment = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(startX, startY), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(endX, endY));
        },
        RecurseRestrictRayWithObstacles: function (rectNode){
            if (!Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.RectangleInteriorsIntersect(this.currentRestrictedRay.get_BoundingBox(), rectNode.get_Rectangle())){
                return;
            }
            var obstacle = rectNode.get_UserData();
            if (null != obstacle){
                var intersections = Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(this.restrictedIntersectionTestSegment, obstacle.get_VisibilityPolyline(), true);
                if (!obstacle.get_IsGroup() || this.stopAtGroups){
                    this.LookForCloserNonGroupIntersectionToRestrictRay(intersections);
                    return;
                }
                if (this.wantGroupCrossings){
                    this.AddGroupIntersectionsToRestrictedRay(obstacle, intersections);
                }
                System.Diagnostics.Debug.Assert$$Boolean$$String(rectNode.get_IsLeaf(), "RectNode with UserData is not a Leaf");
                return;
            }
            this.RecurseRestrictRayWithObstacles(rectNode.get_Left());
            this.RecurseRestrictRayWithObstacles(rectNode.get_Right());
        },
        LookForCloserNonGroupIntersectionToRestrictRay: function (intersections){
            var numberOfGoodIntersections = 0;
            var closestIntersectionInfo = null;
            var localLeastDistSquared = this.restrictedRayLengthSquared;
            var testDirection = Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(this.restrictedIntersectionTestSegment.get_Start(), this.restrictedIntersectionTestSegment.get_End());
            var $it991 = intersections.GetEnumerator();
            while ($it991.MoveNext()){
                var intersectionInfo = $it991.get_Current();
                var intersect = Microsoft.Msagl.Routing.Rectilinear.SpliceUtility.RawIntersection(intersectionInfo, this.currentRestrictedRay.get_Start());
                var dirToIntersect = Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(this.currentRestrictedRay.get_Start(), intersect);
                if (dirToIntersect == Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(testDirection)){
                    continue;
                }
                ++numberOfGoodIntersections;
                if (Microsoft.Msagl.Core.Geometry.Directions.None == dirToIntersect){
                    localLeastDistSquared = 0;
                    closestIntersectionInfo = intersectionInfo;
                    continue;
                }
                var distSquared = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(intersect, this.currentRestrictedRay.get_Start())).get_LengthSquared();
                if (distSquared < localLeastDistSquared){
                    var rawDistSquared = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(intersectionInfo.get_IntersectionPoint(), this.currentRestrictedRay.get_Start())).get_LengthSquared();
                    if (rawDistSquared < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_SquareOfDistanceEpsilon()){
                        continue;
                    }
                    localLeastDistSquared = distSquared;
                    closestIntersectionInfo = intersectionInfo;
                }
            }
            if (null != closestIntersectionInfo){
                if (numberOfGoodIntersections == 1){
                    var intersect = Microsoft.Msagl.Routing.Rectilinear.SpliceUtility.RawIntersection(closestIntersectionInfo, this.currentRestrictedRay.get_Start());
                    if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.CloseIntersections(intersect, this.currentRestrictedRay.get_Start()) || Microsoft.Msagl.Core.Geometry.ApproximateComparer.CloseIntersections(intersect, this.currentRestrictedRay.get_End())){
                        return;
                    }
                }
                this.restrictedRayLengthSquared = localLeastDistSquared;
                this.currentRestrictedRay.set_End(Microsoft.Msagl.Routing.Rectilinear.SpliceUtility.MungeClosestIntersectionInfo(this.currentRestrictedRay.get_Start(), closestIntersectionInfo, !Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsVertical$$Point$$Point(this.currentRestrictedRay.get_Start(), this.currentRestrictedRay.get_End())));
            }
        },
        AddGroupIntersectionsToRestrictedRay: function (obstacle, intersections){
            var $it992 = intersections.GetEnumerator();
            while ($it992.MoveNext()){
                var intersectionInfo = $it992.get_Current();
                var intersect = Microsoft.Msagl.Routing.Rectilinear.SpliceUtility.RawIntersection(intersectionInfo, this.currentRestrictedRay.get_Start());
                var distSquared = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(intersect, this.currentRestrictedRay.get_Start())).get_LengthSquared();
                if (distSquared > this.restrictedRayLengthSquared){
                    continue;
                }
                var dirTowardIntersect = Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$Point$$Point(this.currentRestrictedRay.get_Start(), this.currentRestrictedRay.get_End());
                var polyline = Cast(intersectionInfo.get_Segment1(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
                var dirsOfSide = Microsoft.Msagl.Core.Geometry.CompassVector.VectorDirection$$Point(polyline.Derivative(intersectionInfo.get_Par1()));
                var dirToInsideOfGroup = dirTowardIntersect;
                if (Microsoft.Msagl.Core.Geometry.Directions.None != (dirsOfSide & Microsoft.Msagl.Core.Geometry.CompassVector.RotateRight(dirTowardIntersect))){
                    dirToInsideOfGroup = Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(dirToInsideOfGroup);
                }
                this.CurrentGroupBoundaryCrossingMap.AddIntersection(intersect, obstacle, dirToInsideOfGroup);
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$ObstacleTree);
var Microsoft$Msagl$Routing$Spline$ConeSpanner$ConeSpannerForPortLocations = {
    fullname: "Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSpannerForPortLocations",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        },
        GetTotalSteps: function (coneAngle){
            return ((6.28318530717959 / coneAngle)) | 0;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (obstacles, visibilityGraph, portLocationsPointSet){
            this.obstacles = null;
            this.coneAngle = 0.523598775598299;
            this._PortLocations = null;
            this._VisibilityGraph = null;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.set_PortLocations(portLocationsPointSet);
            this.obstacles = Microsoft.Msagl.Routing.Visibility.VisibilityGraph.OrientHolesClockwise(obstacles);
            this.set_VisibilityGraph(visibilityGraph);
        },
        ConeAngle$$: "System.Double",
        get_ConeAngle: function (){
            return this.coneAngle;
        },
        set_ConeAngle: function (value){
            this.coneAngle = value;
        },
        PortLocations$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Geometry.Point]]",
        get_PortLocations: function (){
            return this._PortLocations;
        },
        set_PortLocations: function (value){
            this._PortLocations = value;
        },
        VisibilityGraph$$: "Microsoft.Msagl.Routing.Visibility.VisibilityGraph",
        get_VisibilityGraph: function (){
            return this._VisibilityGraph;
        },
        set_VisibilityGraph: function (value){
            this._VisibilityGraph = value;
        },
        RunInternal: function (){
            for (var i = 0; i < Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSpannerForPortLocations.GetTotalSteps(this.coneAngle); i++){
                var angle = this.coneAngle * i;
                this.AddDirection(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(System.Math.Cos(angle), System.Math.Sin(angle)));
                this.ProgressStep();
            }
        },
        AddDirection: function (direction){
            var visibilityGraph = new Microsoft.Msagl.Routing.Visibility.VisibilityGraph.ctor();
            Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeperForPortLocations.Sweep(this.obstacles, direction, this.coneAngle, visibilityGraph, this.get_PortLocations());
            var $it993 = visibilityGraph.get_Edges().GetEnumerator();
            while ($it993.MoveNext()){
                var edge = $it993.get_Current();
                this.get_VisibilityGraph().AddEdge$$Point$$Point$$Func$3$VisibilityVertex$VisibilityVertex$VisibilityEdge(edge.get_SourcePoint(), edge.get_TargetPoint(), ($CreateAnonymousDelegate(this, function (a, b){
                    return new Microsoft.Msagl.Routing.Visibility.TollFreeVisibilityEdge.ctor$$VisibilityVertex$$VisibilityVertex(a, b);
                })));
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$ConeSpanner$ConeSpannerForPortLocations);
var Microsoft$Msagl$Layout$Layered$FlatEdgeRouter = {
    fullname: "Microsoft.Msagl.Layout.Layered.FlatEdgeRouter",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (settings, routing){
            this.routing = null;
            this.settings = null;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.settings = settings;
            this.routing = routing;
        },
        Layers$$: "System.Int32[][]",
        get_Layers: function (){
            return this.routing.LayerArrays.get_Layers();
        },
        RunInternal: function (){
            for (var i = 0; i < this.get_Layers().length; i++){
                this.ProgressStep();
                this.RouteFlatEdgesBetweenTwoLayers(this.get_Layers()[i], i < this.get_Layers().length - 1 ? this.get_Layers()[i + 1] : new Int32Array(0));
            }
        },
        RouteFlatEdgesBetweenTwoLayers: function (lowerLayer, upperLayer){
            var twoLayerRouter = new Microsoft.Msagl.Layout.Layered.TwoLayerFlatEdgeRouter.ctor(this.settings, this.routing, lowerLayer, upperLayer);
            twoLayerRouter.Run();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$FlatEdgeRouter);
var Microsoft$Msagl$Core$Geometry$HitTestBehavior = {
    fullname: "Microsoft.Msagl.Core.Geometry.HitTestBehavior",
    staticDefinition: {
        Continue: 0,
        Stop: 1
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$HitTestBehavior);
var Microsoft$Msagl$Routing$InteractiveEdgeRouter = {
    fullname: "Microsoft.Msagl.Routing.InteractiveEdgeRouter",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        },
        PointInsideOfConvexCurve: function (nodeBoundary){
            return Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Addition(nodeBoundary.get_Item$$Double(0), nodeBoundary.get_Item$$Double(1.5))), 2);
        },
        CreateRelaxedPolylinePoints: function (polyline){
            var p = polyline.get_StartPoint();
            var ret = new Microsoft.Msagl.Routing.RelaxedPolylinePoint.ctor(p, p.get_Point());
            var currentRelaxed = ret;
            while (p.get_Next() != null){
                p = p.get_Next();
                var r = (function (){
                    var $v107 = new Microsoft.Msagl.Routing.RelaxedPolylinePoint.ctor(p, p.get_Point());
                    $v107.set_Prev(currentRelaxed);
                    return $v107;
                })();
                currentRelaxed.set_Next(r);
                currentRelaxed = r;
            }
            return ret;
        },
        PullCloserRelaxedPoint: function (relaxedPolylinePoint){
            relaxedPolylinePoint.get_PolylinePoint().set_Point(Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(0.2, relaxedPolylinePoint.get_OriginalPosition()), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(0.8, relaxedPolylinePoint.get_PolylinePoint().get_Point())));
        },
        IntersectionsOfLineAndRectangleNodeOverPolyline$$LineSegment$$RectangleNode$1$Polyline: function (ls, rectNode){
            var ret = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.ctor);
            Microsoft.Msagl.Routing.InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolyline$$LineSegment$$RectangleNode$1$Polyline$$List$1$IntersectionInfo(ls, rectNode, ret);
            return ret;
        },
        IntersectionsOfLineAndRectangleNodeOverPolyline$$LineSegment$$RectangleNode$1$Polyline$$List$1$IntersectionInfo: function (ls, rectNode, listOfIntersections){
            if (rectNode == null)
                return;
            if (!ls.get_BoundingBox().Intersects(rectNode.get_Rectangle()))
                return;
            if (rectNode.get_UserData() != null){
                listOfIntersections.AddRange(Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(ls, rectNode.get_UserData(), true));
                return;
            }
            Microsoft.Msagl.Routing.InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolyline$$LineSegment$$RectangleNode$1$Polyline$$List$1$IntersectionInfo(ls, rectNode.get_Left(), listOfIntersections);
            Microsoft.Msagl.Routing.InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolyline$$LineSegment$$RectangleNode$1$Polyline$$List$1$IntersectionInfo(ls, rectNode.get_Right(), listOfIntersections);
        },
        SetRelaxedPointLocation: function (offset, relaxedPoint){
            var leftTurn = Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(relaxedPoint.get_Next().get_OriginalPosition(), relaxedPoint.get_OriginalPosition(), relaxedPoint.get_Prev().get_OriginalPosition()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise;
            var v = (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(relaxedPoint.get_Next().get_OriginalPosition(), relaxedPoint.get_Prev().get_OriginalPosition())).Normalize(), offset)).Rotate(1.5707963267949);
            if (!leftTurn)
                v = Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(v);
            relaxedPoint.get_PolylinePoint().set_Point(Microsoft.Msagl.Core.Geometry.Point.op_Addition(relaxedPoint.get_OriginalPosition(), v));
        },
        RemoveCollinearVertices: function (ret){
            for (var pp = ret.get_StartPoint().get_Next(); pp.get_Next() != null; pp = pp.get_Next()){
                if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(pp.get_Prev().get_Point(), pp.get_Point(), pp.get_Next().get_Point()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Collinear){
                    pp.get_Prev().set_Next(pp.get_Next());
                    pp.get_Next().set_Prev(pp.get_Prev());
                }
            }
            return ret;
        },
        GetFirstHitPolyline: function (point, rectangleNode){
            var rectNode = Microsoft.Msagl.Routing.InteractiveEdgeRouter.GetFirstHitRectangleNode(point, rectangleNode);
            return rectNode != null ? rectNode.get_UserData() : null;
        },
        GetFirstHitRectangleNode: function (point, rectangleNode){
            if (rectangleNode == null)
                return null;
            return rectangleNode.FirstHitNode$$Point$$Func$3(point, function (pnt, polyline){
                return Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(pnt, polyline) != Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside ? Microsoft.Msagl.Core.Geometry.HitTestBehavior.Stop : Microsoft.Msagl.Core.Geometry.HitTestBehavior.Continue;
            });
        },
        GetTrimmedCurveForHookingUpAnywhere: function (curve, lastPointInside, x0, x1){
            var clockwise = Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(x1.get_IntersectionPoint(), x0.get_IntersectionPoint(), lastPointInside.get_Point()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise;
            var rightX = x0.get_Par0();
            var leftX = x1.get_Par0();
            var tr0,tr1;
            var ret;
            if (clockwise){
                if (rightX < leftX)
                    return curve.Trim(rightX, leftX);
                tr0 = curve.Trim(rightX, curve.get_ParEnd());
                tr1 = curve.Trim(curve.get_ParStart(), leftX);
                ret = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor();
                return ret.AddSegs$$ICurve$$ICurve(tr0, tr1);
            }
            if (leftX < rightX)
                return curve.Trim(leftX, rightX);
            tr0 = curve.Trim(leftX, curve.get_ParEnd());
            tr1 = curve.Trim(curve.get_ParStart(), rightX);
            ret = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor();
            return ret.AddSegs$$ICurve$$ICurve(tr0, tr1);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$IEnumerable$1$ICurve$$Double$$Double$$Double: function (obstacles, padding, loosePadding, coneSpannerAngle){
            this._sourceTightPolyline = null;
            this.targetTightPolyline = null;
            this.targetLoosePolyline = null;
            this.activeRectangle = Microsoft.Msagl.Core.Geometry.Rectangle.CreateAnEmptyBox();
            this.visibilityGraph = null;
            this.activePolygons = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Visibility.Polygon.ctor);
            this.alreadyAddedOrExcludedPolylines = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            this.sourcePort = null;
            this.targetPort = null;
            this.loosePadding = 0;
            this._sourceVisibilityVertex = null;
            this.targetVisibilityVertex = null;
            this._polyline = null;
            this.targetIsInsideOfSourceTightPolyline = false;
            this.sourceIsInsideOfTargetTightPolyline = false;
            this.UseEdgeLengthMultiplier = false;
            this.UseInnerPolylingShortcutting = true;
            this.UsePolylineEndShortcutting = true;
            this.AllowedShootingStraightLines = true;
            this.cornerTable = null;
            this.cacheCorners = false;
            this.foundCachedCorners = 0;
            this._Obstacles = null;
            this._EnteringAngleBound = 0;
            this._SourceLoosePolyline = null;
            this._TightPadding = 0;
            this._OffsetForPolylineRelaxing = 0;
            this._ExpectedProgressSteps = 0;
            this._StartPointOfEdgeRouting = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._ConeSpannerAngle = 0;
            this._UseSpanner = false;
            this._LookForRoundedVertices = false;
            this._ObstacleCalculator = null;
            this._IgnoreTightPadding = false;
            Microsoft.Msagl.Routing.InteractiveEdgeRouter.ctor$$IEnumerable$1$ICurve$$Double$$Double$$Double$$Boolean.call(this, obstacles, padding, loosePadding, coneSpannerAngle, false);
        },
        Obstacles$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Geometry.Curves.ICurve]]",
        get_Obstacles: function (){
            return this._Obstacles;
        },
        set_Obstacles: function (value){
            this._Obstacles = value;
        },
        EnteringAngleBound$$: "System.Double",
        get_EnteringAngleBound: function (){
            return this._EnteringAngleBound;
        },
        set_EnteringAngleBound: function (value){
            this._EnteringAngleBound = value;
        },
        SourceTightPolyline$$: "Microsoft.Msagl.Core.Geometry.Curves.Polyline",
        get_SourceTightPolyline: function (){
            return this._sourceTightPolyline;
        },
        set_SourceTightPolyline: function (value){
            this._sourceTightPolyline = value;
        },
        SourceLoosePolyline$$: "Microsoft.Msagl.Core.Geometry.Curves.Polyline",
        get_SourceLoosePolyline: function (){
            return this._SourceLoosePolyline;
        },
        set_SourceLoosePolyline: function (value){
            this._SourceLoosePolyline = value;
        },
        TargetTightPolyline$$: "Microsoft.Msagl.Core.Geometry.Curves.Polyline",
        get_TargetTightPolyline: function (){
            return this.targetTightPolyline;
        },
        set_TargetTightPolyline: function (value){
            this.targetTightPolyline = value;
        },
        TargetLoosePolyline$$: "Microsoft.Msagl.Core.Geometry.Curves.Polyline",
        get_TargetLoosePolyline: function (){
            return this.targetLoosePolyline;
        },
        set_TargetLoosePolyline: function (value){
            this.targetLoosePolyline = value;
        },
        VisibilityGraph$$: "Microsoft.Msagl.Routing.Visibility.VisibilityGraph",
        get_VisibilityGraph: function (){
            return this.visibilityGraph;
        },
        set_VisibilityGraph: function (value){
            this.visibilityGraph = value;
        },
        SourcePort$$: "Microsoft.Msagl.Core.Layout.Port",
        get_SourcePort: function (){
            return this.sourcePort;
        },
        set_SourcePort: function (value){
            this.sourcePort = value;
            if (this.sourcePort != null){
                this.set_SourceTightPolyline(Microsoft.Msagl.Routing.InteractiveEdgeRouter.GetFirstHitPolyline(this.sourcePort.get_Location(), this.get_ObstacleCalculator().get_RootOfTightHierarchy()));
                if (Is(this.sourcePort, Microsoft.Msagl.Core.Layout.FloatingPort.ctor)){
                    this.alreadyAddedOrExcludedPolylines.Insert(this.get_SourceLoosePolyline());
                    this.set_StartPointOfEdgeRouting(this.get_SourcePort().get_Location());
                }
                else {
                    var bp = Cast(this.sourcePort, Microsoft.Msagl.Core.Layout.CurvePort.ctor);
                    this.set_StartPointOfEdgeRouting(this.TakeBoundaryPortOutsideOfItsLoosePolyline(bp.get_Curve(), bp.get_Parameter(), this.get_SourceLoosePolyline()));
                }
            }
        },
        TargetPort$$: "Microsoft.Msagl.Core.Layout.Port",
        get_TargetPort: function (){
            return this.targetPort;
        },
        set_TargetPort: function (value){
            this.targetPort = value;
        },
        TightPadding$$: "System.Double",
        get_TightPadding: function (){
            return this._TightPadding;
        },
        set_TightPadding: function (value){
            this._TightPadding = value;
        },
        LoosePadding$$: "System.Double",
        get_LoosePadding: function (){
            return this.loosePadding;
        },
        set_LoosePadding: function (value){
            this.loosePadding = value;
            if (this.get_ObstacleCalculator() != null)
                this.get_ObstacleCalculator().set_LoosePadding(value);
        },
        SourceVisibilityVertex$$: "Microsoft.Msagl.Routing.Visibility.VisibilityVertex",
        get_SourceVisibilityVertex: function (){
            return this._sourceVisibilityVertex;
        },
        TargetVisibilityVertex$$: "Microsoft.Msagl.Routing.Visibility.VisibilityVertex",
        get_TargetVisibilityVertex: function (){
            return this.targetVisibilityVertex;
        },
        OffsetForPolylineRelaxing$$: "System.Double",
        get_OffsetForPolylineRelaxing: function (){
            return this._OffsetForPolylineRelaxing;
        },
        set_OffsetForPolylineRelaxing: function (value){
            this._OffsetForPolylineRelaxing = value;
        },
        ExpectedProgressSteps$$: "System.Int32",
        get_ExpectedProgressSteps: function (){
            return this._ExpectedProgressSteps;
        },
        set_ExpectedProgressSteps: function (value){
            this._ExpectedProgressSteps = value;
        },
        ctor: function (){
            this._sourceTightPolyline = null;
            this.targetTightPolyline = null;
            this.targetLoosePolyline = null;
            this.activeRectangle = Microsoft.Msagl.Core.Geometry.Rectangle.CreateAnEmptyBox();
            this.visibilityGraph = null;
            this.activePolygons = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Visibility.Polygon.ctor);
            this.alreadyAddedOrExcludedPolylines = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            this.sourcePort = null;
            this.targetPort = null;
            this.loosePadding = 0;
            this._sourceVisibilityVertex = null;
            this.targetVisibilityVertex = null;
            this._polyline = null;
            this.targetIsInsideOfSourceTightPolyline = false;
            this.sourceIsInsideOfTargetTightPolyline = false;
            this.UseEdgeLengthMultiplier = false;
            this.UseInnerPolylingShortcutting = true;
            this.UsePolylineEndShortcutting = true;
            this.AllowedShootingStraightLines = true;
            this.cornerTable = null;
            this.cacheCorners = false;
            this.foundCachedCorners = 0;
            this._Obstacles = null;
            this._EnteringAngleBound = 0;
            this._SourceLoosePolyline = null;
            this._TightPadding = 0;
            this._OffsetForPolylineRelaxing = 0;
            this._ExpectedProgressSteps = 0;
            this._StartPointOfEdgeRouting = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._ConeSpannerAngle = 0;
            this._UseSpanner = false;
            this._LookForRoundedVertices = false;
            this._ObstacleCalculator = null;
            this._IgnoreTightPadding = false;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.set_ObstacleCalculator(new Microsoft.Msagl.Routing.InteractiveObstacleCalculator.ctor(this.get_Obstacles(), this.get_TightPadding(), this.get_LoosePadding(), false));
        },
        StartPointOfEdgeRouting$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_StartPointOfEdgeRouting: function (){
            return this._StartPointOfEdgeRouting;
        },
        set_StartPointOfEdgeRouting: function (value){
            this._StartPointOfEdgeRouting = value;
        },
        ExtendVisibilityGraphToLocation: function (location){
            if (this.get_VisibilityGraph() == null)
                this.set_VisibilityGraph(new Microsoft.Msagl.Routing.Visibility.VisibilityGraph.ctor());
            var addedPolygons = null;
            if (!this.activeRectangle.Contains$$Point(location)){
                if (this.activeRectangle.get_IsEmpty())
                    this.activeRectangle = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(this.get_SourcePort().get_Location(), location);
                else
                    this.activeRectangle.Add$$Point(location);
                addedPolygons = this.GetAddedPolygonesAndMaybeExtendActiveRectangle();
                var $it994 = addedPolygons.GetEnumerator();
                while ($it994.MoveNext()){
                    var polygon = $it994.get_Current();
                    this.get_VisibilityGraph().AddHole(polygon.get_Polyline());
                }
            }
            if (addedPolygons == null || addedPolygons.get_Count() == 0){
                if (this.targetVisibilityVertex != null)
                    this.get_VisibilityGraph().RemoveVertex(this.targetVisibilityVertex);
                this.CalculateEdgeTargetVisibilityGraph(location);
            }
            else {
                this.RemovePointVisibilityGraphs();
                var visibilityGraphGenerator = new Microsoft.Msagl.Routing.Visibility.InteractiveTangentVisibilityGraphCalculator.ctor(addedPolygons, this.activePolygons, this.get_VisibilityGraph());
                visibilityGraphGenerator.Run();
                this.activePolygons.AddRange(addedPolygons);
                this.CalculateEdgeTargetVisibilityGraph(location);
                this.CalculateSourcePortVisibilityGraph();
            }
        },
        RemovePointVisibilityGraphs: function (){
            if (this.targetVisibilityVertex != null)
                this.get_VisibilityGraph().RemoveVertex(this.targetVisibilityVertex);
            if (this._sourceVisibilityVertex != null)
                this.get_VisibilityGraph().RemoveVertex(this._sourceVisibilityVertex);
        },
        CalculateEdgeTargetVisibilityGraph: function (location){
            (function (){
                var $1 = {
                    Value: this.targetVisibilityVertex
                };
                var $res = Microsoft.Msagl.Routing.Visibility.PointVisibilityCalculator.CalculatePointVisibilityGraph(this.GetActivePolylines(), this.get_VisibilityGraph(), location, Microsoft.Msagl.Routing.Visibility.VisibilityKind.Tangent, $1);
                this.targetVisibilityVertex = $1.Value;
                return $res;
            }).call(this);
        },
        CalculateSourcePortVisibilityGraph: function (){
            (function (){
                var $1 = {
                    Value: this._sourceVisibilityVertex
                };
                var $res = Microsoft.Msagl.Routing.Visibility.PointVisibilityCalculator.CalculatePointVisibilityGraph(this.GetActivePolylines(), this.get_VisibilityGraph(), this.get_StartPointOfEdgeRouting(), Microsoft.Msagl.Routing.Visibility.VisibilityKind.Tangent, $1);
                this._sourceVisibilityVertex = $1.Value;
                return $res;
            }).call(this);
            System.Diagnostics.Debug.Assert$$Boolean(this._sourceVisibilityVertex != null);
        },
        TakeBoundaryPortOutsideOfItsLoosePolyline: function (nodeBoundary, parameter, loosePolyline){
            var location = nodeBoundary.get_Item$$Double(parameter);
            var tangent = (Microsoft.Msagl.Core.Geometry.Point.op_Addition(nodeBoundary.LeftDerivative(parameter).Normalize(), nodeBoundary.RightDerivative(parameter).Normalize())).Normalize();
            if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(Microsoft.Msagl.Routing.InteractiveEdgeRouter.PointInsideOfConvexCurve(nodeBoundary), location, Microsoft.Msagl.Core.Geometry.Point.op_Addition(location, tangent)) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise)
                tangent = Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(tangent);
            tangent = tangent.Rotate(1.5707963267949);
            var len = loosePolyline.get_BoundingBox().get_Diagonal();
            var ls = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(location, Microsoft.Msagl.Core.Geometry.Point.op_Addition(location, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(len, tangent)));
            var p = Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(ls, loosePolyline, false).get_Item$$Int32(0).get_IntersectionPoint();
            var del = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(tangent, (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(p, location)).get_Length()), 0.5);
            while (true){
                ls = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(location, Microsoft.Msagl.Core.Geometry.Point.op_Addition(p, del));
                var foundIntersectionsOutsideOfSource = false;
                var $it995 = Microsoft.Msagl.Routing.InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolyline$$LineSegment$$RectangleNode$1$Polyline(ls, this.get_ObstacleCalculator().get_RootOfLooseHierarchy()).GetEnumerator();
                while ($it995.MoveNext()){
                    var ii = $it995.get_Current();
                    if (ii.get_Segment1() != loosePolyline){
                        del = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(del, 1.5);
                        foundIntersectionsOutsideOfSource = true;
                        break;
                    }
                }
                if (!foundIntersectionsOutsideOfSource)
                    break;
            }
            return ls.get_End();
        },
        GetActivePolylines: function (){
            var $yield = [];
            var $it996 = this.activePolygons.GetEnumerator();
            while ($it996.MoveNext()){
                var polygon = $it996.get_Current();
                $yield.push(polygon.get_Polyline());
            }
            return $yield;
        },
        GetAddedPolygonesAndMaybeExtendActiveRectangle: function (){
            var rect = this.activeRectangle;
            var addedPolygones = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Visibility.Polygon.ctor);
            var added;
            do{
                added = false;
                var $it997 = this.get_ObstacleCalculator().get_RootOfLooseHierarchy().GetNodeItemsIntersectingRectangle(this.activeRectangle).GetEnumerator();
                while ($it997.MoveNext()){
                    var loosePoly = $it997.get_Current();
                    if (!this.alreadyAddedOrExcludedPolylines.Contains$$T(loosePoly)){
                        rect.Add$$Rectangle(loosePoly.get_BoundingBox());
                        addedPolygones.Add(new Microsoft.Msagl.Routing.Visibility.Polygon.ctor(loosePoly));
                        this.alreadyAddedOrExcludedPolylines.Insert(loosePoly);
                        added = true;
                    }
                }
                if (added)
                    this.activeRectangle = rect;
            }
            while (added)
            return addedPolygones;
        },
        RelaxPolyline: function (){
            var relaxedPolylinePoint = Microsoft.Msagl.Routing.InteractiveEdgeRouter.CreateRelaxedPolylinePoints(this._polyline);
            for (relaxedPolylinePoint = relaxedPolylinePoint.get_Next(); relaxedPolylinePoint.get_Next() != null; relaxedPolylinePoint = relaxedPolylinePoint.get_Next())
                this.RelaxPolylinePoint(relaxedPolylinePoint);
        },
        RelaxPolylinePoint: function (relaxedPoint){
            if (relaxedPoint.get_PolylinePoint().get_Prev().get_Prev() == null && Is(this.get_SourcePort(), Microsoft.Msagl.Core.Layout.CurvePort.ctor) && relaxedPoint.get_PolylinePoint().get_Polyline() != this.get_SourceLoosePolyline())
                return;
            if (relaxedPoint.get_PolylinePoint().get_Next().get_Next() == null && Is(this.get_TargetPort(), Microsoft.Msagl.Core.Layout.CurvePort.ctor) && relaxedPoint.get_PolylinePoint().get_Polyline() != this.get_TargetLoosePolyline())
                return;
            for (var d = this.get_OffsetForPolylineRelaxing(); d > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon && !this.RelaxWithGivenOffset(d, relaxedPoint); d /= 2){
            }
        },
        RelaxWithGivenOffset: function (offset, relaxedPoint){
            System.Diagnostics.Debug.Assert$$Boolean(offset > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon);
            Microsoft.Msagl.Routing.InteractiveEdgeRouter.SetRelaxedPointLocation(offset, relaxedPoint);
            if (this.StickingSegmentDoesNotIntersectTightObstacles(relaxedPoint)){
                return true;
            }
            Microsoft.Msagl.Routing.InteractiveEdgeRouter.PullCloserRelaxedPoint(relaxedPoint.get_Prev());
            return false;
        },
        StickingSegmentDoesNotIntersectTightObstacles: function (relaxedPoint){
            return !this.PolylineSegmentIntersectsTightHierarchy(relaxedPoint.get_PolylinePoint().get_Point(), relaxedPoint.get_Prev().get_PolylinePoint().get_Point()) && (relaxedPoint.get_Next() == null || !this.PolylineSegmentIntersectsTightHierarchy(relaxedPoint.get_PolylinePoint().get_Point(), relaxedPoint.get_Next().get_PolylinePoint().get_Point()));
        },
        PolylineSegmentIntersectsTightHierarchy: function (a, b){
            return this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy$$Point$$Point$$RectangleNode$1$Polyline(a, b, this.get_ObstacleCalculator().get_RootOfTightHierarchy());
        },
        PolylineIntersectsPolyRectangleNodeOfTightHierarchy$$Point$$Point$$RectangleNode$1$Polyline: function (a, b, rect){
            return this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy$$LineSegment$$RectangleNode$1$Polyline(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(a, b), rect);
        },
        PolylineIntersectsPolyRectangleNodeOfTightHierarchy$$LineSegment$$RectangleNode$1$Polyline: function (ls, rect){
            if (!ls.get_BoundingBox().Intersects(rect.get_Rectangle()))
                return false;
            if (rect.get_UserData() != null){
                var $it998 = Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(ls, rect.get_UserData(), false).GetEnumerator();
                while ($it998.MoveNext()){
                    var ii = $it998.get_Current();
                    if (ii.get_Segment1() != this.get_SourceTightPolyline() && ii.get_Segment1() != this.get_TargetTightPolyline())
                        return true;
                    if (ii.get_Segment1() == this.get_SourceTightPolyline() && Is(this.get_SourcePort(), Microsoft.Msagl.Core.Layout.CurvePort.ctor))
                        return true;
                    if (ii.get_Segment1() == this.get_TargetTightPolyline() && Is(this.get_TargetPort(), Microsoft.Msagl.Core.Layout.CurvePort.ctor))
                        return true;
                }
                return false;
            }
            return this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy$$LineSegment$$RectangleNode$1$Polyline(ls, rect.get_Left()) || this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy$$LineSegment$$RectangleNode$1$Polyline(ls, rect.get_Right());
        },
        LineCanBeAcceptedForRouting: function (ls){
            var sourceIsFloating = Is(this.get_SourcePort(), Microsoft.Msagl.Core.Layout.FloatingPort.ctor);
            var targetIsFloating = Is(this.get_TargetPort(), Microsoft.Msagl.Core.Layout.FloatingPort.ctor);
            if (!sourceIsFloating && !this.targetIsInsideOfSourceTightPolyline)if (!this.InsideOfTheAllowedConeOfBoundaryPort(ls.get_End(), As(this.get_SourcePort(), Microsoft.Msagl.Core.Layout.CurvePort.ctor)))
                return false;
            if (!targetIsFloating && this.get_TargetPort() != null && !this.sourceIsInsideOfTargetTightPolyline)if (!this.InsideOfTheAllowedConeOfBoundaryPort(ls.get_Start(), As(this.get_TargetPort(), Microsoft.Msagl.Core.Layout.CurvePort.ctor)))
                return false;
            var xx = Microsoft.Msagl.Routing.InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolyline$$LineSegment$$RectangleNode$1$Polyline(ls, this.get_ObstacleCalculator().get_RootOfTightHierarchy());
            var $it999 = xx.GetEnumerator();
            while ($it999.MoveNext()){
                var ii = $it999.get_Current();
                if (ii.get_Segment1() == this.get_SourceTightPolyline())
                    continue;
                if (ii.get_Segment1() == this.targetTightPolyline)
                    continue;
                return false;
            }
            return true;
        },
        InsideOfTheAllowedConeOfBoundaryPort: function (pointToTest, port){
            var boundaryCurve = port.get_Curve();
            var curveIsClockwise = Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CurveIsClockwise(boundaryCurve, Microsoft.Msagl.Routing.InteractiveEdgeRouter.PointInsideOfConvexCurve(boundaryCurve));
            var portLocation = port.get_Location();
            var pointOnTheRightConeSide = this.GetPointOnTheRightBoundaryPortConeSide(portLocation, boundaryCurve, curveIsClockwise, port.get_Parameter());
            var pointOnTheLeftConeSide = this.GetPointOnTheLeftBoundaryPortConeSide(portLocation, boundaryCurve, curveIsClockwise, port.get_Parameter());
            return Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(portLocation, pointOnTheRightConeSide, pointToTest) != Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise && Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(portLocation, pointToTest, pointOnTheLeftConeSide) != Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise;
        },
        GetPointOnTheRightBoundaryPortConeSide: function (portLocation, boundaryCurve, curveIsClockwise, portParam){
            var tan = curveIsClockwise ? boundaryCurve.RightDerivative(portParam) : Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(boundaryCurve.LeftDerivative(portParam));
            return Microsoft.Msagl.Core.Geometry.Point.op_Addition(portLocation, tan.Rotate(this.get_EnteringAngleBound()));
        },
        GetPointOnTheLeftBoundaryPortConeSide: function (portLocation, boundaryCurve, curveIsClockwise, portParam){
            var tan = curveIsClockwise ? Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(boundaryCurve.LeftDerivative(portParam)) : boundaryCurve.RightDerivative(portParam);
            return Microsoft.Msagl.Core.Geometry.Point.op_Addition(portLocation, tan.Rotate(-this.get_EnteringAngleBound()));
        },
        SmoothCorners: function (edgePolyline){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(edgePolyline, "edgePolyline");
            var a = edgePolyline.get_HeadSite();
            var b;
            var c;
            while ((function (){
                var $1 = {
                    Value: b
                };
                var $2 = {
                    Value: c
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.FindCorner(a, $1, $2);
                b = $1.Value;
                c = $2.Value;
                return $res;
            }).call(this))
                a = this.SmoothOneCorner(a, c, b);
        },
        SmoothOneCorner: function (a, c, b){
            if (this.get_CacheCorners()){
                var p,n;
                if ((function (){
                    var $1 = {
                        Value: p
                    };
                    var $2 = {
                        Value: n
                    };
                    var $res = this.FindCachedCorner(a, b, c, $1, $2);
                    p = $1.Value;
                    n = $2.Value;
                    return $res;
                }).call(this)){
                    b.set_PreviousBezierSegmentFitCoefficient(p);
                    b.set_NextBezierSegmentFitCoefficient(n);
                    return b;
                }
            }
            var mult = 1.5;
            var kMin = 0.01;
            var k = 0.5;
            var seg;
            var u,v;
            if (a.get_Previous() == null){
                u = 2;
                v = 1;
            }
            else if (c.get_Next() == null){
                u = 1;
                v = 2;
            }
            else
                u = v = 1;
            do{
                seg = Microsoft.Msagl.Core.Geometry.Curves.Curve.CreateBezierSeg$$Double$$Double$$Site$$Site$$Site(k * u, k * v, a, b, c);
                b.set_PreviousBezierSegmentFitCoefficient(k * u);
                b.set_NextBezierSegmentFitCoefficient(k * v);
                k /= mult;
            }
            while (this.get_ObstacleCalculator().ObstaclesIntersectICurve(seg) && k > kMin)
            k *= mult;
            if (k < 0.5 && k > kMin){
                k = 0.5 * (k + k * mult);
                seg = Microsoft.Msagl.Core.Geometry.Curves.Curve.CreateBezierSeg$$Double$$Double$$Site$$Site$$Site(k * u, k * v, a, b, c);
                if (!this.get_ObstacleCalculator().ObstaclesIntersectICurve(seg)){
                    b.set_PreviousBezierSegmentFitCoefficient(k * u);
                    b.set_NextBezierSegmentFitCoefficient(k * v);
                }
            }
            if (this.get_CacheCorners())
                this.CacheCorner(a, b, c);
            return b;
        },
        FindCachedCorner: function (a, b, c, prev, next){
            var corner = new Microsoft.Msagl.Routing.Corner.ctor(a.get_Point(), b.get_Point(), c.get_Point());
            var prevNext;
            if ((function (){
                var $1 = {
                    Value: prevNext
                };
                var $res = this.cornerTable.TryGetValue(corner, $1);
                prevNext = $1.Value;
                return $res;
            }).call(this)){
                if (Microsoft.Msagl.Core.Geometry.Point.op_Equality(a.get_Point(), corner.a)){
                    prev.Value = prevNext.get_Item1();
                    next.Value = prevNext.get_Item2();
                }
                else {
                    prev.Value = prevNext.get_Item2();
                    next.Value = prevNext.get_Item1();
                }
                this.foundCachedCorners++;
                return true;
            }
            prev.Value = next.Value = 0;
            return false;
        },
        CacheCorner: function (a, b, c){
            this.cornerTable.set_Item$$TKey(new Microsoft.Msagl.Routing.Corner.ctor(a.get_Point(), b.get_Point(), c.get_Point()), new System.Tuple$2.ctor(System.Double.ctor, System.Double.ctor, b.get_PreviousBezierSegmentFitCoefficient(), b.get_NextBezierSegmentFitCoefficient()));
        },
        CacheCorners$$: "System.Boolean",
        get_CacheCorners: function (){
            return this.cacheCorners;
        },
        set_CacheCorners: function (value){
            this.cacheCorners = value;
            if (this.cacheCorners)
                this.cornerTable = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Corner.ctor, System.Tuple$2.ctor);
            else {
                if (this.cornerTable != null)
                    this.cornerTable.Clear();
            }
        },
        TryToRemoveInflectionsAndCollinearSegments: function (underlyingPolyline){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(underlyingPolyline, "underlyingPolyline");
            var progress = true;
            while (progress){
                progress = false;
                for (var s = underlyingPolyline.get_HeadSite(); s != null && s.get_Next() != null; s = s.get_Next()){
                    if (s.get_Turn() * s.get_Next().get_Turn() < 0)
                        progress = (function (){
                            var $1 = {
                                Value: s
                            };
                            var $res = this.TryToRemoveInflectionEdge($1);
                            s = $1.Value;
                            return $res;
                        }).call(this) || progress;
                }
            }
        },
        TryToRemoveInflectionEdge: function (s){
            if (!this.get_ObstacleCalculator().ObstaclesIntersectLine(s.Value.get_Previous().get_Point(), s.Value.get_Next().get_Point())){
                var a = s.Value.get_Previous();
                var b = s.Value.get_Next();
                a.set_Next(b);
                b.set_Previous(a);
                s.Value = a;
                return true;
            }
            if (!this.get_ObstacleCalculator().ObstaclesIntersectLine(s.Value.get_Previous().get_Point(), s.Value.get_Next().get_Next().get_Point())){
                var a = s.Value.get_Previous();
                var b = s.Value.get_Next().get_Next();
                a.set_Next(b);
                b.set_Previous(a);
                s.Value = a;
                return true;
            }
            if (!this.get_ObstacleCalculator().ObstaclesIntersectLine(s.Value.get_Point(), s.Value.get_Next().get_Next().get_Point())){
                var b = s.Value.get_Next().get_Next();
                s.Value.set_Next(b);
                b.set_Previous(s.Value);
                return true;
            }
            return false;
        },
        GetShortestPolyline: function (sourceVisVertex, _targetVisVertex){
            this.CleanTheGraphForShortestPath();
            var pathCalc = new Microsoft.Msagl.Routing.SingleSourceSingleTargetShortestPathOnVisibilityGraph.ctor(this.visibilityGraph, sourceVisVertex, _targetVisVertex);
            var path = pathCalc.GetPath(this.UseEdgeLengthMultiplier);
            if (path == null){
                return null;
            }
            System.Diagnostics.Debug.Assert$$Boolean(System.Linq.Enumerable.First$1$$IEnumerable$1(Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor, path) == sourceVisVertex && System.Linq.Enumerable.Last$1$$IEnumerable$1(Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor, path) == _targetVisVertex);
            var ret = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
            var $it1000 = path.GetEnumerator();
            while ($it1000.MoveNext()){
                var v = $it1000.get_Current();
                ret.AddPoint$$Point(v.Point);
            }
            return Microsoft.Msagl.Routing.InteractiveEdgeRouter.RemoveCollinearVertices(ret);
        },
        CleanTheGraphForShortestPath: function (){
            this.visibilityGraph.ClearPrevEdgesTable();
        },
        OverlapsDetected$$: "System.Boolean",
        get_OverlapsDetected: function (){
            return this.get_ObstacleCalculator().get_OverlapsDetected();
        },
        ConeSpannerAngle$$: "System.Double",
        get_ConeSpannerAngle: function (){
            return this._ConeSpannerAngle;
        },
        set_ConeSpannerAngle: function (value){
            this._ConeSpannerAngle = value;
        },
        TightHierarchy$$: "Microsoft.Msagl.Core.Geometry.RectangleNode`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]",
        get_TightHierarchy: function (){
            return this.get_ObstacleCalculator().get_RootOfTightHierarchy();
        },
        set_TightHierarchy: function (value){
            this.get_ObstacleCalculator().set_RootOfTightHierarchy(value);
        },
        LooseHierarchy$$: "Microsoft.Msagl.Core.Geometry.RectangleNode`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]",
        get_LooseHierarchy: function (){
            return this.get_ObstacleCalculator().get_RootOfLooseHierarchy();
        },
        set_LooseHierarchy: function (value){
            this.get_ObstacleCalculator().set_RootOfLooseHierarchy(value);
        },
        UseSpanner$$: "System.Boolean",
        get_UseSpanner: function (){
            return this._UseSpanner;
        },
        set_UseSpanner: function (value){
            this._UseSpanner = value;
        },
        CalculateObstacles: function (){
            this.set_ObstacleCalculator(new Microsoft.Msagl.Routing.InteractiveObstacleCalculator.ctor(this.get_Obstacles(), this.get_TightPadding(), this.get_LoosePadding(), this.get_IgnoreTightPadding()));
            this.get_ObstacleCalculator().Calculate();
        },
        RouteEdgeToLocation: function (targetLocation){
            this.set_TargetPort(new Microsoft.Msagl.Core.Layout.FloatingPort.ctor(null, targetLocation));
            this.set_TargetTightPolyline(null);
            this.set_TargetLoosePolyline(null);
            var edgeGeometry = new Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor();
            var ls = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(this.get_SourcePort().get_Location(), targetLocation);
            if (this.LineCanBeAcceptedForRouting(ls)){
                this._polyline = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
                this._polyline.AddPoint$$Point(ls.get_Start());
                this._polyline.AddPoint$$Point(ls.get_End());
                edgeGeometry.set_SmoothedPolyline(Microsoft.Msagl.Core.Geometry.SmoothedPolyline.FromPoints(this._polyline));
                edgeGeometry.set_Curve(edgeGeometry.get_SmoothedPolyline().CreateCurve());
                return edgeGeometry;
            }
            if (Is(this.get_SourcePort(), Microsoft.Msagl.Core.Layout.CurvePort.ctor)){
                ls = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(this.get_StartPointOfEdgeRouting(), targetLocation);
                if (Microsoft.Msagl.Routing.InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolyline$$LineSegment$$RectangleNode$1$Polyline(ls, this.get_ObstacleCalculator().get_RootOfTightHierarchy()).get_Count() == 0){
                    this._polyline = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
                    this._polyline.AddPoint$$Point(this.get_SourcePort().get_Location());
                    this._polyline.AddPoint$$Point(ls.get_Start());
                    this._polyline.AddPoint$$Point(ls.get_End());
                    edgeGeometry.set_SmoothedPolyline(Microsoft.Msagl.Core.Geometry.SmoothedPolyline.FromPoints(this._polyline));
                    edgeGeometry.set_Curve(edgeGeometry.get_SmoothedPolyline().CreateCurve());
                    return edgeGeometry;
                }
            }
            this.ExtendVisibilityGraphToLocation(targetLocation);
            this._polyline = this.GetShortestPolyline(this.get_SourceVisibilityVertex(), this.get_TargetVisibilityVertex());
            this.RelaxPolyline();
            if (Is(this.get_SourcePort(), Microsoft.Msagl.Core.Layout.CurvePort.ctor))
                this._polyline.PrependPoint(this.get_SourcePort().get_Location());
            edgeGeometry.set_SmoothedPolyline(Microsoft.Msagl.Core.Geometry.SmoothedPolyline.FromPoints(this._polyline));
            edgeGeometry.set_Curve(edgeGeometry.get_SmoothedPolyline().CreateCurve());
            return edgeGeometry;
        },
        RouteEdgeToPort: function (edgeTargetPort, portLoosePolyline, smooth, smoothedPolyline){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(edgeTargetPort, "edgeTargetToPort");
            if (!this.get_ObstacleCalculator().IsEmpty()){
                this.set_TargetPort(edgeTargetPort);
                this.set_TargetTightPolyline(Microsoft.Msagl.Routing.InteractiveEdgeRouter.GetFirstHitPolyline(edgeTargetPort.get_Location(), this.get_ObstacleCalculator().get_RootOfTightHierarchy()));
                System.Diagnostics.Debug.Assert$$Boolean(this.targetTightPolyline != null);
                var bp = As(edgeTargetPort, Microsoft.Msagl.Core.Layout.CurvePort.ctor);
                if (bp != null)
                    return this.RouteEdgeToBoundaryPort(portLoosePolyline, smooth, smoothedPolyline);
                return this.RouteEdgeToFloatingPortOfNode(portLoosePolyline, smooth, smoothedPolyline);
            }
            if (this.sourcePort != null && this.targetPort != null){
                smoothedPolyline.Value = this.SmoothedPolylineFromTwoPoints(this.sourcePort.get_Location(), this.targetPort.get_Location());
                return new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(this.sourcePort.get_Location(), this.targetPort.get_Location());
            }
            smoothedPolyline.Value = null;
            return null;
        },
        SmoothedPolylineFromTwoPoints: function (s, e){
            this._polyline = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
            this._polyline.AddPoint$$Point(s);
            this._polyline.AddPoint$$Point(e);
            return Microsoft.Msagl.Core.Geometry.SmoothedPolyline.FromPoints(this._polyline);
        },
        RouteEdgeToFloatingPortOfNode: function (portLoosePolyline, smooth, smoothedPolyline){
            if (Is(this.sourcePort, Microsoft.Msagl.Core.Layout.FloatingPort.ctor))
                return this.RouteFromFloatingPortToFloatingPort(portLoosePolyline, smooth, smoothedPolyline);
            return this.RouteFromBoundaryPortToFloatingPort(portLoosePolyline, smooth, smoothedPolyline);
        },
        RouteFromBoundaryPortToFloatingPort: function (targetPortLoosePolyline, smooth, polyline){
            var sourcePortLocation = this.get_SourcePort().get_Location();
            var targetPortLocation = this.targetPort.get_Location();
            var ls = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(sourcePortLocation, targetPortLocation);
            if (this.LineCanBeAcceptedForRouting(ls)){
                polyline.Value = this.SmoothedPolylineFromTwoPoints(ls.get_Start(), ls.get_End());
                return ls;
            }
            if (!this.targetIsInsideOfSourceTightPolyline){
                var takenOutPoint = this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.get_SourcePort().get_Curve(), (Cast(this.get_SourcePort(), Microsoft.Msagl.Core.Layout.CurvePort.ctor)).get_Parameter(), this.get_SourceLoosePolyline());
                ls = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(takenOutPoint, targetPortLocation);
                if (this.LineAvoidsTightHierarchy$$LineSegment$$Polyline(ls, targetPortLoosePolyline)){
                    polyline.Value = this.SmoothedPolylineFromTwoPoints(ls.get_Start(), ls.get_End());
                    return ls;
                }
            }
            this.ExtendVisibilityGraphToLocationOfTargetFloatingPort(targetPortLoosePolyline);
            this._polyline = this.GetShortestPolyline(this.get_SourceVisibilityVertex(), this.get_TargetVisibilityVertex());
            var tmp = this.get_SourceTightPolyline();
            if (!this.targetIsInsideOfSourceTightPolyline)
                this.set_SourceTightPolyline(null);
            this.TryShortcutPolyline();
            this.set_SourceTightPolyline(tmp);
            this.RelaxPolyline();
            this._polyline.PrependPoint(sourcePortLocation);
            return this.SmoothCornersAndReturnCurve(smooth, polyline);
        },
        SmoothCornersAndReturnCurve: function (smooth, smoothedPolyline){
            smoothedPolyline.Value = Microsoft.Msagl.Core.Geometry.SmoothedPolyline.FromPoints(this._polyline);
            if (smooth)
                this.SmoothCorners(smoothedPolyline.Value);
            return smoothedPolyline.Value.CreateCurve();
        },
        RouteFromFloatingPortToFloatingPort: function (portLoosePolyline, smooth, smoothedPolyline){
            var targetPortLocation = this.get_TargetPort().get_Location();
            var ls = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(this.get_StartPointOfEdgeRouting(), targetPortLocation);
            if (this.AllowedShootingStraightLines && this.LineAvoidsTightHierarchy$$LineSegment$$Polyline$$Polyline(ls, this.get_SourceTightPolyline(), this.targetTightPolyline)){
                smoothedPolyline.Value = this.SmoothedPolylineFromTwoPoints(ls.get_Start(), ls.get_End());
                return ls;
            }
            this.ExtendVisibilityGraphToLocationOfTargetFloatingPort(portLoosePolyline);
            this._polyline = this.GetShortestPolyline(this.get_SourceVisibilityVertex(), this.get_TargetVisibilityVertex());
            if (this._polyline == null){
                smoothedPolyline.Value = null;
                return null;
            }
            if (this.get_UseSpanner())
                this.TryShortcutPolyline();
            this.RelaxPolyline();
            smoothedPolyline.Value = Microsoft.Msagl.Core.Geometry.SmoothedPolyline.FromPoints(this._polyline);
            return this.SmoothCornersAndReturnCurve(smooth, smoothedPolyline);
        },
        TryShortcutPolyline: function (){
            if (this.UseInnerPolylingShortcutting)
                while (this.ShortcutPolylineOneTime()){
                }
            if (this.UsePolylineEndShortcutting)
                this.TryShortCutThePolylineEnds();
        },
        TryShortCutThePolylineEnds: function (){
            this.TryShortcutPolylineStart();
            this.TryShortcutPolylineEnd();
        },
        TryShortcutPolylineEnd: function (){
            var a = this._polyline.get_EndPoint();
            var b = a.get_Prev();
            if (b == null)
                return;
            var c = b.get_Prev();
            if (c == null)
                return;
            var m = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(0.5, (Microsoft.Msagl.Core.Geometry.Point.op_Addition(b.get_Point(), c.get_Point())));
            if (this.LineAvoidsTightHierarchy$$Point$$Point$$Polyline$$Polyline(a.get_Point(), m, this._sourceTightPolyline, this.targetTightPolyline)){
                var p = (function (){
                    var $v108 = new Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor(m);
                    $v108.set_Next(a);
                    $v108.set_Prev(c);
                    return $v108;
                }).call(this);
                a.set_Prev(p);
                c.set_Next(p);
            }
        },
        TryShortcutPolylineStart: function (){
            var a = this._polyline.get_StartPoint();
            var b = a.get_Next();
            if (b == null)
                return;
            var c = b.get_Next();
            if (c == null)
                return;
            var m = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(0.5, (Microsoft.Msagl.Core.Geometry.Point.op_Addition(b.get_Point(), c.get_Point())));
            if (this.LineAvoidsTightHierarchy$$Point$$Point$$Polyline$$Polyline(a.get_Point(), m, this._sourceTightPolyline, this.targetTightPolyline)){
                var p = (function (){
                    var $v109 = new Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor(m);
                    $v109.set_Prev(a);
                    $v109.set_Next(c);
                    return $v109;
                }).call(this);
                a.set_Next(p);
                c.set_Prev(p);
            }
        },
        ShortcutPolylineOneTime: function (){
            var ret = false;
            for (var pp = this._polyline.get_StartPoint(); pp.get_Next() != null && pp.get_Next().get_Next() != null; pp = pp.get_Next())
                ret |= this.TryShortcutPolyPoint(pp);
            return ret;
        },
        TryShortcutPolyPoint: function (pp){
            if (this.LineAvoidsTightHierarchy$$LineSegment$$Polyline$$Polyline(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(pp.get_Point(), pp.get_Next().get_Next().get_Point()), this.get_SourceTightPolyline(), this.targetTightPolyline)){
                pp.set_Next(pp.get_Next().get_Next());
                pp.get_Next().set_Prev(pp);
                return true;
            }
            return false;
        },
        ExtendVisibilityGraphToLocationOfTargetFloatingPort: function (portLoosePolyline){
            if (this.get_VisibilityGraph() == null)
                this.set_VisibilityGraph(new Microsoft.Msagl.Routing.Visibility.VisibilityGraph.ctor());
            var addedPolygons = null;
            var targetLocation = this.targetPort.get_Location();
            if (!this.activeRectangle.Contains$$Point(targetLocation)){
                if (this.activeRectangle.get_IsEmpty())
                    this.activeRectangle = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(this.get_SourcePort().get_Location(), targetLocation);
                else
                    this.activeRectangle.Add$$Point(targetLocation);
                addedPolygons = this.GetAddedPolygonesAndMaybeExtendActiveRectangle();
                var $it1001 = addedPolygons.GetEnumerator();
                while ($it1001.MoveNext()){
                    var polygon = $it1001.get_Current();
                    this.get_VisibilityGraph().AddHole(polygon.get_Polyline());
                }
            }
            if (addedPolygons == null){
                if (this.targetVisibilityVertex != null)
                    this.get_VisibilityGraph().RemoveVertex(this.targetVisibilityVertex);
                this.CalculateEdgeTargetVisibilityGraphForFloatingPort(targetLocation, portLoosePolyline);
                if (this.get_SourceVisibilityVertex() == null)
                    this.CalculateSourcePortVisibilityGraph();
            }
            else {
                this.RemovePointVisibilityGraphs();
                var visibilityGraphGenerator = new Microsoft.Msagl.Routing.Visibility.InteractiveTangentVisibilityGraphCalculator.ctor(addedPolygons, this.activePolygons, this.get_VisibilityGraph());
                visibilityGraphGenerator.Run();
                this.activePolygons.AddRange(addedPolygons);
                this.CalculateEdgeTargetVisibilityGraphForFloatingPort(targetLocation, portLoosePolyline);
                this.CalculateSourcePortVisibilityGraph();
            }
        },
        CalculateEdgeTargetVisibilityGraphForFloatingPort: function (targetLocation, targetLoosePoly){
            if (this.get_UseSpanner())
                this.targetVisibilityVertex = this.AddTransientVisibilityEdgesForPort(targetLocation, targetLoosePoly);
            else
                (function (){
                    var $1 = {
                        Value: this.targetVisibilityVertex
                    };
                    var $res = Microsoft.Msagl.Routing.Visibility.PointVisibilityCalculator.CalculatePointVisibilityGraph(this.GetActivePolylinesWithException(targetLoosePoly), this.get_VisibilityGraph(), targetLocation, Microsoft.Msagl.Routing.Visibility.VisibilityKind.Tangent, $1);
                    this.targetVisibilityVertex = $1.Value;
                    return $res;
                }).call(this);
        },
        AddTransientVisibilityEdgesForPort: function (point, loosePoly){
            var v = this.GetVertex(point);
            if (v != null)
                return v;
            v = this.visibilityGraph.AddVertex$$Point(point);
            if (loosePoly != null){
                var $it1002 = loosePoly.GetEnumerator();
                while ($it1002.MoveNext()){
                    var p = $it1002.get_Current();
                    this.visibilityGraph.AddEdge$$Point$$Point$$Func$3$VisibilityVertex$VisibilityVertex$VisibilityEdge(point, p, ($CreateAnonymousDelegate(this, function (a, b){
                        return new Microsoft.Msagl.Routing.Visibility.TollFreeVisibilityEdge.ctor$$VisibilityVertex$$VisibilityVertex(a, b);
                    })));
                }
            }
            else {
                (function (){
                    var $1 = {
                        Value: v
                    };
                    var $res = Microsoft.Msagl.Routing.Visibility.PointVisibilityCalculator.CalculatePointVisibilityGraph(this.GetActivePolylines(), this.get_VisibilityGraph(), point, Microsoft.Msagl.Routing.Visibility.VisibilityKind.Tangent, $1);
                    v = $1.Value;
                    return $res;
                }).call(this);
                System.Diagnostics.Debug.Assert$$Boolean(v != null);
            }
            return v;
        },
        GetVertex: function (point){
            var v = this.visibilityGraph.FindVertex(point);
            if (v == null && this.get_LookForRoundedVertices())
                v = this.visibilityGraph.FindVertex(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Point(point));
            return v;
        },
        LookForRoundedVertices$$: "System.Boolean",
        get_LookForRoundedVertices: function (){
            return this._LookForRoundedVertices;
        },
        set_LookForRoundedVertices: function (value){
            this._LookForRoundedVertices = value;
        },
        ObstacleCalculator$$: "Microsoft.Msagl.Routing.InteractiveObstacleCalculator",
        get_ObstacleCalculator: function (){
            return this._ObstacleCalculator;
        },
        set_ObstacleCalculator: function (value){
            this._ObstacleCalculator = value;
        },
        ctor$$IEnumerable$1$ICurve$$Double$$Double$$Double$$Boolean: function (obstacles, padding, loosePadding, coneSpannerAngle, ignoreTightPadding){
            this._sourceTightPolyline = null;
            this.targetTightPolyline = null;
            this.targetLoosePolyline = null;
            this.activeRectangle = Microsoft.Msagl.Core.Geometry.Rectangle.CreateAnEmptyBox();
            this.visibilityGraph = null;
            this.activePolygons = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Visibility.Polygon.ctor);
            this.alreadyAddedOrExcludedPolylines = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            this.sourcePort = null;
            this.targetPort = null;
            this.loosePadding = 0;
            this._sourceVisibilityVertex = null;
            this.targetVisibilityVertex = null;
            this._polyline = null;
            this.targetIsInsideOfSourceTightPolyline = false;
            this.sourceIsInsideOfTargetTightPolyline = false;
            this.UseEdgeLengthMultiplier = false;
            this.UseInnerPolylingShortcutting = true;
            this.UsePolylineEndShortcutting = true;
            this.AllowedShootingStraightLines = true;
            this.cornerTable = null;
            this.cacheCorners = false;
            this.foundCachedCorners = 0;
            this._Obstacles = null;
            this._EnteringAngleBound = 0;
            this._SourceLoosePolyline = null;
            this._TightPadding = 0;
            this._OffsetForPolylineRelaxing = 0;
            this._ExpectedProgressSteps = 0;
            this._StartPointOfEdgeRouting = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._ConeSpannerAngle = 0;
            this._UseSpanner = false;
            this._LookForRoundedVertices = false;
            this._ObstacleCalculator = null;
            this._IgnoreTightPadding = false;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.set_IgnoreTightPadding(ignoreTightPadding);
            this.set_EnteringAngleBound(1.39626340159546);
            this.set_TightPadding(padding);
            this.set_LoosePadding(loosePadding);
            this.set_OffsetForPolylineRelaxing(0.75 * padding);
            if (coneSpannerAngle > 0){
                System.Diagnostics.Debug.Assert$$Boolean(coneSpannerAngle > 0.0174532925199433);
                System.Diagnostics.Debug.Assert$$Boolean(coneSpannerAngle <= 1.5707963267949);
                this.set_UseSpanner(true);
                this.set_ExpectedProgressSteps(Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSpanner.GetTotalSteps(coneSpannerAngle));
            }
            else {
                this.set_ExpectedProgressSteps(System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor, obstacles));
            }
            this.set_ConeSpannerAngle(coneSpannerAngle);
            this.set_Obstacles(obstacles);
            this.CalculateObstacles();
        },
        IgnoreTightPadding$$: "System.Boolean",
        get_IgnoreTightPadding: function (){
            return this._IgnoreTightPadding;
        },
        set_IgnoreTightPadding: function (value){
            this._IgnoreTightPadding = value;
        },
        GetActivePolylinesWithException: function (targetLoosePoly){
            return System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Visibility.Polygon.ctor, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Visibility.Polygon.ctor, this.activePolygons, $CreateAnonymousDelegate(this, function (polygon){
                return polygon.get_Polyline() != targetLoosePoly;
            })), $CreateAnonymousDelegate(this, function (polygon){
                return polygon.get_Polyline();
            }));
        },
        RouteEdgeToBoundaryPort: function (portLoosePolyline, smooth, smoothedPolyline){
            this.set_TargetLoosePolyline(portLoosePolyline);
            if (Is(this.sourcePort, Microsoft.Msagl.Core.Layout.FloatingPort.ctor))
                return this.RouteFromFloatingPortToBoundaryPort(smooth, smoothedPolyline);
            return this.RouteFromBoundaryPortToBoundaryPort(smooth, smoothedPolyline);
        },
        RouteFromBoundaryPortToBoundaryPort: function (smooth, smoothedPolyline){
            var sourcePortLocation = this.get_SourcePort().get_Location();
            var curve;
            var targetPortLocation = this.targetPort.get_Location();
            var ls = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(sourcePortLocation, targetPortLocation);
            if (this.LineCanBeAcceptedForRouting(ls)){
                this._polyline = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
                this._polyline.AddPoint$$Point(ls.get_Start());
                this._polyline.AddPoint$$Point(ls.get_End());
                smoothedPolyline.Value = this.SmoothedPolylineFromTwoPoints(ls.get_Start(), ls.get_End());
                curve = Microsoft.Msagl.Core.Geometry.SmoothedPolyline.FromPoints(this._polyline).CreateCurve();
            }
            else {
                var takenOutPoint = this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.targetPort.get_Curve(), (Cast(this.targetPort, Microsoft.Msagl.Core.Layout.CurvePort.ctor)).get_Parameter(), this.get_TargetLoosePolyline());
                ls = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(sourcePortLocation, takenOutPoint);
                if (this.InsideOfTheAllowedConeOfBoundaryPort(takenOutPoint, As(this.get_SourcePort(), Microsoft.Msagl.Core.Layout.CurvePort.ctor)) && this.LineAvoidsTightHierarchy$$LineSegment$$Polyline(ls, this._sourceTightPolyline)){
                    this._polyline = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
                    this._polyline.AddPoint$$Point(ls.get_Start());
                    this._polyline.AddPoint$$Point(ls.get_End());
                    this._polyline.AddPoint$$Point(targetPortLocation);
                    curve = this.SmoothCornersAndReturnCurve(smooth, smoothedPolyline);
                }
                else {
                    ls = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(this.get_StartPointOfEdgeRouting(), targetPortLocation);
                    if (this.InsideOfTheAllowedConeOfBoundaryPort(this.get_StartPointOfEdgeRouting(), As(this.get_TargetPort(), Microsoft.Msagl.Core.Layout.CurvePort.ctor)) && this.LineAvoidsTightHierarchy$$LineSegment(ls)){
                        this._polyline = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
                        this._polyline.AddPoint$$Point(sourcePortLocation);
                        this._polyline.AddPoint$$Point(ls.get_Start());
                        this._polyline.AddPoint$$Point(ls.get_End());
                        curve = this.SmoothCornersAndReturnCurve(smooth, smoothedPolyline);
                    }
                    else {
                        var x;
                        if ((function (){
                            var $1 = {
                                Value: x
                            };
                            var $res = Microsoft.Msagl.Core.Geometry.Curves.LineSegment.Intersect(sourcePortLocation, this.get_StartPointOfEdgeRouting(), targetPortLocation, takenOutPoint, $1);
                            x = $1.Value;
                            return $res;
                        }).call(this)){
                            this._polyline = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
                            this._polyline.AddPoint$$Point(sourcePortLocation);
                            this._polyline.AddPoint$$Point(x);
                            this._polyline.AddPoint$$Point(targetPortLocation);
                            curve = this.SmoothCornersAndReturnCurve(smooth, smoothedPolyline);
                        }
                        else if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(this.get_StartPointOfEdgeRouting(), takenOutPoint)){
                            this._polyline = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
                            this._polyline.AddPoint$$Point(sourcePortLocation);
                            this._polyline.AddPoint$$Point(takenOutPoint);
                            this._polyline.AddPoint$$Point(targetPortLocation);
                            curve = this.SmoothCornersAndReturnCurve(smooth, smoothedPolyline);
                        }
                        else if (this.LineAvoidsTightHierarchy$$LineSegment(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(this.get_StartPointOfEdgeRouting(), takenOutPoint))){
                            this._polyline = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
                            this._polyline.AddPoint$$Point(sourcePortLocation);
                            this._polyline.AddPoint$$Point(this.get_StartPointOfEdgeRouting());
                            this._polyline.AddPoint$$Point(takenOutPoint);
                            this._polyline.AddPoint$$Point(targetPortLocation);
                            curve = this.SmoothCornersAndReturnCurve(smooth, smoothedPolyline);
                        }
                        else {
                            this.ExtendVisibilityGraphToTargetBoundaryPort(takenOutPoint);
                            this._polyline = this.GetShortestPolyline(this.get_SourceVisibilityVertex(), this.get_TargetVisibilityVertex());
                            var tmpTargetTight;
                            var tmpSourceTight = (function (){
                                var $1 = {
                                    Value: tmpTargetTight
                                };
                                var $res = this.HideSourceTargetTightsIfNeeded($1);
                                tmpTargetTight = $1.Value;
                                return $res;
                            }).call(this);
                            this.TryShortcutPolyline();
                            this.RecoverSourceTargetTights(tmpSourceTight, tmpTargetTight);
                            this.RelaxPolyline();
                            this._polyline.PrependPoint(sourcePortLocation);
                            this._polyline.AddPoint$$Point(targetPortLocation);
                            curve = this.SmoothCornersAndReturnCurve(smooth, smoothedPolyline);
                        }
                    }
                }
            }
            return curve;
        },
        RecoverSourceTargetTights: function (tmpSourceTight, tmpTargetTight){
            this.set_SourceTightPolyline(tmpSourceTight);
            this.set_TargetTightPolyline(tmpTargetTight);
        },
        HideSourceTargetTightsIfNeeded: function (tmpTargetTight){
            var tmpSourceTight = this.get_SourceTightPolyline();
            tmpTargetTight.Value = this.get_TargetTightPolyline();
            this.set_SourceTightPolyline((function ($p43){
                this.set_TargetTightPolyline($p43);
                return $p43;
            }).call(this, null));
            return tmpSourceTight;
        },
        LineAvoidsTightHierarchy$$LineSegment: function (lineSegment){
            return Microsoft.Msagl.Routing.InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolyline$$LineSegment$$RectangleNode$1$Polyline(lineSegment, this.get_ObstacleCalculator().get_RootOfTightHierarchy()).get_Count() == 0;
        },
        RouteFromFloatingPortToBoundaryPort: function (smooth, smoothedPolyline){
            var targetPortLocation = this.targetPort.get_Location();
            var ls;
            if (this.InsideOfTheAllowedConeOfBoundaryPort(this.sourcePort.get_Location(), Cast(this.targetPort, Microsoft.Msagl.Core.Layout.CurvePort.ctor))){
                ls = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(this.get_SourcePort().get_Location(), targetPortLocation);
                if (this.LineCanBeAcceptedForRouting(ls)){
                    smoothedPolyline.Value = this.SmoothedPolylineFromTwoPoints(ls.get_Start(), ls.get_End());
                    return ls;
                }
            }
            var takenOutTargetPortLocation = this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.get_TargetPort().get_Curve(), (Cast(this.get_TargetPort(), Microsoft.Msagl.Core.Layout.CurvePort.ctor)).get_Parameter(), this.get_TargetLoosePolyline());
            ls = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(this.get_SourcePort().get_Location(), takenOutTargetPortLocation);
            if (this.LineAvoidsTightHierarchy$$LineSegment$$Polyline(ls, this._sourceTightPolyline)){
                this._polyline = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor$$Point$Array([ls.get_Start(), ls.get_End(), targetPortLocation]);
                smoothedPolyline.Value = Microsoft.Msagl.Core.Geometry.SmoothedPolyline.FromPoints(this._polyline);
                return smoothedPolyline.Value.CreateCurve();
            }
            this.ExtendVisibilityGraphToTargetBoundaryPort(takenOutTargetPortLocation);
            this._polyline = this.GetShortestPolyline(this.get_SourceVisibilityVertex(), this.get_TargetVisibilityVertex());
            this.RelaxPolyline();
            this._polyline.AddPoint$$Point(targetPortLocation);
            return this.SmoothCornersAndReturnCurve(smooth, smoothedPolyline);
        },
        LineAvoidsTightHierarchy$$LineSegment$$Polyline: function (ls, polylineToExclude){
            var lineIsGood = true;
            var $it1003 = Microsoft.Msagl.Routing.InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolyline$$LineSegment$$RectangleNode$1$Polyline(ls, this.get_ObstacleCalculator().get_RootOfTightHierarchy()).GetEnumerator();
            while ($it1003.MoveNext()){
                var ii = $it1003.get_Current();
                if (ii.get_Segment1() != polylineToExclude){
                    lineIsGood = false;
                    break;
                }
            }
            return lineIsGood;
        },
        LineAvoidsTightHierarchy$$LineSegment$$Polyline$$Polyline: function (ls, polylineToExclude0, polylineToExclude1){
            var lineIsGood = true;
            var $it1004 = Microsoft.Msagl.Routing.InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolyline$$LineSegment$$RectangleNode$1$Polyline(ls, this.get_ObstacleCalculator().get_RootOfTightHierarchy()).GetEnumerator();
            while ($it1004.MoveNext()){
                var ii = $it1004.get_Current();
                if (!(ii.get_Segment1() == polylineToExclude0 || ii.get_Segment1() == polylineToExclude1)){
                    lineIsGood = false;
                    break;
                }
            }
            return lineIsGood;
        },
        LineAvoidsTightHierarchy$$Point$$Point$$Polyline$$Polyline: function (a, b, polylineToExclude0, polylineToExclude1){
            return this.LineAvoidsTightHierarchy$$LineSegment$$Polyline$$Polyline(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(a, b), polylineToExclude0, polylineToExclude1);
        },
        ExtendVisibilityGraphToTargetBoundaryPort: function (takenOutTargetPortLocation){
            var addedPolygons = null;
            if (this.get_VisibilityGraph() == null)
                this.set_VisibilityGraph(new Microsoft.Msagl.Routing.Visibility.VisibilityGraph.ctor());
            if (!this.activeRectangle.Contains$$Point(takenOutTargetPortLocation) || !this.activeRectangle.Contains$$Rectangle(this.get_TargetLoosePolyline().get_BoundingBox())){
                if (this.activeRectangle.get_IsEmpty()){
                    this.activeRectangle = this.get_TargetLoosePolyline().get_BoundingBox();
                    this.activeRectangle.Add$$Point(this.get_SourcePort().get_Location());
                    this.activeRectangle.Add$$Point(this.get_StartPointOfEdgeRouting());
                    this.activeRectangle.Add$$Point(takenOutTargetPortLocation);
                }
                else {
                    this.activeRectangle.Add$$Point(takenOutTargetPortLocation);
                    this.activeRectangle.Add$$Rectangle(this.get_TargetLoosePolyline().get_BoundingBox());
                }
                addedPolygons = this.GetAddedPolygonesAndMaybeExtendActiveRectangle();
                var $it1005 = addedPolygons.GetEnumerator();
                while ($it1005.MoveNext()){
                    var polygon = $it1005.get_Current();
                    this.get_VisibilityGraph().AddHole(polygon.get_Polyline());
                }
            }
            if (addedPolygons == null){
                if (this.targetVisibilityVertex != null)
                    this.get_VisibilityGraph().RemoveVertex(this.targetVisibilityVertex);
                this.CalculateEdgeTargetVisibilityGraph(takenOutTargetPortLocation);
            }
            else {
                this.RemovePointVisibilityGraphs();
                var visibilityGraphGenerator = new Microsoft.Msagl.Routing.Visibility.InteractiveTangentVisibilityGraphCalculator.ctor(addedPolygons, this.activePolygons, this.get_VisibilityGraph());
                visibilityGraphGenerator.Run();
                this.activePolygons.AddRange(addedPolygons);
                this.CalculateEdgeTargetVisibilityGraph(takenOutTargetPortLocation);
                this.CalculateSourcePortVisibilityGraph();
            }
        },
        GetHitLoosePolyline: function (point){
            if (this.get_ObstacleCalculator().IsEmpty() || this.get_ObstacleCalculator().get_RootOfLooseHierarchy() == null)
                return null;
            return Microsoft.Msagl.Routing.InteractiveEdgeRouter.GetFirstHitPolyline(point, this.get_ObstacleCalculator().get_RootOfLooseHierarchy());
        },
        Clean: function (){
            this.set_SourcePort((function ($p44){
                this.set_TargetPort($p44);
                return $p44;
            }).call(this, null));
            this.set_SourceLoosePolyline((function ($p45){
                this.set_SourceTightPolyline($p45);
                return $p45;
            }).call(this, null));
            this.targetTightPolyline = (function ($p46){
                this.set_TargetLoosePolyline($p46);
                return $p46;
            }).call(this, null);
            this.set_VisibilityGraph(null);
            this._sourceVisibilityVertex = this.targetVisibilityVertex = null;
            this.activePolygons.Clear();
            this.alreadyAddedOrExcludedPolylines.Clear();
            this.activeRectangle.SetToEmpty();
        },
        SetSourcePortAndSourceLoosePolyline: function (port, sourceLoosePolylinePar){
            this.set_SourceLoosePolyline(sourceLoosePolylinePar);
            this.sourcePort = port;
            if (this.sourcePort != null){
                this.set_SourceTightPolyline(Microsoft.Msagl.Routing.InteractiveEdgeRouter.GetFirstHitPolyline(this.sourcePort.get_Location(), this.get_ObstacleCalculator().get_RootOfTightHierarchy()));
                if (Is(this.sourcePort, Microsoft.Msagl.Core.Layout.FloatingPort.ctor)){
                    this.alreadyAddedOrExcludedPolylines.Insert(this.get_SourceLoosePolyline());
                    this.set_StartPointOfEdgeRouting(this.get_SourcePort().get_Location());
                }
                else
                    this.set_StartPointOfEdgeRouting(this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.get_SourcePort().get_Curve(), (Cast(this.sourcePort, Microsoft.Msagl.Core.Layout.CurvePort.ctor)).get_Parameter(), this.get_SourceLoosePolyline()));
            }
        },
        RunInternal: function (){
            this.CalculateWholeTangentVisibilityGraph();
        },
        CalculateWholeTangentVisibilityGraph: function (){
            this.set_VisibilityGraph(new Microsoft.Msagl.Routing.Visibility.VisibilityGraph.ctor());
            this.CalculateWholeVisibilityGraphOnExistingGraph();
        },
        CalculateWholeVisibilityGraphOnExistingGraph: function (){
            this.activePolygons = new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Microsoft.Msagl.Routing.Visibility.Polygon.ctor, this.AllPolygons());
            var $it1006 = this.get_ObstacleCalculator().get_LooseObstacles().GetEnumerator();
            while ($it1006.MoveNext()){
                var polylineLocal = $it1006.get_Current();
                this.get_VisibilityGraph().AddHole(polylineLocal);
            }
            var visibilityGraphGenerator;
            if (this.get_UseSpanner()){
                visibilityGraphGenerator = (function (){
                    var $v110 = new Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSpanner.ctor$$IEnumerable$1$Polyline$$VisibilityGraph(this.get_ObstacleCalculator().get_LooseObstacles(), this.get_VisibilityGraph());
                    $v110.set_ConeAngle(this.get_ConeSpannerAngle());
                    return $v110;
                }).call(this);
            }
            else {
                visibilityGraphGenerator = new Microsoft.Msagl.Routing.Visibility.InteractiveTangentVisibilityGraphCalculator.ctor(new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Visibility.Polygon.ctor), this.activePolygons, this.visibilityGraph);
            }
            visibilityGraphGenerator.Run();
        },
        RouteSplineFromPortToPortWhenTheWholeGraphIsReady: function (sourcePortLocal, targetPortLocal, smooth, smoothedPolyline){
            var reversed = (Is(sourcePortLocal, Microsoft.Msagl.Core.Layout.FloatingPort.ctor) && Is(targetPortLocal, Microsoft.Msagl.Core.Layout.CurvePort.ctor)) || Is(sourcePortLocal, Microsoft.Msagl.Core.Layout.HookUpAnywhereFromInsidePort.ctor);
            if (reversed){
                var tmp = sourcePortLocal;
                sourcePortLocal = targetPortLocal;
                targetPortLocal = tmp;
            }
            this.sourcePort = sourcePortLocal;
            this.targetPort = targetPortLocal;
            this.FigureOutSourceTargetPolylinesAndActiveRectangle();
            var curve = this.GetEdgeGeomByRouting(smooth, smoothedPolyline);
            if (curve == null)
                return null;
            this._sourceVisibilityVertex = this.targetVisibilityVertex = null;
            if (reversed)
                curve = curve.Reverse();
            return curve;
        },
        GetEdgeGeomByRouting: function (smooth, smoothedPolyline){
            this.targetIsInsideOfSourceTightPolyline = this.get_SourceTightPolyline() == null || Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(this.targetPort.get_Location(), this.get_SourceTightPolyline()) == Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Inside;
            this.sourceIsInsideOfTargetTightPolyline = this.get_TargetTightPolyline() == null || Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(this.sourcePort.get_Location(), this.get_TargetTightPolyline()) == Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Inside;
            var curvePort = As(this.sourcePort, Microsoft.Msagl.Core.Layout.CurvePort.ctor);
            var curve;
            if (curvePort != null){
                this.set_StartPointOfEdgeRouting(!this.targetIsInsideOfSourceTightPolyline ? this.TakeBoundaryPortOutsideOfItsLoosePolyline(curvePort.get_Curve(), curvePort.get_Parameter(), this.get_SourceLoosePolyline()) : curvePort.get_Location());
                this.CalculateSourcePortVisibilityGraph();
                if (Is(this.targetPort, Microsoft.Msagl.Core.Layout.CurvePort.ctor))
                    curve = this.RouteFromBoundaryPortToBoundaryPort(smooth, smoothedPolyline);
                else
                    curve = this.RouteFromBoundaryPortToFloatingPort(this.targetLoosePolyline, smooth, smoothedPolyline);
            }
            else {
                if (Is(this.targetPort, Microsoft.Msagl.Core.Layout.FloatingPort.ctor)){
                    this.ExtendVisibilityGraphFromFloatingSourcePort();
                    System.Diagnostics.Debug.Assert$$Boolean(this._sourceVisibilityVertex != null);
                    curve = this.RouteFromFloatingPortToFloatingPort(this.targetLoosePolyline, smooth, smoothedPolyline);
                }
                else
                    curve = this.RouteFromFloatingPortToAnywherePort((Cast(this.targetPort, Microsoft.Msagl.Core.Layout.HookUpAnywhereFromInsidePort.ctor)).get_LoosePolyline(), smooth, smoothedPolyline, Cast(this.targetPort, Microsoft.Msagl.Core.Layout.HookUpAnywhereFromInsidePort.ctor));
            }
            return curve;
        },
        RouteFromFloatingPortToAnywherePort: function (targetLoosePoly, smooth, smoothedPolyline, port){
            if (!port.get_Curve().get_BoundingBox().Contains$$Point(this.sourcePort.get_Location())){
                smoothedPolyline.Value = null;
                return null;
            }
            this._sourceVisibilityVertex = this.GetVertex(this.sourcePort.get_Location());
            this._polyline = this.GetShortestPolylineToMulitpleTargets(this.get_SourceVisibilityVertex(), this.Targets(targetLoosePoly));
            if (this._polyline == null){
                smoothedPolyline.Value = null;
                return null;
            }
            if (this.get_UseSpanner())
                this.TryShortcutPolyline();
            this.RelaxPolyline();
            this.FixLastPolylinePointForAnywherePort(port);
            if (port.get_HookSize() > 0)
                this.BuildHook(port);
            return this.SmoothCornersAndReturnCurve(smooth, smoothedPolyline);
        },
        BuildHook: function (port){
            var curve = port.get_Curve();
            var ellipse = new Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor$$Double$$Double$$Point(port.get_HookSize(), port.get_HookSize(), this._polyline.get_End());
            var intersections = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.ctor, Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(curve, ellipse, true));
            System.Diagnostics.Debug.Assert$$Boolean(intersections.length == 2);
            if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(intersections[0].get_IntersectionPoint(), this._polyline.get_End(), this._polyline.get_EndPoint().get_Prev().get_Point()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise)
                System.Linq.Enumerable.Reverse$1(Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.ctor, intersections);
            var polylineTangent = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this._polyline.get_End(), this._polyline.get_EndPoint().get_Prev().get_Point())).Normalize();
            var tan0 = curve.Derivative(intersections[0].get_Par0()).Normalize();
            var prj0 = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(tan0, polylineTangent);
            if (System.Math.Abs$$Double(prj0) < 0.2)
                this.ExtendPolyline(tan0, intersections[0], polylineTangent, port);
            else {
                var tan1 = curve.Derivative(intersections[1].get_Par0()).Normalize();
                var prj1 = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(tan1, polylineTangent);
                if (prj1 < prj0)
                    this.ExtendPolyline(tan1, intersections[1], polylineTangent, port);
                else
                    this.ExtendPolyline(tan0, intersections[0], polylineTangent, port);
            }
        },
        ExtendPolyline: function (tangentAtIntersection, x, polylineTangent, port){
            var normal = tangentAtIntersection.Rotate(1.5707963267949);
            if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(normal, polylineTangent) < 0)
                normal = Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(normal);
            var pointBeforeLast = Microsoft.Msagl.Core.Geometry.Point.op_Addition(x.get_IntersectionPoint(), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(normal, port.get_HookSize()));
            var pointAfterX;
            if (!(function (){
                var $1 = {
                    Value: pointAfterX
                };
                var $res = Microsoft.Msagl.Core.Geometry.Point.LineLineIntersection(pointBeforeLast, Microsoft.Msagl.Core.Geometry.Point.op_Addition(pointBeforeLast, tangentAtIntersection), this._polyline.get_End(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(this._polyline.get_End(), polylineTangent), $1);
                pointAfterX = $1.Value;
                return $res;
            }).call(this))
                return;
            this._polyline.AddPoint$$Point(pointAfterX);
            this._polyline.AddPoint$$Point(pointBeforeLast);
            this._polyline.AddPoint$$Point(x.get_IntersectionPoint());
        },
        FixLastPolylinePointForAnywherePort: function (port){
            while (true){
                var lastPointInside = this.GetLastPointInsideOfCurveOnPolyline(port.get_Curve());
                lastPointInside.get_Next().set_Next(null);
                this._polyline.set_EndPoint(lastPointInside.get_Next());
                var dir = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(lastPointInside.get_Next().get_Point(), lastPointInside.get_Point());
                dir = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(dir.Normalize(), port.get_Curve().get_BoundingBox().get_Diagonal());
                var dir0 = dir.Rotate(-port.get_AdjustmentAngle());
                var dir1 = dir.Rotate(port.get_AdjustmentAngle());
                var rx = Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveIntersectionOne(port.get_Curve(), new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(lastPointInside.get_Point(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(lastPointInside.get_Point(), dir0)), true);
                var lx = Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveIntersectionOne(port.get_Curve(), new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(lastPointInside.get_Point(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(lastPointInside.get_Point(), dir1)), true);
                if (rx == null || lx == null)
                    return;
                var trimmedCurve = Microsoft.Msagl.Routing.InteractiveEdgeRouter.GetTrimmedCurveForHookingUpAnywhere(port.get_Curve(), lastPointInside, rx, lx);
                var newLastPoint = trimmedCurve.get_Item$$Double(trimmedCurve.ClosestParameter(lastPointInside.get_Point()));
                if (!this.LineAvoidsTightHierarchy$$LineSegment$$Polyline$$Polyline(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(lastPointInside.get_Point(), newLastPoint), this.get_SourceTightPolyline(), null)){
                    var xx = Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveIntersectionOne(port.get_Curve(), new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(lastPointInside.get_Point(), lastPointInside.get_Next().get_Point()), false);
                    if (xx == null)
                        return;
                    this._polyline.get_EndPoint().set_Point(xx.get_IntersectionPoint());
                    break;
                }
                this._polyline.get_EndPoint().set_Point(newLastPoint);
                if (lastPointInside.get_Prev() == null || !this.TryShortcutPolyPoint(lastPointInside.get_Prev()))
                    break;
            }
        },
        GetLastPointInsideOfCurveOnPolyline: function (curve){
            for (var p = this._polyline.get_EndPoint().get_Prev(); p != null; p = p.get_Prev()){
                if (p.get_Prev() == null)
                    return p;
                if (Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(p.get_Point(), curve) == Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Inside)
                    return p;
            }
            throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
        },
        GetShortestPolylineToMulitpleTargets: function (sourceVisVertex, targets){
            this.CleanTheGraphForShortestPath();
            var pathCalc = new Microsoft.Msagl.Routing.SingleSourceMultipleTargetsShortestPathOnVisibilityGraph.ctor(sourceVisVertex, targets, this.get_VisibilityGraph());
            var path = pathCalc.GetPath();
            if (path == null)
                return null;
            System.Diagnostics.Debug.Assert$$Boolean(System.Linq.Enumerable.First$1$$IEnumerable$1(Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor, path) == sourceVisVertex && System.Linq.Enumerable.Contains$1$$IEnumerable$1$$TSource(Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor, targets, System.Linq.Enumerable.Last$1$$IEnumerable$1(Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor, path)));
            var ret = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
            var $it1007 = path.GetEnumerator();
            while ($it1007.MoveNext()){
                var v = $it1007.get_Current();
                ret.AddPoint$$Point(v.Point);
            }
            return Microsoft.Msagl.Routing.InteractiveEdgeRouter.RemoveCollinearVertices(ret);
        },
        Targets: function (targetLoosePoly){
            return new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor, targetLoosePoly, $CreateAnonymousDelegate(this, function (p){
                return this.visibilityGraph.FindVertex(p);
            })));
        },
        ExtendVisibilityGraphFromFloatingSourcePort: function (){
            var fp = As(this.sourcePort, Microsoft.Msagl.Core.Layout.FloatingPort.ctor);
            System.Diagnostics.Debug.Assert$$Boolean(fp != null);
            this.set_StartPointOfEdgeRouting(fp.get_Location());
            if (this.get_UseSpanner())
                this._sourceVisibilityVertex = this.AddTransientVisibilityEdgesForPort(this.sourcePort.get_Location(), this.get_SourceLoosePolyline());
            else {
                (function (){
                    var $1 = {
                        Value: this._sourceVisibilityVertex
                    };
                    var $res = Microsoft.Msagl.Routing.Visibility.PointVisibilityCalculator.CalculatePointVisibilityGraph(System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, this.GetActivePolylines(), $CreateAnonymousDelegate(this, function (p){
                        return p != this.get_SourceLoosePolyline();
                    })), this.get_VisibilityGraph(), this.get_StartPointOfEdgeRouting(), Microsoft.Msagl.Routing.Visibility.VisibilityKind.Tangent, $1);
                    this._sourceVisibilityVertex = $1.Value;
                    return $res;
                }).call(this);
            }
        },
        FigureOutSourceTargetPolylinesAndActiveRectangle: function (){
            this._sourceTightPolyline = Microsoft.Msagl.Routing.InteractiveEdgeRouter.GetFirstHitPolyline(this.sourcePort.get_Location(), this.get_ObstacleCalculator().get_RootOfTightHierarchy());
            this.set_SourceLoosePolyline(Microsoft.Msagl.Routing.InteractiveEdgeRouter.GetFirstHitPolyline(this.sourcePort.get_Location(), this.get_ObstacleCalculator().get_RootOfLooseHierarchy()));
            this.targetTightPolyline = Microsoft.Msagl.Routing.InteractiveEdgeRouter.GetFirstHitPolyline(this.targetPort.get_Location(), this.get_ObstacleCalculator().get_RootOfTightHierarchy());
            this.targetLoosePolyline = Microsoft.Msagl.Routing.InteractiveEdgeRouter.GetFirstHitPolyline(this.targetPort.get_Location(), this.get_ObstacleCalculator().get_RootOfLooseHierarchy());
            this.activeRectangle = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-Infinity, Infinity), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(Infinity, -Infinity));
        },
        AllPolygons: function (){
            var $yield = [];
            var $it1008 = this.get_ObstacleCalculator().get_LooseObstacles().GetEnumerator();
            while ($it1008.MoveNext()){
                var p = $it1008.get_Current();
                $yield.push(new Microsoft.Msagl.Routing.Visibility.Polygon.ctor(p));
            }
            return $yield;
        },
        GetVisibilityGraph: function (){
            return this.get_VisibilityGraph();
        },
        CalculatePortVisibilityGraph: function (portLocationsPointSet){
            var coneSpanner = (function (){
                var $v111 = new Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSpannerForPortLocations.ctor(this.get_ObstacleCalculator().get_LooseObstacles(), this.get_VisibilityGraph(), portLocationsPointSet);
                $v111.set_ConeAngle(this.get_ConeSpannerAngle());
                return $v111;
            }).call(this);
            coneSpanner.Run();
        },
        AddActivePolygons: function (polygons){
            this.activePolygons.AddRange(polygons);
        },
        ClearActivePolygons: function (){
            this.activePolygons.Clear();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$InteractiveEdgeRouter);
var Microsoft$Msagl$Routing$InteractiveObstacleCalculator = {
    fullname: "Microsoft.Msagl.Routing.InteractiveObstacleCalculator",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Routing.InteractiveObstacleCalculator.LooseDistCoefficient = 2.1;
        },
        UpdateRectsForParents: function (node){
            while (node.get_Parent() != null){
                node.get_Parent().rectangle.Add$$Rectangle(node.get_Rectangle());
                node = node.get_Parent();
            }
        },
        CreateTightObstacles$$IEnumerable$1$ICurve$$Double$$Set$1$Polyline: function (obstacles, tightPadding, tightObstacleSet){
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.DataStructures.Set$1.op_Inequality(tightObstacleSet, null));
            if (System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor, obstacles) == 0)
                return null;
            var $it1010 = obstacles.GetEnumerator();
            while ($it1010.MoveNext()){
                var curve = $it1010.get_Current();
                Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CalculateTightPolyline(tightObstacleSet, tightPadding, curve);
            }
            return Microsoft.Msagl.Routing.InteractiveObstacleCalculator.RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(tightObstacleSet);
        },
        RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy: function (tightObstacleSet){
            var hierarchy = Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CalculateHierarchy(tightObstacleSet);
            var overlappingPairSet;
            while ((overlappingPairSet = Microsoft.Msagl.Routing.InteractiveObstacleCalculator.GetOverlappedPairSet(hierarchy)).get_Count() > 0)
                hierarchy = Microsoft.Msagl.Routing.InteractiveObstacleCalculator.ReplaceTightObstaclesWithConvexHulls(tightObstacleSet, overlappingPairSet);
            return hierarchy;
        },
        CalculateTightPolyline: function (tightObstacles, tightPadding, curve){
            var tightPoly = Microsoft.Msagl.Routing.InteractiveObstacleCalculator.PaddedPolylineBoundaryOfNode(curve, tightPadding);
            tightObstacles.Insert(tightPoly);
        },
        ReplaceTightObstaclesWithConvexHulls: function (tightObsts, overlappingPairSet){
            var overlapping = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            var $it1013 = overlappingPairSet.GetEnumerator();
            while ($it1013.MoveNext()){
                var pair = $it1013.get_Current();
                overlapping.Insert(pair.get_Item1());
                overlapping.Insert(pair.get_Item2());
            }
            var intToPoly = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, overlapping);
            var polyToInt = Microsoft.Msagl.Routing.InteractiveObstacleCalculator.MapToInt$1(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, intToPoly);
            var graph = new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.Tuple$2.ctor, Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, overlappingPairSet, function (pair){
                return new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(polyToInt.get_Item$$TKey(pair.get_Item1()), polyToInt.get_Item$$TKey(pair.get_Item2()));
            }));
            var connectedComponents = Microsoft.Msagl.Core.GraphAlgorithms.ConnectedComponentCalculator$1.GetComponents(graph);
            var $it1014 = connectedComponents.GetEnumerator();
            while ($it1014.MoveNext()){
                var component = $it1014.get_Current();
                var polys = System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.Int32.ctor, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, component, function (i){
                    return intToPoly[i];
                });
                var points = System.Linq.Enumerable.SelectMany$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, polys, function (p){
                    return p;
                });
                var convexHull = Microsoft.Msagl.Core.Geometry.ConvexHull.CreateConvexHullAsClosedPolyline(points);
                var $it1015 = polys.GetEnumerator();
                while ($it1015.MoveNext()){
                    var poly = $it1015.get_Current();
                    tightObsts.Remove(poly);
                }
                tightObsts.Insert(convexHull);
            }
            return Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CalculateHierarchy(tightObsts);
        },
        MapToInt$1: function (T, objects){
            var ret = new System.Collections.Generic.Dictionary$2.ctor(T, System.Int32.ctor);
            for (var i = 0; i < objects.length; i++)
                ret.set_Item$$TKey(objects[i], i);
            return ret;
        },
        GetOverlappedPairSet: function (rootOfObstacleHierarchy){
            var overlappingPairSet = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(System.Tuple$2.ctor);
            Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.CrossRectangleNodes$1$$RectangleNode$1$$RectangleNode$1$$Action$2(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, rootOfObstacleHierarchy, rootOfObstacleHierarchy, function (a, b){
                if (Microsoft.Msagl.Routing.InteractiveObstacleCalculator.PolylinesIntersect(a, b)){
                    overlappingPairSet.Insert(new System.Tuple$2.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, a, b));
                }
            });
            return overlappingPairSet;
        },
        PolylinesIntersect: function (a, b){
            var ret = Microsoft.Msagl.Core.Geometry.Curves.Curve.CurvesIntersect(a, b) || Microsoft.Msagl.Routing.InteractiveObstacleCalculator.OneCurveLiesInsideOfOther(a, b);
            return ret;
        },
        CalculateHierarchy: function (polylines){
            var rectNodes = System.Linq.Enumerable.ToList$1(Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, polylines, function (polyline){
                return Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CreateRectNodeOfPolyline(polyline);
            }));
            return Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnListOfNodes(rectNodes);
        },
        CreateRectNodeOfPolyline: function (polyline){
            return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, polyline, (As(polyline, Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor)).get_BoundingBox());
        },
        OneCurveLiesInsideOfOther: function (polyA, polyB){
            System.Diagnostics.Debug.Assert$$Boolean$$String(!Microsoft.Msagl.Core.Geometry.Curves.Curve.CurvesIntersect(polyA, polyB), "The curves should not intersect");
            return (Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(polyA.get_Start(), polyB) != Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside || Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(polyB.get_Start(), polyA) != Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside);
        },
        CreatePaddedPolyline: function (poly, padding){
            System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(poly.get_Item$$Double(0), poly.get_Item$$Double(1), poly.get_Item$$Double(2)) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise, "Unpadded polyline is not clockwise");
            var ret = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
            if (!Microsoft.Msagl.Routing.InteractiveObstacleCalculator.PadCorner(ret, poly.get_EndPoint().get_Prev(), poly.get_EndPoint(), poly.get_StartPoint(), padding))
                return Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CreatePaddedPolyline((function (){
                    var $v112 = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor$$IEnumerable$1$Point(Microsoft.Msagl.Core.Geometry.ConvexHull.CalculateConvexHull(poly));
                    $v112.set_Closed(true);
                    return $v112;
                })(), padding);
            if (!Microsoft.Msagl.Routing.InteractiveObstacleCalculator.PadCorner(ret, poly.get_EndPoint(), poly.get_StartPoint(), poly.get_StartPoint().get_Next(), padding))
                return Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CreatePaddedPolyline((function (){
                    var $v113 = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor$$IEnumerable$1$Point(Microsoft.Msagl.Core.Geometry.ConvexHull.CalculateConvexHull(poly));
                    $v113.set_Closed(true);
                    return $v113;
                })(), padding);
            for (var pp = poly.get_StartPoint(); pp.get_Next().get_Next() != null; pp = pp.get_Next())
                if (!Microsoft.Msagl.Routing.InteractiveObstacleCalculator.PadCorner(ret, pp, pp.get_Next(), pp.get_Next().get_Next(), padding))
                    return Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CreatePaddedPolyline((function (){
                        var $v114 = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor$$IEnumerable$1$Point(Microsoft.Msagl.Core.Geometry.ConvexHull.CalculateConvexHull(poly));
                        $v114.set_Closed(true);
                        return $v114;
                    })(), padding);
            System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(ret.get_Item$$Double(0), ret.get_Item$$Double(1), ret.get_Item$$Double(2)) != Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise, "Padded polyline is counterclockwise");
            ret.set_Closed(true);
            return ret;
        },
        PadCorner: function (poly, p0, p1, p2, padding){
            var a,b;
            var numberOfPoints = (function (){
                var $1 = {
                    Value: a
                };
                var $2 = {
                    Value: b
                };
                var $res = Microsoft.Msagl.Routing.InteractiveObstacleCalculator.GetPaddedCorner(p0, p1, p2, $1, $2, padding);
                a = $1.Value;
                b = $2.Value;
                return $res;
            })();
            if (numberOfPoints == -1)
                return false;
            poly.AddPoint$$Point(a);
            if (numberOfPoints == 2)
                poly.AddPoint$$Point(b);
            return true;
        },
        GetPaddedCorner: function (first, second, third, a, b, padding){
            var u = first.get_Point();
            var v = second.get_Point();
            var w = third.get_Point();
            if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(u, v, w) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise){
                a.Value = new Microsoft.Msagl.Core.Geometry.Point.ctor();
                b.Value = new Microsoft.Msagl.Core.Geometry.Point.ctor();
                return -1;
            }
            var uvPerp = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v, u)).Rotate(1.5707963267949).Normalize();
            if (Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CornerIsNotTooSharp(u, v, w)){
                uvPerp = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(uvPerp, padding);
                var vwPerp = (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(w, v)).Normalize(), padding)).Rotate(1.5707963267949);
                var result = Microsoft.Msagl.Core.Geometry.Point.LineLineIntersection(Microsoft.Msagl.Core.Geometry.Point.op_Addition(u, uvPerp), Microsoft.Msagl.Core.Geometry.Point.op_Addition(v, uvPerp), Microsoft.Msagl.Core.Geometry.Point.op_Addition(v, vwPerp), Microsoft.Msagl.Core.Geometry.Point.op_Addition(w, vwPerp), a);
                System.Diagnostics.Debug.Assert$$Boolean(result);
                b.Value = a.Value;
                return 1;
            }
            var l = Microsoft.Msagl.Core.Geometry.Point.op_Addition((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v, u)).Normalize(), (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v, w)).Normalize());
            if (l.get_Length() < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_IntersectionEpsilon()){
                a.Value = b.Value = Microsoft.Msagl.Core.Geometry.Point.op_Addition(v, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(padding, uvPerp));
                return 1;
            }
            var d = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(l.Normalize(), padding);
            var dp = d.Rotate(1.5707963267949);
            var xp = (padding - Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(d, uvPerp)) / (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(dp, uvPerp));
            a.Value = Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Addition(d, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(xp, dp)), v);
            b.Value = Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(d, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(xp, dp)), v);
            return 2;
        },
        CornerIsNotTooSharp: function (u, v, w){
            var a = Microsoft.Msagl.Core.Geometry.Point.op_Addition((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(u, v)).Rotate(0.785398163397448), v);
            return Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(v, a, w) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise;
        },
        CurveIsClockwise: function (iCurve, pointInside){
            return Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(pointInside, iCurve.get_Start(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(iCurve.get_Start(), iCurve.Derivative(iCurve.get_ParStart()))) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise;
        },
        PaddedPolylineBoundaryOfNode: function (curve, padding){
            return Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CreatePaddedPolyline(Microsoft.Msagl.Core.Geometry.Curves.Curve.PolylineAroundClosedCurve(curve), padding);
        },
        LoosePolylineWithFewCorners: function (tightPolyline, p){
            if (p < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return tightPolyline;
            var loosePolyline = Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CreateLoosePolylineOnBisectors(tightPolyline, p);
            return loosePolyline;
        },
        CreateLoosePolylineOnBisectors: function (tightPolyline, offset){
            return (function (){
                var $v115 = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor$$IEnumerable$1$Point(Microsoft.Msagl.Core.Geometry.ConvexHull.CalculateConvexHull(Microsoft.Msagl.Routing.InteractiveObstacleCalculator.BisectorPoints(tightPolyline, offset)));
                $v115.set_Closed(true);
                return $v115;
            })();
        },
        BisectorPoints: function (tightPolyline, offset){
            var ret = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            for (var pp = tightPolyline.get_StartPoint(); pp != null; pp = pp.get_Next()){
                var skip;
                var currentSticking = (function (){
                    var $1 = {
                        Value: skip
                    };
                    var $res = Microsoft.Msagl.Routing.InteractiveObstacleCalculator.GetStickingVertexOnBisector(pp, offset, $1);
                    skip = $1.Value;
                    return $res;
                })();
                if (!skip)
                    ret.Add(currentSticking);
            }
            return ret;
        },
        GetStickingVertexOnBisector: function (pp, p, skip){
            var u = pp.get_Polyline().Prev(pp).get_Point();
            var v = pp.get_Point();
            var w = pp.get_Polyline().Next(pp).get_Point();
            var z = Microsoft.Msagl.Core.Geometry.Point.op_Addition((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v, u)).Normalize(), (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v, w)).Normalize());
            var zLen = z.get_Length();
            if (zLen < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                skip.Value = true;
            else {
                skip.Value = false;
                z = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(z, zLen);
            }
            return Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(p, z), v);
        },
        FindMaxPaddingForTightPolyline: function (hierarchy, polyline, desiredPadding){
            var dist = desiredPadding;
            var polygon = new Microsoft.Msagl.Routing.Visibility.Polygon.ctor(polyline);
            var boundingBox = polyline.get_BoundingBox();
            boundingBox.Pad$$Double(2 * desiredPadding);
            var $it1016 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, hierarchy.GetNodeItemsIntersectingRectangle(boundingBox), function (p){
                return p != polyline;
            }).GetEnumerator();
            while ($it1016.MoveNext()){
                var poly = $it1016.get_Current();
                var separation = Microsoft.Msagl.Routing.Visibility.Polygon.Distance$$Polygon$$Polygon(polygon, new Microsoft.Msagl.Routing.Visibility.Polygon.ctor(poly));
                dist = System.Math.Min$$Double$$Double(dist, separation / 2.1);
            }
            return dist;
        },
        CurveIntersectsRectangleNode: function (curve, curveBox, rectNode){
            if (!rectNode.get_Rectangle().Intersects(curveBox.Value))
                return false;
            if (rectNode.get_UserData() != null){
                var curveUnderTest = rectNode.get_UserData();
                return Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveIntersectionOne(curveUnderTest, curve, false) != null || Microsoft.Msagl.Routing.InteractiveObstacleCalculator.Inside(curveUnderTest, curve);
            }
            System.Diagnostics.Debug.Assert$$Boolean(rectNode.get_Left() != null && rectNode.get_Right() != null);
            return Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CurveIntersectsRectangleNode(curve, curveBox, rectNode.get_Left()) || Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CurveIntersectsRectangleNode(curve, curveBox, rectNode.get_Right());
        },
        Inside: function (curveUnderTest, curve){
            return Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(curve.get_Start(), curveUnderTest) == Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Inside;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (obstacles, tightPadding, loosePadding, ignoreTightPadding){
            this.tightPolylinesToLooseDistances = null;
            this.tightObstacles = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            this._TightPadding = 0;
            this._LoosePadding = 0;
            this._Obstacles = null;
            this._OverlapsDetected = false;
            this._LooseObstacles = null;
            this._RootOfTightHierarchy = null;
            this._RootOfLooseHierarchy = null;
            this._IgnoreTightPadding = false;
            System.Object.ctor.call(this);
            this.set_Obstacles(obstacles);
            this.set_TightPadding(tightPadding);
            this.set_LoosePadding(loosePadding);
            this.set_IgnoreTightPadding(ignoreTightPadding);
        },
        TightPadding$$: "System.Double",
        get_TightPadding: function (){
            return this._TightPadding;
        },
        set_TightPadding: function (value){
            this._TightPadding = value;
        },
        LoosePadding$$: "System.Double",
        get_LoosePadding: function (){
            return this._LoosePadding;
        },
        set_LoosePadding: function (value){
            this._LoosePadding = value;
        },
        Obstacles$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Geometry.Curves.ICurve]]",
        get_Obstacles: function (){
            return this._Obstacles;
        },
        set_Obstacles: function (value){
            this._Obstacles = value;
        },
        OverlapsDetected$$: "System.Boolean",
        get_OverlapsDetected: function (){
            return this._OverlapsDetected;
        },
        set_OverlapsDetected: function (value){
            this._OverlapsDetected = value;
        },
        TightObstacles$$: "Microsoft.Msagl.Core.DataStructures.Set`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]",
        get_TightObstacles: function (){
            return this.tightObstacles;
        },
        set_TightObstacles: function (value){
            this.tightObstacles = value;
        },
        LooseObstacles$$: "System.Collections.Generic.List`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]",
        get_LooseObstacles: function (){
            return this._LooseObstacles;
        },
        set_LooseObstacles: function (value){
            this._LooseObstacles = value;
        },
        RootOfTightHierarchy$$: "Microsoft.Msagl.Core.Geometry.RectangleNode`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]",
        get_RootOfTightHierarchy: function (){
            return this._RootOfTightHierarchy;
        },
        set_RootOfTightHierarchy: function (value){
            this._RootOfTightHierarchy = value;
        },
        RootOfLooseHierarchy$$: "Microsoft.Msagl.Core.Geometry.RectangleNode`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]",
        get_RootOfLooseHierarchy: function (){
            return this._RootOfLooseHierarchy;
        },
        set_RootOfLooseHierarchy: function (value){
            this._RootOfLooseHierarchy = value;
        },
        IgnoreTightPadding$$: "System.Boolean",
        get_IgnoreTightPadding: function (){
            return this._IgnoreTightPadding;
        },
        set_IgnoreTightPadding: function (value){
            this._IgnoreTightPadding = value;
        },
        Calculate: function (){
            if (!this.get_IgnoreTightPadding())
                this.CreateTightObstacles();
            else
                this.CreateTightObstaclesIgnoringTightPadding();
            if (!this.IsEmpty())
                this.CreateLooseObstacles();
        },
        CreateLooseObstacles: function (){
            this.tightPolylinesToLooseDistances = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, System.Double.ctor);
            this.set_LooseObstacles(new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor));
            var $it1009 = this.get_TightObstacles().GetEnumerator();
            while ($it1009.MoveNext()){
                var tightPolyline = $it1009.get_Current();
                var distance = Microsoft.Msagl.Routing.InteractiveObstacleCalculator.FindMaxPaddingForTightPolyline(this.get_RootOfTightHierarchy(), tightPolyline, this.get_LoosePadding());
                this.tightPolylinesToLooseDistances.set_Item$$TKey(tightPolyline, distance);
                this.get_LooseObstacles().Add(Microsoft.Msagl.Routing.InteractiveObstacleCalculator.LoosePolylineWithFewCorners(tightPolyline, distance));
            }
            this.set_RootOfLooseHierarchy(Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CalculateHierarchy(this.get_LooseObstacles()));
            System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Routing.InteractiveObstacleCalculator.GetOverlappedPairSet(this.get_RootOfLooseHierarchy()).get_Count() == 0, "Overlaps are found in LooseObstacles");
        },
        CreateTightObstacles: function (){
            this.set_RootOfTightHierarchy(Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CreateTightObstacles$$IEnumerable$1$ICurve$$Double$$Set$1$Polyline(this.get_Obstacles(), this.get_TightPadding(), this.get_TightObstacles()));
            this.set_OverlapsDetected(this.get_TightObstacles().get_Count() < System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor, this.get_Obstacles()));
        },
        CreateTightObstaclesIgnoringTightPadding: function (){
            var polysWithoutPadding = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, this.get_Obstacles(), $CreateAnonymousDelegate(this, function (o){
                return Microsoft.Msagl.Core.Geometry.Curves.Curve.PolylineAroundClosedCurve(o);
            })));
            var polylineHierarchy = Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CalculateHierarchy(polysWithoutPadding);
            var overlappingPairSet = Microsoft.Msagl.Routing.InteractiveObstacleCalculator.GetOverlappedPairSet(polylineHierarchy);
            this.set_TightObstacles(new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor));
            if (overlappingPairSet.get_Count() == 0){
                for (var $i1012 = 0,$l1012 = polysWithoutPadding.length,polyline = polysWithoutPadding[$i1012]; $i1012 < $l1012; $i1012++, polyline = polysWithoutPadding[$i1012]){
                    var distance = Microsoft.Msagl.Routing.InteractiveObstacleCalculator.FindMaxPaddingForTightPolyline(polylineHierarchy, polyline, this.get_TightPadding());
                    this.get_TightObstacles().Insert(Microsoft.Msagl.Routing.InteractiveObstacleCalculator.LoosePolylineWithFewCorners(polyline, distance));
                }
                this.set_RootOfTightHierarchy(Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CalculateHierarchy(this.get_TightObstacles()));
            }
            else {
                for (var $i1013 = 0,$l1013 = polysWithoutPadding.length,poly = polysWithoutPadding[$i1013]; $i1013 < $l1013; $i1013++, poly = polysWithoutPadding[$i1013])
                    this.get_TightObstacles().Insert(Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CreatePaddedPolyline(poly, this.get_TightPadding()));
                if (!this.IsEmpty()){
                    this.set_RootOfTightHierarchy(Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CalculateHierarchy(this.get_TightObstacles()));
                    this.set_OverlapsDetected(false);
                    while ((overlappingPairSet = Microsoft.Msagl.Routing.InteractiveObstacleCalculator.GetOverlappedPairSet(this.get_RootOfTightHierarchy())).get_Count() > 0){
                        this.set_RootOfTightHierarchy(Microsoft.Msagl.Routing.InteractiveObstacleCalculator.ReplaceTightObstaclesWithConvexHulls(this.get_TightObstacles(), overlappingPairSet));
                        this.set_OverlapsDetected(true);
                    }
                }
            }
        },
        IsEmpty: function (){
            return Microsoft.Msagl.Core.DataStructures.Set$1.op_Equality(this.get_TightObstacles(), null) || this.get_TightObstacles().get_Count() == 0;
        },
        ObstaclesIntersectLine: function (a, b){
            return this.ObstaclesIntersectICurve(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(a, b));
        },
        ObstaclesIntersectICurve: function (curve){
            var rect = curve.get_BoundingBox();
            return (function (){
                var $1 = {
                    Value: rect
                };
                var $res = Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CurveIntersectsRectangleNode(curve, $1, this.get_RootOfTightHierarchy());
                rect = $1.Value;
                return $res;
            }).call(this);
        },
        ScaleLooseObstacles: function (coefficient){
            this.get_LooseObstacles().Clear();
            var $it1017 = this.get_TightObstacles().GetEnumerator();
            while ($it1017.MoveNext()){
                var tightPolyline = $it1017.get_Current();
                this.get_LooseObstacles().Add(Microsoft.Msagl.Routing.InteractiveObstacleCalculator.LoosePolylineWithFewCorners(tightPolyline, this.tightPolylinesToLooseDistances.get_Item$$TKey(tightPolyline) * coefficient));
            }
            this.set_RootOfLooseHierarchy(Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CalculateHierarchy(this.get_LooseObstacles()));
            System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Routing.InteractiveObstacleCalculator.GetOverlappedPairSet(this.get_RootOfLooseHierarchy()).get_Count() == 0, "Overlaps are found in LooseObstacles");
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$InteractiveObstacleCalculator);
var Microsoft$Msagl$Routing$Rectilinear$Nudging$AxisEdge = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdge",
    baseTypeName: "Microsoft.Msagl.Routing.Visibility.VisibilityEdge",
    staticDefinition: {
        cctor: function (){
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (source, target){
            this.RightNeighbors = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdge.ctor);
            this.setOfLongestSegs = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Routing.Rectilinear.Nudging.LongestNudgedSegment.ctor);
            this._Direction = Microsoft.Msagl.Core.Geometry.Directions.None;
            this._LeftBound = 0;
            this._RightBound = 0;
            Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor$$VisibilityVertex$$VisibilityVertex.call(this, source, target);
            this.set_RightBound(Infinity);
            this.set_LeftBound(-Infinity);
            this.set_Direction(Microsoft.Msagl.Core.Geometry.CompassVector.DirectionsFromPointToPoint(source.Point, target.Point));
            System.Diagnostics.Debug.Assert$$Boolean(this.get_Direction() == Microsoft.Msagl.Core.Geometry.Directions.East || this.get_Direction() == Microsoft.Msagl.Core.Geometry.Directions.North);
        },
        Direction$$: "Microsoft.Msagl.Core.Geometry.Directions",
        get_Direction: function (){
            return this._Direction;
        },
        set_Direction: function (value){
            this._Direction = value;
        },
        AddRightNeighbor: function (edge){
            this.RightNeighbors.Insert(edge);
        },
        LeftBound$$: "System.Double",
        get_LeftBound: function (){
            return this._LeftBound;
        },
        set_LeftBound: function (value){
            this._LeftBound = value;
        },
        RightBound$$: "System.Double",
        get_RightBound: function (){
            return this._RightBound;
        },
        set_RightBound: function (value){
            this._RightBound = value;
        },
        LongestNudgedSegments$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Routing.Rectilinear.Nudging.LongestNudgedSegment]]",
        get_LongestNudgedSegments: function (){
            return this.setOfLongestSegs;
        },
        AddLongestNudgedSegment: function (segment){
            this.setOfLongestSegs.Insert(segment);
        },
        BoundFromRight: function (rightbound){
            rightbound = System.Math.Max$$Double$$Double(rightbound, this.get_LeftBound());
            this.set_RightBound(System.Math.Min$$Double$$Double(rightbound, this.get_RightBound()));
        },
        BoundFromLeft: function (leftbound){
            leftbound = System.Math.Min$$Double$$Double(leftbound, this.get_RightBound());
            this.set_LeftBound(System.Math.Max$$Double$$Double(leftbound, this.get_LeftBound()));
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$Nudging$AxisEdge);
var Microsoft$Msagl$Routing$Rectilinear$Nudging$AxisEdgesContainer = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdgesContainer",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IEnumerable$1"],
    Kind: "Class",
    definition: {
        ctor: function (source){
            this.edges = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdge.ctor);
            this.UpPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._Source = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            System.Object.ctor.call(this);
            this.set_Source(source);
        },
        AddEdge: function (edge){
            this.UpPoint = edge.get_TargetPoint();
            System.Diagnostics.Debug.Assert$$Boolean(this.edges.Contains$$T(edge) == false);
            this.edges.Insert(edge);
        },
        Source$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Source: function (){
            return this._Source;
        },
        set_Source: function (value){
            this._Source = value;
        },
        GetEnumerator: function (){
            return this.edges.GetEnumerator();
        },
        RemoveAxis: function (edge){
            System.Diagnostics.Debug.Assert$$Boolean(this.edges.Contains$$T(edge));
            this.edges.Remove(edge);
        },
        IsEmpty: function (){
            return this.edges.get_Count() == 0;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$Nudging$AxisEdgesContainer);
var Microsoft$Msagl$Routing$Rectilinear$Nudging$CombinatorialNudger = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.Nudging.CombinatorialNudger",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Routing.Rectilinear.Nudging.CombinatorialNudger.NotOrdered = 2147483647;
        },
        CompareTwoPathEdges: function (x, y){
            if (x == y)
                return 0;
            System.Diagnostics.Debug.Assert$$Boolean(x.get_AxisEdge() == y.get_AxisEdge());
            var r = Microsoft.Msagl.Routing.Rectilinear.Nudging.CombinatorialNudger.CompareInDirectionStartingFromAxisEdge(x, y, x.get_AxisEdge(), x.get_AxisEdge().get_Direction());
            return r != 0 ? r : -Microsoft.Msagl.Routing.Rectilinear.Nudging.CombinatorialNudger.CompareInDirectionStartingFromAxisEdge(x, y, x.get_AxisEdge(), Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(x.get_AxisEdge().get_Direction()));
        },
        CompareInDirectionStartingFromAxisEdge: function (x, y, axisEdge, direction){
            while (true){
                x = Microsoft.Msagl.Routing.Rectilinear.Nudging.CombinatorialNudger.GetNextPathEdgeInDirection(x, axisEdge, direction);
                if (x == null)
                    return 0;
                y = Microsoft.Msagl.Routing.Rectilinear.Nudging.CombinatorialNudger.GetNextPathEdgeInDirection(y, axisEdge, direction);
                if (y == null)
                    return 0;
                if (x.get_AxisEdge() == y.get_AxisEdge()){
                    direction = Microsoft.Msagl.Routing.Rectilinear.Nudging.CombinatorialNudger.FindContinuedDirection(axisEdge, direction, x.get_AxisEdge());
                    axisEdge = x.get_AxisEdge();
                    var r = Microsoft.Msagl.Routing.Rectilinear.Nudging.CombinatorialNudger.GetExistingOrder(x, y);
                    if (r == 2147483647)
                        continue;
                    return direction == axisEdge.get_Direction() ? r : -r;
                }
                var forkVertex = direction == axisEdge.get_Direction() ? axisEdge.get_Target() : axisEdge.get_Source();
                var xFork = Microsoft.Msagl.Routing.Rectilinear.Nudging.CombinatorialNudger.OtherVertex(x.get_AxisEdge(), forkVertex);
                var yFork = Microsoft.Msagl.Routing.Rectilinear.Nudging.CombinatorialNudger.OtherVertex(y.get_AxisEdge(), forkVertex);
                var projection = Microsoft.Msagl.Routing.Rectilinear.Nudging.CombinatorialNudger.ProjectionForCompare(axisEdge, direction != axisEdge.get_Direction());
                return projection(xFork.Point).CompareTo$$Double(projection(yFork.Point));
            }
        },
        FindContinuedDirection: function (edge, direction, nextAxisEdge){
            if (edge.get_Direction() == direction)
                return nextAxisEdge.get_Source() == edge.get_Target() ? nextAxisEdge.get_Direction() : Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(nextAxisEdge.get_Direction());
            return nextAxisEdge.get_Source() == edge.get_Source() ? nextAxisEdge.get_Direction() : Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(nextAxisEdge.get_Direction());
        },
        OtherVertex: function (axisEdge, v){
            return axisEdge.get_Source() == v ? axisEdge.get_Target() : axisEdge.get_Source();
        },
        ProjectionForCompare: function (axisEdge, isReversed){
            if (axisEdge.get_Direction() == Microsoft.Msagl.Core.Geometry.Directions.North)
                return isReversed ? (function (p){
                    return -p.get_X();
                }) : (function (p){
                    return p.get_X();
                });
            return isReversed ? (function (p){
                return p.get_Y();
            }) : (function (p){
                return -p.get_Y();
            });
        },
        GetNextPathEdgeInDirection: function (e, axisEdge, direction){
            System.Diagnostics.Debug.Assert$$Boolean(e.get_AxisEdge() == axisEdge);
            return axisEdge.get_Direction() == direction ? (e.get_Reversed() ? e.get_Prev() : e.get_Next()) : (e.get_Reversed() ? e.get_Next() : e.get_Prev());
        },
        GetExistingOrder: function (x, y){
            var xi = x.get_Index();
            if (xi == -1)
                return 2147483647;
            var yi = y.get_Index();
            System.Diagnostics.Debug.Assert$$Boolean(yi != -1);
            return xi.CompareTo$$Int32(yi);
        },
        InitQueueOfSources: function (queue, dictionary, graph){
            var $it1024 = graph.Vertices().GetEnumerator();
            while ($it1024.MoveNext()){
                var v = $it1024.get_Current();
                var inDegree = v.get_InEdges().get_Count();
                dictionary.set_Item$$TKey(v, inDegree);
                if (inDegree == 0)
                    queue.Enqueue(v);
            }
            System.Diagnostics.Debug.Assert$$Boolean(queue.get_Count() > 0);
        },
        WalkGraphEdgesInTopologicalOrderIfPossible: function (visibilityGraph){
            var $yield = [];
            var sourcesQueue = new System.Collections.Generic.Queue$1.ctor(Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor);
            var inDegreeLeftUnprocessed = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor, System.Int32.ctor);
            Microsoft.Msagl.Routing.Rectilinear.Nudging.CombinatorialNudger.InitQueueOfSources(sourcesQueue, inDegreeLeftUnprocessed, visibilityGraph);
            while (sourcesQueue.get_Count() > 0){
                var visVertex = sourcesQueue.Dequeue();
                var $it1025 = visVertex.get_OutEdges().GetEnumerator();
                while ($it1025.MoveNext()){
                    var edge = $it1025.get_Current();
                    var incomingEdges = inDegreeLeftUnprocessed.set_Item$$TKey(edge.get_Target(), inDegreeLeftUnprocessed.get_Item$$TKey(edge.get_Target()) - 1);
                    if (incomingEdges == 1)
                        sourcesQueue.Enqueue(edge.get_Target());
                    $yield.push(Cast(edge, Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdge.ctor));
                }
            }
            return $yield;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (paths){
            this.pathVisibilityGraph = new Microsoft.Msagl.Routing.Visibility.VisibilityGraph.ctor();
            this.axisEdgesToPathOrders = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdge.ctor, System.Collections.Generic.List$1.ctor);
            this._OriginalPaths = null;
            System.Object.ctor.call(this);
            this.set_OriginalPaths(paths);
        },
        PathVisibilityGraph$$: "Microsoft.Msagl.Routing.Visibility.VisibilityGraph",
        get_PathVisibilityGraph: function (){
            return this.pathVisibilityGraph;
        },
        OriginalPaths$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Routing.Rectilinear.Nudging.Path]]",
        get_OriginalPaths: function (){
            return this._OriginalPaths;
        },
        set_OriginalPaths: function (value){
            this._OriginalPaths = value;
        },
        GetOrder: function (){
            this.FillTheVisibilityGraphByWalkingThePaths();
            this.InitPathOrder();
            this.OrderPaths();
            return this.axisEdgesToPathOrders;
        },
        FillTheVisibilityGraphByWalkingThePaths: function (){
            var $it1018 = this.get_OriginalPaths().GetEnumerator();
            while ($it1018.MoveNext()){
                var path = $it1018.get_Current();
                this.FillTheVisibilityGraphByWalkingPath(path);
            }
        },
        FillTheVisibilityGraphByWalkingPath: function (path){
            var pathEdgesEnum = this.CreatePathEdgesFromPoints(path.get_PathPoints(), path.get_Width()).GetEnumerator();
            if (pathEdgesEnum.MoveNext())
                path.SetFirstEdge(pathEdgesEnum.get_Current());
            while (pathEdgesEnum.MoveNext())
                path.AddEdge(pathEdgesEnum.get_Current());
        },
        CreatePathEdgesFromPoints: function (pathPoints, width){
            var $yield = [];
            var p0 = System.Linq.Enumerable.First$1$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Point.ctor, pathPoints);
            var $it1019 = System.Linq.Enumerable.Skip$1(Microsoft.Msagl.Core.Geometry.Point.ctor, pathPoints, 1).GetEnumerator();
            while ($it1019.MoveNext()){
                var p1 = $it1019.get_Current();
                $yield.push(this.CreatePathEdge(p0, p1, width));
                p0 = p1;
            }
            return $yield;
        },
        CreatePathEdge: function (p0, p1, width){
            var dir = Microsoft.Msagl.Core.Geometry.CompassVector.DirectionsFromPointToPoint(p0, p1);
            switch (dir){
                case Microsoft.Msagl.Core.Geometry.Directions.East:
                case Microsoft.Msagl.Core.Geometry.Directions.North:
                    return new Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge.ctor(this.GetAxisEdge(p0, p1), width);
                case Microsoft.Msagl.Core.Geometry.Directions.South:
                case Microsoft.Msagl.Core.Geometry.Directions.West:
                    return (function (){
                    var $v116 = new Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge.ctor(this.GetAxisEdge(p1, p0), width);
                    $v116.set_Reversed(true);
                    return $v116;
                }).call(this);
                default:
                    throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            }
        },
        GetAxisEdge: function (p0, p1){
            return As(this.get_PathVisibilityGraph().AddEdge$$Point$$Point$$Func$3$VisibilityVertex$VisibilityVertex$VisibilityEdge(p0, p1, ($CreateAnonymousDelegate(this, function (m, n){
                return new Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdge.ctor(m, n);
            }))), Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdge.ctor);
        },
        InitPathOrder: function (){
            var $it1020 = System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor, Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdge.ctor, this.get_PathVisibilityGraph().get_Edges(), $CreateAnonymousDelegate(this, function (a){
                return Cast(a, Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdge.ctor);
            })).GetEnumerator();
            while ($it1020.MoveNext()){
                var axisEdge = $it1020.get_Current();
                this.axisEdgesToPathOrders.set_Item$$TKey(axisEdge, new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge.ctor));
            }
            var $it1021 = System.Linq.Enumerable.SelectMany$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.ctor, Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge.ctor, this.get_OriginalPaths(), $CreateAnonymousDelegate(this, function (path){
                return path.get_PathEdges();
            })).GetEnumerator();
            while ($it1021.MoveNext()){
                var pathEdge = $it1021.get_Current();
                this.axisEdgesToPathOrders.get_Item$$TKey(pathEdge.get_AxisEdge()).Add(pathEdge);
            }
        },
        OrderPaths: function (){
            var $it1022 = Microsoft.Msagl.Routing.Rectilinear.Nudging.CombinatorialNudger.WalkGraphEdgesInTopologicalOrderIfPossible(this.get_PathVisibilityGraph()).GetEnumerator();
            while ($it1022.MoveNext()){
                var axisEdge = $it1022.get_Current();
                this.OrderPathEdgesSharingEdge(axisEdge);
            }
        },
        OrderPathEdgesSharingEdge: function (edge){
            var pathOrder = this.PathOrderOfVisEdge(edge);
            pathOrder.Sort$$Comparison$1(Microsoft.Msagl.Routing.Rectilinear.Nudging.CombinatorialNudger.CompareTwoPathEdges);
            var i = 0;
            var $it1023 = pathOrder.GetEnumerator();
            while ($it1023.MoveNext()){
                var pathEdge = $it1023.get_Current();
                pathEdge.set_Index(i++);
            }
        },
        PathOrderOfVisEdge: function (axisEdge){
            return this.axisEdgesToPathOrders.get_Item$$TKey(axisEdge);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$Nudging$CombinatorialNudger);
var Microsoft$Msagl$Routing$Rectilinear$Nudging$AxisEdgeHighPointEvent = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdgeHighPointEvent",
    baseTypeName: "Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (edge, point){
            this.site = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._AxisEdge = null;
            Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent.ctor.call(this);
            this.site = point;
            this.set_AxisEdge(edge);
        },
        AxisEdge$$: "Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdge",
        get_AxisEdge: function (){
            return this._AxisEdge;
        },
        set_AxisEdge: function (value){
            this._AxisEdge = value;
        },
        Site$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Site: function (){
            return this.site;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$Nudging$AxisEdgeHighPointEvent);
var Microsoft$Msagl$Routing$Rectilinear$Nudging$AxisEdgeLowPointEvent = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdgeLowPointEvent",
    baseTypeName: "Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (edge, point){
            this.site = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._AxisEdge = null;
            Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent.ctor.call(this);
            this.site = point;
            this.set_AxisEdge(edge);
        },
        AxisEdge$$: "Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdge",
        get_AxisEdge: function (){
            return this._AxisEdge;
        },
        set_AxisEdge: function (value){
            this._AxisEdge = value;
        },
        Site$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Site: function (){
            return this.site;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$Nudging$AxisEdgeLowPointEvent);
var Microsoft$Msagl$Core$DataStructures$ComparerOnDelegate$1 = {
    fullname: "Microsoft.Msagl.Core.DataStructures.ComparerOnDelegate$1",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IComparer$1"],
    Kind: "Class",
    definition: {
        ctor: function (T, compare){
            this.T = T;
            this.comparer = null;
            System.Object.ctor.call(this);
            this.comparer = compare;
        },
        Compare: function (x, y){
            return this.comparer(x, y);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$DataStructures$ComparerOnDelegate$1);
var Microsoft$Msagl$Routing$Rectilinear$Nudging$FreeSpaceFinder = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.Nudging.FreeSpaceFinder",
    baseTypeName: "Microsoft.Msagl.Routing.Visibility.LineSweeperBase",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Routing.Rectilinear.Nudging.FreeSpaceFinder.AreaComparisonEpsilon = Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_IntersectionEpsilon();
        },
        X: function (p){
            return p.get_X();
        },
        MinusY: function (p){
            return -p.get_Y();
        },
        PointToTheLeftOfLineOrOnLineLocal: function (a, linePoint0, linePoint1){
            return Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(a, linePoint0, linePoint1) > -Microsoft.Msagl.Routing.Rectilinear.Nudging.FreeSpaceFinder.AreaComparisonEpsilon;
        },
        PointToTheRightOfLineOrOnLineLocal: function (a, linePoint0, linePoint1){
            return Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(linePoint0, linePoint1, a) < Microsoft.Msagl.Routing.Rectilinear.Nudging.FreeSpaceFinder.AreaComparisonEpsilon;
        },
        EdgeHighPointEvent: function (edge, point){
            return new Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdgeHighPointEvent.ctor(edge, point);
        },
        EdgeLowPointEvent: function (edge, point){
            return new Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdgeLowPointEvent.ctor(edge, point);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (direction, obstacles, axisEdgesToObstaclesTheyOriginatedFrom, pathOrders, axisEdges){
            this.xProjection = null;
            this.edgeContainersTree = null;
            this._PathOrders = null;
            this._AxisEdgesToObstaclesTheyOriginatedFrom = null;
            this._SweepPole = Microsoft.Msagl.Core.Geometry.Directions.None;
            this._AxisEdges = null;
            Microsoft.Msagl.Routing.Visibility.LineSweeperBase.ctor.call(this, obstacles, new Microsoft.Msagl.Core.Geometry.CompassVector.ctor$$Directions(direction).ToPoint());
            this.set_DirectionPerp(new Microsoft.Msagl.Core.Geometry.CompassVector.ctor$$Directions(direction).get_Right().ToPoint());
            this.set_PathOrders(pathOrders);
            this.xProjection = direction == Microsoft.Msagl.Core.Geometry.Directions.North ? Microsoft.Msagl.Routing.Rectilinear.Nudging.FreeSpaceFinder.X : Microsoft.Msagl.Routing.Rectilinear.Nudging.FreeSpaceFinder.MinusY;
            this.edgeContainersTree = new Microsoft.Msagl.Core.DataStructures.RbTree$1.ctor$$IComparer$1(Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdgesContainer.ctor, new Microsoft.Msagl.Routing.Rectilinear.Nudging.FreeSpaceFinder.FreeSpaceFinderComparer.ctor(this));
            this.set_SweepPole(Microsoft.Msagl.Core.Geometry.CompassVector.VectorDirection$$Point(this.get_SweepDirection()));
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.CompassVector.IsPureDirection$$Directions(this.get_SweepPole()));
            this.set_AxisEdges(axisEdges);
            this.set_AxisEdgesToObstaclesTheyOriginatedFrom(axisEdgesToObstaclesTheyOriginatedFrom);
        },
        PathOrders$$: "System.Collections.Generic.Dictionary`2[[Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdge],[System.Collections.Generic.List`1[[Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge]]]]",
        get_PathOrders: function (){
            return this._PathOrders;
        },
        set_PathOrders: function (value){
            this._PathOrders = value;
        },
        AxisEdgesToObstaclesTheyOriginatedFrom$$: "System.Collections.Generic.Dictionary`2[[Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdge],[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]",
        get_AxisEdgesToObstaclesTheyOriginatedFrom: function (){
            return this._AxisEdgesToObstaclesTheyOriginatedFrom;
        },
        set_AxisEdgesToObstaclesTheyOriginatedFrom: function (value){
            this._AxisEdgesToObstaclesTheyOriginatedFrom = value;
        },
        SweepPole$$: "Microsoft.Msagl.Core.Geometry.Directions",
        get_SweepPole: function (){
            return this._SweepPole;
        },
        set_SweepPole: function (value){
            this._SweepPole = value;
        },
        FindFreeSpace: function (){
            this.InitTheQueueOfEvents();
            this.ProcessEvents();
        },
        ProcessEvents: function (){
            while (this.get_EventQueue().get_Count() > 0)
                this.ProcessEvent(this.get_EventQueue().Dequeue());
        },
        ProcessEvent: function (sweepEvent){
            var vertexEvent = As(sweepEvent, Microsoft.Msagl.Routing.Spline.ConeSpanner.VertexEvent.ctor);
            if (vertexEvent != null)
                this.ProcessVertexEvent(vertexEvent);
            else {
                var lowEdgeEvent = As(sweepEvent, Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdgeLowPointEvent.ctor);
                this.set_Z(this.GetZ$$Point(sweepEvent.get_Site()));
                if (lowEdgeEvent != null)
                    this.ProcessLowEdgeEvent(lowEdgeEvent);
                else
                    this.ProcessHighEdgeEvent(Cast(sweepEvent, Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdgeHighPointEvent.ctor));
            }
        },
        ProcessHighEdgeEvent: function (edgeForNudgingHighPointEvent){
            var edge = edgeForNudgingHighPointEvent.get_AxisEdge();
            this.RemoveEdge(edge);
            this.ConstraintEdgeWithObstaclesAtZ(edge, edge.get_Target().Point);
        },
        ProcessLowEdgeEvent: function (lowEdgeEvent){
            var edge = lowEdgeEvent.get_AxisEdge();
            var containerNode = this.GetOrCreateAxisEdgesContainer(edge);
            containerNode.Item.AddEdge(edge);
            var prev = this.edgeContainersTree.Previous(containerNode);
            if (prev != null){
                var $it1026 = prev.Item.GetEnumerator();
                while ($it1026.MoveNext()){
                    var prevEdge = $it1026.get_Current();
                    var $it1027 = containerNode.Item.GetEnumerator();
                    while ($it1027.MoveNext()){
                        var ed = $it1027.get_Current();
                        this.TryToAddRightNeighbor(prevEdge, ed);
                    }
                }
            }
            var next = this.edgeContainersTree.Next(containerNode);
            if (next != null){
                var $it1028 = containerNode.Item.GetEnumerator();
                while ($it1028.MoveNext()){
                    var ed = $it1028.get_Current();
                    var $it1029 = next.Item.GetEnumerator();
                    while ($it1029.MoveNext()){
                        var neEdge = $it1029.get_Current();
                        this.TryToAddRightNeighbor(ed, neEdge);
                    }
                }
            }
            this.ConstraintEdgeWithObstaclesAtZ(edge, edge.get_Source().Point);
        },
        TryToAddRightNeighbor: function (leftEdge, rightEdge){
            if (this.ProjectionsOfEdgesOverlap(leftEdge, rightEdge))
                leftEdge.AddRightNeighbor(rightEdge);
        },
        ProjectionsOfEdgesOverlap: function (leftEdge, rightEdge){
            return this.get_SweepPole() == Microsoft.Msagl.Core.Geometry.Directions.North ? !(leftEdge.get_TargetPoint().get_Y() < rightEdge.get_SourcePoint().get_Y() - Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon || rightEdge.get_TargetPoint().get_Y() < leftEdge.get_SourcePoint().get_Y() - Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon) : !(leftEdge.get_TargetPoint().get_X() < rightEdge.get_SourcePoint().get_X() - Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon || rightEdge.get_TargetPoint().get_X() < leftEdge.get_SourcePoint().get_X() - Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon);
        },
        ConstraintEdgeWithObstaclesAtZ: function (edge, point){
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.Point.op_Equality(point, edge.get_Source().Point) || Microsoft.Msagl.Core.Geometry.Point.op_Equality(point, edge.get_Target().Point));
            this.ConstraintEdgeWithObstaclesAtZFromLeft(edge, point);
            this.ConstraintEdgeWithObstaclesAtZFromRight(edge, point);
        },
        ConstraintEdgeWithObstaclesAtZFromRight: function (edge, point){
            var node = this.GetActiveSideFromRight(point);
            if (node == null)
                return;
            if (this.NotRestricting(edge, (Cast(node.Item, Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftObstacleSide.ctor)).get_Polyline()))
                return;
            var x = this.get_ObstacleSideComparer().IntersectionOfSideAndSweepLine(node.Item);
            edge.BoundFromRight(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(x, this.get_DirectionPerp()));
        },
        GetActiveSideFromRight: function (point){
            return this.get_LeftObstacleSideTree().FindFirst$$Func$2($CreateAnonymousDelegate(this, function (side){
                return Microsoft.Msagl.Routing.Rectilinear.Nudging.FreeSpaceFinder.PointToTheLeftOfLineOrOnLineLocal(point, side.get_Start(), side.get_End());
            }));
        },
        ConstraintEdgeWithObstaclesAtZFromLeft: function (edge, point){
            var node = this.GetActiveSideFromLeft(point);
            if (node == null)
                return;
            if (this.NotRestricting(edge, (Cast(node.Item, Microsoft.Msagl.Routing.Spline.ConeSpanner.RightObstacleSide.ctor)).get_Polyline()))
                return;
            var x = this.get_ObstacleSideComparer().IntersectionOfSideAndSweepLine(node.Item);
            edge.BoundFromLeft(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(x, this.get_DirectionPerp()));
        },
        GetActiveSideFromLeft: function (point){
            return this.get_RightObstacleSideTree().FindLast$$Func$2($CreateAnonymousDelegate(this, function (side){
                return Microsoft.Msagl.Routing.Rectilinear.Nudging.FreeSpaceFinder.PointToTheRightOfLineOrOnLineLocal(point, side.get_Start(), side.get_End());
            }));
        },
        GetOrCreateAxisEdgesContainer: function (edge){
            var source = edge.get_Source().Point;
            var ret = this.GetAxisEdgesContainerNode(source);
            if (ret != null)
                return ret;
            return this.edgeContainersTree.Insert(new Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdgesContainer.ctor(source));
        },
        GetAxisEdgesContainerNode: function (point){
            var prj = this.xProjection(point);
            var ret = this.edgeContainersTree.FindFirst$$Func$2($CreateAnonymousDelegate(this, function (cont){
                return this.xProjection(cont.get_Source()) >= prj - Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon / 2;
            }));
            if (ret != null)if (this.xProjection(ret.Item.get_Source()) <= prj + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon / 2)
                return ret;
            return null;
        },
        ProcessVertexEvent: function (vertexEvent){
            this.set_Z(this.GetZ$$SweepEvent(vertexEvent));
            var leftVertexEvent = As(vertexEvent, Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftVertexEvent.ctor);
            if (leftVertexEvent != null)
                this.ProcessLeftVertex(leftVertexEvent, vertexEvent.get_Vertex().get_NextOnPolyline());
            else {
                var rightVertexEvent = As(vertexEvent, Microsoft.Msagl.Routing.Spline.ConeSpanner.RightVertexEvent.ctor);
                if (rightVertexEvent != null)
                    this.ProcessRightVertex(rightVertexEvent, vertexEvent.get_Vertex().get_PrevOnPolyline());
                else {
                    this.ProcessLeftVertex(vertexEvent, vertexEvent.get_Vertex().get_NextOnPolyline());
                    this.ProcessRightVertex(vertexEvent, vertexEvent.get_Vertex().get_PrevOnPolyline());
                }
            }
        },
        ProcessRightVertex: function (rightVertexEvent, nextVertex){
            System.Diagnostics.Debug.Assert$$Boolean(this.get_Z() == Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(rightVertexEvent.get_Site(), this.get_SweepDirection()));
            var site = rightVertexEvent.get_Site();
            this.ProcessPrevSegmentForRightVertex(rightVertexEvent, site);
            var delta = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(nextVertex.get_Point(), rightVertexEvent.get_Site());
            var deltaX = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(delta, this.get_DirectionPerp());
            var deltaZ = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(delta, this.get_SweepDirection());
            if (deltaZ <= Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                if (deltaX > 0 && deltaZ >= 0)
                    this.EnqueueEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.RightVertexEvent.ctor(nextVertex));
                else
                    this.RestrictEdgeContainerToTheRightOfEvent(rightVertexEvent.get_Vertex());
            }
            else {
                this.InsertRightSide(new Microsoft.Msagl.Routing.Spline.ConeSpanner.RightObstacleSide.ctor(rightVertexEvent.get_Vertex()));
                this.EnqueueEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.RightVertexEvent.ctor(nextVertex));
                this.RestrictEdgeContainerToTheRightOfEvent(rightVertexEvent.get_Vertex());
            }
        },
        RestrictEdgeContainerToTheRightOfEvent: function (polylinePoint){
            var site = polylinePoint.get_Point();
            var siteX = this.xProjection(site);
            var containerNode = this.edgeContainersTree.FindFirst$$Func$2($CreateAnonymousDelegate(this, function (container){
                return siteX <= this.xProjection(container.get_Source());
            }));
            if (containerNode != null){
                var $it1030 = containerNode.Item.GetEnumerator();
                while ($it1030.MoveNext()){
                    var edge = $it1030.get_Current();
                    if (!this.NotRestricting(edge, polylinePoint.get_Polyline()))
                        edge.BoundFromLeft(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.get_DirectionPerp(), site));
                }
            }
        },
        NotRestricting: function (edge, polyline){
            var p;
            return (function (){
                var $1 = {
                    Value: p
                };
                var $res = this.get_AxisEdgesToObstaclesTheyOriginatedFrom().TryGetValue(edge, $1);
                p = $1.Value;
                return $res;
            }).call(this) && p == polyline;
        },
        ProcessPrevSegmentForRightVertex: function (rightVertexEvent, site){
            var prevSite = rightVertexEvent.get_Vertex().get_NextOnPolyline().get_Point();
            var delta = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(site, prevSite);
            var deltaZ = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(delta, this.get_SweepDirection());
            if (deltaZ > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                this.RemoveRightSide(new Microsoft.Msagl.Routing.Spline.ConeSpanner.RightObstacleSide.ctor(rightVertexEvent.get_Vertex().get_NextOnPolyline()));
        },
        RemoveEdge: function (edge){
            var containerNode = this.GetAxisEdgesContainerNode(edge.get_Source().Point);
            containerNode.Item.RemoveAxis(edge);
            if (containerNode.Item.IsEmpty())
                this.edgeContainersTree.DeleteNodeInternal(containerNode);
        },
        ProcessLeftVertex: function (leftVertexEvent, nextVertex){
            System.Diagnostics.Debug.Assert$$Boolean(this.get_Z() == Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(leftVertexEvent.get_Site(), this.get_SweepDirection()));
            var site = leftVertexEvent.get_Site();
            this.ProcessPrevSegmentForLeftVertex(leftVertexEvent, site);
            var delta = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(nextVertex.get_Point(), leftVertexEvent.get_Site());
            var deltaX = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(delta, this.get_DirectionPerp());
            var deltaZ = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(delta, this.get_SweepDirection());
            if (deltaZ <= Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                if (deltaX < 0 && deltaZ >= 0)
                    this.EnqueueEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftVertexEvent.ctor(nextVertex));
            }
            else {
                this.InsertLeftSide(new Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftObstacleSide.ctor(leftVertexEvent.get_Vertex()));
                this.EnqueueEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftVertexEvent.ctor(nextVertex));
            }
            this.RestrictEdgeFromTheLeftOfEvent(leftVertexEvent.get_Vertex());
        },
        RestrictEdgeFromTheLeftOfEvent: function (polylinePoint){
            var site = polylinePoint.get_Point();
            var containerNode = this.GetContainerNodeToTheLeftOfEvent(site);
            if (containerNode != null){
                var $it1031 = containerNode.Item.GetEnumerator();
                while ($it1031.MoveNext()){
                    var edge = $it1031.get_Current();
                    if (!this.NotRestricting(edge, polylinePoint.get_Polyline()))
                        edge.BoundFromRight(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(site, this.get_DirectionPerp()));
                }
            }
        },
        GetContainerNodeToTheLeftOfEvent: function (site){
            var siteX = this.xProjection(site);
            return this.edgeContainersTree.FindLast$$Func$2($CreateAnonymousDelegate(this, function (container){
                return this.xProjection(container.get_Source()) <= siteX;
            }));
        },
        ProcessPrevSegmentForLeftVertex: function (leftVertexEvent, site){
            var prevSite = leftVertexEvent.get_Vertex().get_PrevOnPolyline().get_Point();
            var delta = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(site, prevSite);
            var deltaZ = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(delta, this.get_SweepDirection());
            if (deltaZ > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                this.RemoveLeftSide(new Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftObstacleSide.ctor(leftVertexEvent.get_Vertex().get_PrevOnPolyline()));
        },
        InitTheQueueOfEvents: function (){
            this.InitQueueOfEvents();
            var $it1032 = this.get_AxisEdges().GetEnumerator();
            while ($it1032.MoveNext()){
                var axisEdge = $it1032.get_Current();
                this.EnqueueEventsForEdge(axisEdge);
            }
        },
        AxisEdges$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdge]]",
        get_AxisEdges: function (){
            return this._AxisEdges;
        },
        set_AxisEdges: function (value){
            this._AxisEdges = value;
        },
        EnqueueEventsForEdge: function (edge){
            if (this.EdgeIsParallelToSweepDir(edge)){
                this.EnqueueEvent(Microsoft.Msagl.Routing.Rectilinear.Nudging.FreeSpaceFinder.EdgeLowPointEvent(edge, edge.get_Source().Point));
                this.EnqueueEvent(Microsoft.Msagl.Routing.Rectilinear.Nudging.FreeSpaceFinder.EdgeHighPointEvent(edge, edge.get_Target().Point));
            }
        },
        EdgeIsParallelToSweepDir: function (edge){
            return edge.get_Direction() == this.get_SweepPole() || edge.get_Direction() == Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(this.get_SweepPole());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$Nudging$FreeSpaceFinder);
var Microsoft$Msagl$Routing$Rectilinear$Nudging$FreeSpaceFinder$FreeSpaceFinderComparer = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.Nudging.FreeSpaceFinder.FreeSpaceFinderComparer",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IComparer$1"],
    Kind: "Class",
    definition: {
        ctor: function (owner){
            this.m_Owner = null;
            System.Object.ctor.call(this);
            this.m_Owner = owner;
        },
        Compare: function (x, y){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(x, "x");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(y, "y");
            return (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(x.get_Source(), this.m_Owner.get_DirectionPerp())).CompareTo$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(y.get_Source(), this.m_Owner.get_DirectionPerp()));
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$Nudging$FreeSpaceFinder$FreeSpaceFinderComparer);
var Microsoft$Msagl$Routing$Rectilinear$Nudging$LinkedPointSplitter = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPointSplitter",
    baseTypeName: "System.Object",
    staticDefinition: {
        TrySplitVerticalPoint: function (linkedPoint, point){
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(linkedPoint.get_X(), linkedPoint.get_Next().get_X()));
            if (Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPointSplitter.Low(linkedPoint) + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon < point.get_Y() && point.get_Y() + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon < Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPointSplitter.High(linkedPoint))
                linkedPoint.SetNewNext(point);
        },
        TrySplitHorizontalPoint: function (horizontalPoint, point, xAligned){
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(horizontalPoint.get_Y(), horizontalPoint.get_Next().get_Y()));
            if (xAligned && horizontalPoint.get_X() + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon < point.get_X() && point.get_X() + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon < horizontalPoint.get_Next().get_X() || !xAligned && horizontalPoint.get_Next().get_X() + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon < point.get_X() && point.get_X() + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon < horizontalPoint.get_X()){
                horizontalPoint.SetNewNext(point);
                return horizontalPoint.get_Next();
            }
            return horizontalPoint;
        },
        Low: function (vertPoint){
            return System.Math.Min$$Double$$Double(vertPoint.get_Point().get_Y(), vertPoint.get_Next().get_Point().get_Y());
        },
        High: function (vertPoint){
            return System.Math.Max$$Double$$Double(vertPoint.get_Point().get_Y(), vertPoint.get_Next().get_Point().get_Y());
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (horizontalPoints, verticalPoints){
            this.tree = new Microsoft.Msagl.Core.DataStructures.RbTree$1.ctor$$Func$3(Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint.ctor, $CreateAnonymousDelegate(this, function (a, b){
                return a.get_Point().get_X().CompareTo$$Double(b.get_Point().get_X());
            }));
            this._HorizontalPoints = null;
            this._VerticalPoints = null;
            this._Queue = null;
            System.Object.ctor.call(this);
            this.set_VerticalPoints(verticalPoints);
            this.set_HorizontalPoints(horizontalPoints);
        },
        HorizontalPoints$$: "System.Collections.Generic.List`1[[Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint]]",
        get_HorizontalPoints: function (){
            return this._HorizontalPoints;
        },
        set_HorizontalPoints: function (value){
            this._HorizontalPoints = value;
        },
        VerticalPoints$$: "System.Collections.Generic.List`1[[Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint]]",
        get_VerticalPoints: function (){
            return this._VerticalPoints;
        },
        set_VerticalPoints: function (value){
            this._VerticalPoints = value;
        },
        SplitPoints: function (){
            if (this.get_VerticalPoints().get_Count() == 0 || this.get_HorizontalPoints().get_Count() == 0)
                return;
            this.InitEventQueue();
            this.ProcessEvents();
        },
        ProcessEvents: function (){
            while (!this.get_Queue().IsEmpty()){
                var z;
                var linkedPoint = (function (){
                    var $1 = {
                        Value: z
                    };
                    var $res = this.get_Queue().Dequeue$$Double($1);
                    z = $1.Value;
                    return $res;
                }).call(this);
                this.ProcessEvent(linkedPoint, z);
            }
        },
        ProcessEvent: function (linkedPoint, z){
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(linkedPoint.get_Next().get_Point().get_X(), linkedPoint.get_Point().get_X()))if (z == Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPointSplitter.Low(linkedPoint))
                this.ProcessLowLinkedPointEvent(linkedPoint);
            else
                this.ProcessHighLinkedPointEvent(linkedPoint);
            else
                this.IntersectWithTree(linkedPoint);
        },
        IntersectWithTree: function (horizontalPoint){
            var left,right;
            var xAligned;
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(horizontalPoint.get_Y(), horizontalPoint.get_Next().get_Y()));
            var y = horizontalPoint.get_Y();
            if (horizontalPoint.get_Point().get_X() < horizontalPoint.get_Next().get_Point().get_X()){
                left = horizontalPoint.get_Point().get_X();
                right = horizontalPoint.get_Next().get_Point().get_X();
                xAligned = true;
            }
            else {
                right = horizontalPoint.get_Point().get_X();
                left = horizontalPoint.get_Next().get_Point().get_X();
                xAligned = false;
            }
            if (xAligned)
                for (var node = this.tree.FindFirst$$Func$2($CreateAnonymousDelegate(this, function (p){
                    return left <= p.get_Point().get_X();
                })); node != null && node.Item.get_Point().get_X() <= right; node = this.tree.Next(node)){
                    var p = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(node.Item.get_Point().get_X(), y);
                    horizontalPoint = Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPointSplitter.TrySplitHorizontalPoint(horizontalPoint, p, true);
                    Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPointSplitter.TrySplitVerticalPoint(node.Item, p);
                }
            else
                for (var node = this.tree.FindLast$$Func$2($CreateAnonymousDelegate(this, function (p){
                    return p.get_Point().get_X() <= right;
                })); node != null && node.Item.get_Point().get_X() >= left; node = this.tree.Previous(node)){
                    var p = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(node.Item.get_Point().get_X(), y);
                    horizontalPoint = Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPointSplitter.TrySplitHorizontalPoint(horizontalPoint, p, false);
                    Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPointSplitter.TrySplitVerticalPoint(node.Item, p);
                }
        },
        ProcessHighLinkedPointEvent: function (linkedPoint){
            this.tree.Remove(linkedPoint);
        },
        ProcessLowLinkedPointEvent: function (linkedPoint){
            this.tree.Insert(linkedPoint);
        },
        InitEventQueue: function (){
            this.set_Queue(new Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueue$1.ctor(Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint.ctor));
            var $it1033 = this.get_VerticalPoints().GetEnumerator();
            while ($it1033.MoveNext()){
                var vertPoint = $it1033.get_Current();
                this.get_Queue().Enqueue(vertPoint, Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPointSplitter.Low(vertPoint));
            }
            var $it1034 = this.get_HorizontalPoints().GetEnumerator();
            while ($it1034.MoveNext()){
                var horizPoint = $it1034.get_Current();
                this.get_Queue().Enqueue(horizPoint, horizPoint.get_Point().get_Y());
            }
        },
        Queue$$: "Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueue`1[[Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint]]",
        get_Queue: function (){
            return this._Queue;
        },
        set_Queue: function (value){
            this._Queue = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$Nudging$LinkedPointSplitter);
var Microsoft$Msagl$Routing$Rectilinear$Nudging$Nudger = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger",
    baseTypeName: "System.Object",
    staticDefinition: {
        ObstacleTest: function (pnt, polyline){
            return (Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(pnt, polyline) != Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside) ? Microsoft.Msagl.Core.Geometry.HitTestBehavior.Stop : Microsoft.Msagl.Core.Geometry.HitTestBehavior.Continue;
        },
        SetWidthsOfArrowheadsForEdge: function (path){
            var edgeGeom = path.get_EdgeGeometry();
            if (edgeGeom.get_TargetArrowhead() != null){
                var pathEdge = path.get_LastEdge();
                pathEdge.set_Width(System.Math.Max$$Double$$Double(edgeGeom.get_TargetArrowhead().get_Width(), pathEdge.get_Width()));
            }
            if (edgeGeom.get_SourceArrowhead() != null){
                var pathEdge = path.get_FirstEdge();
                pathEdge.set_Width(System.Math.Max$$Double$$Double(edgeGeom.get_SourceArrowhead().get_Width(), pathEdge.get_Width()));
            }
        },
        MoveLongestSegIdealPositionsInsideFeasibleInterval: function (seg){
            if (seg.get_IsFixed())
                return;
            var leftBound = seg.GetLeftBound();
            var rightBound = seg.GetRightBound();
            if (seg.get_IdealPosition() < leftBound)
                seg.set_IdealPosition(leftBound);
            else if (seg.get_IdealPosition() > rightBound)
                seg.set_IdealPosition(rightBound);
        },
        Rectilinearise: function (a, b){
            b = b.Clone();
            if (a.get_X() != b.get_X() && a.get_Y() != b.get_Y()){
                var dx = System.Math.Abs$$Double(a.get_X() - b.get_X());
                var dy = System.Math.Abs$$Double(a.get_Y() - b.get_Y());
                if (dx < dy)
                    b.set_X(a.get_X());
                else
                    b.set_Y(a.get_Y());
            }
            return b;
        },
        ParallelToDirection: function (edge, direction){
            switch (direction){
                case Microsoft.Msagl.Core.Geometry.Directions.North:
                case Microsoft.Msagl.Core.Geometry.Directions.South:
                    return Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(edge.get_SourcePoint().get_X(), edge.get_TargetPoint().get_X());
                default:
                    return Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(edge.get_SourcePoint().get_Y(), edge.get_TargetPoint().get_Y());
            }
        },
        SegmentPosition: function (segment, direction){
            return direction == Microsoft.Msagl.Core.Geometry.Directions.North ? segment.get_Start().get_X() : -segment.get_Start().get_Y();
        },
        FindPortEntryRectCrossingAxisEdge: function (portEntry, axisEdge, rect){
            var ar = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(axisEdge.get_SourcePoint(), axisEdge.get_TargetPoint());
            var $it1053 = portEntry.get_AllowedRectangles().GetEnumerator();
            while ($it1053.MoveNext()){
                var r = $it1053.get_Current();
                if (r.Intersects(ar)){
                    rect.Value = r;
                    return true;
                }
            }
            rect.Value = Microsoft.Msagl.Core.Geometry.Rectangle.CreateAnEmptyBox();
            return false;
        },
        CalculateIdealPositionsForLongestSegs: function (path, projectionToPerp){
            var currentLongSeg = null;
            var ret = null;
            var prevOffset = projectionToPerp(path.get_Start());
            var $it1055 = path.get_PathEdges().GetEnumerator();
            while ($it1055.MoveNext()){
                var edge = $it1055.get_Current();
                if (edge.get_LongestNudgedSegment() != null){
                    currentLongSeg = edge.get_LongestNudgedSegment();
                    if (ret != null){
                        var t;
                        Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.SetIdealPositionForSeg(ret, t = projectionToPerp(ret.get_Start()), prevOffset, projectionToPerp(currentLongSeg.get_Start()));
                        prevOffset = t;
                        ret = null;
                    }
                }
                else if (currentLongSeg != null){
                    ret = currentLongSeg;
                    currentLongSeg = null;
                }
            }
            if (ret != null)
                Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.SetIdealPositionForSeg(ret, projectionToPerp(ret.get_Start()), prevOffset, projectionToPerp(path.get_End()));
            else if (currentLongSeg != null)
                currentLongSeg.set_IdealPosition(projectionToPerp(currentLongSeg.get_Start()));
        },
        SetIdealPositionForSeg: function (segment, segPosition, offset0, offset1){
            var max = System.Math.Max$$Double$$Double(offset0, offset1);
            var min = System.Math.Min$$Double$$Double(offset0, offset1);
            if (min + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon < segPosition)if (segPosition < max)
                segment.set_IdealPosition(0.5 * (max + min));
            else
                segment.set_IdealPosition(max);
            else
                segment.set_IdealPosition(min);
        },
        BuildPolylineForPath: function (path){
            var points = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, path.get_PathPoints(), function (p){
                return p.Clone();
            }));
            (function (){
                var $1 = {
                    Value: points
                };
                var $res = Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.ExtendPolylineToPorts($1, path);
                points = $1.Value;
                return $res;
            })();
            for (var i = 0; i < points.length - 1; i++)
                System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.CompassVector.IsPureDirection$$Point$$Point(points[i], points[i + 1]));
            return points;
        },
        ExtendPolylineToPorts: function (points, path){
            Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.ExtendPolylineToSourcePort(points, path.get_EdgeGeometry().get_SourcePort().get_Location());
            Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.ExtendPolylineToTargetPort(points, path.get_EdgeGeometry().get_TargetPort().get_Location());
            if (points.Value.length < 2){
                points.Value = new Array(2);
                points.Value[0] = path.get_EdgeGeometry().get_SourcePort().get_Location();
                points.Value[1] = path.get_EdgeGeometry().get_TargetPort().get_Location();
            }
        },
        ExtendPolylineToTargetPort: function (points, location){
            var n = points.Value.length - 1;
            var dir = Microsoft.Msagl.Core.Geometry.CompassVector.VectorDirection$$Point$$Point(points.Value[n - 1], points.Value[n]);
            if (Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.ProjectionsAreClose(points.Value[n - 1], dir, location)){
                points.Value = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Linq.Enumerable.Take$1(Microsoft.Msagl.Core.Geometry.Point.ctor, points.Value, n));
                return;
            }
            if (dir == Microsoft.Msagl.Core.Geometry.Directions.East || dir == Microsoft.Msagl.Core.Geometry.Directions.West)
                points.Value[n].set_X(location.get_X());
            else
                points.Value[n].set_Y(location.get_Y());
        },
        ProjectionsAreClose: function (a, dir, b){
            if (dir == Microsoft.Msagl.Core.Geometry.Directions.East || dir == Microsoft.Msagl.Core.Geometry.Directions.West)
                return Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(a.get_X(), b.get_X());
            return Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(a.get_Y(), b.get_Y());
        },
        ExtendPolylineToSourcePort: function (points, location){
            var dir = Microsoft.Msagl.Core.Geometry.CompassVector.VectorDirection$$Point$$Point(points.Value[0], points.Value[1]);
            if (Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.ProjectionsAreClose(points.Value[1], dir, location)){
                points.Value = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Linq.Enumerable.Skip$1(Microsoft.Msagl.Core.Geometry.Point.ctor, points.Value, 1));
                return;
            }
            if (dir == Microsoft.Msagl.Core.Geometry.Directions.East || dir == Microsoft.Msagl.Core.Geometry.Directions.West)
                points.Value[0].set_X(location.get_X());
            else
                points.Value[0].set_Y(location.get_Y());
        },
        RemoveSwitchbacksAndMiddlePoints: function (points){
            var $yield = [];
            var en = points.GetEnumerator();
            en.MoveNext();
            var a = en.get_Current();
            $yield.push(a);
            en.MoveNext();
            var b = en.get_Current();
            var prevDir = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b, a)).get_CompassDirection();
            while (en.MoveNext()){
                var dir = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(en.get_Current(), b)).get_CompassDirection();
                if (dir == prevDir || Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(dir) == prevDir || dir == Microsoft.Msagl.Core.Geometry.Directions.None)
                    b = en.get_Current();
                else {
                    if (!Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(a, b)){
                        $yield.push(a = Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.Rectilinearise(a, b));
                    }
                    b = en.get_Current();
                    prevDir = dir;
                }
            }
            if (!Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(a, b))
                $yield.push(Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.Rectilinearise(a, b));
            return $yield;
        },
        NudgePaths: function (paths, cornerFitRadius, paddedObstacles, ancestorsSets, removeStaircases){
            if (!System.Linq.Enumerable.Any$1$$IEnumerable$1(Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.ctor, paths))
                return;
            var nudger = new Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.ctor(paths, cornerFitRadius, paddedObstacles, ancestorsSets);
            nudger.Calculate(Microsoft.Msagl.Core.Geometry.Directions.North, true);
            nudger.Calculate(Microsoft.Msagl.Core.Geometry.Directions.East, false);
            nudger.Calculate(Microsoft.Msagl.Core.Geometry.Directions.North, false);
            if (removeStaircases)
                nudger.RemoveStaircases();
            var $it1057 = paths.GetEnumerator();
            while ($it1057.MoveNext()){
                var path = $it1057.get_Current();
                path.get_EdgeGeometry().set_Curve(new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor$$IEnumerable$1$Point(Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.BuildPolylineForPath(path)));
            }
        },
        MapPortsToShapes: function (listOfShapes){
            var portToShapes = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Port.ctor, Microsoft.Msagl.Routing.Shape.ctor);
            var $it1058 = listOfShapes.GetEnumerator();
            while ($it1058.MoveNext()){
                var shape = $it1058.get_Current();
                var $it1059 = shape.get_Ports().GetEnumerator();
                while ($it1059.MoveNext()){
                    var port = $it1059.get_Current();
                    portToShapes.set_Item$$TKey(port, shape);
                }
            }
            return portToShapes;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (paths, cornerFitRad, obstacles, ancestorsSets){
            this.axisEdgesToObstaclesTheyOriginatedFrom = null;
            this._Paths = null;
            this._Obstacles = null;
            this._PathVisibilityGraph = null;
            this._AncestorsSets = null;
            this._HierarchyOfObstacles = null;
            this._HierarchyOfGroups = null;
            this._NudgingDirection = Microsoft.Msagl.Core.Geometry.Directions.None;
            this._EdgeSeparation = 0;
            this._Solver = null;
            this._LongestNudgedSegs = null;
            this._PathOrders = null;
            this._PathToObstacles = null;
            this._PortToShapes = null;
            System.Object.ctor.call(this);
            this.set_AncestorsSets(ancestorsSets);
            this.set_HierarchyOfGroups(Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnEnumeration(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, ancestorsSets.get_Keys(), $CreateAnonymousDelegate(this, function (shape){
                return shape.get_IsGroup();
            })), $CreateAnonymousDelegate(this, function (group){
                return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(Microsoft.Msagl.Routing.Shape.ctor, group, group.get_BoundingBox());
            }))));
            this.set_Obstacles(obstacles);
            this.set_EdgeSeparation(2 * cornerFitRad);
            this.set_Paths(new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.ctor, paths));
            this.set_HierarchyOfObstacles(Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnEnumeration(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, obstacles, $CreateAnonymousDelegate(this, function (p){
                return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, p, p.get_BoundingBox());
            }))));
            this.MapPathsToTheirObstacles();
        },
        HasGroups$$: "System.Boolean",
        get_HasGroups: function (){
            return (null != this.get_HierarchyOfGroups()) && (this.get_HierarchyOfGroups().get_Count() > 0);
        },
        Paths$$: "System.Collections.Generic.List`1[[Microsoft.Msagl.Routing.Rectilinear.Nudging.Path]]",
        get_Paths: function (){
            return this._Paths;
        },
        set_Paths: function (value){
            this._Paths = value;
        },
        Obstacles$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]",
        get_Obstacles: function (){
            return this._Obstacles;
        },
        set_Obstacles: function (value){
            this._Obstacles = value;
        },
        PathVisibilityGraph$$: "Microsoft.Msagl.Routing.Visibility.VisibilityGraph",
        get_PathVisibilityGraph: function (){
            return this._PathVisibilityGraph;
        },
        set_PathVisibilityGraph: function (value){
            this._PathVisibilityGraph = value;
        },
        AncestorsSets$$: "System.Collections.Generic.Dictionary`2[[Microsoft.Msagl.Routing.Shape],[Microsoft.Msagl.Core.DataStructures.Set`1[[Microsoft.Msagl.Routing.Shape]]]]",
        get_AncestorsSets: function (){
            return this._AncestorsSets;
        },
        set_AncestorsSets: function (value){
            this._AncestorsSets = value;
        },
        MapPathsToTheirObstacles: function (){
            this.set_PathToObstacles(new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.ctor, System.Tuple$2.ctor));
            var $it1035 = this.get_Paths().GetEnumerator();
            while ($it1035.MoveNext()){
                var path = $it1035.get_Current();
                this.MapPathToItsObstacles(path);
            }
        },
        MapPathToItsObstacles: function (path){
            var startNode = this.get_HierarchyOfObstacles().FirstHitNode$$Point$$Func$3(System.Linq.Enumerable.First$1$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Point.ctor, path.get_PathPoints()), Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.ObstacleTest);
            var endNode = this.get_HierarchyOfObstacles().FirstHitNode$$Point$$Func$3(System.Linq.Enumerable.Last$1$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Point.ctor, path.get_PathPoints()), Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.ObstacleTest);
            if ((null != startNode) && (null != endNode)){
                this.get_PathToObstacles().set_Item$$TKey(path, new System.Tuple$2.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, startNode.get_UserData(), endNode.get_UserData()));
            }
        },
        HierarchyOfObstacles$$: "Microsoft.Msagl.Core.Geometry.RectangleNode`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]",
        get_HierarchyOfObstacles: function (){
            return this._HierarchyOfObstacles;
        },
        set_HierarchyOfObstacles: function (value){
            this._HierarchyOfObstacles = value;
        },
        HierarchyOfGroups$$: "Microsoft.Msagl.Core.Geometry.RectangleNode`1[[Microsoft.Msagl.Routing.Shape]]",
        get_HierarchyOfGroups: function (){
            return this._HierarchyOfGroups;
        },
        set_HierarchyOfGroups: function (value){
            this._HierarchyOfGroups = value;
        },
        Calculate: function (direction, mergePaths){
            this.set_NudgingDirection(direction);
            Microsoft.Msagl.Routing.Rectilinear.Nudging.PathRefiner.RefinePaths(this.get_Paths(), mergePaths);
            this.GetPathOrdersAndPathGraph();
            this.MapAxisEdgesToTheirObstacles();
            this.DrawPaths();
        },
        MapAxisEdgesToTheirObstacles: function (){
            this.axisEdgesToObstaclesTheyOriginatedFrom = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdge.ctor, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            var $it1036 = this.get_Paths().GetEnumerator();
            while ($it1036.MoveNext()){
                var path = $it1036.get_Current();
                this.MapPathEndAxisEdgesToTheirObstacles(path);
            }
            var $it1037 = this.get_Paths().GetEnumerator();
            while ($it1037.MoveNext()){
                var path = $it1037.get_Current();
                this.UmmapPathInteriourFromStrangerObstacles(path);
            }
        },
        UmmapPathInteriourFromStrangerObstacles: function (path){
            var firstUnmappedEdge = this.FindFirstUnmappedEdge(path);
            if (firstUnmappedEdge == null)
                return;
            var lastUnmappedEdge = this.FindLastUnmappedEdge(path);
            for (var edge = firstUnmappedEdge; edge != null && edge != lastUnmappedEdge; edge = edge.get_Next())
                this.axisEdgesToObstaclesTheyOriginatedFrom.Remove(edge.get_AxisEdge());
        },
        FindLastUnmappedEdge: function (path){
            for (var edge = path.get_LastEdge(); edge != null; edge = edge.get_Prev())
                if (edge.get_AxisEdge().get_Direction() != this.get_NudgingDirection())
                    return edge;
            return null;
        },
        FindFirstUnmappedEdge: function (path){
            for (var edge = path.get_FirstEdge(); edge != null; edge = edge.get_Next())
                if (edge.get_AxisEdge().get_Direction() != this.get_NudgingDirection())
                    return edge;
            return null;
        },
        MapPathEndAxisEdgesToTheirObstacles: function (path){
            var coupleOfObstacles;
            if ((function (){
                var $1 = {
                    Value: coupleOfObstacles
                };
                var $res = this.get_PathToObstacles().TryGetValue(path, $1);
                coupleOfObstacles = $1.Value;
                return $res;
            }).call(this)){
                this.ProcessThePathStartToMapAxisEdgesToTheirObstacles(path, coupleOfObstacles.get_Item1());
                this.ProcessThePathEndToMapAxisEdgesToTheirObstacles(path, coupleOfObstacles.get_Item2());
            }
        },
        ProcessThePathEndToMapAxisEdgesToTheirObstacles: function (path, endPolyline){
            for (var edge = path.get_LastEdge(); edge != null && Microsoft.Msagl.Core.Geometry.CompassVector.DirectionsAreParallel(edge.get_Direction(), this.get_NudgingDirection()); edge = edge.get_Prev())
                this.axisEdgesToObstaclesTheyOriginatedFrom.set_Item$$TKey(edge.get_AxisEdge(), endPolyline);
        },
        ProcessThePathStartToMapAxisEdgesToTheirObstacles: function (path, startPolyline){
            for (var edge = path.get_FirstEdge(); edge != null && Microsoft.Msagl.Core.Geometry.CompassVector.DirectionsAreParallel(edge.get_Direction(), this.get_NudgingDirection()); edge = edge.get_Next())
                this.axisEdgesToObstaclesTheyOriginatedFrom.set_Item$$TKey(edge.get_AxisEdge(), startPolyline);
        },
        GetPathOrdersAndPathGraph: function (){
            var combinatorialNudger = new Microsoft.Msagl.Routing.Rectilinear.Nudging.CombinatorialNudger.ctor(this.get_Paths());
            this.set_PathOrders(combinatorialNudger.GetOrder());
            this.set_PathVisibilityGraph(combinatorialNudger.get_PathVisibilityGraph());
        },
        NudgingDirection$$: "Microsoft.Msagl.Core.Geometry.Directions",
        get_NudgingDirection: function (){
            return this._NudgingDirection;
        },
        set_NudgingDirection: function (value){
            this._NudgingDirection = value;
        },
        DrawPaths: function (){
            this.SetWidthsOfArrowheads();
            this.CreateLongestNudgedSegments();
            this.FindFreeSpaceInDirection(System.Linq.Enumerable.Cast$1(Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdge.ctor, this.get_PathVisibilityGraph().get_Edges()));
            this.MoveLongestSegsIdealPositionsInsideFeasibleIntervals();
            this.PositionShiftedEdges();
        },
        SetWidthsOfArrowheads: function (){
            var $it1038 = this.get_Paths().GetEnumerator();
            while ($it1038.MoveNext()){
                var edgePath = $it1038.get_Current();
                Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.SetWidthsOfArrowheadsForEdge(edgePath);
            }
        },
        EdgeSeparation$$: "System.Double",
        get_EdgeSeparation: function (){
            return this._EdgeSeparation;
        },
        set_EdgeSeparation: function (value){
            this._EdgeSeparation = value;
        },
        PositionShiftedEdges: function (){
            this.set_Solver(new Microsoft.Msagl.Core.ProjectionSolver.UniformOneDimensionalSolver.ctor(this.get_EdgeSeparation()));
            var $it1039 = this.get_LongestNudgedSegs().GetEnumerator();
            while ($it1039.MoveNext()){
                var segment = $it1039.get_Current();
                this.CreateVariablesOfLongestSegment(segment);
            }
            this.CreateConstraintsOfTheOrder();
            this.CreateConstraintsBetweenLongestSegments();
            this.get_Solver().Solve();
            this.ShiftPathEdges();
        },
        MoveLongestSegsIdealPositionsInsideFeasibleIntervals: function (){
            var $it1040 = this.get_LongestNudgedSegs().GetEnumerator();
            while ($it1040.MoveNext()){
                var seg = $it1040.get_Current();
                Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.MoveLongestSegIdealPositionsInsideFeasibleInterval(seg);
            }
        },
        ShiftPathEdges: function (){
            var $it1041 = this.get_Paths().GetEnumerator();
            while ($it1041.MoveNext()){
                var path = $it1041.get_Current();
                path.set_PathPoints(System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Geometry.Point.ctor, this.GetShiftedPoints(path)));
            }
        },
        GetShiftedPoints: function (path){
            return Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.RemoveSwitchbacksAndMiddlePoints(this.GetShiftedPointsSimple(path));
        },
        GetShiftedPointsSimple: function (path){
            var $yield = [];
            var edge = path.get_FirstEdge();
            $yield.push(this.ShiftedPoint(edge.get_Source(), edge.get_LongestNudgedSegment()));
            var $it1042 = path.get_PathEdges().GetEnumerator();
            while ($it1042.MoveNext()){
                var e = $it1042.get_Current();
                $yield.push(this.ShiftedEdgePositionOfTarget(e));
            }
            return $yield;
        },
        ShiftedEdgePositionOfTarget: function (e){
            return e.get_LongestNudgedSegment() != null || e.get_Next() == null ? this.ShiftedPoint(e.get_Target(), e.get_LongestNudgedSegment()) : this.ShiftedPoint(e.get_Next().get_Source(), e.get_Next().get_LongestNudgedSegment());
        },
        ShiftedPoint: function (point, segment){
            if (segment == null)
                return point;
            var t = this.get_Solver().GetVariablePosition(segment.Id);
            return this.get_NudgingDirection() == Microsoft.Msagl.Core.Geometry.Directions.North ? new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(t, point.get_Y()) : new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(point.get_X(), -t);
        },
        CreateConstraintsBetweenLongestSegments: function (){
            var $it1043 = this.get_LongestNudgedSegs().GetEnumerator();
            while ($it1043.MoveNext()){
                var segment = $it1043.get_Current();
                this.CreateConstraintsBetweenLongestSegmentsForSegment(segment);
            }
        },
        CreateConstraintsBetweenLongestSegmentsForSegment: function (segment){
            var rightNeighbors = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Routing.Rectilinear.Nudging.LongestNudgedSegment.ctor);
            var $it1044 = segment.get_Edges().GetEnumerator();
            while ($it1044.MoveNext()){
                var pathEdge = $it1044.get_Current();
                var axisEdge = pathEdge.get_AxisEdge();
                if (axisEdge != null){
                    var $it1045 = axisEdge.RightNeighbors.GetEnumerator();
                    while ($it1045.MoveNext()){
                        var rightNeiAxisEdge = $it1045.get_Current();
                        var $it1046 = rightNeiAxisEdge.get_LongestNudgedSegments().GetEnumerator();
                        while ($it1046.MoveNext()){
                            var longSeg = $it1046.get_Current();
                            rightNeighbors.Insert(longSeg);
                        }
                    }
                }
            }
            var $it1047 = rightNeighbors.GetEnumerator();
            while ($it1047.MoveNext()){
                var seg = $it1047.get_Current();
                this.ConstraintTwoLongestSegs(segment, seg);
            }
        },
        CreateConstraintsOfTheOrder: function (){
            var $it1048 = this.get_PathOrders().GetEnumerator();
            while ($it1048.MoveNext()){
                var kv = $it1048.get_Current();
                if (Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.ParallelToDirection(kv.get_Key(), this.get_NudgingDirection()))
                    this.CreateConstraintsOfThePathOrder(kv.get_Value());
            }
        },
        CreateConstraintsOfThePathOrder: function (pathOrder){
            var prevEdge = null;
            var $it1049 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge.ctor, pathOrder, $CreateAnonymousDelegate(this, function (p){
                return p.get_LongestNudgedSegment() != null;
            })).GetEnumerator();
            while ($it1049.MoveNext()){
                var pathEdge = $it1049.get_Current();
                if (prevEdge != null)
                    this.ConstraintTwoLongestSegs(prevEdge.get_LongestNudgedSegment(), pathEdge.get_LongestNudgedSegment());
                prevEdge = pathEdge;
            }
        },
        ConstraintTwoLongestSegs: function (prevSeg, seg){
            if (!prevSeg.get_IsFixed() || !seg.get_IsFixed())
                this.get_Solver().AddConstraint(prevSeg.Id, seg.Id);
        },
        Solver$$: "Microsoft.Msagl.Core.ProjectionSolver.UniformOneDimensionalSolver",
        get_Solver: function (){
            return this._Solver;
        },
        set_Solver: function (value){
            this._Solver = value;
        },
        CreateVariablesOfLongestSegment: function (segment){
            if (!segment.get_IsFixed()){
                var leftBound = segment.GetLeftBound();
                var rightBound = segment.GetRightBound();
                if (leftBound >= rightBound){
                    this.get_Solver().AddFixedVariable(segment.Id, Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.SegmentPosition(segment, this.get_NudgingDirection()));
                    segment.set_IsFixed(true);
                }
                else {
                    this.get_Solver().AddVariable$$Int32$$Double$$Double$$Double(segment.Id, Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.SegmentPosition(segment, this.get_NudgingDirection()), segment.get_IdealPosition(), segment.get_Width());
                    if (leftBound != -Infinity)
                        this.get_Solver().SetLowBound(leftBound, segment.Id);
                    if (rightBound != Infinity)
                        this.get_Solver().SetUpperBound(segment.Id, rightBound);
                }
            }
            else
                this.get_Solver().AddFixedVariable(segment.Id, Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.SegmentPosition(segment, this.get_NudgingDirection()));
        },
        LongestNudgedSegs$$: "System.Collections.Generic.List`1[[Microsoft.Msagl.Routing.Rectilinear.Nudging.LongestNudgedSegment]]",
        get_LongestNudgedSegs: function (){
            return this._LongestNudgedSegs;
        },
        set_LongestNudgedSegs: function (value){
            this._LongestNudgedSegs = value;
        },
        PathOrders$$: "System.Collections.Generic.Dictionary`2[[Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdge],[System.Collections.Generic.List`1[[Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge]]]]",
        get_PathOrders: function (){
            return this._PathOrders;
        },
        set_PathOrders: function (value){
            this._PathOrders = value;
        },
        PathToObstacles$$: "System.Collections.Generic.Dictionary`2[[Microsoft.Msagl.Routing.Rectilinear.Nudging.Path],[System.Tuple`2[[Microsoft.Msagl.Core.Geometry.Curves.Polyline],[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]]]",
        get_PathToObstacles: function (){
            return this._PathToObstacles;
        },
        set_PathToObstacles: function (value){
            this._PathToObstacles = value;
        },
        FindFreeSpaceInDirection: function (axisEdges){
            this.BoundAxisEdgesByRectsKnownInAdvance();
            var freeSpaceFinder = new Microsoft.Msagl.Routing.Rectilinear.Nudging.FreeSpaceFinder.ctor(this.get_NudgingDirection(), this.get_Obstacles(), this.axisEdgesToObstaclesTheyOriginatedFrom, this.get_PathOrders(), axisEdges);
            freeSpaceFinder.FindFreeSpace();
        },
        BoundAxisEdgesByRectsKnownInAdvance: function (){
            var $it1050 = this.get_Paths().GetEnumerator();
            while ($it1050.MoveNext()){
                var path = $it1050.get_Current();
                if (this.get_HasGroups())
                    this.BoundPathByMinCommonAncestors(path);
                this.BoundAxisEdgesAdjacentToSourceAndTargetOnEdge(path);
            }
        },
        BoundPathByMinCommonAncestors: function (path){
            var $it1051 = System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Core.Geometry.Rectangle.ctor, this.GetMinCommonAncestors(path.get_EdgeGeometry()), $CreateAnonymousDelegate(this, function (sh){
                return sh.get_BoundingBox();
            })).GetEnumerator();
            while ($it1051.MoveNext()){
                var rect = $it1051.get_Current();
                var $it1052 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdge.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge.ctor, Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdge.ctor, path.get_PathEdges(), $CreateAnonymousDelegate(this, function (e){
                    return e.get_AxisEdge();
                })), $CreateAnonymousDelegate(this, function (axisEdge){
                    return axisEdge.get_Direction() == this.get_NudgingDirection();
                })).GetEnumerator();
                while ($it1052.MoveNext()){
                    var edge = $it1052.get_Current();
                    this.BoundAxisEdgeByRect(rect, edge);
                }
            }
        },
        GetMinCommonAncestors: function (edgeGeometry){
            if (this.get_PortToShapes() == null)
                this.set_PortToShapes(Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.MapPortsToShapes(this.get_AncestorsSets().get_Keys()));
            var commonAncestors = Microsoft.Msagl.Core.DataStructures.Set$1.op_Multiply(this.AncestorsForPort(edgeGeometry.get_SourcePort()), this.AncestorsForPort(edgeGeometry.get_TargetPort()));
            return System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, commonAncestors, $CreateAnonymousDelegate(this, function (anc){
                return !System.Linq.Enumerable.Any$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, anc.get_Children(), $CreateAnonymousDelegate(this, function (child){
                    return commonAncestors.Contains$$T(child);
                }));
            }));
        },
        PortToShapes$$: "System.Collections.Generic.Dictionary`2[[Microsoft.Msagl.Core.Layout.Port],[Microsoft.Msagl.Routing.Shape]]",
        get_PortToShapes: function (){
            return this._PortToShapes;
        },
        set_PortToShapes: function (value){
            this._PortToShapes = value;
        },
        AncestorsForPort: function (port){
            var shape;
            if ((function (){
                var $1 = {
                    Value: shape
                };
                var $res = this.get_PortToShapes().TryGetValue(port, $1);
                shape = $1.Value;
                return $res;
            }).call(this)){
                return this.get_AncestorsSets().get_Item$$TKey(shape);
            }
            return new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Routing.Shape.ctor, this.get_HierarchyOfGroups().AllHitItems$$Rectangle$$Func$2(new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(port.get_Location(), port.get_Location()), null));
        },
        BoundAxisEdgeAdjacentToObstaclePort: function (port, axisEdge){
            if (Is(port, Microsoft.Msagl.Routing.Rectilinear.WaypointPort.ctor) || (port.get_Curve() == null && port.get_PortEntry() == null))
                this.BoundAxisByPoint(port.get_Location(), axisEdge);
            else if (port.get_PortEntry() == null){
                if (port.get_Curve().get_BoundingBox().Contains$$Point(port.get_Location()))
                    this.BoundAxisEdgeByRect(port.get_Curve().get_BoundingBox(), axisEdge);
            }
            else {
                var portEntry = As(port.get_PortEntry(), Microsoft.Msagl.Core.Layout.PortEntryOnCurve.ctor);
                if (portEntry != null){
                    var rect;
                    if ((function (){
                        var $1 = {
                            Value: rect
                        };
                        var $res = Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.FindPortEntryRectCrossingAxisEdge(portEntry, axisEdge, $1);
                        rect = $1.Value;
                        return $res;
                    }).call(this))
                        this.BoundAxisEdgeByRect(rect, axisEdge);
                }
            }
        },
        BoundAxisByPoint: function (point, axisEdge){
            if (axisEdge != null && axisEdge.get_Direction() == this.get_NudgingDirection())if (this.get_NudgingDirection() == Microsoft.Msagl.Core.Geometry.Directions.North){
                axisEdge.BoundFromLeft(point.get_X());
                axisEdge.BoundFromRight(point.get_X());
            }
            else {
                axisEdge.BoundFromLeft(-point.get_Y());
                axisEdge.BoundFromRight(-point.get_Y());
            }
        },
        BoundAxisEdgesAdjacentToSourceAndTargetOnEdge: function (path){
            this.BoundAxisEdgeAdjacentToObstaclePort(path.get_EdgeGeometry().get_SourcePort(), path.get_FirstEdge().get_AxisEdge());
            this.BoundAxisEdgeAdjacentToObstaclePort(path.get_EdgeGeometry().get_TargetPort(), path.get_LastEdge().get_AxisEdge());
        },
        BoundAxisEdgeByRect: function (rectangle, axisEdge){
            if (axisEdge != null && axisEdge.get_Direction() == this.get_NudgingDirection())if (this.get_NudgingDirection() == Microsoft.Msagl.Core.Geometry.Directions.North){
                axisEdge.BoundFromLeft(rectangle.get_Left());
                axisEdge.BoundFromRight(rectangle.get_Right());
            }
            else {
                axisEdge.BoundFromLeft(-rectangle.get_Top());
                axisEdge.BoundFromRight(-rectangle.get_Bottom());
            }
        },
        CreateLongestNudgedSegments: function (){
            var projectionToPerp = this.get_NudgingDirection() == Microsoft.Msagl.Core.Geometry.Directions.East ? Microsoft.Msagl.Routing.Rectilinear.Nudging.FreeSpaceFinder.MinusY : Microsoft.Msagl.Routing.Rectilinear.Nudging.FreeSpaceFinder.X;
            this.set_LongestNudgedSegs(new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Rectilinear.Nudging.LongestNudgedSegment.ctor));
            var $it1054 = this.get_Paths().GetEnumerator();
            while ($it1054.MoveNext()){
                var path = $it1054.get_Current();
                this.CreateLongestNudgedSegmentsForPath(path, projectionToPerp);
            }
        },
        CreateLongestNudgedSegmentsForPath: function (path, projectionToPerp){
            this.GoOverPathAndCreateLongSegs(path);
            Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.CalculateIdealPositionsForLongestSegs(path, projectionToPerp);
        },
        GoOverPathAndCreateLongSegs: function (path){
            var currentLongestSeg = null;
            var oppositeDir = Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(this.get_NudgingDirection());
            var $it1056 = path.get_PathEdges().GetEnumerator();
            while ($it1056.MoveNext()){
                var edge = $it1056.get_Current();
                var edgeDir = edge.get_Direction();
                if (edgeDir == this.get_NudgingDirection() || edgeDir == oppositeDir){
                    if (currentLongestSeg == null){
                        edge.set_LongestNudgedSegment(currentLongestSeg = new Microsoft.Msagl.Routing.Rectilinear.Nudging.LongestNudgedSegment.ctor(this.get_LongestNudgedSegs().get_Count()));
                        this.get_LongestNudgedSegs().Add(edge.get_LongestNudgedSegment());
                    }
                    else
                        edge.set_LongestNudgedSegment(currentLongestSeg);
                    if (edge.get_IsFixed())
                        currentLongestSeg.set_IsFixed(true);
                }
                else {
                    edge.set_LongestNudgedSegment(null);
                    currentLongestSeg = null;
                }
            }
        },
        RemoveStaircases: function (){
            Microsoft.Msagl.Routing.Rectilinear.Nudging.StaircaseRemover.RemoveStaircases(this.get_Paths(), this.get_HierarchyOfObstacles());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$Nudging$Nudger);
var Microsoft$Msagl$Routing$Rectilinear$Nudging$PointProjection = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.Nudging.PointProjection",
    Kind: "Delegate",
    definition: {
        ctor: function (obj, func){
            System.MulticastDelegate.ctor.call(this, obj, func);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$Nudging$PointProjection);
var Microsoft$Msagl$Core$ProjectionSolver$UniformOneDimensionalSolver = {
    fullname: "Microsoft.Msagl.Core.ProjectionSolver.UniformOneDimensionalSolver",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (variableSeparation){
            this.idealPositions = new System.Collections.Generic.Dictionary$2.ctor(System.Int32.ctor, System.Double.ctor);
            this.varSepartion = 0;
            this.varList = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.ProjectionSolver.UniformSolverVar.ctor);
            this.constraints = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor);
            this.graph = null;
            this.solverShell = new Microsoft.Msagl.Core.ProjectionSolver.SolverShell.ctor();
            this.boundsToInt = new System.Collections.Generic.Dictionary$2.ctor(System.Double.ctor, System.Int32.ctor);
            System.Object.ctor.call(this);
            this.varSepartion = variableSeparation;
        },
        SetLowBound: function (bound, id){
            var v = this.Var(id);
            v.set_LowBound(System.Math.Max$$Double$$Double(bound, v.get_LowBound()));
        },
        Var: function (id){
            return this.varList.get_Item$$Int32(id);
        },
        SetUpperBound: function (id, bound){
            var v = this.Var(id);
            v.set_UpperBound(System.Math.Min$$Double$$Double(bound, v.get_UpperBound()));
        },
        Solve: function (){
            this.SolveByRegularSolver();
        },
        SolveByRegularSolver: function (){
            this.CreateVariablesForBounds();
            for (var i = 0; i < this.varList.get_Count(); i++){
                var v = this.varList.get_Item$$Int32(i);
                if (v.IsFixed)
                    this.solverShell.AddFixedVariable(i, v.get_Position());
                else {
                    this.solverShell.AddVariableWithIdealPosition$$Int32$$Double(i, this.idealPositions.get_Item$$TKey(i));
                    if (v.get_LowBound() != -Infinity)
                        this.constraints.Insert(new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(this.GetBoundId(v.get_LowBound()), i));
                    if (v.get_UpperBound() != Infinity)
                        this.constraints.Insert(new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(i, this.GetBoundId(v.get_UpperBound())));
                }
            }
            this.CreateGraphAndRemoveCycles();
            var $it1060 = this.graph.get_Edges().GetEnumerator();
            while ($it1060.MoveNext()){
                var edge = $it1060.get_Current();
                var w = 0;
                if (edge.get_First() < this.varList.get_Count())
                    w += this.varList.get_Item$$Int32(edge.get_First()).get_Width();
                if (edge.get_Second() < this.varList.get_Count())
                    w += this.varList.get_Item$$Int32(edge.get_Second()).get_Width();
                w /= 2;
                this.solverShell.AddLeftRightSeparationConstraint$$Int32$$Int32$$Double(edge.get_First(), edge.get_Second(), this.varSepartion + w);
            }
            this.solverShell.Solve();
            for (var i = 0; i < this.varList.get_Count(); i++)
                this.varList.get_Item$$Int32(i).set_Position(this.solverShell.GetVariableResolvedPosition(i));
        },
        GetBoundId: function (bound){
            return this.boundsToInt.get_Item$$TKey(bound);
        },
        CreateVariablesForBounds: function (){
            var $it1061 = this.varList.GetEnumerator();
            while ($it1061.MoveNext()){
                var v = $it1061.get_Current();
                if (v.IsFixed)
                    continue;
                if (v.get_LowBound() != -Infinity)
                    this.RegisterBoundVar(v.get_LowBound());
                if (v.get_UpperBound() != Infinity)
                    this.RegisterBoundVar(v.get_UpperBound());
            }
        },
        RegisterBoundVar: function (bound){
            if (!this.boundsToInt.ContainsKey(bound)){
                var varIndex = this.varList.get_Count() + this.boundsToInt.get_Count();
                this.boundsToInt.set_Item$$TKey(bound, varIndex);
                this.solverShell.AddFixedVariable(varIndex, bound);
            }
        },
        CreateGraphAndRemoveCycles: function (){
            this.graph = new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor$$IEnumerable$1$$Int32(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, this.constraints, this.varList.get_Count() + this.boundsToInt.get_Count());
            var feedbackSet = Microsoft.Msagl.Core.GraphAlgorithms.CycleRemoval$1.GetFeedbackSet(this.graph);
            if (feedbackSet != null){
                var $it1062 = feedbackSet.GetEnumerator();
                while ($it1062.MoveNext()){
                    var edge = $it1062.get_Current();
                    this.graph.RemoveEdge(As(edge, Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor));
                }
            }
        },
        GetVariablePosition: function (id){
            return this.varList.get_Item$$Int32(id).get_Position();
        },
        AddConstraint: function (i, j){
            this.constraints.Insert(new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(i, j));
        },
        AddVariable$$Int32$$Double$$Double$$Double: function (id, currentPosition, idealPosition, width){
            this.idealPositions.set_Item$$TKey(id, idealPosition);
            this.AddVariable$$Int32$$Double$$Boolean$$Double(id, currentPosition, false, width);
        },
        AddFixedVariable: function (id, position){
            this.AddVariable$$Int32$$Double$$Boolean$$Double(id, position, true, 0);
        },
        AddVariable$$Int32$$Double$$Boolean$$Double: function (id, position, isFixed, width){
            System.Diagnostics.Debug.Assert$$Boolean(id == this.varList.get_Count());
            this.varList.Add((function (){
                var $v117 = new Microsoft.Msagl.Core.ProjectionSolver.UniformSolverVar.ctor();
                $v117.IsFixed = isFixed;
                $v117.set_Position(position);
                $v117.set_Width(width);
                return $v117;
            }).call(this));
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$ProjectionSolver$UniformOneDimensionalSolver);
var Microsoft$Msagl$Routing$Rectilinear$Nudging$LinkedPoint = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IEnumerable$1"],
    Kind: "Class",
    definition: {
        ctor: function (point){
            this._Point = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._Next = null;
            System.Object.ctor.call(this);
            this.set_Point(point);
        },
        Point$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Point: function (){
            return this._Point;
        },
        set_Point: function (value){
            this._Point = value;
        },
        Next$$: "Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint",
        get_Next: function (){
            return this._Next;
        },
        set_Next: function (value){
            this._Next = value;
        },
        GetEnumerator: function (){
            var $yield = [];
            for (var p = this; p != null; p = p.get_Next())
                $yield.push(p.get_Point());
            return $yield.GetEnumerator();
        },
        X$$: "System.Double",
        get_X: function (){
            return this.get_Point().get_X();
        },
        Y$$: "System.Double",
        get_Y: function (){
            return this.get_Point().get_Y();
        },
        InsertVerts: function (i, j, points){
            for (j--; i < j; j--)
                this.SetNewNext(points[j]);
        },
        InsertVertsInReverse: function (i, j, points){
            for (i++; i < j; i++)
                this.SetNewNext(points[i]);
        },
        SetNewNext: function (p){
            var nv = new Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint.ctor(p);
            var tmp = this.get_Next();
            this.set_Next(nv);
            nv.set_Next(tmp);
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.CompassVector.IsPureDirection$$Point$$Point(this.get_Point(), this.get_Next().get_Point()));
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$Nudging$LinkedPoint);
var Microsoft$Msagl$Routing$Rectilinear$Nudging$PathRefiner = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.Nudging.PathRefiner",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Routing.Rectilinear.Nudging.PathRefiner.DigitsToRound = Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_DistanceEpsilonPrecision();
        },
        RefinePaths: function (paths, mergePaths){
            Microsoft.Msagl.Routing.Rectilinear.Nudging.PathRefiner.AdjustPaths(paths);
            var pathsToFirstLinkedVertices = Microsoft.Msagl.Routing.Rectilinear.Nudging.PathRefiner.CreatePathsToFirstLinkedVerticesMap(paths);
            Microsoft.Msagl.Routing.Rectilinear.Nudging.PathRefiner.Refine(pathsToFirstLinkedVertices.get_Values());
            Microsoft.Msagl.Routing.Rectilinear.Nudging.PathRefiner.CrossVerticalAndHorizontalSegs(pathsToFirstLinkedVertices.get_Values());
            Microsoft.Msagl.Routing.Rectilinear.Nudging.PathRefiner.ReconstructPathsFromLinkedVertices(pathsToFirstLinkedVertices);
            if (mergePaths)
                new Microsoft.Msagl.Routing.Rectilinear.Nudging.PathMerger.ctor(paths).MergePaths();
        },
        AdjustPaths: function (paths){
            var $it1063 = paths.GetEnumerator();
            while ($it1063.MoveNext()){
                var path = $it1063.get_Current();
                path.set_PathPoints(System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Routing.Rectilinear.Nudging.PathRefiner.AdjustPathPoints(System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, path.get_PathPoints(), function (p){
                    return p.Clone();
                })))));
            }
        },
        AdjustPathPoints: function (points){
            var $yield = [];
            var p = Microsoft.Msagl.Routing.Rectilinear.Nudging.PathRefiner.AdjustPoint(points.get_Item$$Int32(0));
            $yield.push(p);
            for (var i = 1; i < System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Point.ctor, points); i++){
                var np = Microsoft.Msagl.Routing.Rectilinear.Nudging.PathRefiner.AdjustPoint(points.get_Item$$Int32(i));
                if (Microsoft.Msagl.Core.Geometry.Point.op_Inequality(p, np)){
                    p = np;
                    $yield.push(p);
                }
            }
            return $yield;
        },
        AdjustPoint: function (p0){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(System.Math.Round$$Double$$Int32(p0.get_X(), Microsoft.Msagl.Routing.Rectilinear.Nudging.PathRefiner.DigitsToRound), System.Math.Round$$Double$$Int32(p0.get_Y(), Microsoft.Msagl.Routing.Rectilinear.Nudging.PathRefiner.DigitsToRound));
        },
        CrossVerticalAndHorizontalSegs: function (pathsFirstLinked){
            var horizontalPoints = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint.ctor);
            var verticalPoints = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint.ctor);
            var $it1064 = pathsFirstLinked.GetEnumerator();
            while ($it1064.MoveNext()){
                var pnt = $it1064.get_Current();
                for (var p = pnt; p.get_Next() != null; p = p.get_Next())
                    if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(p.get_Point().get_X(), p.get_Next().get_Point().get_X()))
                        verticalPoints.Add(p);
                    else
                        horizontalPoints.Add(p);
            }
            (new Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPointSplitter.ctor(horizontalPoints, verticalPoints)).SplitPoints();
        },
        ReconstructPathsFromLinkedVertices: function (pathsToPathLinkedPoints){
            var $it1065 = pathsToPathLinkedPoints.GetEnumerator();
            while ($it1065.MoveNext()){
                var pair = $it1065.get_Current();
                pair.get_Key().set_PathPoints(pair.get_Value());
            }
        },
        Refine: function (pathFirstPoints){
            Microsoft.Msagl.Routing.Rectilinear.Nudging.PathRefiner.RefineInDirection(Microsoft.Msagl.Core.Geometry.Directions.North, pathFirstPoints);
            Microsoft.Msagl.Routing.Rectilinear.Nudging.PathRefiner.RefineInDirection(Microsoft.Msagl.Core.Geometry.Directions.East, pathFirstPoints);
        },
        RefineInDirection: function (direction, pathFirstPoints){
            var projectionToDirection,projectionToPerp;
            (function (){
                var $1 = {
                    Value: projectionToPerp
                };
                var $2 = {
                    Value: projectionToDirection
                };
                var $res = Microsoft.Msagl.Routing.Rectilinear.Nudging.PathRefiner.GetProjectionsDelegates(direction, $1, $2);
                projectionToPerp = $1.Value;
                projectionToDirection = $2.Value;
                return $res;
            })();
            var linkedPointsInDirection = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint.ctor, Microsoft.Msagl.Routing.Rectilinear.Nudging.PathRefiner.GetAllLinkedVertsInDirection(projectionToPerp, pathFirstPoints));
            var colliniarBuckets = System.Linq.Enumerable.GroupBy$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint.ctor, System.Double.ctor, linkedPointsInDirection, function (p){
                return projectionToPerp(p.get_Point());
            });
            var $it1066 = colliniarBuckets.GetEnumerator();
            while ($it1066.MoveNext()){
                var pathLinkedPointBucket = $it1066.get_Current();
                Microsoft.Msagl.Routing.Rectilinear.Nudging.PathRefiner.RefineCollinearBucket(pathLinkedPointBucket, projectionToDirection);
            }
        },
        GetProjectionsDelegates: function (direction, projectionToPerp, projectionToDirection){
            if (direction == Microsoft.Msagl.Core.Geometry.Directions.East){
                projectionToDirection.Value = function (p){
                    return p.get_X();
                };
                projectionToPerp.Value = function (p){
                    return p.get_Y();
                };
            }
            else {
                projectionToPerp.Value = function (p){
                    return p.get_X();
                };
                projectionToDirection.Value = function (p){
                    return p.get_Y();
                };
            }
        },
        GetAllLinkedVertsInDirection: function (projectionToPerp, initialVerts){
            var $yield = [];
            var $it1067 = initialVerts.GetEnumerator();
            while ($it1067.MoveNext()){
                var vert = $it1067.get_Current();
                for (var v = vert; v.get_Next() != null; v = v.get_Next())
                    if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(projectionToPerp(v.get_Point()), projectionToPerp(v.get_Next().get_Point())))
                        $yield.push(v);
            }
            return $yield;
        },
        RefineCollinearBucket: function (pathLinkedVertices, projectionToDirection){
            var dict = new System.Collections.Generic.SortedDictionary$2.ctor$$IComparer$1(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Int32.ctor, new Microsoft.Msagl.Routing.Rectilinear.Nudging.PointByDelegateComparer.ctor(projectionToDirection));
            var $it1068 = pathLinkedVertices.GetEnumerator();
            while ($it1068.MoveNext()){
                var pathLinkedPoint = $it1068.get_Current();
                if (!dict.ContainsKey(pathLinkedPoint.get_Point()))
                    dict.set_Item$$TKey(pathLinkedPoint.get_Point(), 0);
                if (!dict.ContainsKey(pathLinkedPoint.get_Next().get_Point()))
                    dict.set_Item$$TKey(pathLinkedPoint.get_Next().get_Point(), 0);
            }
            var arrayOfPoints = new Array(dict.get_Count());
            var i = 0;
            var $it1069 = dict.get_Keys().GetEnumerator();
            while ($it1069.MoveNext()){
                var point = $it1069.get_Current();
                arrayOfPoints[i++] = point;
            }
            for (i = 0; i < arrayOfPoints.length; i++)
                dict.set_Item$$TKey(arrayOfPoints[i], i);
            var $it1070 = pathLinkedVertices.GetEnumerator();
            while ($it1070.MoveNext()){
                var pathLinkedVertex = $it1070.get_Current();
                i = dict.get_Item$$TKey(pathLinkedVertex.get_Point());
                var j = dict.get_Item$$TKey(pathLinkedVertex.get_Next().get_Point());
                if (System.Math.Abs$$Int32(j - i) > 1)
                    Microsoft.Msagl.Routing.Rectilinear.Nudging.PathRefiner.InsertPoints(pathLinkedVertex, arrayOfPoints, i, j);
            }
        },
        InsertPoints: function (pathLinkedVertex, arrayOfPoints, i, j){
            if (i < j)
                pathLinkedVertex.InsertVerts(i, j, arrayOfPoints);
            else
                pathLinkedVertex.InsertVertsInReverse(j, i, arrayOfPoints);
        },
        CreatePathsToFirstLinkedVerticesMap: function (edgePaths){
            var dict = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.ctor, Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint.ctor);
            var $it1071 = edgePaths.GetEnumerator();
            while ($it1071.MoveNext()){
                var path = $it1071.get_Current();
                dict.set_Item$$TKey(path, Microsoft.Msagl.Routing.Rectilinear.Nudging.PathRefiner.CreateLinkedVertexOfEdgePath(path));
            }
            return dict;
        },
        CreateLinkedVertexOfEdgePath: function (path){
            var pathPoint = new Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint.ctor(System.Linq.Enumerable.First$1$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Point.ctor, path.get_PathPoints()));
            var first = pathPoint;
            System.Linq.Enumerable.Aggregate$2$$IEnumerable$1$$TAccumulate$$Func$3(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint.ctor, System.Linq.Enumerable.Skip$1(Microsoft.Msagl.Core.Geometry.Point.ctor, path.get_PathPoints(), 1), pathPoint, function (lp, p){
                lp.set_Next(new Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint.ctor(p));
                return lp.get_Next();
            });
            return first;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$Nudging$PathRefiner);
var Microsoft$Msagl$Routing$Rectilinear$Nudging$PointByDelegateComparer = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.Nudging.PointByDelegateComparer",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IComparer$1"],
    Kind: "Class",
    definition: {
        ctor: function (projection){
            this.projection = null;
            System.Object.ctor.call(this);
            this.projection = projection;
        },
        Compare: function (x, y){
            return this.projection(x).CompareTo$$Double(this.projection(y));
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$Nudging$PointByDelegateComparer);
var Microsoft$Msagl$Core$ProjectionSolver$UniformSolverVar = {
    fullname: "Microsoft.Msagl.Core.ProjectionSolver.UniformSolverVar",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.lowBound = -Infinity;
            this.upperBound = Infinity;
            this.IsFixed = false;
            this.position = 0;
            this._Width = 0;
            System.Object.ctor.call(this);
        },
        Width$$: "System.Double",
        get_Width: function (){
            return this._Width;
        },
        set_Width: function (value){
            this._Width = value;
        },
        Position$$: "System.Double",
        get_Position: function (){
            return this.position;
        },
        set_Position: function (value){
            if (value < this.lowBound)
                this.position = this.lowBound;
            else if (value > this.upperBound)
                this.position = this.upperBound;
            else
                this.position = value;
        },
        LowBound$$: "System.Double",
        get_LowBound: function (){
            return this.lowBound;
        },
        set_LowBound: function (value){
            System.Diagnostics.Debug.Assert$$Boolean(value <= this.upperBound);
            this.lowBound = value;
        },
        UpperBound$$: "System.Double",
        get_UpperBound: function (){
            return this.upperBound;
        },
        set_UpperBound: function (value){
            System.Diagnostics.Debug.Assert$$Boolean(value >= this.get_LowBound());
            this.upperBound = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$ProjectionSolver$UniformSolverVar);
var Microsoft$Msagl$Routing$Rectilinear$Nudging$SpaceCalculationEvent = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.Nudging.SpaceCalculationEvent",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$Nudging$SpaceCalculationEvent);
var Microsoft$Msagl$Routing$Rectilinear$Nudging$PathEdge = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge",
    baseTypeName: "System.Object",
    staticDefinition: {
        VectorsAreParallel: function (a, b){
            return Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(a.get_X() * b.get_Y() - a.get_Y() * b.get_X(), 0);
        },
        EdgesAreParallel: function (edge, pathEdge){
            return Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge.VectorsAreParallel(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(edge.get_AxisEdge().get_TargetPoint(), edge.get_AxisEdge().get_SourcePoint()), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(pathEdge.get_AxisEdge().get_TargetPoint(), pathEdge.get_AxisEdge().get_SourcePoint()));
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (edgeForNudging, width){
            this.longestNudgedSegment = null;
            this.index = -1;
            this._AxisEdge = null;
            this._Next = null;
            this._Prev = null;
            this._Width = 0;
            this._Path = null;
            this._IsFixed = false;
            this._Reversed = false;
            System.Object.ctor.call(this);
            this.set_AxisEdge(edgeForNudging);
            this.set_Width(width);
        },
        AxisEdge$$: "Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdge",
        get_AxisEdge: function (){
            return this._AxisEdge;
        },
        set_AxisEdge: function (value){
            this._AxisEdge = value;
        },
        Next$$: "Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge",
        get_Next: function (){
            return this._Next;
        },
        set_Next: function (value){
            this._Next = value;
        },
        Prev$$: "Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge",
        get_Prev: function (){
            return this._Prev;
        },
        set_Prev: function (value){
            this._Prev = value;
        },
        Width$$: "System.Double",
        get_Width: function (){
            return this._Width;
        },
        set_Width: function (value){
            this._Width = value;
        },
        Path$$: "Microsoft.Msagl.Routing.Rectilinear.Nudging.Path",
        get_Path: function (){
            return this._Path;
        },
        set_Path: function (value){
            this._Path = value;
        },
        LongestNudgedSegment$$: "Microsoft.Msagl.Routing.Rectilinear.Nudging.LongestNudgedSegment",
        get_LongestNudgedSegment: function (){
            return this.longestNudgedSegment;
        },
        set_LongestNudgedSegment: function (value){
            this.longestNudgedSegment = value;
            if (this.longestNudgedSegment != null){
                this.longestNudgedSegment.AddEdge(this);
                this.get_AxisEdge().AddLongestNudgedSegment(this.longestNudgedSegment);
            }
        },
        IsFixed$$: "System.Boolean",
        get_IsFixed: function (){
            return this._IsFixed;
        },
        set_IsFixed: function (value){
            this._IsFixed = value;
        },
        Source$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Source: function (){
            return !this.get_Reversed() ? this.get_AxisEdge().get_SourcePoint() : this.get_AxisEdge().get_TargetPoint();
        },
        Target$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Target: function (){
            return this.get_Reversed() ? this.get_AxisEdge().get_SourcePoint() : this.get_AxisEdge().get_TargetPoint();
        },
        Direction$$: "Microsoft.Msagl.Core.Geometry.Directions",
        get_Direction: function (){
            return this.get_Reversed() ? Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(this.get_AxisEdge().get_Direction()) : this.get_AxisEdge().get_Direction();
        },
        Reversed$$: "System.Boolean",
        get_Reversed: function (){
            return this._Reversed;
        },
        set_Reversed: function (value){
            this._Reversed = value;
        },
        Index$$: "System.Int32",
        get_Index: function (){
            return this.index;
        },
        set_Index: function (value){
            this.index = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$Nudging$PathEdge);
var Microsoft$Msagl$Routing$Rectilinear$Nudging$LongestNudgedSegment = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.Nudging.LongestNudgedSegment",
    baseTypeName: "Microsoft.Msagl.Routing.Visibility.SegmentBase",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (variable){
            this.edges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge.ctor);
            this.start = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.end = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.isFixed = false;
            this.Id = -1;
            this._CompassDirection = Microsoft.Msagl.Core.Geometry.Directions.None;
            this._DirectionPerp = new Microsoft.Msagl.Core.Geometry.CompassVector.ctor();
            this._IdealPosition = 0;
            Microsoft.Msagl.Routing.Visibility.SegmentBase.ctor.call(this);
            this.Id = variable;
        },
        CompassDirection$$: "Microsoft.Msagl.Core.Geometry.Directions",
        get_CompassDirection: function (){
            return this._CompassDirection;
        },
        set_CompassDirection: function (value){
            this._CompassDirection = value;
        },
        Start$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Start: function (){
            return this.start;
        },
        End$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_End: function (){
            return this.end;
        },
        Edges$$: "System.Collections.Generic.List`1[[Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge]]",
        get_Edges: function (){
            return this.edges;
        },
        AddEdge: function (edge){
            if (this.get_Edges().get_Count() == 0){
                var dir = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(edge.get_Target(), edge.get_Source())).get_CompassDirection();
                switch (dir){
                    case Microsoft.Msagl.Core.Geometry.Directions.South:
                        dir = Microsoft.Msagl.Core.Geometry.Directions.North;
                        break;
                    case Microsoft.Msagl.Core.Geometry.Directions.West:
                        dir = Microsoft.Msagl.Core.Geometry.Directions.East;
                        break;
                }
                this.set_CompassDirection(dir);
                this.start = edge.get_Source();
                this.end = edge.get_Source();
            }
            switch (this.get_CompassDirection()){
                case Microsoft.Msagl.Core.Geometry.Directions.North:
                    this.TryPointForStartAndEndNorth(edge.get_Source());
                    this.TryPointForStartAndEndNorth(edge.get_Target());
                    break;
                case Microsoft.Msagl.Core.Geometry.Directions.East:
                    this.TryPointForStartAndEndEast(edge.get_Source());
                    this.TryPointForStartAndEndEast(edge.get_Target());
                    break;
            }
            this.get_Edges().Add(edge);
        },
        TryPointForStartAndEndNorth: function (p){
            if (p.get_Y() < this.start.get_Y())
                this.start = p;
            else if (p.get_Y() > this.end.get_Y())
                this.end = p;
        },
        TryPointForStartAndEndEast: function (p){
            if (p.get_X() < this.start.get_X())
                this.start = p;
            else if (p.get_X() > this.end.get_X())
                this.end = p;
        },
        DirectionPerp$$: "Microsoft.Msagl.Core.Geometry.CompassVector",
        get_DirectionPerp: function (){
            return this._DirectionPerp;
        },
        set_DirectionPerp: function (value){
            this._DirectionPerp = value;
        },
        IsFixed$$: "System.Boolean",
        get_IsFixed: function (){
            return this.isFixed;
        },
        set_IsFixed: function (value){
            this.isFixed = value;
        },
        Width$$: "System.Double",
        get_Width: function (){
            return System.Linq.Enumerable.Max$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge.ctor, this.edges, $CreateAnonymousDelegate(this, function (edge){
                return edge.get_Width();
            }));
        },
        GetLeftBound: function (){
            if (!this.get_IsFixed())
                return System.Linq.Enumerable.Max$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge.ctor, this.get_Edges(), $CreateAnonymousDelegate(this, function (edge){
                    return edge.get_AxisEdge().get_LeftBound();
                }));
            return this.get_CompassDirection() == Microsoft.Msagl.Core.Geometry.Directions.North ? this.get_Edges().get_Item$$Int32(0).get_Source().get_X() : -this.get_Edges().get_Item$$Int32(0).get_Source().get_Y();
        },
        GetRightBound: function (){
            if (!this.get_IsFixed())
                return System.Linq.Enumerable.Min$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge.ctor, this.get_Edges(), $CreateAnonymousDelegate(this, function (edge){
                    return edge.get_AxisEdge().get_RightBound();
                }));
            return this.Position();
        },
        Position: function (){
            return this.get_CompassDirection() == Microsoft.Msagl.Core.Geometry.Directions.North ? this.get_Edges().get_Item$$Int32(0).get_Source().get_X() : -this.get_Edges().get_Item$$Int32(0).get_Source().get_Y();
        },
        IdealPosition$$: "System.Double",
        get_IdealPosition: function (){
            return this._IdealPosition;
        },
        set_IdealPosition: function (value){
            this._IdealPosition = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$Nudging$LongestNudgedSegment);
var Microsoft$Msagl$Routing$Rectilinear$Nudging$Path = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.Nudging.Path",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (edgeGeometry){
            this._EdgeGeometry = null;
            this._PathPoints = null;
            this._FirstEdge = null;
            this._LastEdge = null;
            System.Object.ctor.call(this);
            this.set_EdgeGeometry(edgeGeometry);
        },
        EdgeGeometry$$: "Microsoft.Msagl.Core.Layout.EdgeGeometry",
        get_EdgeGeometry: function (){
            return this._EdgeGeometry;
        },
        set_EdgeGeometry: function (value){
            this._EdgeGeometry = value;
        },
        PathPoints$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Geometry.Point]]",
        get_PathPoints: function (){
            return this._PathPoints;
        },
        set_PathPoints: function (value){
            this._PathPoints = value;
        },
        Width$$: "System.Double",
        get_Width: function (){
            return this.get_EdgeGeometry().get_LineWidth();
        },
        End$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_End: function (){
            return this.get_LastEdge().get_Target();
        },
        Start$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Start: function (){
            return this.get_FirstEdge().get_Source();
        },
        PathEdges$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge]]",
        get_PathEdges: function (){
            var $yield = [];
            for (var e = this.get_FirstEdge(); e != null; e = e.get_Next())
                $yield.push(e);
            return $yield;
        },
        FirstEdge$$: "Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge",
        get_FirstEdge: function (){
            return this._FirstEdge;
        },
        set_FirstEdge: function (value){
            this._FirstEdge = value;
        },
        LastEdge$$: "Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge",
        get_LastEdge: function (){
            return this._LastEdge;
        },
        set_LastEdge: function (value){
            this._LastEdge = value;
        },
        SetIsFixedByFollowingParallelEdges: function (){
        },
        AddEdge: function (edge){
            edge.set_Path(this);
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.Point.op_Equality(edge.get_Source(), this.get_LastEdge().get_Target()));
            this.get_LastEdge().set_Next(edge);
            edge.set_Prev(this.get_LastEdge());
            this.set_LastEdge(edge);
        },
        SetFirstEdge: function (edge){
            this.set_LastEdge((function ($p47){
                this.set_FirstEdge($p47);
                return $p47;
            }).call(this, edge));
            edge.set_Path(this);
        },
        toString: function (){
            return System.String.Format$$IFormatProvider$$String$$Object$Array(System.Globalization.CultureInfo.get_InvariantCulture(), "{0}->{1}", [this.get_EdgeGeometry().get_SourcePort().get_Location(), this.get_EdgeGeometry().get_TargetPort().get_Location()]);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$Nudging$Path);
var Microsoft$Msagl$Core$Geometry$RectangleNode$1 = {
    fullname: "Microsoft.Msagl.Core.Geometry.RectangleNode$1",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (TData){
            Microsoft.Msagl.Core.Geometry.RectangleNode$1.GroupSplitThreshold = 2;
        },
        VisitTreeStatic: function (rectangleNode, hitTest, hitRectangle){
            if (rectangleNode.get_Rectangle().Intersects(hitRectangle)){
                if (hitTest(rectangleNode.get_UserData()) == Microsoft.Msagl.Core.Geometry.HitTestBehavior.Continue){
                    if (rectangleNode.get_Left() != null){
                        if (Microsoft.Msagl.Core.Geometry.RectangleNode$1.VisitTreeStatic(rectangleNode.get_Left(), hitTest, hitRectangle) == Microsoft.Msagl.Core.Geometry.HitTestBehavior.Continue && Microsoft.Msagl.Core.Geometry.RectangleNode$1.VisitTreeStatic(rectangleNode.get_Right(), hitTest, hitRectangle) == Microsoft.Msagl.Core.Geometry.HitTestBehavior.Continue){
                            return Microsoft.Msagl.Core.Geometry.HitTestBehavior.Continue;
                        }
                        return Microsoft.Msagl.Core.Geometry.HitTestBehavior.Stop;
                    }
                    return Microsoft.Msagl.Core.Geometry.HitTestBehavior.Continue;
                }
                return Microsoft.Msagl.Core.Geometry.HitTestBehavior.Stop;
            }
            return Microsoft.Msagl.Core.Geometry.HitTestBehavior.Continue;
        },
        CreateRectangleNodeOnEnumeration: function (nodes){
            if (nodes == null)
                return null;
            var nodeList = new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, nodes);
            return Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnListOfNodes(nodeList);
        },
        CreateRectangleNodeOnData: function (dataEnumeration, rectangleDelegate){
            if (dataEnumeration == null || rectangleDelegate == null)
                return null;
            var nodeList = new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(this.TData, Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, dataEnumeration, function (d){
                return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(this.TData, d, rectangleDelegate(d));
            }));
            return Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnListOfNodes(nodeList);
        },
        CreateRectangleNodeOnListOfNodes: function (nodes){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(nodes, "nodes");
            if (nodes.get_Count() == 0)
                return null;
            if (nodes.get_Count() == 1)
                return nodes.get_Item$$Int32(0);
            var b0 = nodes.get_Item$$Int32(0).get_Rectangle();
            var seed0 = 1;
            var seed1 = (function (){
                var $1 = {
                    Value: b0
                };
                var $2 = {
                    Value: seed0
                };
                var $res = Microsoft.Msagl.Core.Geometry.RectangleNode$1.ChooseSeeds(nodes, $1, $2);
                b0 = $1.Value;
                seed0 = $2.Value;
                return $res;
            })();
            var gr0 = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor);
            var gr1 = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor);
            gr0.Add(nodes.get_Item$$Int32(seed0));
            gr1.Add(nodes.get_Item$$Int32(seed1));
            var box0 = nodes.get_Item$$Int32(seed0).get_Rectangle();
            var box1 = nodes.get_Item$$Int32(seed1).get_Rectangle();
            (function (){
                var $1 = {
                    Value: box0
                };
                var $2 = {
                    Value: box1
                };
                var $res = Microsoft.Msagl.Core.Geometry.RectangleNode$1.DivideNodes(nodes, seed0, seed1, gr0, gr1, $1, $2, 2);
                box0 = $1.Value;
                box1 = $2.Value;
                return $res;
            })();
            var ret = (function (){
                var $v119 = new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$Int32(this.TData, nodes.get_Count());
                $v119.set_Rectangle(new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Rectangle$$Rectangle(box0, box1));
                $v119.set_Left(Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnListOfNodes(gr0));
                $v119.set_Right(Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnListOfNodes(gr1));
                return $v119;
            })();
            return ret;
        },
        ChooseSeeds: function (nodes, b0, seed0){
            var area = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Rectangle$$Rectangle(b0.Value, nodes.get_Item$$Int32(seed0.Value).get_Rectangle()).get_Area();
            for (var i = 2; i < nodes.get_Count(); i++){
                var area0 = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Rectangle$$Rectangle(b0.Value, nodes.get_Item$$Int32(i).get_Rectangle()).get_Area();
                if (area0 > area){
                    seed0.Value = i;
                    area = area0;
                }
            }
            var seed1 = 0;
            for (var i = 0; i < nodes.get_Count(); i++){
                if (i != seed0.Value){
                    seed1 = i;
                    break;
                }
            }
            area = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Rectangle$$Rectangle(nodes.get_Item$$Int32(seed0.Value).get_Rectangle(), nodes.get_Item$$Int32(seed1).get_Rectangle()).get_Area();
            for (var i = 0; i < nodes.get_Count(); i++){
                if (i == seed0.Value)
                    continue;
                var area1 = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Rectangle$$Rectangle(nodes.get_Item$$Int32(seed0.Value).get_Rectangle(), nodes.get_Item$$Int32(i).get_Rectangle()).get_Area();
                if (area1 > area){
                    seed1 = i;
                    area = area1;
                }
            }
            return seed1;
        },
        DivideNodes: function (nodes, seed0, seed1, gr0, gr1, box0, box1, groupSplitThreshold){
            for (var i = 0; i < nodes.get_Count(); i++){
                if (i == seed0 || i == seed1)
                    continue;
                var box0_ = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Rectangle$$Rectangle(box0.Value, nodes.get_Item$$Int32(i).get_Rectangle());
                var delta0 = box0_.get_Area() - box0.Value.get_Area();
                var box1_ = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Rectangle$$Rectangle(box1.Value, nodes.get_Item$$Int32(i).get_Rectangle());
                var delta1 = box1_.get_Area() - box1.Value.get_Area();
                if (gr0.get_Count() * groupSplitThreshold < gr1.get_Count()){
                    gr0.Add(nodes.get_Item$$Int32(i));
                    box0.Value = box0_;
                }
                else if (gr1.get_Count() * groupSplitThreshold < gr0.get_Count()){
                    gr1.Add(nodes.get_Item$$Int32(i));
                    box1.Value = box1_;
                }
                else if (delta0 < delta1){
                    gr0.Add(nodes.get_Item$$Int32(i));
                    box0.Value = box0_;
                }
                else if (delta1 < delta0){
                    gr1.Add(nodes.get_Item$$Int32(i));
                    box1.Value = box1_;
                }
                else if (box0.Value.get_Area() < box1.Value.get_Area()){
                    gr0.Add(nodes.get_Item$$Int32(i));
                    box0.Value = box0_;
                }
                else {
                    gr1.Add(nodes.get_Item$$Int32(i));
                    box1.Value = box1_;
                }
            }
        },
        TraverseHierarchy: function (node, visitor){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(node, "node");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(visitor, "visitor");
            visitor(node);
            if (node.get_Left() != null)
                Microsoft.Msagl.Core.Geometry.RectangleNode$1.TraverseHierarchy(node.get_Left(), visitor);
            if (node.get_Right() != null)
                Microsoft.Msagl.Core.Geometry.RectangleNode$1.TraverseHierarchy(node.get_Right(), visitor);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (TData){
            this.TData = TData;
            this.left = null;
            this.right = null;
            this.rectangle = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
            this._Count = 0;
            this._UserData = null;
            this._Parent = null;
            System.Object.ctor.call(this);
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this._Count;
        },
        set_Count: function (value){
            this._Count = value;
        },
        ctor$$TData$$Rectangle: function (TData, data, rect){
            this.TData = TData;
            this.left = null;
            this.right = null;
            this.rectangle = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
            this._Count = 0;
            this._UserData = null;
            this._Parent = null;
            System.Object.ctor.call(this);
            this.set_UserData(data);
            this.set_Rectangle(rect);
            this.set_Count(1);
        },
        ctor$$Int32: function (TData, count){
            this.TData = TData;
            this.left = null;
            this.right = null;
            this.rectangle = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
            this._Count = 0;
            this._UserData = null;
            this._Parent = null;
            System.Object.ctor.call(this);
            this.set_Count(count);
        },
        Rectangle$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_Rectangle: function (){
            return this.rectangle;
        },
        set_Rectangle: function (value){
            this.rectangle = value;
        },
        IsLeaf$$: "System.Boolean",
        get_IsLeaf: function (){
            return this.left == null;
        },
        Left$$: "Microsoft.Msagl.Core.Geometry.RectangleNode`1[[`0]]",
        get_Left: function (){
            return this.left;
        },
        set_Left: function (value){
            if (this.left != null && this.left.get_Parent() == this)
                this.left.set_Parent(null);
            this.left = value;
            if (this.left != null)
                this.left.set_Parent(this);
        },
        Right$$: "Microsoft.Msagl.Core.Geometry.RectangleNode`1[[`0]]",
        get_Right: function (){
            return this.right;
        },
        set_Right: function (value){
            if (this.right != null && this.right.get_Parent() == this)
                this.right.set_Parent(null);
            this.right = value;
            if (this.right != null)
                this.right.set_Parent(this);
        },
        UserData$$: "`0",
        get_UserData: function (){
            return this._UserData;
        },
        set_UserData: function (value){
            this._UserData = value;
        },
        Parent$$: "Microsoft.Msagl.Core.Geometry.RectangleNode`1[[`0]]",
        get_Parent: function (){
            return this._Parent;
        },
        set_Parent: function (value){
            this._Parent = value;
        },
        IsLeftChild$$: "System.Boolean",
        get_IsLeftChild: function (){
            System.Diagnostics.Debug.Assert$$Boolean(this.get_Parent() != null);
            return this.Equals$$Object(this.get_Parent().get_Left());
        },
        FirstHitNode$$Point$$Func$3: function (point, hitTestForPointDelegate){
            if (this.rectangle.Contains$$Point(point)){
                if (this.get_IsLeaf()){
                    if (hitTestForPointDelegate != null){
                        return hitTestForPointDelegate(point, this.get_UserData()) == Microsoft.Msagl.Core.Geometry.HitTestBehavior.Stop ? this : null;
                    }
                    return this;
                }
                return (this.get_Left().FirstHitNode$$Point$$Func$3(point, hitTestForPointDelegate) != null ? this.get_Left().FirstHitNode$$Point$$Func$3(point, hitTestForPointDelegate) : this.get_Right().FirstHitNode$$Point$$Func$3(point, hitTestForPointDelegate));
            }
            return null;
        },
        FirstIntersectedNode: function (r){
            if (r.Intersects(this.rectangle)){
                if (this.get_IsLeaf())
                    return this;
                return (this.get_Left().FirstIntersectedNode(r) != null ? this.get_Left().FirstIntersectedNode(r) : this.get_Right().FirstIntersectedNode(r));
            }
            return null;
        },
        FirstHitNode$$Point: function (point){
            if (this.rectangle.Contains$$Point(point)){
                if (this.get_IsLeaf())
                    return this;
                return (this.get_Left().FirstHitNode$$Point(point) != null ? this.get_Left().FirstHitNode$$Point(point) : this.get_Right().FirstHitNode$$Point(point));
            }
            return null;
        },
        AllHitItems$$Rectangle$$Func$2: function (rectanglePar, hitTestAccept){
            var $yield = [];
            var stack = new System.Collections.Generic.Stack$1.ctor(Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor);
            stack.Push(this);
            while (stack.get_Count() > 0){
                var node = stack.Pop();
                if (node.get_Rectangle().Intersects(rectanglePar)){
                    if (node.get_IsLeaf()){
                        if ((null == hitTestAccept) || hitTestAccept(node.get_UserData())){
                            $yield.push(node.get_UserData());
                        }
                    }
                    else {
                        stack.Push(node.left);
                        stack.Push(node.right);
                    }
                }
            }
            return $yield;
        },
        AllHitItems$$Point: function (point){
            var $yield = [];
            var stack = new System.Collections.Generic.Stack$1.ctor(Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor);
            stack.Push(this);
            while (stack.get_Count() > 0){
                var node = stack.Pop();
                if (node.get_Rectangle().Contains$$Point(point)){
                    if (node.get_IsLeaf())
                        $yield.push(node.get_UserData());
                    else {
                        stack.Push(node.left);
                        stack.Push(node.right);
                    }
                }
            }
            return $yield;
        },
        VisitTree: function (hitTest, hitRectangle){
            Microsoft.Msagl.Core.Geometry.RectangleNode$1.VisitTreeStatic(this, hitTest, hitRectangle);
        },
        Clone: function (){
            var ret = (function (){
                var $v118 = new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$Int32(this.TData, this.get_Count());
                $v118.set_UserData(this.get_UserData());
                $v118.set_Rectangle(this.get_Rectangle());
                return $v118;
            }).call(this);
            if (this.get_Left() != null)
                ret.set_Left(this.get_Left().Clone());
            if (this.get_Right() != null)
                ret.set_Right(this.get_Right().Clone());
            return ret;
        },
        GetNodeItemsIntersectingRectangle: function (rectanglePar){
            return System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, this.TData, this.GetLeafRectangleNodesIntersectingRectangle(rectanglePar), $CreateAnonymousDelegate(this, function (node){
                return node.get_UserData();
            }));
        },
        GetLeafRectangleNodesIntersectingRectangle: function (rectanglePar){
            var $yield = [];
            var stack = new System.Collections.Generic.Stack$1.ctor(Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor);
            stack.Push(this);
            while (stack.get_Count() > 0){
                var node = stack.Pop();
                if (node.get_Rectangle().Intersects(rectanglePar)){
                    if (node.get_IsLeaf()){
                        $yield.push(node);
                    }
                    else {
                        stack.Push(node.left);
                        stack.Push(node.right);
                    }
                }
            }
            return $yield;
        },
        GetAllLeaves: function (){
            return System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, this.TData, this.GetAllLeafNodes(), $CreateAnonymousDelegate(this, function (n){
                return n.get_UserData();
            }));
        },
        GetAllLeafNodes: function (){
            return this.EnumRectangleNodes(true);
        },
        GetAllNodes: function (){
            return this.EnumRectangleNodes(false);
        },
        EnumRectangleNodes: function (leafOnly){
            var $yield = [];
            var stack = new System.Collections.Generic.Stack$1.ctor(Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor);
            stack.Push(this);
            while (stack.get_Count() > 0){
                var node = stack.Pop();
                if (node.get_IsLeaf() || !leafOnly){
                    $yield.push(node);
                }
                if (!node.get_IsLeaf()){
                    stack.Push(node.left);
                    stack.Push(node.right);
                }
            }
            return $yield;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$RectangleNode$1);
var Microsoft$Msagl$Routing$Rectilinear$BasicObstacleSide = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.BasicObstacleSide",
    baseTypeName: "Microsoft.Msagl.Routing.Spline.ConeSpanner.ObstacleSide",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (obstacle, startVertex, scanDir, traverseClockwise){
            this.endVertex = null;
            this._Obstacle = null;
            this._Slope = 0;
            this._SlopeInverse = 0;
            Microsoft.Msagl.Routing.Spline.ConeSpanner.ObstacleSide.ctor.call(this, startVertex);
            this.set_Obstacle(obstacle);
            this.endVertex = traverseClockwise ? startVertex.get_NextOnPolyline() : startVertex.get_PrevOnPolyline();
            if (!scanDir.IsPerpendicular$$Point$$Point(startVertex.get_Point(), this.endVertex.get_Point())){
                this.set_Slope(Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.Slope$$Point$$Point$$ScanDirection(startVertex.get_Point(), this.endVertex.get_Point(), scanDir));
                this.set_SlopeInverse(1 / this.get_Slope());
            }
        },
        Obstacle$$: "Microsoft.Msagl.Routing.Rectilinear.Obstacle",
        get_Obstacle: function (){
            return this._Obstacle;
        },
        set_Obstacle: function (value){
            this._Obstacle = value;
        },
        Slope$$: "System.Double",
        get_Slope: function (){
            return this._Slope;
        },
        set_Slope: function (value){
            this._Slope = value;
        },
        SlopeInverse$$: "System.Double",
        get_SlopeInverse: function (){
            return this._SlopeInverse;
        },
        set_SlopeInverse: function (value){
            this._SlopeInverse = value;
        },
        EndVertex$$: "Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint",
        get_EndVertex: function (){
            return this.endVertex;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$BasicObstacleSide);
var Microsoft$Msagl$Routing$Rectilinear$BasicReflectionEvent = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.BasicReflectionEvent",
    baseTypeName: "Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$Obstacle$$Obstacle$$Point: function (initialObstacle, reflectingObstacle, site){
            this.site = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._ReflectingObstacle = null;
            this._InitialObstacle = null;
            this._PreviousSite = null;
            Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent.ctor.call(this);
            this.set_InitialObstacle(initialObstacle);
            this.set_ReflectingObstacle(reflectingObstacle);
            this.site = site;
        },
        ReflectingObstacle$$: "Microsoft.Msagl.Routing.Rectilinear.Obstacle",
        get_ReflectingObstacle: function (){
            return this._ReflectingObstacle;
        },
        set_ReflectingObstacle: function (value){
            this._ReflectingObstacle = value;
        },
        InitialObstacle$$: "Microsoft.Msagl.Routing.Rectilinear.Obstacle",
        get_InitialObstacle: function (){
            return this._InitialObstacle;
        },
        set_InitialObstacle: function (value){
            this._InitialObstacle = value;
        },
        PreviousSite$$: "Microsoft.Msagl.Routing.Rectilinear.BasicReflectionEvent",
        get_PreviousSite: function (){
            return this._PreviousSite;
        },
        set_PreviousSite: function (value){
            this._PreviousSite = value;
        },
        ctor$$BasicReflectionEvent$$Obstacle$$Point: function (previousSite, reflectingObstacle, site){
            this.site = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._ReflectingObstacle = null;
            this._InitialObstacle = null;
            this._PreviousSite = null;
            Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent.ctor.call(this);
            this.set_InitialObstacle(previousSite.get_ReflectingObstacle());
            this.set_ReflectingObstacle(reflectingObstacle);
            this.site = site;
            this.set_PreviousSite(previousSite);
        },
        IsStaircaseStep: function (reflectionTarget){
            return (this.get_InitialObstacle() == reflectionTarget);
        },
        Site$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Site: function (){
            return this.site;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$BasicReflectionEvent);
var Microsoft$Msagl$Routing$Rectilinear$BasicVertexEvent = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.BasicVertexEvent",
    baseTypeName: "Microsoft.Msagl.Routing.Spline.ConeSpanner.VertexEvent",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (obstacle, p){
            this._Obstacle = null;
            Microsoft.Msagl.Routing.Spline.ConeSpanner.VertexEvent.ctor.call(this, p);
            this.set_Obstacle(obstacle);
        },
        Obstacle$$: "Microsoft.Msagl.Routing.Rectilinear.Obstacle",
        get_Obstacle: function (){
            return this._Obstacle;
        },
        set_Obstacle: function (value){
            this._Obstacle = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$BasicVertexEvent);
var Microsoft$Msagl$Routing$Rectilinear$OpenVertexEvent = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.OpenVertexEvent",
    baseTypeName: "Microsoft.Msagl.Routing.Rectilinear.BasicVertexEvent",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (obstacle, p){
            Microsoft.Msagl.Routing.Rectilinear.BasicVertexEvent.ctor.call(this, obstacle, p);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$OpenVertexEvent);
var Microsoft$Msagl$Core$Geometry$Directions = {
    fullname: "Microsoft.Msagl.Core.Geometry.Directions",
    staticDefinition: {
        None: 0,
        North: 1,
        East: 2,
        South: 4,
        West: 8
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Directions);
var Microsoft$Msagl$Core$Geometry$CompassVector = {
    fullname: "Microsoft.Msagl.Core.Geometry.CompassVector",
    baseTypeName: "System.ValueType",
    staticDefinition: {
        op_Equality: function (a, b){
            return a.get_Dir() == b.get_Dir();
        },
        op_Inequality: function (a, b){
            return a.get_Dir() != b.get_Dir();
        },
        RotateRight: function (direction){
            switch (direction){
                case Microsoft.Msagl.Core.Geometry.Directions.North:
                    return Microsoft.Msagl.Core.Geometry.Directions.East;
                case Microsoft.Msagl.Core.Geometry.Directions.East:
                    return Microsoft.Msagl.Core.Geometry.Directions.South;
                case Microsoft.Msagl.Core.Geometry.Directions.South:
                    return Microsoft.Msagl.Core.Geometry.Directions.West;
                case Microsoft.Msagl.Core.Geometry.Directions.West:
                    return Microsoft.Msagl.Core.Geometry.Directions.North;
                default:
                    throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            }
        },
        RotateLeft: function (direction){
            switch (direction){
                case Microsoft.Msagl.Core.Geometry.Directions.North:
                    return Microsoft.Msagl.Core.Geometry.Directions.West;
                case Microsoft.Msagl.Core.Geometry.Directions.West:
                    return Microsoft.Msagl.Core.Geometry.Directions.South;
                case Microsoft.Msagl.Core.Geometry.Directions.South:
                    return Microsoft.Msagl.Core.Geometry.Directions.East;
                case Microsoft.Msagl.Core.Geometry.Directions.East:
                    return Microsoft.Msagl.Core.Geometry.Directions.North;
                default:
                    throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            }
        },
        ToIndex: function (direction){
            switch (direction){
                case Microsoft.Msagl.Core.Geometry.Directions.North:
                    return 0;
                case Microsoft.Msagl.Core.Geometry.Directions.East:
                    return 1;
                case Microsoft.Msagl.Core.Geometry.Directions.South:
                    return 2;
                case Microsoft.Msagl.Core.Geometry.Directions.West:
                    return 3;
                default:
                    throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            }
        },
        VectorDirection$$Point: function (d){
            var r = Microsoft.Msagl.Core.Geometry.Directions.None;
            if (d.get_X() > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                r = Microsoft.Msagl.Core.Geometry.Directions.East;
            else if (d.get_X() < -Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                r = Microsoft.Msagl.Core.Geometry.Directions.West;
            if (d.get_Y() > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                r |= Microsoft.Msagl.Core.Geometry.Directions.North;
            else if (d.get_Y() < -Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                r |= Microsoft.Msagl.Core.Geometry.Directions.South;
            return r;
        },
        VectorDirection$$Point$$Point: function (a, b){
            var r = Microsoft.Msagl.Core.Geometry.Directions.None;
            var horizontalDiff = b.get_X() - a.get_X();
            var verticalDiff = b.get_Y() - a.get_Y();
            var halfEpsilon = Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon / 2;
            if (horizontalDiff > halfEpsilon)
                r = Microsoft.Msagl.Core.Geometry.Directions.East;
            else if (-horizontalDiff > halfEpsilon)
                r = Microsoft.Msagl.Core.Geometry.Directions.West;
            if (verticalDiff > halfEpsilon)
                r |= Microsoft.Msagl.Core.Geometry.Directions.North;
            else if (-verticalDiff > halfEpsilon)
                r |= Microsoft.Msagl.Core.Geometry.Directions.South;
            return r;
        },
        DirectionsFromPointToPoint: function (a, b){
            return Microsoft.Msagl.Core.Geometry.CompassVector.VectorDirection$$Point$$Point(a, b);
        },
        PureDirectionFromPointToPoint: function (a, b){
            var dir = Microsoft.Msagl.Core.Geometry.CompassVector.VectorDirection$$Point$$Point(a, b);
            System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Core.Geometry.CompassVector.IsPureDirection$$Directions(dir), "Impure direction found");
            return dir;
        },
        OppositeDir: function (direction){
            switch (direction){
                case Microsoft.Msagl.Core.Geometry.Directions.North:
                    return Microsoft.Msagl.Core.Geometry.Directions.South;
                case Microsoft.Msagl.Core.Geometry.Directions.West:
                    return Microsoft.Msagl.Core.Geometry.Directions.East;
                case Microsoft.Msagl.Core.Geometry.Directions.South:
                    return Microsoft.Msagl.Core.Geometry.Directions.North;
                case Microsoft.Msagl.Core.Geometry.Directions.East:
                    return Microsoft.Msagl.Core.Geometry.Directions.West;
                default:
                    return Microsoft.Msagl.Core.Geometry.Directions.None;
            }
        },
        IsPureDirection$$Directions: function (direction){
            switch (direction){
                case Microsoft.Msagl.Core.Geometry.Directions.North:
                    return true;
                case Microsoft.Msagl.Core.Geometry.Directions.East:
                    return true;
                case Microsoft.Msagl.Core.Geometry.Directions.South:
                    return true;
                case Microsoft.Msagl.Core.Geometry.Directions.West:
                    return true;
                default:
                    return false;
            }
        },
        IsPureDirection$$Point$$Point: function (a, b){
            return Microsoft.Msagl.Core.Geometry.CompassVector.IsPureDirection$$Directions(Microsoft.Msagl.Core.Geometry.CompassVector.DirectionsFromPointToPoint(a, b));
        },
        DirectionsAreParallel: function (a, b){
            return a == b || a == Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(b);
        },
        ToPoint$$Directions: function (dir){
            return (new Microsoft.Msagl.Core.Geometry.CompassVector.ctor$$Directions(dir)).ToPoint();
        },
        op_UnaryNegation: function (directionVector){
            return new Microsoft.Msagl.Core.Geometry.CompassVector.ctor$$Directions(Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(directionVector.get_Dir()));
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Struct",
    definition: {
        ctor$$Directions: function (direction){
            this._Dir = Microsoft.Msagl.Core.Geometry.Directions.None;
            Microsoft.Msagl.Core.Geometry.CompassVector.ctor.call(this);
            this.set_Dir(direction);
        },
        GetHashCode: function (){
            return this.get_Dir();
        },
        ctor$$Point: function (a){
            this._Dir = Microsoft.Msagl.Core.Geometry.Directions.None;
            Microsoft.Msagl.Core.Geometry.CompassVector.ctor.call(this);
            this.set_Dir(Microsoft.Msagl.Core.Geometry.CompassVector.VectorDirection$$Point(a));
        },
        ctor$$Point$$Point: function (a, b){
            this._Dir = Microsoft.Msagl.Core.Geometry.Directions.None;
            Microsoft.Msagl.Core.Geometry.CompassVector.ctor.call(this);
            this.set_Dir(Microsoft.Msagl.Core.Geometry.CompassVector.VectorDirection$$Point$$Point(a, b));
        },
        Dir$$: "Microsoft.Msagl.Core.Geometry.Directions",
        get_Dir: function (){
            return this._Dir;
        },
        set_Dir: function (value){
            this._Dir = value;
        },
        Left$$: "Microsoft.Msagl.Core.Geometry.CompassVector",
        get_Left: function (){
            return new Microsoft.Msagl.Core.Geometry.CompassVector.ctor$$Directions(Microsoft.Msagl.Core.Geometry.CompassVector.RotateLeft(this.get_Dir()));
        },
        Right$$: "Microsoft.Msagl.Core.Geometry.CompassVector",
        get_Right: function (){
            return new Microsoft.Msagl.Core.Geometry.CompassVector.ctor$$Directions(Microsoft.Msagl.Core.Geometry.CompassVector.RotateRight(this.get_Dir()));
        },
        Opposite$$: "Microsoft.Msagl.Core.Geometry.CompassVector",
        get_Opposite: function (){
            return new Microsoft.Msagl.Core.Geometry.CompassVector.ctor$$Directions(Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(this.get_Dir()));
        },
        Equals$$CompassVector: function (other){
            return System.Object.Equals$$Object$$Object(other.get_Dir(), this.get_Dir());
        },
        Equals$$Object: function (obj){
            if (System.Object.ReferenceEquals(null, obj))
                return false;
            if (obj.GetType() != Typeof(Microsoft.Msagl.Core.Geometry.CompassVector.ctor))
                return false;
            return this.Equals$$CompassVector(Cast(obj, Microsoft.Msagl.Core.Geometry.CompassVector.ctor));
        },
        toString: function (){
            return this.get_Dir().toString();
        },
        ToPoint: function (){
            var p = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            if ((this.get_Dir() & Microsoft.Msagl.Core.Geometry.Directions.East) == Microsoft.Msagl.Core.Geometry.Directions.East)
                p.set_X(p.get_X() + 1);
            if ((this.get_Dir() & Microsoft.Msagl.Core.Geometry.Directions.North) == Microsoft.Msagl.Core.Geometry.Directions.North)
                p.set_Y(p.get_Y() + 1);
            if ((this.get_Dir() & Microsoft.Msagl.Core.Geometry.Directions.West) == Microsoft.Msagl.Core.Geometry.Directions.West)
                p.set_X(p.get_X() - 1);
            if ((this.get_Dir() & Microsoft.Msagl.Core.Geometry.Directions.South) == Microsoft.Msagl.Core.Geometry.Directions.South)
                p.set_Y(p.get_Y() - 1);
            return p;
        },
        Negate: function (){
            return Microsoft.Msagl.Core.Geometry.CompassVector.op_UnaryNegation(this);
        },
        ctor: function (){
            this._Dir = Microsoft.Msagl.Core.Geometry.Directions.None;
            System.ValueType.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$CompassVector);
var Microsoft$Msagl$Routing$Rectilinear$HighBendVertexEvent = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.HighBendVertexEvent",
    baseTypeName: "Microsoft.Msagl.Routing.Rectilinear.BasicVertexEvent",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (obstacle, p){
            Microsoft.Msagl.Routing.Rectilinear.BasicVertexEvent.ctor.call(this, obstacle, p);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$HighBendVertexEvent);
var Microsoft$Msagl$Routing$Rectilinear$LowBendVertexEvent = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.LowBendVertexEvent",
    baseTypeName: "Microsoft.Msagl.Routing.Rectilinear.BasicVertexEvent",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (obstacle, p){
            Microsoft.Msagl.Routing.Rectilinear.BasicVertexEvent.ctor.call(this, obstacle, p);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$LowBendVertexEvent);
var Microsoft$Msagl$Routing$Rectilinear$ScanSegmentTree = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.ScanSegmentTree",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IComparer$1"],
    Kind: "Class",
    definition: {
        ctor: function (scanDir){
            this.segmentTree = null;
            this.lookupSegment = new Microsoft.Msagl.Routing.Rectilinear.ScanSegment.ctor$$Point$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, 0), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, 1));
            this.findIntersectorPred = null;
            this.findPointPred = null;
            this._ScanDirection = null;
            System.Object.ctor.call(this);
            this.set_ScanDirection(scanDir);
            this.segmentTree = new Microsoft.Msagl.Core.DataStructures.RbTree$1.ctor$$IComparer$1(Microsoft.Msagl.Routing.Rectilinear.ScanSegment.ctor, this);
            this.findIntersectorPred = $CreateDelegate(this, this.CompareIntersector);
            this.findPointPred = $CreateDelegate(this, this.CompareToPoint);
        },
        ScanDirection$$: "Microsoft.Msagl.Routing.Rectilinear.ScanDirection",
        get_ScanDirection: function (){
            return this._ScanDirection;
        },
        set_ScanDirection: function (value){
            this._ScanDirection = value;
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this.segmentTree.get_Count();
        },
        Segments$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Routing.Rectilinear.ScanSegment]]",
        get_Segments: function (){
            return this.segmentTree;
        },
        InsertUnique: function (seg){
            this.AssertValidSegmentForInsertion(seg);
            var node = this.segmentTree.Find$$T(seg);
            if (null != node){
                System.Diagnostics.Debug.Assert$$Boolean$$String(seg.get_IsOverlapped() == node.Item.get_IsOverlapped(), "Existing node found with different isOverlapped");
                return node;
            }
            return this.segmentTree.Insert(seg);
        },
        AssertValidSegmentForInsertion: function (seg){
            System.Diagnostics.Debug.Assert$$Boolean$$String((seg.get_End().get_X() >= seg.get_Start().get_X()) && (seg.get_End().get_Y() >= seg.get_Start().get_Y()), "Reversed direction in ScanSegment");
            System.Diagnostics.Debug.Assert$$Boolean$$String(this.get_ScanDirection().IsFlat$$Point$$Point(seg.get_Start(), seg.get_End()), "non-flat segment cannot be inserted");
        },
        Remove: function (seg){
            System.Diagnostics.Debug.Assert$$Boolean$$String(seg.get_IsVertical() == this.get_ScanDirection().get_IsVertical(), "seg.IsVertical != ScanDirection.IsVertical");
            this.segmentTree.Remove(seg);
        },
        Find: function (start, end){
            System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(start, end) || !this.get_ScanDirection().IsPerpendicular$$Point$$Point(start, end), "perpendicular segment passed");
            this.lookupSegment.Update(start, end);
            var node = this.segmentTree.Find$$T(this.lookupSegment);
            if ((null != node) && Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(node.Item.get_End(), end)){
                return node.Item;
            }
            return null;
        },
        FindLowestIntersector: function (start, end){
            var node = this.FindLowestIntersectorNode(start, end);
            return (null != node) ? node.Item : null;
        },
        FindLowestIntersectorNode: function (start, end){
            System.Diagnostics.Debug.Assert$$Boolean$$String(this.get_ScanDirection().IsPerpendicular$$Point$$Point(start, end), "non-perpendicular segment passed");
            this.lookupSegment.Update(start, start);
            var node = this.segmentTree.FindLast$$Func$2(this.findIntersectorPred);
            if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(start, end)){
                if ((null != node) && (this.get_ScanDirection().Compare(node.Item.get_End(), start) < 0)){
                    node = null;
                }
            }
            else {
                this.lookupSegment.Update(start, end);
                while ((null != node) && !node.Item.IntersectsSegment(this.lookupSegment)){
                    if (this.get_ScanDirection().Compare(node.Item.get_Start(), end) > 0){
                        return null;
                    }
                    node = this.segmentTree.Next(node);
                }
            }
            return node;
        },
        FindHighestIntersector: function (start, end){
            System.Diagnostics.Debug.Assert$$Boolean$$String(this.get_ScanDirection().IsPerpendicular$$Point$$Point(start, end), "non-perpendicular segment passed");
            this.lookupSegment.Update(end, end);
            var node = this.segmentTree.FindLast$$Func$2(this.findIntersectorPred);
            if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(start, end)){
                if ((null != node) && (this.get_ScanDirection().Compare(node.Item.get_End(), start) < 0)){
                    node = null;
                }
            }
            else {
                this.lookupSegment.Update(start, end);
                while ((null != node) && !node.Item.IntersectsSegment(this.lookupSegment)){
                    if (this.get_ScanDirection().Compare(node.Item.get_End(), start) < 0){
                        return null;
                    }
                    node = this.segmentTree.Previous(node);
                }
            }
            return (null != node) ? node.Item : null;
        },
        CompareIntersector: function (seg){
            return (this.get_ScanDirection().Compare(seg.get_Start(), this.lookupSegment.get_Start()) <= 0);
        },
        FindSegmentContainingPoint: function (location, allowUnfound){
            return this.FindSegmentOverlappingPoints(location, location, allowUnfound);
        },
        FindSegmentOverlappingPoints: function (start, end, allowUnfound){
            this.lookupSegment.Update(start, end);
            var node = this.segmentTree.FindFirst$$Func$2(this.findPointPred);
            if (null != node){
                var seg = node.Item;
                if (this.get_ScanDirection().Compare(seg.get_Start(), end) <= 0){
                    return seg;
                }
            }
            if (!allowUnfound){
                System.Diagnostics.Debug.Assert$$Boolean$$String(false, "Could not find expected segment");
            }
            return null;
        },
        CompareToPoint: function (treeSeg){
            return (this.get_ScanDirection().Compare(treeSeg.get_End(), this.lookupSegment.get_Start()) >= 0);
        },
        MergeAndRemoveNextNode: function (currentSegment, nextSegNode){
            if (-1 == this.get_ScanDirection().Compare(currentSegment.get_End(), nextSegNode.Item.get_End())){
                currentSegment.Update(currentSegment.get_Start(), nextSegNode.Item.get_End());
            }
            currentSegment.MergeGroupBoundaryCrossingList(nextSegNode.Item.GroupBoundaryPointAndCrossingsList);
            this.segmentTree.DeleteNodeInternal(nextSegNode);
            return this.segmentTree.Find$$T(currentSegment);
        },
        MergeSegments: function (){
            if (this.segmentTree.get_Count() < 2){
                return;
            }
            var currentSegNode = this.segmentTree.TreeMinimum();
            var nextSegNode = this.segmentTree.Next(currentSegNode);
            for (; null != nextSegNode; nextSegNode = this.segmentTree.Next(currentSegNode)){
                var cmp = this.get_ScanDirection().Compare(nextSegNode.Item.get_Start(), currentSegNode.Item.get_End());
                switch (cmp){
                    case 1:
                        currentSegNode = nextSegNode;
                        break;
                    case 0:
                        if (nextSegNode.Item.get_IsOverlapped() == currentSegNode.Item.get_IsOverlapped()){
                        currentSegNode = this.MergeAndRemoveNextNode(currentSegNode.Item, nextSegNode);
                    }
                        else {
                        currentSegNode.Item.set_NeedEndOverlapVertex(true);
                        nextSegNode.Item.set_NeedStartOverlapVertex(true);
                        currentSegNode = nextSegNode;
                    }
                        break;
                    default:
                        System.Diagnostics.Debug.Assert$$Boolean$$String((Microsoft.Msagl.Core.Geometry.Point.op_Inequality(nextSegNode.Item.get_Start(), currentSegNode.Item.get_Start())) || (Microsoft.Msagl.Core.Geometry.Point.op_LessThan(nextSegNode.Item.get_End(), currentSegNode.Item.get_End())), "Identical segments are not allowed, and longer ones must come first");
                        if (currentSegNode.Item.get_IsOverlapped() != nextSegNode.Item.get_IsOverlapped()){
                        System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Core.Geometry.ApproximateComparer.CloseIntersections(currentSegNode.Item.get_End(), nextSegNode.Item.get_Start()), "Segments share a span with different IsOverlapped");
                        if (currentSegNode.Item.get_IsOverlapped()){
                            if (Microsoft.Msagl.Core.Geometry.Point.op_Equality(currentSegNode.Item.get_Start(), nextSegNode.Item.get_Start())){
                                currentSegNode = this.MergeAndRemoveNextNode(nextSegNode.Item, currentSegNode);
                            }
                            else {
                                currentSegNode.Item.Update(currentSegNode.Item.get_Start(), nextSegNode.Item.get_Start());
                                currentSegNode = nextSegNode;
                            }
                        }
                        else {
                            if (Microsoft.Msagl.Core.Geometry.Point.op_Equality(currentSegNode.Item.get_End(), nextSegNode.Item.get_End())){
                                currentSegNode = this.MergeAndRemoveNextNode(currentSegNode.Item, nextSegNode);
                            }
                            else {
                                var nextSegment = nextSegNode.Item;
                                var currentSegment = currentSegNode.Item;
                                this.segmentTree.DeleteNodeInternal(nextSegNode);
                                nextSegment.Update(currentSegment.get_End(), nextSegment.get_End());
                                this.segmentTree.Insert(nextSegment);
                                nextSegment.TrimGroupBoundaryCrossingList();
                                currentSegNode = this.segmentTree.Find$$T(currentSegment);
                            }
                        }
                        break;
                    };currentSegNode = this.MergeAndRemoveNextNode(currentSegNode.Item, nextSegNode);
                        break;
                }
            }
        },
        Compare: function (first, second){
            if (first == second)
                return 0;
            if (first == null)
                return -1;
            if (second == null)
                return 1;
            var cmp = this.get_ScanDirection().Compare(first.get_Start(), second.get_Start());
            if (0 == cmp){
                cmp = -this.get_ScanDirection().Compare(first.get_End(), second.get_End());
            }
            return cmp;
        },
        DevTraceInfo: function (verboseLevel, format, args){
        },
        DevTraceVerifyVisibility: function (){
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$ScanSegmentTree);
var Microsoft$Msagl$Routing$Rectilinear$StaticGraphUtility = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility",
    baseTypeName: "System.Object",
    staticDefinition: {
        EdgeDirection$$VisibilityEdge: function (edge){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.EdgeDirection$$VisibilityVertex$$VisibilityVertex(edge.get_Source(), edge.get_Target());
        },
        EdgeDirection$$VisibilityVertex$$VisibilityVertex: function (source, target){
            return Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$Point$$Point(source.Point, target.Point);
        },
        GetVertex: function (edge, dir){
            var edgeDir = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.EdgeDirection$$VisibilityEdge(edge);
            System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Core.Geometry.Directions.None != (dir & (edgeDir | Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(edgeDir))), "dir is orthogonal to edge");
            return (dir == edgeDir) ? edge.get_Target() : edge.get_Source();
        },
        FindNextVertex: function (vertex, dir){
            var cEdges = vertex.get_InEdges().get_Count();
            for (var ii = 0; ii < cEdges; ++ii){
                var edge = vertex.get_InEdges().get_Item$$Int32(ii);
                if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$Point$$Point(vertex.Point, edge.get_SourcePoint()) == dir){
                    return edge.get_Source();
                }
            }
            var outEdgeNode = vertex.get_OutEdges().IsEmpty() ? null : vertex.get_OutEdges().TreeMinimum();
            for (; outEdgeNode != null; outEdgeNode = vertex.get_OutEdges().Next(outEdgeNode)){
                var edge = outEdgeNode.Item;
                if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$Point$$Point(vertex.Point, edge.get_TargetPoint()) == dir){
                    return edge.get_Target();
                }
            }
            return null;
        },
        FindNextEdge: function (vg, vertex, dir){
            var nextVertex = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.FindNextVertex(vertex, dir);
            return (null == nextVertex) ? null : vg.FindEdge$$Point$$Point(vertex.Point, nextVertex.Point);
        },
        FindBendPointBetween: function (sourcePoint, targetPoint, finalEdgeDir){
            var targetDir = Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(sourcePoint, targetPoint);
            System.Diagnostics.Debug.Assert$$Boolean$$String(!Microsoft.Msagl.Routing.Rectilinear.PointComparer.IsPureDirection$$Directions(targetDir), "pure direction has no bend");
            var firstDir = targetDir & ~finalEdgeDir;
            System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Routing.Rectilinear.PointComparer.IsPureDirection$$Directions(firstDir), "firstDir is not pure");
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsVertical$$Directions(firstDir) ? new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(sourcePoint.get_X(), targetPoint.get_Y()) : new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(targetPoint.get_X(), sourcePoint.get_Y());
        },
        SegmentIntersection$$Point$$Point$$Point: function (first, second, from){
            var dir = Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$Point$$Point(first, second);
            var intersect = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsVertical$$Directions(dir) ? new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(first.get_X(), from.get_Y()) : new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(from.get_X(), first.get_Y());
            return intersect;
        },
        SegmentIntersection$$SegmentBase$$Point: function (seg, from){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.SegmentIntersection$$Point$$Point$$Point(seg.get_Start(), seg.get_End(), from);
        },
        SegmentsIntersect$$SegmentBase$$SegmentBase: function (first, second){
            var intersect;
            return (function (){
                var $1 = {
                    Value: intersect
                };
                var $res = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.SegmentsIntersect$$SegmentBase$$SegmentBase$$Point(first, second, $1);
                intersect = $1.Value;
                return $res;
            })();
        },
        SegmentsIntersect$$SegmentBase$$SegmentBase$$Point: function (first, second, intersect){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IntervalsIntersect(first.get_Start(), first.get_End(), second.get_Start(), second.get_End(), intersect);
        },
        SegmentsIntersect$$LineSegment$$LineSegment$$Point: function (first, second, intersect){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IntervalsIntersect(first.get_Start(), first.get_End(), second.get_Start(), second.get_End(), intersect);
        },
        SegmentIntersection$$SegmentBase$$SegmentBase: function (first, second){
            var intersect;
            if (!(function (){
                var $1 = {
                    Value: intersect
                };
                var $res = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.SegmentsIntersect$$SegmentBase$$SegmentBase$$Point(first, second, $1);
                intersect = $1.Value;
                return $res;
            })()){
                System.Diagnostics.Debug.Assert$$Boolean$$String(false, "intersect is not on both segments");
            }
            return intersect;
        },
        IntervalsOverlap$$SegmentBase$$SegmentBase: function (first, second){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IntervalsOverlap$$Point$$Point$$Point$$Point(first.get_Start(), first.get_End(), second.get_Start(), second.get_End());
        },
        IntervalsOverlap$$LineSegment$$LineSegment: function (first, second){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IntervalsOverlap$$Point$$Point$$Point$$Point(first.get_Start(), first.get_End(), second.get_Start(), second.get_End());
        },
        IntervalsOverlap$$Point$$Point$$Point$$Point: function (start1, end1, start2, end2){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IntervalsAreCollinear$$Point$$Point$$Point$$Point(start1, end1, start2, end2) && Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Point$$Point(start1, end2) != Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Point$$Point(end1, start2);
        },
        IntervalsAreCollinear$$SegmentBase$$SegmentBase: function (first, second){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IntervalsAreCollinear$$Point$$Point$$Point$$Point(first.get_Start(), first.get_End(), second.get_Start(), second.get_End());
        },
        IntervalsAreCollinear$$Point$$Point$$Point$$Point: function (start1, end1, start2, end2){
            System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsVertical$$Point$$Point(start1, end1) == Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsVertical$$Point$$Point(start2, end2), "segments are not in the same orientation");
            var vertical = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsVertical$$Point$$Point(start1, end1);
            if (Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsVertical$$Point$$Point(start2, end2) == vertical){
                return vertical ? Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Double$$Double(start1.get_X(), start2.get_X()) : Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Double$$Double(start1.get_Y(), start2.get_Y());
            }
            return false;
        },
        IntervalsAreSame: function (start1, end1, start2, end2){
            return Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(start1, start2) && Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(end1, end2);
        },
        IntervalsIntersect: function (firstStart, firstEnd, secondStart, secondEnd, intersect){
            System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsVertical$$Point$$Point(firstStart, firstEnd) != Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsVertical$$Point$$Point(secondStart, secondEnd), "cannot intersect two parallel segments");
            intersect.Value = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.SegmentIntersection$$Point$$Point$$Point(firstStart, firstEnd, secondStart);
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.PointIsOnSegment$$Point$$Point$$Point(firstStart, firstEnd, intersect.Value) && Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.PointIsOnSegment$$Point$$Point$$Point(secondStart, secondEnd, intersect.Value);
        },
        SegmentIntersection$$VisibilityEdge$$Point: function (edge, from){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.SegmentIntersection$$Point$$Point$$Point(edge.get_SourcePoint(), edge.get_TargetPoint(), from);
        },
        LowVertex: function (edge){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsAscending$$VisibilityEdge(edge) ? edge.get_Source() : edge.get_Target();
        },
        HighVertex: function (edge){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsAscending$$VisibilityEdge(edge) ? edge.get_Target() : edge.get_Source();
        },
        PointIsOnSegment$$Point$$Point$$Point: function (first, second, test){
            return Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(first, test) || Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(second, test) || (Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$Point$$Point(first, test) == Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$Point$$Point(test, second));
        },
        PointIsOnSegment$$SegmentBase$$Point: function (seg, test){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.PointIsOnSegment$$Point$$Point$$Point(seg.get_Start(), seg.get_End(), test);
        },
        PointIsOnSegment$$LineSegment$$Point: function (seg, test){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.PointIsOnSegment$$Point$$Point$$Point(seg.get_Start(), seg.get_End(), test);
        },
        PointIsOnSegmentInterior$$Point$$Point$$Point: function (first, second, test){
            var firstDir = Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(first, test);
            var secondDir = Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(test, second);
            System.Diagnostics.Debug.Assert$$Boolean$$String((Microsoft.Msagl.Core.Geometry.Directions.None != firstDir) || (Microsoft.Msagl.Core.Geometry.Directions.None != secondDir), "zero-length segment");
            return (firstDir == secondDir);
        },
        PointIsOnSegmentInterior$$LineSegment$$Point: function (seg, test){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.PointIsOnSegmentInterior$$Point$$Point$$Point(seg.get_Start(), seg.get_End(), test);
        },
        PointIsOnSegmentInterior$$SegmentBase$$Point: function (seg, test){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.PointIsOnSegmentInterior$$Point$$Point$$Point(seg.get_Start(), seg.get_End(), test);
        },
        IsVertical$$Directions: function (dir){
            return (Microsoft.Msagl.Core.Geometry.Directions.None != (dir & (5)));
        },
        IsVertical$$VisibilityEdge: function (edge){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsVertical$$Directions(Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$Point$$Point(edge.get_SourcePoint(), edge.get_TargetPoint()));
        },
        IsVertical$$Point$$Point: function (first, second){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsVertical$$Directions(Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$Point$$Point(first, second));
        },
        IsVertical$$SegmentBase: function (seg){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsVertical$$Directions(Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$Point$$Point(seg.get_Start(), seg.get_End()));
        },
        IsVertical$$LineSegment: function (seg){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsVertical$$Directions(Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$Point$$Point(seg.get_Start(), seg.get_End()));
        },
        IsAscending$$Directions: function (dir){
            return (Microsoft.Msagl.Core.Geometry.Directions.None != (dir & (3)));
        },
        IsAscending$$VisibilityEdge: function (edge){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsAscending$$Directions(Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.EdgeDirection$$VisibilityEdge(edge));
        },
        Slope$$SegmentBase$$ScanDirection: function (seg, scanDir){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.Slope$$Point$$Point$$ScanDirection(seg.get_Start(), seg.get_End(), scanDir);
        },
        Slope$$Point$$Point$$ScanDirection: function (start, end, scanDir){
            var lineDirAsPoint = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(end, start);
            return (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(lineDirAsPoint, scanDir.get_PerpDirectionAsPoint())) / (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(lineDirAsPoint, scanDir.get_DirectionAsPoint()));
        },
        SortAscending: function (a, b){
            var dir = Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(a, b);
            System.Diagnostics.Debug.Assert$$Boolean$$String((Microsoft.Msagl.Core.Geometry.Directions.None == dir) || Microsoft.Msagl.Routing.Rectilinear.PointComparer.IsPureDirection$$Directions(dir), "SortAscending with impure direction");
            return ((Microsoft.Msagl.Core.Geometry.Directions.None == dir) || Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsAscending$$Directions(dir)) ? new System.Tuple$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, a, b) : new System.Tuple$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, b, a);
        },
        RectangleBorderIntersect: function (boundingBox, point, dir){
            switch (dir){
                case Microsoft.Msagl.Core.Geometry.Directions.North:
                case Microsoft.Msagl.Core.Geometry.Directions.South:
                    return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(point.get_X(), Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.GetRectangleBound(boundingBox, dir));
                case Microsoft.Msagl.Core.Geometry.Directions.East:
                case Microsoft.Msagl.Core.Geometry.Directions.West:
                    return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.GetRectangleBound(boundingBox, dir), point.get_Y());
                default:
                    throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            }
        },
        GetRectangleBound: function (rect, dir){
            switch (dir){
                case Microsoft.Msagl.Core.Geometry.Directions.North:
                    return rect.get_Top();
                case Microsoft.Msagl.Core.Geometry.Directions.South:
                    return rect.get_Bottom();
                case Microsoft.Msagl.Core.Geometry.Directions.East:
                    return rect.get_Right();
                case Microsoft.Msagl.Core.Geometry.Directions.West:
                    return rect.get_Left();
                default:
                    throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            }
        },
        RectangleInteriorsIntersect: function (a, b){
            return (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Double$$Double(a.get_Bottom(), b.get_Top()) < 0) && (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Double$$Double(b.get_Bottom(), a.get_Top()) < 0) && (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Double$$Double(a.get_Left(), b.get_Right()) < 0) && (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Double$$Double(b.get_Left(), a.get_Right()) < 0);
        },
        PointIsInRectangleInterior: function (point, rect){
            return (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Double$$Double(point.get_Y(), rect.get_Top()) < 0) && (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Double$$Double(rect.get_Bottom(), point.get_Y()) < 0) && (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Double$$Double(point.get_X(), rect.get_Right()) < 0) && (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Double$$Double(rect.get_Left(), point.get_X()) < 0);
        },
        Assert: function (condition, message, obstacleTree, vg){
            if (!condition){
                System.Diagnostics.Debug.Assert$$Boolean$$String(condition, message);
            }
        },
        Test_ShowVisibilityGraph: function (obstacleTree, vg){
        },
        Test_DumpVisibilityGraph: function (obstacleTree, vg){
        },
        Test_ShowPathsBeforeNudging: function (obstacleTree, edgePaths){
        },
        Test_DumpPathsBeforeNudging: function (obstacleTree, edgePaths){
        },
        Test_ShowPathsAfterNudging: function (obstacleTree, edgePaths){
        },
        Test_DumpPathsAfterNudging: function (obstacleTree, edgePaths){
        },
        Test_ShowScanSegments: function (obstacleTree, hSegs, vSegs){
        },
        Test_DumpScanSegments: function (obstacleTree, hSegs, vSegs){
        },
        IsEqualForDebugger$$Double$$Double: function (variable, want){
            return (variable < (want + 1)) && (variable > (want - 1));
        },
        IsEqualForDebugger$$Point$$Double$$Double: function (variable, wantX, wantY){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsEqualForDebugger$$Double$$Double(variable.get_X(), wantX) && Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsEqualForDebugger$$Double$$Double(variable.get_Y(), wantY);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$StaticGraphUtility);
var Microsoft$Msagl$Routing$Rectilinear$CloseVertexEvent = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.CloseVertexEvent",
    baseTypeName: "Microsoft.Msagl.Routing.Rectilinear.BasicVertexEvent",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (obstacle, p){
            Microsoft.Msagl.Routing.Rectilinear.BasicVertexEvent.ctor.call(this, obstacle, p);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$CloseVertexEvent);
var Microsoft$Msagl$Routing$Rectilinear$TransientGraphUtility = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.TransientGraphUtility",
    baseTypeName: "System.Object",
    staticDefinition: {
        FindBracketingVertices: function (sourceVertex, targetPoint, dirToTarget, bracketSource, bracketTarget){
            bracketSource.Value = sourceVertex;
            for (; ;){
                bracketTarget.Value = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.FindNextVertex(bracketSource.Value, dirToTarget);
                if (null == bracketTarget.Value){
                    break;
                }
                if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(bracketTarget.Value.Point, targetPoint)){
                    return true;
                }
                if (dirToTarget != Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$Point$$Point(bracketTarget.Value.Point, targetPoint)){
                    break;
                }
                bracketSource.Value = bracketTarget.Value;
            }
            return null != bracketTarget.Value;
        },
        TraverseToFirstVertexAtOrAbove: function (startVertex, start, dir){
            var returnVertex = startVertex;
            var oppositeDir = Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(dir);
            for (; ;){
                var nextVertex = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.FindNextVertex(returnVertex, dir);
                if ((null == nextVertex) || (Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(nextVertex.Point, start) == oppositeDir)){
                    break;
                }
                returnVertex = nextVertex;
            }
            return returnVertex;
        },
        GetNextSpliceSource: function (spliceSource, spliceTargetDir, extendDir){
            var nextSpliceSource = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.FindNextVertex(spliceSource.Value, extendDir);
            if (null == nextSpliceSource){
                nextSpliceSource = spliceSource.Value;
                for (; ;){
                    nextSpliceSource = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.FindNextVertex(nextSpliceSource, Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(spliceTargetDir));
                    if (null == nextSpliceSource){
                        return false;
                    }
                    var nextSpliceSourceExtend = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.FindNextVertex(nextSpliceSource, extendDir);
                    if (null != nextSpliceSourceExtend){
                        nextSpliceSource = nextSpliceSourceExtend;
                        break;
                    }
                }
            }
            spliceSource.Value = nextSpliceSource;
            return true;
        },
        GetSpliceTarget: function (spliceSource, spliceTargetDir, nextExtendPoint){
            var prevDir = Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$Point$$Point(spliceSource.Value.Point, nextExtendPoint);
            var nextDir = prevDir;
            var spliceTarget = spliceSource.Value;
            while (nextDir == prevDir){
                spliceSource.Value = spliceTarget;
                spliceTarget = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.FindNextVertex(spliceSource.Value, spliceTargetDir);
                if (null == spliceTarget){
                    break;
                }
                if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(spliceTarget.Point, nextExtendPoint)){
                    spliceTarget = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.FindNextVertex(spliceTarget, spliceTargetDir);
                    break;
                }
                nextDir = Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$Point$$Point(spliceTarget.Point, nextExtendPoint);
            }
            return spliceTarget;
        },
        IsSkippableSpliceSourceEdgeWithNullTarget: function (spliceSourceEdge){
            return (null != spliceSourceEdge) && (null != spliceSourceEdge.get_IsPassable()) && (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Double$$Double(spliceSourceEdge.get_Length(), Microsoft.Msagl.Routing.Rectilinear.GroupBoundaryCrossing.get_BoundaryWidth()));
        },
        IsReflectionEdge: function (edge){
            return (null != edge) && (edge.get_Weight() == 5);
        },
        IsPointPastSegmentEnd: function (maxSegment, point){
            return Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(maxSegment.get_Start(), maxSegment.get_End()) == Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(maxSegment.get_End(), point);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (graphGen){
            this.AddedVertices = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Rectilinear.VisibilityVertexRectilinear.ctor);
            this.AddedEdges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Visibility.TollFreeVisibilityEdge.ctor);
            this.edgesToRestore = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor);
            this._LimitPortVisibilitySpliceToEndpointBoundingBox = false;
            this._GraphGenerator = null;
            System.Object.ctor.call(this);
            this.set_GraphGenerator(graphGen);
        },
        LimitPortVisibilitySpliceToEndpointBoundingBox$$: "System.Boolean",
        get_LimitPortVisibilitySpliceToEndpointBoundingBox: function (){
            return this._LimitPortVisibilitySpliceToEndpointBoundingBox;
        },
        set_LimitPortVisibilitySpliceToEndpointBoundingBox: function (value){
            this._LimitPortVisibilitySpliceToEndpointBoundingBox = value;
        },
        GraphGenerator$$: "Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator",
        get_GraphGenerator: function (){
            return this._GraphGenerator;
        },
        set_GraphGenerator: function (value){
            this._GraphGenerator = value;
        },
        ObstacleTree$$: "Microsoft.Msagl.Routing.Rectilinear.ObstacleTree",
        get_ObstacleTree: function (){
            return this.get_GraphGenerator().ObstacleTree;
        },
        VisGraph$$: "Microsoft.Msagl.Routing.Visibility.VisibilityGraph",
        get_VisGraph: function (){
            return this.get_GraphGenerator().get_VisibilityGraph();
        },
        IsSparseVg$$: "System.Boolean",
        get_IsSparseVg: function (){
            return Is(this.get_GraphGenerator(), Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ctor);
        },
        AddVertex: function (location){
            var vertex = this.get_VisGraph().AddVertex$$Point(location);
            this.AddedVertices.Add(Cast(vertex, Microsoft.Msagl.Routing.Rectilinear.VisibilityVertexRectilinear.ctor));
            return vertex;
        },
        FindOrAddVertex: function (location){
            var vertex = this.get_VisGraph().FindVertex(location);
            return (vertex != null ? vertex : this.AddVertex(location));
        },
        FindOrAddEdge$$VisibilityVertex$$VisibilityVertex: function (sourceVertex, targetVertex){
            return this.FindOrAddEdge$$VisibilityVertex$$VisibilityVertex$$Double(sourceVertex, targetVertex, 1);
        },
        FindOrAddEdge$$VisibilityVertex$$VisibilityVertex$$Double: function (sourceVertex, targetVertex, weight){
            var dirToTarget = Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$VisibilityVertex$$VisibilityVertex(sourceVertex, targetVertex);
            var bracketSource,bracketTarget;
            var splitVertex = targetVertex;
            if (!(function (){
                var $1 = {
                    Value: bracketSource
                };
                var $2 = {
                    Value: bracketTarget
                };
                var $res = Microsoft.Msagl.Routing.Rectilinear.TransientGraphUtility.FindBracketingVertices(sourceVertex, targetVertex.Point, dirToTarget, $1, $2);
                bracketSource = $1.Value;
                bracketTarget = $2.Value;
                return $res;
            }).call(this)){
                var tempSource;
                if ((function (){
                    var $1 = {
                        Value: bracketTarget
                    };
                    var $2 = {
                        Value: tempSource
                    };
                    var $res = Microsoft.Msagl.Routing.Rectilinear.TransientGraphUtility.FindBracketingVertices(targetVertex, sourceVertex.Point, Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(dirToTarget), $1, $2);
                    bracketTarget = $1.Value;
                    tempSource = $2.Value;
                    return $res;
                }).call(this)){
                    System.Diagnostics.Debug.Assert$$Boolean$$String(bracketSource == sourceVertex, "Mismatched bracketing detection");
                    bracketSource = tempSource;
                    splitVertex = sourceVertex;
                }
            }
            var edge = this.get_VisGraph().FindEdge$$Point$$Point(bracketSource.Point, bracketTarget.Point);
            edge = (null != edge) ? this.SplitEdge$$VisibilityEdge$$VisibilityVertex(edge, splitVertex) : this.CreateEdge(bracketSource, bracketTarget, weight);
            return edge;
        },
        DevTrace_VerifyEdge: function (edge){
        },
        DevTrace_VerifyVertex: function (vertex){
        },
        DevTrace_VerifyAllVertices: function (vg){
        },
        DevTrace_VerifyAllEdgeIntersections: function (visibilityGraph){
        },
        CreateEdge: function (first, second, weight){
            var source = first;
            var target = second;
            if (!Microsoft.Msagl.Routing.Rectilinear.PointComparer.IsPureLower(source.Point, target.Point)){
                source = second;
                target = first;
            }
            var edge = new Microsoft.Msagl.Routing.Visibility.TollFreeVisibilityEdge.ctor$$VisibilityVertex$$VisibilityVertex$$Double(source, target, weight);
            Microsoft.Msagl.Routing.Visibility.VisibilityGraph.AddEdge$$VisibilityEdge(edge);
            this.AddedEdges.Add(edge);
            return edge;
        },
        RemoveFromGraph: function (){
            this.RemoveAddedVertices();
            this.RemoveAddedEdges();
            this.RestoreRemovedEdges();
        },
        RemoveAddedVertices: function (){
            var $it1072 = this.AddedVertices.GetEnumerator();
            while ($it1072.MoveNext()){
                var vertex = $it1072.get_Current();
                if (null != this.get_VisGraph().FindVertex(vertex.Point)){
                    this.get_VisGraph().RemoveVertex(vertex);
                }
            }
            this.AddedVertices.Clear();
        },
        RemoveAddedEdges: function (){
            var $it1073 = this.AddedEdges.GetEnumerator();
            while ($it1073.MoveNext()){
                var edge = $it1073.get_Current();
                if (null != this.get_VisGraph().FindVertex(edge.get_SourcePoint())){
                    Microsoft.Msagl.Routing.Visibility.VisibilityGraph.RemoveEdge$$VisibilityEdge(edge);
                }
            }
            this.AddedEdges.Clear();
        },
        RestoreRemovedEdges: function (){
            var $it1074 = this.edgesToRestore.GetEnumerator();
            while ($it1074.MoveNext()){
                var edge = $it1074.get_Current();
                System.Diagnostics.Debug.Assert$$Boolean$$String(!(Is(edge, Microsoft.Msagl.Routing.Visibility.TollFreeVisibilityEdge.ctor)), "Unexpected Transient edge");
                Microsoft.Msagl.Routing.Visibility.VisibilityGraph.AddEdge$$VisibilityEdge(edge);
            }
            this.edgesToRestore.Clear();
        },
        FindNextEdge: function (vertex, dir){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.FindNextEdge(this.get_VisGraph(), vertex, dir);
        },
        FindPerpendicularOrContainingEdge: function (startVertex, dir, pointLocation){
            Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.Assert(Microsoft.Msagl.Core.Geometry.Directions.None == (Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(dir) & Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(startVertex.Point, pointLocation)), "the ray from \'dir\' is away from pointLocation", this.get_ObstacleTree(), this.get_VisGraph());
            while (true){
                var nextVertex = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.FindNextVertex(startVertex, dir);
                if (null == nextVertex){
                    break;
                }
                var dirCheck = Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(nextVertex.Point, pointLocation);
                if (Microsoft.Msagl.Core.Geometry.Directions.None != (Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(dir) & dirCheck)){
                    return this.get_VisGraph().FindEdge$$Point$$Point(startVertex.Point, nextVertex.Point);
                }
                startVertex = nextVertex;
            }
            return null;
        },
        FindNearestPerpendicularOrContainingEdge: function (startVertex, dir, pointLocation){
            var dirTowardLocation = ~dir & Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(startVertex.Point, pointLocation);
            var currentVertex = startVertex;
            var currentDirTowardLocation = dirTowardLocation;
            while (Microsoft.Msagl.Core.Geometry.Directions.None != currentDirTowardLocation){
                var nextVertex = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.FindNextVertex(currentVertex, dirTowardLocation);
                if (null == nextVertex){
                    break;
                }
                if (Microsoft.Msagl.Core.Geometry.Directions.None != (Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(dirTowardLocation) & Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(nextVertex.Point, pointLocation))){
                    break;
                }
                currentVertex = nextVertex;
                currentDirTowardLocation = ~dir & Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(currentVertex.Point, pointLocation);
            }
            var perpEdge;
            while (true){
                perpEdge = this.FindPerpendicularOrContainingEdge(currentVertex, dir, pointLocation);
                if ((null != perpEdge) || (currentVertex == startVertex)){
                    break;
                }
                currentVertex = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.FindNextVertex(currentVertex, Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(dirTowardLocation));
            }
            return perpEdge;
        },
        ConnectVertexToTargetEdge: function (sourceVertex, targetEdge, targetIntersect, finalEdgeDir, weight){
            var targetVertex = this.FindOrAddVertex(targetIntersect);
            if ((targetVertex != targetEdge.get_Source()) && (targetVertex != targetEdge.get_Target())){
                this.SplitEdge$$VisibilityEdge$$VisibilityVertex(targetEdge, targetVertex);
            }
            this.ConnectVertexToTargetVertex(sourceVertex, targetVertex, finalEdgeDir, weight);
        },
        ConnectVertexToTargetVertex: function (sourceVertex, targetVertex, finalEdgeDir, weight){
            Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.Assert(Microsoft.Msagl.Routing.Rectilinear.PointComparer.IsPureDirection$$Directions(finalEdgeDir), "finalEdgeDir is not pure", this.get_ObstacleTree(), this.get_VisGraph());
            if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(sourceVertex.Point, targetVertex.Point)){
                return;
            }
            var targetDirs = Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(sourceVertex.Point, targetVertex.Point);
            if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.IsPureDirection$$Directions(targetDirs)){
                this.FindOrAddEdge$$VisibilityVertex$$VisibilityVertex(sourceVertex, targetVertex);
                return;
            }
            var bendPoint = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.FindBendPointBetween(sourceVertex.Point, targetVertex.Point, finalEdgeDir);
            var bendVertex = this.FindOrAddVertex(bendPoint);
            this.FindOrAddEdge$$VisibilityVertex$$VisibilityVertex$$Double(sourceVertex, bendVertex, weight);
            this.FindOrAddEdge$$VisibilityVertex$$VisibilityVertex$$Double(bendVertex, targetVertex, weight);
        },
        AddEdgeToTargetEdge: function (sourceVertex, targetEdge, targetIntersect){
            Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.Assert(Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(sourceVertex.Point, targetIntersect) || Microsoft.Msagl.Routing.Rectilinear.PointComparer.IsPureDirection$$Point$$Point(sourceVertex.Point, targetIntersect), "non-orthogonal edge request", this.get_ObstacleTree(), this.get_VisGraph());
            Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.Assert(Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.PointIsOnSegment$$Point$$Point$$Point(targetEdge.get_SourcePoint(), targetEdge.get_TargetPoint(), targetIntersect), "targetIntersect is not on targetEdge", this.get_ObstacleTree(), this.get_VisGraph());
            var targetVertex = this.get_VisGraph().FindVertex(targetIntersect);
            if (null == targetVertex){
                targetVertex = this.AddVertex(targetIntersect);
                this.SplitEdge$$VisibilityEdge$$VisibilityVertex(targetEdge, targetVertex);
            }
            this.FindOrAddEdge$$VisibilityVertex$$VisibilityVertex(sourceVertex, targetVertex);
            return targetVertex;
        },
        SplitEdge$$VisibilityEdge$$Point: function (edge, splitPoint){
            return this.SplitEdge$$VisibilityEdge$$VisibilityVertex(edge, this.FindOrAddVertex(splitPoint));
        },
        SplitEdge$$VisibilityEdge$$VisibilityVertex: function (edge, splitVertex){
            if (null == edge){
                return null;
            }
            Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.Assert(Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.PointIsOnSegment$$Point$$Point$$Point(edge.get_SourcePoint(), edge.get_TargetPoint(), splitVertex.Point), "splitVertex is not on edge", this.get_ObstacleTree(), this.get_VisGraph());
            if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(edge.get_Source().Point, splitVertex.Point) || Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(edge.get_Target().Point, splitVertex.Point)){
                return edge;
            }
            if (!(Is(edge, Microsoft.Msagl.Routing.Visibility.TollFreeVisibilityEdge.ctor))){
                this.edgesToRestore.Add(edge);
            }
            Microsoft.Msagl.Routing.Visibility.VisibilityGraph.RemoveEdge$$VisibilityEdge(edge);
            if ((this.get_IsSparseVg() || (edge.get_Weight() == 500)) && (splitVertex.get_Degree() > 0)){
                this.FindOrAddEdge$$VisibilityVertex$$VisibilityVertex$$Double(splitVertex, edge.get_Source(), edge.get_Weight());
                return this.FindOrAddEdge$$VisibilityVertex$$VisibilityVertex$$Double(splitVertex, edge.get_Target(), edge.get_Weight());
            }
            this.CreateEdge(splitVertex, edge.get_Target(), edge.get_Weight());
            return this.CreateEdge(edge.get_Source(), splitVertex, edge.get_Weight());
        },
        ExtendEdgeChain$$VisibilityVertex$$Rectangle$$LineSegment$$PointAndCrossingsList$$Boolean: function (startVertex, limitRect, maxVisibilitySegment, pacList, isOverlapped){
            var dir = Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(maxVisibilitySegment.get_Start(), maxVisibilitySegment.get_End());
            if (dir == Microsoft.Msagl.Core.Geometry.Directions.None){
                return;
            }
            System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Core.Geometry.CompassVector.IsPureDirection$$Directions(dir), "impure max visibility segment");
            Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.Assert(Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(maxVisibilitySegment.get_Start(), startVertex.Point) || (Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$Point$$Point(maxVisibilitySegment.get_Start(), startVertex.Point) == dir), "Inconsistent direction found", this.get_ObstacleTree(), this.get_VisGraph());
            var oppositeFarBound = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.GetRectangleBound(limitRect, dir);
            var maxDesiredSplicePoint = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsVertical$$Directions(dir) ? Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(startVertex.Point.get_X(), oppositeFarBound)) : Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(oppositeFarBound, startVertex.Point.get_Y()));
            if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(maxDesiredSplicePoint, startVertex.Point)){
                return;
            }
            if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$Point$$Point(startVertex.Point, maxDesiredSplicePoint) != dir){
                return;
            }
            var maxDesiredSegment = maxVisibilitySegment;
            if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(maxDesiredSplicePoint, maxDesiredSegment.get_End()) == dir){
                maxDesiredSegment = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(maxDesiredSegment.get_Start(), maxDesiredSplicePoint);
            }
            this.ExtendEdgeChain$$VisibilityVertex$$Directions$$LineSegment$$LineSegment$$PointAndCrossingsList$$Boolean(startVertex, dir, maxDesiredSegment, maxVisibilitySegment, pacList, isOverlapped);
        },
        ExtendEdgeChain$$VisibilityVertex$$Directions$$LineSegment$$LineSegment$$PointAndCrossingsList$$Boolean: function (startVertex, extendDir, maxDesiredSegment, maxVisibilitySegment, pacList, isOverlapped){
            Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.Assert(Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$Point$$Point(maxDesiredSegment.get_Start(), maxDesiredSegment.get_End()) == extendDir, "maxDesiredSegment is reversed", this.get_ObstacleTree(), this.get_VisGraph());
            var segmentDir = Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(startVertex.Point, maxDesiredSegment.get_End());
            if (segmentDir != extendDir){
                Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.Assert(isOverlapped || (segmentDir != Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(extendDir)), "obstacle encountered between prevPoint and startVertex", this.get_ObstacleTree(), this.get_VisGraph());
                return;
            }
            var spliceSourceDir = Microsoft.Msagl.Core.Geometry.CompassVector.RotateLeft(extendDir);
            var spliceSource = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.FindNextVertex(startVertex, spliceSourceDir);
            if (null == spliceSource){
                spliceSourceDir = Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(spliceSourceDir);
                spliceSource = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.FindNextVertex(startVertex, spliceSourceDir);
                if (null == spliceSource){
                    return;
                }
            }
            var spliceTargetDir = Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(spliceSourceDir);
            var spliceTarget;
            if ((function (){
                var $1 = {
                    Value: spliceTarget
                };
                var $res = this.ExtendSpliceWorker(spliceSource, extendDir, spliceTargetDir, maxDesiredSegment, maxVisibilitySegment, isOverlapped, $1);
                spliceTarget = $1.Value;
                return $res;
            }).call(this)){
                (function (){
                    var $1 = {
                        Value: spliceTarget
                    };
                    var $res = this.ExtendSpliceWorker(spliceTarget, extendDir, spliceSourceDir, maxDesiredSegment, maxVisibilitySegment, isOverlapped, $1);
                    spliceTarget = $1.Value;
                    return $res;
                }).call(this);
            }
            this.SpliceGroupBoundaryCrossings(pacList, startVertex, maxDesiredSegment);
        },
        SpliceGroupBoundaryCrossings: function (crossingList, startVertex, maxSegment){
            if ((null == crossingList) || (0 == crossingList.get_Count())){
                return;
            }
            crossingList.Reset();
            var start = maxSegment.get_Start();
            var end = maxSegment.get_End();
            var dir = Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$Point$$Point(start, end);
            if (!Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsAscending$$Directions(dir)){
                start = maxSegment.get_End();
                end = maxSegment.get_Start();
                dir = Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(dir);
            }
            startVertex = Microsoft.Msagl.Routing.Rectilinear.TransientGraphUtility.TraverseToFirstVertexAtOrAbove(startVertex, start, Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(dir));
            for (var currentVertex = startVertex; null != currentVertex; currentVertex = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.FindNextVertex(currentVertex, dir)){
                var isFinalVertex = (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Point$$Point(currentVertex.Point, end) >= 0);
                while (crossingList.CurrentIsBeforeOrAt(currentVertex.Point)){
                    var pac = crossingList.Pop();
                    if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Point$$Point(pac.get_Location(), startVertex.Point) > 0){
                        if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Point$$Point(pac.get_Location(), end) <= 0){
                            this.SpliceGroupBoundaryCrossing(currentVertex, pac, Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(dir));
                        }
                    }
                    if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Point$$Point(pac.get_Location(), startVertex.Point) >= 0){
                        if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Point$$Point(pac.get_Location(), end) < 0){
                            this.SpliceGroupBoundaryCrossing(currentVertex, pac, dir);
                        }
                    }
                }
                if (isFinalVertex){
                    break;
                }
            }
        },
        SpliceGroupBoundaryCrossing: function (currentVertex, pac, dirToInside){
            var crossings = Microsoft.Msagl.Routing.Rectilinear.PointAndCrossingsList.ToCrossingArray(pac.get_Crossings(), dirToInside);
            if (null != crossings){
                var outerVertex = (this.get_VisGraph().FindVertex(pac.get_Location()) != null ? this.get_VisGraph().FindVertex(pac.get_Location()) : this.AddVertex(pac.get_Location()));
                if (Microsoft.Msagl.Core.Geometry.Point.op_Inequality(currentVertex.Point, outerVertex.Point)){
                    this.FindOrAddEdge$$VisibilityVertex$$VisibilityVertex(currentVertex, outerVertex);
                }
                var interiorPoint = crossings[0].GetInteriorVertexPoint(pac.get_Location());
                var interiorVertex = (this.get_VisGraph().FindVertex(interiorPoint) != null ? this.get_VisGraph().FindVertex(interiorPoint) : this.AddVertex(interiorPoint));
                this.FindOrAddEdge$$VisibilityVertex$$VisibilityVertex(outerVertex, interiorVertex);
                var edge = this.get_VisGraph().FindEdge$$Point$$Point(outerVertex.Point, interiorVertex.Point);
                var crossingsArray = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Routing.Shape.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.GroupBoundaryCrossing.ctor, Microsoft.Msagl.Routing.Shape.ctor, crossings, $CreateAnonymousDelegate(this, function (c){
                    return c.get_Group().get_InputShape();
                })));
                edge.set_IsPassable($CreateAnonymousDelegate(this, function (){
                    return System.Linq.Enumerable.Any$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, crossingsArray, $CreateAnonymousDelegate(this, function (s){
                        return s.get_IsTransparent();
                    }));
                }));
            }
        },
        ExtendSpliceWorker: function (spliceSource, extendDir, spliceTargetDir, maxDesiredSegment, maxVisibilitySegment, isOverlapped, spliceTarget){
            var extendVertex = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.FindNextVertex(spliceSource, spliceTargetDir);
            spliceTarget.Value = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.FindNextVertex(extendVertex, spliceTargetDir);
            for (; ;){
                if (!(function (){
                    var $1 = {
                        Value: spliceSource
                    };
                    var $res = Microsoft.Msagl.Routing.Rectilinear.TransientGraphUtility.GetNextSpliceSource($1, spliceTargetDir, extendDir);
                    spliceSource = $1.Value;
                    return $res;
                }).call(this)){
                    break;
                }
                var nextExtendPoint = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.FindBendPointBetween(extendVertex.Point, spliceSource.Point, Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(spliceTargetDir));
                if (Microsoft.Msagl.Routing.Rectilinear.TransientGraphUtility.IsPointPastSegmentEnd(maxVisibilitySegment, nextExtendPoint)){
                    break;
                }
                spliceTarget.Value = (function (){
                    var $1 = {
                        Value: spliceSource
                    };
                    var $res = Microsoft.Msagl.Routing.Rectilinear.TransientGraphUtility.GetSpliceTarget($1, spliceTargetDir, nextExtendPoint);
                    spliceSource = $1.Value;
                    return $res;
                }).call(this);
                if (null == spliceTarget.Value){
                    if (this.IsSkippableSpliceSourceWithNullSpliceTarget(spliceSource, extendDir)){
                        continue;
                    }
                    if (this.get_ObstacleTree().SegmentCrossesAnObstacle(spliceSource.Point, nextExtendPoint)){
                        return false;
                    }
                }
                var nextExtendVertex = this.get_VisGraph().FindVertex(nextExtendPoint);
                if (null != nextExtendVertex){
                    if ((null == spliceTarget.Value) || (null != this.get_VisGraph().FindEdge$$Point$$Point(extendVertex.Point, nextExtendPoint))){
                        if (null == spliceTarget.Value){
                            this.Debug_VerifyNonOverlappedExtension(isOverlapped, extendVertex, nextExtendVertex, null, null);
                            this.FindOrAddEdge$$VisibilityVertex$$VisibilityVertex$$Double(extendVertex, nextExtendVertex, isOverlapped ? 500 : 1);
                        }
                        return false;
                    }
                    Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.Assert(spliceTarget.Value == Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.FindNextVertex(nextExtendVertex, spliceTargetDir), "no edge exists between an existing nextExtendVertex and spliceTarget", this.get_ObstacleTree(), this.get_VisGraph());
                }
                else {
                    Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.Assert((null == spliceTarget.Value) || spliceTargetDir == Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$Point$$Point(nextExtendPoint, spliceTarget.Value.Point), "spliceTarget is not to spliceTargetDir of nextExtendVertex", this.get_ObstacleTree(), this.get_VisGraph());
                    nextExtendVertex = this.AddVertex(nextExtendPoint);
                }
                this.FindOrAddEdge$$VisibilityVertex$$VisibilityVertex$$Double(extendVertex, nextExtendVertex, isOverlapped ? 500 : 1);
                this.Debug_VerifyNonOverlappedExtension(isOverlapped, extendVertex, nextExtendVertex, spliceSource, spliceTarget.Value);
                this.FindOrAddEdge$$VisibilityVertex$$VisibilityVertex$$Double(spliceSource, nextExtendVertex, isOverlapped ? 500 : 1);
                if (isOverlapped){
                    isOverlapped = this.SeeIfSpliceIsStillOverlapped(extendDir, nextExtendVertex);
                }
                extendVertex = nextExtendVertex;
                if (Microsoft.Msagl.Core.Geometry.Directions.None == (extendDir & Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(nextExtendPoint, maxDesiredSegment.get_End()))){
                    spliceTarget.Value = null;
                    break;
                }
            }
            return null != spliceTarget.Value;
        },
        Debug_VerifyNonOverlappedExtension: function (isOverlapped, extendVertex, nextExtendVertex, spliceSource, spliceTarget){
            if (isOverlapped){
                return;
            }
            Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.Assert(!this.get_ObstacleTree().SegmentCrossesANonGroupObstacle(extendVertex.Point, nextExtendVertex.Point), "extendDir edge crosses an obstacle", this.get_ObstacleTree(), this.get_VisGraph());
            if (spliceSource == null){
                return;
            }
            if ((null == spliceTarget) || (null == this.get_VisGraph().FindEdge$$Point$$Point(spliceSource.Point, spliceTarget.Point) && (null == this.get_VisGraph().FindEdge$$Point$$Point(spliceSource.Point, nextExtendVertex.Point)))){
                Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.Assert(!this.get_ObstacleTree().SegmentCrossesAnObstacle(spliceSource.Point, nextExtendVertex.Point), "spliceSource->extendVertex edge crosses an obstacle", this.get_ObstacleTree(), this.get_VisGraph());
                Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.Assert((null == spliceTarget) || (null != this.get_VisGraph().FindEdge$$Point$$Point(nextExtendVertex.Point, spliceTarget.Point)) || !this.get_ObstacleTree().SegmentCrossesAnObstacle(nextExtendVertex.Point, spliceTarget.Point), "extendVertex->spliceTarget edge crosses an obstacle", this.get_ObstacleTree(), this.get_VisGraph());
            }
        },
        SeeIfSpliceIsStillOverlapped: function (extendDir, nextExtendVertex){
            var edge = this.FindNextEdge(nextExtendVertex, Microsoft.Msagl.Core.Geometry.CompassVector.RotateLeft(extendDir));
            var maybeFreeSpace = (null == edge) ? false : (1 == edge.get_Weight());
            if (!maybeFreeSpace){
                edge = this.FindNextEdge(nextExtendVertex, Microsoft.Msagl.Core.Geometry.CompassVector.RotateRight(extendDir));
                maybeFreeSpace = (null == edge) ? false : (1 == edge.get_Weight());
            }
            return !maybeFreeSpace || this.get_ObstacleTree().PointIsInsideAnObstacle$$Point$$Directions(nextExtendVertex.Point, extendDir);
        },
        IsSkippableSpliceSourceWithNullSpliceTarget: function (spliceSource, extendDir){
            if (Microsoft.Msagl.Routing.Rectilinear.TransientGraphUtility.IsSkippableSpliceSourceEdgeWithNullTarget(Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.FindNextEdge(this.get_VisGraph(), spliceSource, extendDir))){
                return true;
            }
            var spliceSourceEdge = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.FindNextEdge(this.get_VisGraph(), spliceSource, Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(extendDir));
            return (Microsoft.Msagl.Routing.Rectilinear.TransientGraphUtility.IsSkippableSpliceSourceEdgeWithNullTarget(spliceSourceEdge) || Microsoft.Msagl.Routing.Rectilinear.TransientGraphUtility.IsReflectionEdge(spliceSourceEdge));
        },
        toString: function (){
            return System.String.Format$$String$$Object$$Object("{0} {1}", this.AddedVertices.get_Count(), this.edgesToRestore.get_Count());
        },
        DevTraceInfo: function (verboseLevel, format, args){
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$TransientGraphUtility);
var Microsoft$Msagl$Routing$Visibility$PortObstacleEvent = {
    fullname: "Microsoft.Msagl.Routing.Visibility.PortObstacleEvent",
    baseTypeName: "Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (site){
            this.site = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent.ctor.call(this);
            this.site = site;
        },
        Site$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Site: function (){
            return this.site;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Visibility$PortObstacleEvent);
var Microsoft$Msagl$Routing$Visibility$TollFreeVisibilityEdge = {
    fullname: "Microsoft.Msagl.Routing.Visibility.TollFreeVisibilityEdge",
    baseTypeName: "Microsoft.Msagl.Routing.Visibility.VisibilityEdge",
    staticDefinition: {
        cctor: function (){
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$VisibilityVertex$$VisibilityVertex: function (source, target){
            Microsoft.Msagl.Routing.Visibility.TollFreeVisibilityEdge.ctor$$VisibilityVertex$$VisibilityVertex$$Double.call(this, source, target, 0);
        },
        ctor$$VisibilityVertex$$VisibilityVertex$$Double: function (source, target, weight){
            Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor$$VisibilityVertex$$VisibilityVertex$$Double.call(this, source, target, weight);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Visibility$TollFreeVisibilityEdge);
var Microsoft$Msagl$Routing$Rectilinear$EventQueue = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.EventQueue",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IComparer$1"],
    Kind: "Class",
    definition: {
        ctor: function (){
            this.scanDirection = null;
            this.eventTree = null;
            System.Object.ctor.call(this);
            this.eventTree = new Microsoft.Msagl.Core.DataStructures.BinaryHeapWithComparer$1.ctor(Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent.ctor, this);
        },
        Reset: function (scanDir){
            System.Diagnostics.Debug.Assert$$Boolean$$String(0 == this.eventTree.get_Count(), "Stray events in EventQueue.Reset");
            this.scanDirection = scanDir;
        },
        Enqueue: function (evt){
            this.eventTree.Enqueue(evt);
        },
        Dequeue: function (){
            var evt = this.eventTree.Dequeue();
            return evt;
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this.eventTree.get_Count();
        },
        Compare: function (lhs, rhs){
            if (lhs == rhs){
                return 0;
            }
            if (lhs == null){
                return -1;
            }
            if (rhs == null){
                return 1;
            }
            var cmp = this.scanDirection.ComparePerpCoord(lhs.get_Site(), rhs.get_Site());
            if (0 == cmp){
                var lhsIsNotReflection = !(Is(lhs, Microsoft.Msagl.Routing.Rectilinear.BasicReflectionEvent.ctor));
                var rhsIsNotReflection = !(Is(rhs, Microsoft.Msagl.Routing.Rectilinear.BasicReflectionEvent.ctor));
                cmp = lhsIsNotReflection.CompareTo$$Boolean(rhsIsNotReflection);
                if (0 == cmp){
                    cmp = this.scanDirection.CompareScanCoord(lhs.get_Site(), rhs.get_Site());
                }
            }
            return cmp;
        },
        DevTraceInfo: function (verboseLevel, format, args){
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$EventQueue);
var Microsoft$Msagl$Routing$Rectilinear$FreePoint = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.FreePoint",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (transUtil, point){
            this.maxVisibilitySegmentsAndCrossings = new Array(4);
            this._Vertex = null;
            this._IsOverlapped = false;
            this._OutOfBoundsDirectionFromGraph = Microsoft.Msagl.Core.Geometry.Directions.None;
            System.Object.ctor.call(this);
            this.set_OutOfBoundsDirectionFromGraph(Microsoft.Msagl.Core.Geometry.Directions.None);
            this.GetVertex(transUtil, point);
        },
        Vertex$$: "Microsoft.Msagl.Routing.Visibility.VisibilityVertex",
        get_Vertex: function (){
            return this._Vertex;
        },
        set_Vertex: function (value){
            this._Vertex = value;
        },
        Point$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Point: function (){
            return this.get_Vertex().Point;
        },
        IsOverlapped$$: "System.Boolean",
        get_IsOverlapped: function (){
            return this._IsOverlapped;
        },
        set_IsOverlapped: function (value){
            this._IsOverlapped = value;
        },
        InitialWeight$$: "System.Double",
        get_InitialWeight: function (){
            return this.get_IsOverlapped() ? 500 : 1;
        },
        OutOfBoundsDirectionFromGraph$$: "Microsoft.Msagl.Core.Geometry.Directions",
        get_OutOfBoundsDirectionFromGraph: function (){
            return this._OutOfBoundsDirectionFromGraph;
        },
        set_OutOfBoundsDirectionFromGraph: function (value){
            this._OutOfBoundsDirectionFromGraph = value;
        },
        IsOutOfBounds$$: "System.Boolean",
        get_IsOutOfBounds: function (){
            return Microsoft.Msagl.Core.Geometry.Directions.None != this.get_OutOfBoundsDirectionFromGraph();
        },
        GetVertex: function (transUtil, point){
            this.set_Vertex(transUtil.FindOrAddVertex(point));
        },
        AddEdgeToAdjacentEdge: function (transUtil, targetEdge, dirToExtend, limitRect){
            var targetIntersect = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.SegmentIntersection$$VisibilityEdge$$Point(targetEdge, this.get_Point());
            var targetVertex = transUtil.get_VisGraph().FindVertex(targetIntersect);
            if (null != targetVertex){
                this.AddToAdjacentVertex(transUtil, targetVertex, dirToExtend, limitRect);
            }
            else {
                targetVertex = transUtil.AddEdgeToTargetEdge(this.get_Vertex(), targetEdge, targetIntersect);
            }
            this.ExtendEdgeChain(transUtil, targetVertex, dirToExtend, limitRect);
            return targetVertex;
        },
        AddToAdjacentVertex: function (transUtil, targetVertex, dirToExtend, limitRect){
            if (!Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(this.get_Point(), targetVertex.Point)){
                transUtil.FindOrAddEdge$$VisibilityVertex$$VisibilityVertex$$Double(this.get_Vertex(), targetVertex, this.get_InitialWeight());
            }
            this.ExtendEdgeChain(transUtil, targetVertex, dirToExtend, limitRect);
        },
        ExtendEdgeChain: function (transUtil, targetVertex, dirToExtend, limitRect){
            Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.Assert(Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(this.get_Point(), targetVertex.Point) || (Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$Point$$Point(this.get_Point(), targetVertex.Point) == dirToExtend), "input dir does not match with to-targetVertex direction", transUtil.get_ObstacleTree(), transUtil.get_VisGraph());
            var extendOverlapped = this.get_IsOverlapped();
            if (extendOverlapped){
                extendOverlapped = transUtil.get_ObstacleTree().PointIsInsideAnObstacle$$Point$$Directions(targetVertex.Point, dirToExtend);
            }
            var segmentAndCrossings = this.GetSegmentAndCrossings(this.get_IsOverlapped() ? targetVertex : this.get_Vertex(), dirToExtend, transUtil);
            transUtil.ExtendEdgeChain$$VisibilityVertex$$Rectangle$$LineSegment$$PointAndCrossingsList$$Boolean(targetVertex, limitRect, segmentAndCrossings.get_Item1(), segmentAndCrossings.get_Item2(), extendOverlapped);
        },
        GetSegmentAndCrossings: function (startVertex, dirToExtend, transUtil){
            var dirIndex = Microsoft.Msagl.Core.Geometry.CompassVector.ToIndex(dirToExtend);
            var segmentAndCrossings = this.maxVisibilitySegmentsAndCrossings[dirIndex];
            if (null == segmentAndCrossings){
                var pacList;
                var maxVisibilitySegment = (function (){
                    var $1 = {
                        Value: pacList
                    };
                    var $res = transUtil.get_ObstacleTree().CreateMaxVisibilitySegment(startVertex.Point, dirToExtend, $1);
                    pacList = $1.Value;
                    return $res;
                }).call(this);
                segmentAndCrossings = new System.Tuple$2.ctor(Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor, Microsoft.Msagl.Routing.Rectilinear.PointAndCrossingsList.ctor, maxVisibilitySegment, pacList);
                this.maxVisibilitySegmentsAndCrossings[dirIndex] = segmentAndCrossings;
            }
            else {
                if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(startVertex.Point, segmentAndCrossings.get_Item1().get_Start()) == dirToExtend){
                    segmentAndCrossings.get_Item1().set_Start(startVertex.Point);
                }
            }
            return segmentAndCrossings;
        },
        MaxVisibilityInDirectionForNonOverlappedFreePoint: function (dirToExtend, transUtil){
            System.Diagnostics.Debug.Assert$$Boolean$$String(!this.get_IsOverlapped(), "Do not precalculate overlapped obstacle visibility as we should extend from the outer target vertex instead");
            var segmentAndCrossings = this.GetSegmentAndCrossings(this.get_Vertex(), dirToExtend, transUtil);
            return segmentAndCrossings.get_Item1().get_End();
        },
        SpliceIntoEdge: function (transUtil, edge){
            transUtil.SplitEdge$$VisibilityEdge$$VisibilityVertex(edge, this.get_Vertex());
        },
        AddOobEdgesFromGraphCorner: function (transUtil, cornerPoint){
            var dirs = Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(cornerPoint, this.get_Vertex().Point);
            var cornerVertex = transUtil.get_VisGraph().FindVertex(cornerPoint);
            transUtil.ConnectVertexToTargetVertex(cornerVertex, this.get_Vertex(), dirs & (5), 1);
            transUtil.ConnectVertexToTargetVertex(cornerVertex, this.get_Vertex(), dirs & (10), 1);
        },
        RemoveFromGraph: function (){
            this.set_Vertex(null);
        },
        toString: function (){
            return this.get_Vertex().toString();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$FreePoint);
var Microsoft$Msagl$Routing$Rectilinear$HighObstacleSide = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.HighObstacleSide",
    baseTypeName: "Microsoft.Msagl.Routing.Rectilinear.BasicObstacleSide",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (obstacle, startVertex, scanDir){
            Microsoft.Msagl.Routing.Rectilinear.BasicObstacleSide.ctor.call(this, obstacle, startVertex, scanDir, scanDir.get_IsVertical());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$HighObstacleSide);
var Microsoft$Msagl$Routing$Rectilinear$LowReflectionEvent = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.LowReflectionEvent",
    baseTypeName: "Microsoft.Msagl.Routing.Rectilinear.BasicReflectionEvent",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (previousSite, targetSide, site){
            this._Side = null;
            Microsoft.Msagl.Routing.Rectilinear.BasicReflectionEvent.ctor$$BasicReflectionEvent$$Obstacle$$Point.call(this, previousSite, targetSide.get_Obstacle(), site);
            this.set_Side(targetSide);
        },
        Side$$: "Microsoft.Msagl.Routing.Rectilinear.LowObstacleSide",
        get_Side: function (){
            return this._Side;
        },
        set_Side: function (value){
            this._Side = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$LowReflectionEvent);
var Microsoft$Msagl$Routing$Rectilinear$LookaheadScan = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.LookaheadScan",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IComparer$1"],
    Kind: "Class",
    definition: {
        ctor: function (scanDir){
            this.eventTree = null;
            this.findFirstPred = null;
            this.scanDirection = null;
            this.staleSites = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Rectilinear.BasicReflectionEvent.ctor);
            this.findFirstPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            System.Object.ctor.call(this);
            this.scanDirection = scanDir;
            this.eventTree = new Microsoft.Msagl.Core.DataStructures.RbTree$1.ctor$$IComparer$1(Microsoft.Msagl.Routing.Rectilinear.BasicReflectionEvent.ctor, this);
            this.findFirstPred = $CreateAnonymousDelegate(this, function (n){
                return this.CompareToFindFirstPoint(n.get_Site()) >= 0;
            });
        },
        Add: function (initialSite){
            System.Diagnostics.Debug.Assert$$Boolean$$String(null == this.Find(initialSite.get_Site()), "Should not add the same Lookahead coordinate twice");
            this.eventTree.Insert(initialSite);
        },
        MarkStaleSite: function (siteEvent){
            this.staleSites.Add(siteEvent);
        },
        RemoveStaleSites: function (){
            var cSites = this.staleSites.get_Count();
            if (cSites > 0){
                for (var ii = 0; ii < cSites; ++ii){
                    this.RemoveExact(this.staleSites.get_Item$$Int32(ii));
                }
                this.staleSites.Clear();
            }
        },
        RemoveSitesForFlatBottom: function (low, high){
            for (var node = this.FindFirstInRange(low, high); null != node; node = this.FindNextInRange(node, high)){
                this.MarkStaleSite(node.Item);
            }
            this.RemoveStaleSites();
        },
        Find: function (site){
            return this.FindFirstInRange(site, site);
        },
        Remove: function (initialSite){
            return null != this.eventTree.Remove(initialSite);
        },
        RemoveExact: function (initialSite){
            var node = this.eventTree.Find$$T(initialSite);
            if (null != node){
                if (Microsoft.Msagl.Core.Geometry.Point.op_Equality(node.Item.get_Site(), initialSite.get_Site())){
                    this.eventTree.DeleteNodeInternal(node);
                    return true;
                }
            }
            return false;
        },
        FindFirstInRange: function (low, high){
            this.findFirstPoint = low;
            var nextNode = this.eventTree.FindFirst$$Func$2(this.findFirstPred);
            if (null != nextNode){
                if (this.Compare$$Point$$Point(nextNode.Item.get_Site(), high) <= 0){
                    return nextNode;
                }
            }
            return null;
        },
        CompareToFindFirstPoint: function (treeItem){
            return this.Compare$$Point$$Point(treeItem, this.findFirstPoint);
        },
        FindNextInRange: function (prev, high){
            var nextNode = this.eventTree.Next(prev);
            if ((null != nextNode) && (this.Compare$$Point$$Point(nextNode.Item.get_Site(), high) <= 0)){
                return nextNode;
            }
            return null;
        },
        Compare$$BasicReflectionEvent$$BasicReflectionEvent: function (lhs, rhs){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(lhs, "lhs");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(rhs, "rhs");
            return this.scanDirection.CompareScanCoord(lhs.get_Site(), rhs.get_Site());
        },
        Compare$$Point$$Point: function (lhs, rhs){
            return this.scanDirection.CompareScanCoord(lhs, rhs);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$LookaheadScan);
var Microsoft$Msagl$Routing$Rectilinear$LowObstacleSide = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.LowObstacleSide",
    baseTypeName: "Microsoft.Msagl.Routing.Rectilinear.BasicObstacleSide",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (obstacle, startVertex, scanDir){
            Microsoft.Msagl.Routing.Rectilinear.BasicObstacleSide.ctor.call(this, obstacle, startVertex, scanDir, scanDir.get_IsHorizontal());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$LowObstacleSide);
var Microsoft$Msagl$Routing$Rectilinear$MsmtRectilinearPath = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.MsmtRectilinearPath",
    baseTypeName: "System.Object",
    staticDefinition: {
        RestorePathStages: function (waypointEntries, lastEntry){
            var paths = new System.Collections.Generic.List$1.ctor(System.Collections.Generic.IEnumerable$1.ctor);
            waypointEntries.Reverse();
            var $it1075 = waypointEntries.GetEnumerator();
            while ($it1075.MoveNext()){
                var waypointEntry = $it1075.get_Current();
                paths.Add((function (){
                    var $1 = {
                        Value: lastEntry
                    };
                    var $res = Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.RestorePath$$VertexEntry$$VisibilityVertex($1, waypointEntry.waypointVector[0]);
                    lastEntry = $1.Value;
                    return $res;
                })());
            }
            paths.Add(Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.RestorePath$$VertexEntry(lastEntry));
            paths.Reverse();
            return paths;
        },
        UpdateTargetEntriesForEachDirection: function (targetVertexEntries, tempTargetEntries, bestCost, bestEntry){
            for (var ii = 0; ii < tempTargetEntries.length; ++ii){
                var tempEntry = tempTargetEntries[ii];
                if (tempEntry == null){
                    continue;
                }
                if ((targetVertexEntries[ii] == null) || (tempEntry.get_Cost() < targetVertexEntries[ii].get_Cost())){
                    targetVertexEntries[ii] = tempEntry;
                    if (tempEntry.get_Cost() < bestCost.Value){
                        bestCost.Value = tempEntry.get_Cost();
                        bestEntry.Value = tempEntry;
                    }
                }
            }
            return;
        },
        GetBarycenterOfUniquePortLocations: function (vertices){
            var center = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            var prevVertex = null;
            var count = 0;
            var $it1077 = System.Linq.Enumerable.OrderBy$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, vertices, function (s){
                return s.Point;
            }).GetEnumerator();
            while ($it1077.MoveNext()){
                var vertex = $it1077.get_Current();
                if ((prevVertex != null) && Microsoft.Msagl.Core.Geometry.ApproximateComparer.CloseIntersections(vertex.Point, prevVertex.Point)){
                    continue;
                }
                prevVertex = vertex;
                ++count;
                center = Microsoft.Msagl.Core.Geometry.Point.op_Addition(center, vertex.Point);
            }
            return Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(center, count);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (bendPenalty){
            this.bendPenaltyAsAPercentageOfDistance = 4;
            this.currentPassTargetEntries = new Array(4);
            System.Object.ctor.call(this);
            this.bendPenaltyAsAPercentageOfDistance = bendPenalty;
        },
        GetPath$$IEnumerable$1$VisibilityVertex$$IEnumerable$1$VisibilityVertex: function (sources, targets){
            return Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.RestorePath$$VertexEntry(this.GetPathStage(null, sources, null, targets));
        },
        GetPath$$IEnumerable$1$VisibilityVertex$$IEnumerable$1$VisibilityVertex$$IEnumerable$1$VisibilityVertex: function (sources, waypoints, targets){
            var waypointEntries = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Rectilinear.MsmtRectilinearPath.WaypointEntry.ctor);
            var waypointEnum = waypoints.GetEnumerator();
            waypointEnum.MoveNext();
            var sourceWaypointEntry = new Microsoft.Msagl.Routing.Rectilinear.MsmtRectilinearPath.WaypointEntry.ctor(waypointEnum.get_Current());
            waypointEntries.Add(sourceWaypointEntry);
            var lastEntry;
            if (!this.GetFirstPathStage(sourceWaypointEntry, sources) || !(function (){
                var $1 = {
                    Value: sourceWaypointEntry
                };
                var $res = this.GetWaypointPathStages(waypointEnum, waypointEntries, $1);
                sourceWaypointEntry = $1.Value;
                return $res;
            }).call(this) || !(function (){
                var $1 = {
                    Value: lastEntry
                };
                var $res = this.GetLastPathStage(sourceWaypointEntry, targets, $1);
                lastEntry = $1.Value;
                return $res;
            }).call(this)){
                return null;
            }
            return Microsoft.Msagl.Routing.Rectilinear.MsmtRectilinearPath.RestorePathStages(waypointEntries, lastEntry);
        },
        GetFirstPathStage: function (sourceWaypointEntry, sources){
            return null != this.GetPathStage(null, sources, sourceWaypointEntry.entryVector, sourceWaypointEntry.waypointVector);
        },
        GetWaypointPathStages: function (waypointEnum, waypointEntries, sourceWaypointEntry){
            while (waypointEnum.MoveNext()){
                var targetWaypointEntry = new Microsoft.Msagl.Routing.Rectilinear.MsmtRectilinearPath.WaypointEntry.ctor(waypointEnum.get_Current());
                waypointEntries.Add(targetWaypointEntry);
                if (null == this.GetPathStage(sourceWaypointEntry.Value.entryVector, sourceWaypointEntry.Value.waypointVector, targetWaypointEntry.entryVector, targetWaypointEntry.waypointVector)){
                    return false;
                }
                sourceWaypointEntry.Value = targetWaypointEntry;
            }
            return true;
        },
        GetLastPathStage: function (sourceWaypointEntry, targets, lastEntry){
            lastEntry.Value = this.GetPathStage(sourceWaypointEntry.entryVector, sourceWaypointEntry.waypointVector, null, targets);
            return lastEntry.Value != null;
        },
        GetPathStage: function (sourceVertexEntries, sources, targetVertexEntries, targets){
            var ssstCalculator = new Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.ctor();
            var bestEntry = null;
            var bestCost = 3.59538626972463E+305;
            var bestPathCostRatio = Infinity;
            var sourceCenter = Microsoft.Msagl.Routing.Rectilinear.MsmtRectilinearPath.GetBarycenterOfUniquePortLocations(sources);
            var targetCenter = Microsoft.Msagl.Routing.Rectilinear.MsmtRectilinearPath.GetBarycenterOfUniquePortLocations(targets);
            var distance = Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.ManhattanDistance(sourceCenter, targetCenter);
            ssstCalculator.set_BendsImportance(System.Math.Max$$Double$$Double(0.001, distance * (this.bendPenaltyAsAPercentageOfDistance * 0.01)));
            var interiorLengthAdjustment = ssstCalculator.get_LengthImportance();
            var tempTargetEntries = (targetVertexEntries != null) ? this.currentPassTargetEntries : null;
            var $it1076 = System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(null, null, System.Linq.Enumerable.OrderBy$2$$IEnumerable$1$$Func$2(null, System.Double.ctor, System.Linq.Enumerable.SelectMany$3$$IEnumerable$1$$Func$2$$Func$3(Microsoft.Msagl.Routing.Rectilinear.VisibilityVertexRectilinear.ctor, Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor, null, System.Linq.Enumerable.Cast$1(Microsoft.Msagl.Routing.Rectilinear.VisibilityVertexRectilinear.ctor, sources), $CreateAnonymousDelegate(this, function (source){
                return targets;
            }), $CreateAnonymousDelegate(this, function (source, target){
                return $CreateAnonymousObject({
                    source: source,
                    target: target
                });
            })), $CreateAnonymousDelegate(this, function ($$x0){
                return Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.ManhattanDistance($$x0.get_source().Point, $$x0.get_target().Point);
            })), $CreateAnonymousDelegate(this, function ($$x1){
                return $CreateAnonymousObject({
                    sourceV: $$x1.get_source(),
                    targetV: $$x1.get_target()
                });
            })).GetEnumerator();
            while ($it1076.MoveNext()){
                var pair = $it1076.get_Current();
                var source = pair.get_sourceV();
                var target = pair.get_targetV();
                if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(source.Point, target.Point)){
                    continue;
                }
                var sourceCostAdjustment = Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.ManhattanDistance(source.Point, sourceCenter) * interiorLengthAdjustment;
                var targetCostAdjustment = Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.ManhattanDistance(target.Point, targetCenter) * interiorLengthAdjustment;
                var adjustedBestCost = bestCost;
                if (targetVertexEntries != null){
                    System.Array.Clear(tempTargetEntries, 0, tempTargetEntries.length);
                    adjustedBestCost = ssstCalculator.MultistageAdjustedCostBound(bestCost);
                }
                var lastEntry = ssstCalculator.GetPathWithCost(sourceVertexEntries, source, sourceCostAdjustment, tempTargetEntries, target, targetCostAdjustment, adjustedBestCost);
                if (tempTargetEntries != null){
                    (function (){
                        var $1 = {
                            Value: bestCost
                        };
                        var $2 = {
                            Value: bestEntry
                        };
                        var $res = Microsoft.Msagl.Routing.Rectilinear.MsmtRectilinearPath.UpdateTargetEntriesForEachDirection(targetVertexEntries, tempTargetEntries, $1, $2);
                        bestCost = $1.Value;
                        bestEntry = $2.Value;
                        return $res;
                    }).call(this);
                    continue;
                }
                if (lastEntry == null){
                    continue;
                }
                var costRatio = lastEntry.get_Cost() / Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.ManhattanDistance(source.Point, target.Point);
                if ((lastEntry.get_Cost() < bestCost) || Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(lastEntry.get_Cost(), bestCost) && (costRatio < bestPathCostRatio)){
                    bestCost = lastEntry.get_Cost();
                    bestEntry = lastEntry;
                    bestPathCostRatio = lastEntry.get_Cost() / Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.ManhattanDistance(source.Point, target.Point);
                }
            }
            return bestEntry;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$MsmtRectilinearPath);
var Microsoft$Msagl$Routing$Rectilinear$MsmtRectilinearPath$WaypointEntry = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.MsmtRectilinearPath.WaypointEntry",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (waypoint){
            this.waypointVector = new Array(1);
            this.entryVector = new Array(4);
            System.Object.ctor.call(this);
            this.waypointVector[0] = waypoint;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$MsmtRectilinearPath$WaypointEntry);
var Microsoft$Msagl$Routing$Rectilinear$Obstacle = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.Obstacle",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Routing.Rectilinear.Obstacle.FirstSentinelOrdinal = 1;
            Microsoft.Msagl.Routing.Rectilinear.Obstacle.FirstNonSentinelOrdinal = 10;
        },
        CreateLoosePolyline: function (polyline){
            var loosePolyline = Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CreatePaddedPolyline(polyline, Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_IntersectionEpsilon() * 10);
            Microsoft.Msagl.Routing.Rectilinear.Obstacle.RoundVertices(loosePolyline);
            return loosePolyline;
        },
        CreateSentinel: function (a, b, scanDir, scanlineOrdinal){
            var sentinel = new Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor$$Point$$Point$$Int32(a, b, scanlineOrdinal);
            sentinel.CreateInitialSides(sentinel.get_PaddedPolyline().get_StartPoint(), scanDir);
            return sentinel;
        },
        RoundVertices: function (polyline){
            var ppt = polyline.get_StartPoint();
            do{
                ppt.set_Point(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Point(ppt.get_Point()));
                ppt = ppt.get_NextOnPolyline();
            }
            while (ppt != polyline.get_StartPoint())
            Microsoft.Msagl.Routing.Rectilinear.Obstacle.RemoveCloseAndCollinearVerticesInPlace(polyline);
            polyline.RequireInit();
            System.Diagnostics.Debug.Assert$$Boolean$$String(polyline.IsClockwise(), "Polyline is not clockwise after RoundVertices");
        },
        RemoveCloseAndCollinearVerticesInPlace: function (polyline){
            var epsilon = Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_IntersectionEpsilon() * 10;
            for (var pp = polyline.get_StartPoint().get_Next(); pp != null; pp = pp.get_Next()){
                if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point$$Double(pp.get_Prev().get_Point(), pp.get_Point(), epsilon)){
                    if (pp.get_Next() == null){
                        polyline.RemoveEndPoint();
                    }
                    else {
                        pp.get_Prev().set_Next(pp.get_Next());
                        pp.get_Next().set_Prev(pp.get_Prev());
                    }
                }
            }
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point$$Double(polyline.get_Start(), polyline.get_End(), epsilon)){
                polyline.RemoveStartPoint();
            }
            Microsoft.Msagl.Routing.InteractiveEdgeRouter.RemoveCollinearVertices(polyline);
            if ((polyline.get_EndPoint().get_Prev() != null) && (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(polyline.get_EndPoint().get_Prev().get_Point(), polyline.get_End(), polyline.get_Start()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Collinear)){
                polyline.RemoveEndPoint();
            }
            if ((polyline.get_StartPoint().get_Next() != null) && (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(polyline.get_End(), polyline.get_Start(), polyline.get_StartPoint().get_Next().get_Point()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Collinear)){
                polyline.RemoveStartPoint();
            }
            return polyline;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$Shape$$Boolean$$Double: function (shape, makeRect, padding){
            this.looseVisibilityPolyline = null;
            this._ActiveLowSide = null;
            this._ActiveHighSide = null;
            this._InputShape = null;
            this._IsRectangle = false;
            this._PaddedPolyline = null;
            this._Ordinal = 0;
            this._Clump = null;
            this._OverlapsGroupCorner = false;
            this._ConvexHull = null;
            this._Ports = null;
            System.Object.ctor.call(this);
            if (makeRect){
                var paddedBox = shape.get_BoundingBox();
                paddedBox.Pad$$Double(padding);
                this.set_PaddedPolyline(Microsoft.Msagl.Core.Geometry.Curves.Curve.PolyFromBox(paddedBox));
            }
            else {
                this.set_PaddedPolyline(Microsoft.Msagl.Routing.InteractiveObstacleCalculator.PaddedPolylineBoundaryOfNode(shape.get_BoundaryCurve(), padding));
            }
            Microsoft.Msagl.Routing.Rectilinear.Obstacle.RoundVertices(this.get_PaddedPolyline());
            this.set_IsRectangle(this.IsPolylineRectangle());
            if (!this.get_IsRectangle()){
                this.ConvertToRectangleIfClose();
            }
            this.set_InputShape(shape);
            this.set_Ports(new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Port.ctor, this.get_InputShape().get_Ports()));
        },
        ctor$$Point$$Point$$Int32: function (a, b, scanlineOrdinal){
            this.looseVisibilityPolyline = null;
            this._ActiveLowSide = null;
            this._ActiveHighSide = null;
            this._InputShape = null;
            this._IsRectangle = false;
            this._PaddedPolyline = null;
            this._Ordinal = 0;
            this._Clump = null;
            this._OverlapsGroupCorner = false;
            this._ConvexHull = null;
            this._Ports = null;
            System.Object.ctor.call(this);
            this.set_PaddedPolyline((function (){
                var $v120 = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor$$Point$$Point(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Point(a), Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Point(b));
                $v120.set_Closed(true);
                return $v120;
            }).call(this));
            this.set_Ordinal(scanlineOrdinal);
        },
        ActiveLowSide$$: "Microsoft.Msagl.Routing.Rectilinear.LowObstacleSide",
        get_ActiveLowSide: function (){
            return this._ActiveLowSide;
        },
        set_ActiveLowSide: function (value){
            this._ActiveLowSide = value;
        },
        ActiveHighSide$$: "Microsoft.Msagl.Routing.Rectilinear.HighObstacleSide",
        get_ActiveHighSide: function (){
            return this._ActiveHighSide;
        },
        set_ActiveHighSide: function (value){
            this._ActiveHighSide = value;
        },
        InputShape$$: "Microsoft.Msagl.Routing.Shape",
        get_InputShape: function (){
            return this._InputShape;
        },
        set_InputShape: function (value){
            this._InputShape = value;
        },
        IsRectangle$$: "System.Boolean",
        get_IsRectangle: function (){
            return this._IsRectangle;
        },
        set_IsRectangle: function (value){
            this._IsRectangle = value;
        },
        PaddedPolyline$$: "Microsoft.Msagl.Core.Geometry.Curves.Polyline",
        get_PaddedPolyline: function (){
            return this._PaddedPolyline;
        },
        set_PaddedPolyline: function (value){
            this._PaddedPolyline = value;
        },
        VisibilityPolyline$$: "Microsoft.Msagl.Core.Geometry.Curves.Polyline",
        get_VisibilityPolyline: function (){
            return (this.get_ConvexHull() != null) ? this.get_ConvexHull().get_Polyline() : this.get_PaddedPolyline();
        },
        LooseVisibilityPolyline$$: "Microsoft.Msagl.Core.Geometry.Curves.Polyline",
        get_LooseVisibilityPolyline: function (){
            if (this.looseVisibilityPolyline == null){
                this.looseVisibilityPolyline = Microsoft.Msagl.Routing.Rectilinear.Obstacle.CreateLoosePolyline(this.get_VisibilityPolyline());
            }
            return this.looseVisibilityPolyline;
        },
        PaddedBoundingBox$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_PaddedBoundingBox: function (){
            return this.get_PaddedPolyline().get_BoundingBox();
        },
        VisibilityBoundingBox$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_VisibilityBoundingBox: function (){
            return this.get_VisibilityPolyline().get_BoundingBox();
        },
        IsGroup$$: "System.Boolean",
        get_IsGroup: function (){
            return (null != this.get_InputShape()) && this.get_InputShape().get_IsGroup();
        },
        IsTransparentAncestor$$: "System.Boolean",
        get_IsTransparentAncestor: function (){
            return this.get_InputShape() == null ? false : this.get_InputShape().get_IsTransparent();
        },
        set_IsTransparentAncestor: function (value){
            if (this.get_InputShape() == null)
                throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            this.get_InputShape().set_IsTransparent(value);
        },
        Ordinal$$: "System.Int32",
        get_Ordinal: function (){
            return this._Ordinal;
        },
        set_Ordinal: function (value){
            this._Ordinal = value;
        },
        Clump$$: "Microsoft.Msagl.Routing.Rectilinear.Clump",
        get_Clump: function (){
            return this._Clump;
        },
        set_Clump: function (value){
            this._Clump = value;
        },
        IsOverlapped$$: "System.Boolean",
        get_IsOverlapped: function (){
            System.Diagnostics.Debug.Assert$$Boolean$$String((this.get_Clump() == null) || !this.get_IsGroup(), "Groups should not be considered overlapped");
            System.Diagnostics.Debug.Assert$$Boolean$$String((this.get_Clump() == null) || (this.get_ConvexHull() == null), "Clumped obstacles should not have overlapped convex hulls");
            return (this.get_Clump() != null);
        },
        IsInSameClump: function (other){
            return this.get_IsOverlapped() && (this.get_Clump() == other.get_Clump());
        },
        OverlapsGroupCorner$$: "System.Boolean",
        get_OverlapsGroupCorner: function (){
            return this._OverlapsGroupCorner;
        },
        set_OverlapsGroupCorner: function (value){
            this._OverlapsGroupCorner = value;
        },
        IsPrimaryObstacle$$: "System.Boolean",
        get_IsPrimaryObstacle: function (){
            return (this.get_ConvexHull() == null) || (this == this.get_ConvexHull().get_PrimaryObstacle());
        },
        ConvexHull$$: "Microsoft.Msagl.Routing.Rectilinear.OverlapConvexHull",
        get_ConvexHull: function (){
            return this._ConvexHull;
        },
        set_ConvexHull: function (value){
            this._ConvexHull = value;
        },
        IsInConvexHull$$: "System.Boolean",
        get_IsInConvexHull: function (){
            return this.get_ConvexHull() != null;
        },
        SetConvexHull: function (hull){
            this.set_Clump(null);
            this.set_IsRectangle(false);
            this.set_ConvexHull(hull);
            this.looseVisibilityPolyline = null;
        },
        Ports$$: "Microsoft.Msagl.Core.DataStructures.Set`1[[Microsoft.Msagl.Core.Layout.Port]]",
        get_Ports: function (){
            return this._Ports;
        },
        set_Ports: function (value){
            this._Ports = value;
        },
        IsSentinel$$: "System.Boolean",
        get_IsSentinel: function (){
            return null == this.get_InputShape();
        },
        CreateInitialSides: function (startPoint, scanDir){
            System.Diagnostics.Debug.Assert$$Boolean$$String((null == this.get_ActiveLowSide()) && (null == this.get_ActiveHighSide()), "Cannot call SetInitialSides when sides are already set");
            this.set_ActiveLowSide(new Microsoft.Msagl.Routing.Rectilinear.LowObstacleSide.ctor(this, startPoint, scanDir));
            this.set_ActiveHighSide(new Microsoft.Msagl.Routing.Rectilinear.HighObstacleSide.ctor(this, startPoint, scanDir));
            if (scanDir.IsFlat$$SegmentBase(this.get_ActiveHighSide())){
                this.set_ActiveHighSide(new Microsoft.Msagl.Routing.Rectilinear.HighObstacleSide.ctor(this, this.get_ActiveHighSide().get_EndVertex(), scanDir));
            }
        },
        Close: function (){
            this.set_ActiveLowSide(null);
            this.set_ActiveHighSide(null);
        },
        IsPolylineRectangle: function (){
            if (System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor, this.get_PaddedPolyline().get_PolylinePoints()) != 4){
                return false;
            }
            var ppt = this.get_PaddedPolyline().get_StartPoint();
            var nextPpt = ppt.get_NextOnPolyline();
            var dir = Microsoft.Msagl.Core.Geometry.CompassVector.DirectionsFromPointToPoint(ppt.get_Point(), nextPpt.get_Point());
            if (!Microsoft.Msagl.Core.Geometry.CompassVector.IsPureDirection$$Directions(dir)){
                return false;
            }
            do{
                ppt = nextPpt;
                nextPpt = ppt.get_NextOnPolyline();
                var nextDir = Microsoft.Msagl.Core.Geometry.CompassVector.DirectionsFromPointToPoint(ppt.get_Point(), nextPpt.get_Point());
                if (nextDir != Microsoft.Msagl.Core.Geometry.CompassVector.RotateRight(dir)){
                    return false;
                }
                dir = nextDir;
            }
            while (ppt != this.get_PaddedPolyline().get_StartPoint())
            return true;
        },
        ConvertToRectangleIfClose: function (){
            if (System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor, this.get_PaddedPolyline().get_PolylinePoints()) != 4){
                return;
            }
            var ppt = this.get_PaddedPolyline().get_StartPoint();
            var nextPpt = ppt.get_NextOnPolyline();
            var testPoint = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(ppt.get_Point(), nextPpt.get_Point());
            var slope = ((testPoint.get_X() == 0) || (testPoint.get_Y() == 0)) ? 0 : System.Math.Abs$$Double(testPoint.get_Y() / testPoint.get_X());
            var factor = 1000;
            if ((slope < factor) && (slope > (0.001))){
                return;
            }
            var radian90 = 1.5707963267949;
            var maxAngleDiff = 0.0015707963267949;
            do{
                var nextNextPpt = nextPpt.get_NextOnPolyline();
                var angle = Microsoft.Msagl.Core.Geometry.Point.Angle$$Point$$Point$$Point(ppt.get_Point(), nextPpt.get_Point(), nextNextPpt.get_Point());
                if (System.Math.Abs$$Double(radian90 - angle) > maxAngleDiff){
                    return;
                }
                ppt = nextPpt;
                nextPpt = nextNextPpt;
            }
            while (ppt != this.get_PaddedPolyline().get_StartPoint())
            this.set_PaddedPolyline(Microsoft.Msagl.Core.Geometry.Curves.Curve.PolyFromBox(this.get_PaddedPolyline().get_BoundingBox()));
            this.set_IsRectangle(true);
            System.Diagnostics.Debug.Assert$$Boolean$$String(this.IsPolylineRectangle(), "PaddedPolyline is not rectangular");
            return;
        },
        GetPortChanges: function (addedPorts, removedPorts){
            addedPorts.Value = Microsoft.Msagl.Core.DataStructures.Set$1.op_Subtraction(this.get_InputShape().get_Ports(), this.get_Ports());
            removedPorts.Value = Microsoft.Msagl.Core.DataStructures.Set$1.op_Subtraction(this.get_Ports(), this.get_InputShape().get_Ports());
            if ((0 == addedPorts.Value.get_Count()) && (0 == removedPorts.Value.get_Count())){
                return false;
            }
            this.set_Ports(new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Port.ctor, this.get_InputShape().get_Ports()));
            return true;
        },
        toString: function (){
            var typeString = this.GetType().toString();
            var lastDotLoc = typeString.lastIndexOf(".");
            if (lastDotLoc >= 0){
                typeString = typeString.substr(lastDotLoc + 1);
            }
            return typeString + " [" + this.get_InputShape() + "]";
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$Obstacle);
var Microsoft$Msagl$Routing$Rectilinear$ObstaclePort = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.ObstaclePort",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (port, obstacle){
            this.CenterVertex = null;
            this.VisibilityRectangle = Microsoft.Msagl.Core.Geometry.Rectangle.CreateAnEmptyBox();
            this._Port = null;
            this._Obstacle = null;
            this._PortEntrances = null;
            this._HasCollinearEntrances = false;
            this._Location = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            System.Object.ctor.call(this);
            this.set_Port(port);
            this.set_Obstacle(obstacle);
            this.set_PortEntrances(new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Rectilinear.ObstaclePortEntrance.ctor));
            this.set_Location(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Point(this.get_Port().get_Location()));
        },
        Port$$: "Microsoft.Msagl.Core.Layout.Port",
        get_Port: function (){
            return this._Port;
        },
        set_Port: function (value){
            this._Port = value;
        },
        Obstacle$$: "Microsoft.Msagl.Routing.Rectilinear.Obstacle",
        get_Obstacle: function (){
            return this._Obstacle;
        },
        set_Obstacle: function (value){
            this._Obstacle = value;
        },
        PortEntrances$$: "System.Collections.Generic.List`1[[Microsoft.Msagl.Routing.Rectilinear.ObstaclePortEntrance]]",
        get_PortEntrances: function (){
            return this._PortEntrances;
        },
        set_PortEntrances: function (value){
            this._PortEntrances = value;
        },
        HasCollinearEntrances$$: "System.Boolean",
        get_HasCollinearEntrances: function (){
            return this._HasCollinearEntrances;
        },
        set_HasCollinearEntrances: function (value){
            this._HasCollinearEntrances = value;
        },
        Location$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Location: function (){
            return this._Location;
        },
        set_Location: function (value){
            this._Location = value;
        },
        CreatePortEntrance: function (unpaddedBorderIntersect, outDir, obstacleTree){
            var entrance = new Microsoft.Msagl.Routing.Rectilinear.ObstaclePortEntrance.ctor(this, unpaddedBorderIntersect, outDir, obstacleTree);
            this.get_PortEntrances().Add(entrance);
            this.VisibilityRectangle.Add$$Point(entrance.get_MaxVisibilitySegment().get_End());
            this.set_HasCollinearEntrances(this.get_HasCollinearEntrances() | entrance.get_IsCollinearWithPort());
        },
        Clear: function (){
            this.RemoveFromGraph();
            this.get_PortEntrances().Clear();
        },
        ClearVisibility: function (){
            this.get_PortEntrances().Clear();
        },
        AddToGraph: function (transUtil, routeToCenter){
            if (routeToCenter){
                this.CenterVertex = transUtil.FindOrAddVertex(this.get_Location());
            }
        },
        RemoveFromGraph: function (){
            var $it1078 = this.get_PortEntrances().GetEnumerator();
            while ($it1078.MoveNext()){
                var entrance = $it1078.get_Current();
                entrance.RemoveFromGraph();
            }
            this.CenterVertex = null;
        },
        LocationHasChanged$$: "System.Boolean",
        get_LocationHasChanged: function (){
            return !Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(this.get_Location(), Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Point(this.get_Port().get_Location()));
        },
        PortCurve$$: "Microsoft.Msagl.Core.Geometry.Curves.ICurve",
        get_PortCurve: function (){
            return this.get_Port().get_Curve();
        },
        PortLocation$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_PortLocation: function (){
            return this.get_Port().get_Location();
        },
        toString: function (){
            return this.get_Port() + this.get_Obstacle().toString();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$ObstaclePort);
var Microsoft$Msagl$Routing$Rectilinear$ObstaclePortEntrance = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.ObstaclePortEntrance",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (oport, unpaddedBorderIntersect, outDir, obstacleTree){
            this.unpaddedToPaddedBorderWeight = 1;
            this.pointAndCrossingsList = null;
            this._ObstaclePort = null;
            this._UnpaddedBorderIntersect = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._OutwardDirection = Microsoft.Msagl.Core.Geometry.Directions.None;
            this._VisibilityBorderIntersect = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._IsOverlapped = false;
            this._MaxVisibilitySegment = null;
            System.Object.ctor.call(this);
            this.set_ObstaclePort(oport);
            this.set_UnpaddedBorderIntersect(unpaddedBorderIntersect);
            this.set_OutwardDirection(outDir);
            var lineSeg = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(this.get_UnpaddedBorderIntersect(), Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.RectangleBorderIntersect(oport.get_Obstacle().get_VisibilityBoundingBox(), this.get_UnpaddedBorderIntersect(), outDir));
            var xxs = Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(lineSeg, oport.get_Obstacle().get_VisibilityPolyline(), true);
            System.Diagnostics.Debug.Assert$$Boolean$$String(1 == xxs.get_Count(), "Expected one intersection");
            this.set_VisibilityBorderIntersect(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Point(Microsoft.Msagl.Routing.Rectilinear.SpliceUtility.RawIntersection(xxs.get_Item$$Int32(0), this.get_UnpaddedBorderIntersect())));
            this.set_MaxVisibilitySegment((function (){
                var $1 = {
                    Value: this.pointAndCrossingsList
                };
                var $res = obstacleTree.CreateMaxVisibilitySegment(this.get_VisibilityBorderIntersect(), this.get_OutwardDirection(), $1);
                this.pointAndCrossingsList = $1.Value;
                return $res;
            }).call(this));
            if (this.get_Obstacle().get_IsOverlapped() || (this.get_Obstacle().get_IsGroup() && !this.get_Obstacle().get_IsInConvexHull())){
                this.set_IsOverlapped(obstacleTree.IntersectionIsInsideAnotherObstacle(null, this.get_Obstacle(), this.get_VisibilityBorderIntersect(), Microsoft.Msagl.Routing.Rectilinear.ScanDirection.GetInstance(this.get_OutwardDirection())));
                if (!this.get_Obstacle().get_IsGroup() || this.get_IsOverlapped() || this.InteriorEdgeCrossesObstacle$$ObstacleTree(obstacleTree)){
                    this.unpaddedToPaddedBorderWeight = 500;
                }
            }
            if (this.get_Obstacle().get_IsInConvexHull() && (this.unpaddedToPaddedBorderWeight == 1)){
                this.SetUnpaddedToPaddedBorderWeightFromHullSiblingOverlaps(obstacleTree);
            }
        },
        ObstaclePort$$: "Microsoft.Msagl.Routing.Rectilinear.ObstaclePort",
        get_ObstaclePort: function (){
            return this._ObstaclePort;
        },
        set_ObstaclePort: function (value){
            this._ObstaclePort = value;
        },
        Obstacle$$: "Microsoft.Msagl.Routing.Rectilinear.Obstacle",
        get_Obstacle: function (){
            return this.get_ObstaclePort().get_Obstacle();
        },
        UnpaddedBorderIntersect$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_UnpaddedBorderIntersect: function (){
            return this._UnpaddedBorderIntersect;
        },
        set_UnpaddedBorderIntersect: function (value){
            this._UnpaddedBorderIntersect = value;
        },
        OutwardDirection$$: "Microsoft.Msagl.Core.Geometry.Directions",
        get_OutwardDirection: function (){
            return this._OutwardDirection;
        },
        set_OutwardDirection: function (value){
            this._OutwardDirection = value;
        },
        VisibilityBorderIntersect$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_VisibilityBorderIntersect: function (){
            return this._VisibilityBorderIntersect;
        },
        set_VisibilityBorderIntersect: function (value){
            this._VisibilityBorderIntersect = value;
        },
        IsOverlapped$$: "System.Boolean",
        get_IsOverlapped: function (){
            return this._IsOverlapped;
        },
        set_IsOverlapped: function (value){
            this._IsOverlapped = value;
        },
        InitialWeight$$: "System.Double",
        get_InitialWeight: function (){
            return this.get_IsOverlapped() ? 500 : 1;
        },
        IsCollinearWithPort$$: "System.Boolean",
        get_IsCollinearWithPort: function (){
            return Microsoft.Msagl.Core.Geometry.CompassVector.IsPureDirection$$Directions(Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(this.get_VisibilityBorderIntersect(), this.get_ObstaclePort().get_Location()));
        },
        MaxVisibilitySegment$$: "Microsoft.Msagl.Core.Geometry.Curves.LineSegment",
        get_MaxVisibilitySegment: function (){
            return this._MaxVisibilitySegment;
        },
        set_MaxVisibilitySegment: function (value){
            this._MaxVisibilitySegment = value;
        },
        IsVertical$$: "System.Boolean",
        get_IsVertical: function (){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsVertical$$LineSegment(this.get_MaxVisibilitySegment());
        },
        WantVisibilityIntersection$$: "System.Boolean",
        get_WantVisibilityIntersection: function (){
            return !this.get_IsOverlapped() && this.get_CanExtend() && (!this.get_ObstaclePort().get_HasCollinearEntrances() || this.get_IsCollinearWithPort());
        },
        CanExtend$$: "System.Boolean",
        get_CanExtend: function (){
            return Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(this.get_MaxVisibilitySegment().get_Start(), this.get_MaxVisibilitySegment().get_End()) != Microsoft.Msagl.Core.Geometry.Directions.None;
        },
        SetUnpaddedToPaddedBorderWeightFromHullSiblingOverlaps: function (obstacleTree){
            if (this.get_Obstacle().get_IsGroup() ? this.InteriorEdgeCrossesObstacle$$ObstacleTree(obstacleTree) : this.InteriorEdgeCrossesConvexHullSiblings()){
                this.unpaddedToPaddedBorderWeight = 500;
            }
        },
        InteriorEdgeCrossesObstacle$$ObstacleTree: function (obstacleTree){
            var rect = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(this.get_UnpaddedBorderIntersect(), this.get_VisibilityBorderIntersect());
            return this.InteriorEdgeCrossesObstacle$$Rectangle$$Func$2$Obstacle$Polyline$$IEnumerable$1$Obstacle(rect, $CreateAnonymousDelegate(this, function (obs){
                return obs.get_VisibilityPolyline();
            }), System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, obstacleTree.get_Root().GetLeafRectangleNodesIntersectingRectangle(rect), $CreateAnonymousDelegate(this, function (node){
                return !node.get_UserData().get_IsGroup() && (node.get_UserData() != this.get_Obstacle());
            })), $CreateAnonymousDelegate(this, function (node){
                return node.get_UserData();
            })));
        },
        InteriorEdgeCrossesConvexHullSiblings: function (){
            var rect = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(this.get_UnpaddedBorderIntersect(), this.get_VisibilityBorderIntersect());
            return this.InteriorEdgeCrossesObstacle$$Rectangle$$Func$2$Obstacle$Polyline$$IEnumerable$1$Obstacle(rect, $CreateAnonymousDelegate(this, function (obs){
                return obs.get_PaddedPolyline();
            }), System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor, this.get_Obstacle().get_ConvexHull().get_Obstacles(), $CreateAnonymousDelegate(this, function (obs){
                return obs != this.get_Obstacle();
            })));
        },
        InteriorEdgeCrossesObstacle$$Rectangle$$Func$2$Obstacle$Polyline$$IEnumerable$1$Obstacle: function (rect, whichPolylineToUse, candidates){
            var lineSeg = null;
            var $it1079 = candidates.GetEnumerator();
            while ($it1079.MoveNext()){
                var blocker = $it1079.get_Current();
                var blockerPolyline = whichPolylineToUse(blocker);
                if (!Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.RectangleInteriorsIntersect(rect, blockerPolyline.get_BoundingBox())){
                    continue;
                }
                lineSeg = (lineSeg != null ? lineSeg : new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(this.get_UnpaddedBorderIntersect(), this.get_VisibilityBorderIntersect()));
                var xx = Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveIntersectionOne(lineSeg, blockerPolyline, false);
                if (xx != null){
                    return true;
                }
                if (Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside != Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(this.get_UnpaddedBorderIntersect(), blockerPolyline)){
                    return true;
                }
            }
            return false;
        },
        HasGroupCrossings$$: "System.Boolean",
        get_HasGroupCrossings: function (){
            return (this.pointAndCrossingsList != null) && (this.pointAndCrossingsList.get_Count() > 0);
        },
        HasGroupCrossingBeforePoint: function (point){
            if (!this.get_HasGroupCrossings()){
                return false;
            }
            var pac = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsAscending$$Directions(this.get_OutwardDirection()) ? this.pointAndCrossingsList.get_First() : this.pointAndCrossingsList.get_Last();
            return Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(this.get_MaxVisibilitySegment().get_Start(), pac.get_Location()) == Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(pac.get_Location(), point);
        },
        AddToAdjacentVertex: function (transUtil, targetVertex, limitRect, routeToCenter){
            var borderVertex = transUtil.get_VisGraph().FindVertex(this.get_VisibilityBorderIntersect());
            if (null != borderVertex){
                this.ExtendFromBorderVertex(transUtil, borderVertex, limitRect, routeToCenter);
                return;
            }
            if (this.get_OutwardDirection() == Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$Point$$Point(targetVertex.Point, this.get_VisibilityBorderIntersect())){
                System.Diagnostics.Debug.Assert$$Boolean$$String(false, "Unexpected reversed direction between VisibilityBorderIntersect and targetVertex");
                this.set_VisibilityBorderIntersect(targetVertex.Point);
                borderVertex = targetVertex;
            }
            else {
                borderVertex = transUtil.FindOrAddVertex(this.get_VisibilityBorderIntersect());
                transUtil.FindOrAddEdge$$VisibilityVertex$$VisibilityVertex$$Double(borderVertex, targetVertex, this.get_InitialWeight());
            }
            this.ExtendEdgeChain(transUtil, borderVertex, targetVertex, limitRect, routeToCenter);
        },
        ExtendFromBorderVertex: function (transUtil, borderVertex, limitRect, routeToCenter){
            this.ExtendEdgeChain(transUtil, borderVertex, borderVertex, limitRect, routeToCenter);
        },
        ExtendEdgeChain: function (transUtil, paddedBorderVertex, targetVertex, limitRect, routeToCenter){
            transUtil.ExtendEdgeChain$$VisibilityVertex$$Rectangle$$LineSegment$$PointAndCrossingsList$$Boolean(targetVertex, limitRect, this.get_MaxVisibilitySegment(), this.pointAndCrossingsList, this.get_IsOverlapped());
            var unpaddedBorderVertex = transUtil.FindOrAddVertex(this.get_UnpaddedBorderIntersect());
            transUtil.FindOrAddEdge$$VisibilityVertex$$VisibilityVertex$$Double(unpaddedBorderVertex, paddedBorderVertex, this.unpaddedToPaddedBorderWeight);
            if (routeToCenter){
                transUtil.ConnectVertexToTargetVertex(this.get_ObstaclePort().CenterVertex, unpaddedBorderVertex, this.get_OutwardDirection(), this.get_InitialWeight());
            }
        },
        RemoveFromGraph: function (){
        },
        toString: function (){
            return System.String.Format$$IFormatProvider$$String$$Object$Array(System.Globalization.CultureInfo.get_InvariantCulture(), "{0} {1}~{2} {3}", [this.get_ObstaclePort().get_Location(), this.get_UnpaddedBorderIntersect(), this.get_VisibilityBorderIntersect(), this.get_OutwardDirection()]);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$ObstaclePortEntrance);
var Microsoft$Msagl$Routing$Rectilinear$PortManager = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.PortManager",
    baseTypeName: "System.Object",
    staticDefinition: {
        GetPathPointsFromOverlappingCollinearVisibility: function (sourceEntrance, targetEntrance){
            if (!Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IntervalsAreSame(sourceEntrance.get_MaxVisibilitySegment().get_Start(), sourceEntrance.get_MaxVisibilitySegment().get_End(), targetEntrance.get_MaxVisibilitySegment().get_End(), targetEntrance.get_MaxVisibilitySegment().get_Start())){
                return null;
            }
            if (sourceEntrance.get_HasGroupCrossings() || targetEntrance.get_HasGroupCrossings()){
                return null;
            }
            if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(sourceEntrance.get_UnpaddedBorderIntersect(), targetEntrance.get_UnpaddedBorderIntersect())){
                return null;
            }
            return [sourceEntrance.get_UnpaddedBorderIntersect(), targetEntrance.get_UnpaddedBorderIntersect()];
        },
        GetPathPointsFromIntersectingVisibility: function (sourceEntrance, targetEntrance){
            var intersect;
            if (!(function (){
                var $1 = {
                    Value: intersect
                };
                var $res = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.SegmentsIntersect$$LineSegment$$LineSegment$$Point(sourceEntrance.get_MaxVisibilitySegment(), targetEntrance.get_MaxVisibilitySegment(), $1);
                intersect = $1.Value;
                return $res;
            })()){
                return null;
            }
            if (sourceEntrance.HasGroupCrossingBeforePoint(intersect) || targetEntrance.HasGroupCrossingBeforePoint(intersect)){
                return null;
            }
            return [sourceEntrance.get_UnpaddedBorderIntersect(), intersect, targetEntrance.get_UnpaddedBorderIntersect()];
        },
        GetDerivative: function (oport, borderPoint){
            var param = oport.get_PortCurve().ClosestParameter(borderPoint);
            var deriv = oport.get_PortCurve().Derivative(param);
            var parMid = (oport.get_PortCurve().get_ParStart() + oport.get_PortCurve().get_ParEnd()) / 2;
            if (!Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CurveIsClockwise(oport.get_PortCurve(), oport.get_PortCurve().get_Item$$Double(parMid))){
                deriv = Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(deriv);
            }
            return deriv;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (graphGenerator){
            this.obstaclePortMap = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Port.ctor, Microsoft.Msagl.Routing.Rectilinear.ObstaclePort.ctor);
            this.freePointMap = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Routing.Rectilinear.FreePoint.ctor);
            this.freePointLocationsUsedByRouteEdges = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            this.graphGenerator = null;
            this.obstaclePortsInGraph = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Rectilinear.ObstaclePort.ctor);
            this.freePointsInGraph = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Routing.Rectilinear.FreePoint.ctor);
            this.portSpliceLimitRectangle = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
            this.activeAncestors = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor);
            this._TransUtil = null;
            this._RouteToCenterOfObstacles = false;
            System.Object.ctor.call(this);
            this.set_TransUtil(new Microsoft.Msagl.Routing.Rectilinear.TransientGraphUtility.ctor(graphGenerator));
            this.graphGenerator = graphGenerator;
        },
        TransUtil$$: "Microsoft.Msagl.Routing.Rectilinear.TransientGraphUtility",
        get_TransUtil: function (){
            return this._TransUtil;
        },
        set_TransUtil: function (value){
            this._TransUtil = value;
        },
        RouteToCenterOfObstacles$$: "System.Boolean",
        get_RouteToCenterOfObstacles: function (){
            return this._RouteToCenterOfObstacles;
        },
        set_RouteToCenterOfObstacles: function (value){
            this._RouteToCenterOfObstacles = value;
        },
        LimitPortVisibilitySpliceToEndpointBoundingBox$$: "System.Boolean",
        get_LimitPortVisibilitySpliceToEndpointBoundingBox: function (){
            return this.get_TransUtil().get_LimitPortVisibilitySpliceToEndpointBoundingBox();
        },
        set_LimitPortVisibilitySpliceToEndpointBoundingBox: function (value){
            this.get_TransUtil().set_LimitPortVisibilitySpliceToEndpointBoundingBox(value);
        },
        VisGraph$$: "Microsoft.Msagl.Routing.Visibility.VisibilityGraph",
        get_VisGraph: function (){
            return this.graphGenerator.get_VisibilityGraph();
        },
        HScanSegments$$: "Microsoft.Msagl.Routing.Rectilinear.ScanSegmentTree",
        get_HScanSegments: function (){
            return this.graphGenerator.HorizontalScanSegments;
        },
        VScanSegments$$: "Microsoft.Msagl.Routing.Rectilinear.ScanSegmentTree",
        get_VScanSegments: function (){
            return this.graphGenerator.VerticalScanSegments;
        },
        ObstacleTree$$: "Microsoft.Msagl.Routing.Rectilinear.ObstacleTree",
        get_ObstacleTree: function (){
            return this.graphGenerator.ObstacleTree;
        },
        AncestorSets$$: "System.Collections.Generic.Dictionary`2[[Microsoft.Msagl.Routing.Shape],[Microsoft.Msagl.Core.DataStructures.Set`1[[Microsoft.Msagl.Routing.Shape]]]]",
        get_AncestorSets: function (){
            return this.get_ObstacleTree().AncestorSets;
        },
        Clear: function (){
            this.get_TransUtil().RemoveFromGraph();
            this.obstaclePortMap.Clear();
        },
        CreateObstaclePorts: function (obstacle){
            var $it1080 = obstacle.get_Ports().GetEnumerator();
            while ($it1080.MoveNext()){
                var port = $it1080.get_Current();
                this.CreateObstaclePort(obstacle, port);
            }
        },
        CreateObstaclePort: function (obstacle, port){
            System.Diagnostics.Debug.Assert$$Boolean$$String(!this.obstaclePortMap.ContainsKey(port), "Port is used by more than one obstacle");
            if (null == port.get_Curve()){
                return null;
            }
            var roundedLocation = Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Point(port.get_Location());
            if (Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside == Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(roundedLocation, obstacle.get_InputShape().get_BoundaryCurve())){
                return null;
            }
            if ((obstacle.get_InputShape().get_BoundaryCurve() != port.get_Curve()) && (Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside == Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(roundedLocation, port.get_Curve()))){
                return null;
            }
            var oport = new Microsoft.Msagl.Routing.Rectilinear.ObstaclePort.ctor(port, obstacle);
            this.obstaclePortMap.set_Item$$TKey(port, oport);
            return oport;
        },
        FindVertices: function (port){
            var vertices = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor);
            var oport;
            if ((function (){
                var $1 = {
                    Value: oport
                };
                var $res = this.obstaclePortMap.TryGetValue(port, $1);
                oport = $1.Value;
                return $res;
            }).call(this)){
                if (this.get_RouteToCenterOfObstacles()){
                    vertices.Add(oport.CenterVertex);
                    return vertices;
                }
                var $it1081 = oport.get_PortEntrances().GetEnumerator();
                while ($it1081.MoveNext()){
                    var entrance = $it1081.get_Current();
                    var vertex = this.get_VisGraph().FindVertex(entrance.get_UnpaddedBorderIntersect());
                    if (null != vertex){
                        vertices.Add(vertex);
                    }
                }
                return vertices;
            }
            vertices.Add(this.get_VisGraph().FindVertex(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Point(port.get_Location())));
            return vertices;
        },
        RemoveObstaclePorts: function (obstacle){
            var $it1082 = obstacle.get_Ports().GetEnumerator();
            while ($it1082.MoveNext()){
                var port = $it1082.get_Current();
                this.RemoveObstaclePort(port);
            }
        },
        RemoveObstaclePort: function (port){
            this.obstaclePortMap.Remove(port);
        },
        AddControlPointsToGraph: function (edgeGeom, shapeToObstacleMap){
            this.GetPortSpliceLimitRectangle(edgeGeom);
            this.activeAncestors.Clear();
            var sourceOport,targetOport;
            var ssAncs = (function (){
                var $1 = {
                    Value: sourceOport
                };
                var $res = this.FindAncestorsAndObstaclePort(edgeGeom.get_SourcePort(), $1);
                sourceOport = $1.Value;
                return $res;
            }).call(this);
            var ttAncs = (function (){
                var $1 = {
                    Value: targetOport
                };
                var $res = this.FindAncestorsAndObstaclePort(edgeGeom.get_TargetPort(), $1);
                targetOport = $1.Value;
                return $res;
            }).call(this);
            if ((this.get_AncestorSets().get_Count() > 0) && (null != sourceOport) && (null != targetOport)){
                var ttAncsOnly = Microsoft.Msagl.Core.DataStructures.Set$1.op_Subtraction(ttAncs, ssAncs);
                var ssAncsOnly = Microsoft.Msagl.Core.DataStructures.Set$1.op_Subtraction(ssAncs, ttAncs);
                this.ActivateAncestors(ssAncsOnly, ttAncsOnly, shapeToObstacleMap);
            }
            this.AddPortToGraph(edgeGeom.get_SourcePort(), sourceOport);
            this.AddPortToGraph(edgeGeom.get_TargetPort(), targetOport);
            this.AddWaypointsToGraph(edgeGeom);
        },
        AddWaypointsToGraph: function (edgeGeom){
            if (null == edgeGeom.get_Waypoints()){
                return;
            }
            var lastOobWaypoint = null;
            var firstWaypoint = null;
            var $it1083 = edgeGeom.get_Waypoints().GetEnumerator();
            while ($it1083.MoveNext()){
                var point = $it1083.get_Current();
                var freePoint = this.AddFreePointToGraph(point);
                if (firstWaypoint == null){
                    firstWaypoint = freePoint;
                }
                if (!freePoint.get_IsOutOfBounds()){
                    lastOobWaypoint = null;
                    continue;
                }
                if (null != lastOobWaypoint){
                    if (!this.get_ObstacleTree().get_GraphBox().Intersects(new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(lastOobWaypoint.get_Point(), freePoint.get_Point()))){
                        var dirs = Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(lastOobWaypoint.get_Point(), freePoint.get_Point());
                        if (Microsoft.Msagl.Core.Geometry.CompassVector.IsPureDirection$$Directions(dirs)){
                            this.get_TransUtil().ConnectVertexToTargetVertex(lastOobWaypoint.get_Vertex(), freePoint.get_Vertex(), dirs, 1);
                        }
                        else {
                            this.get_TransUtil().ConnectVertexToTargetVertex(lastOobWaypoint.get_Vertex(), freePoint.get_Vertex(), dirs & (5), 1);
                            this.get_TransUtil().ConnectVertexToTargetVertex(lastOobWaypoint.get_Vertex(), freePoint.get_Vertex(), dirs & (10), 1);
                        }
                    }
                    else {
                        if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.IsPureDirection$$Directions(freePoint.get_OutOfBoundsDirectionFromGraph()) && Microsoft.Msagl.Routing.Rectilinear.PointComparer.IsPureDirection$$Directions(lastOobWaypoint.get_OutOfBoundsDirectionFromGraph()) && (lastOobWaypoint.get_OutOfBoundsDirectionFromGraph() != Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(freePoint.get_OutOfBoundsDirectionFromGraph()))){
                            this.get_TransUtil().ConnectVertexToTargetVertex(freePoint.get_Vertex(), lastOobWaypoint.get_Vertex(), Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(freePoint.get_OutOfBoundsDirectionFromGraph()), 1);
                        }
                    }
                }
                lastOobWaypoint = freePoint;
            }
            this.ConnectOobWaypointToEndpointVisibilityAtGraphBoundary(firstWaypoint, edgeGeom.get_SourcePort());
            this.ConnectOobWaypointToEndpointVisibilityAtGraphBoundary(lastOobWaypoint, edgeGeom.get_TargetPort());
        },
        ConnectOobWaypointToEndpointVisibilityAtGraphBoundary: function (oobWaypoint, port){
            if ((oobWaypoint == null) || !oobWaypoint.get_IsOutOfBounds()){
                return;
            }
            var endpointVertices = this.FindVertices(port);
            var dirFromGraph = oobWaypoint.get_OutOfBoundsDirectionFromGraph() & (5);
            this.ConnectToGraphAtPointsCollinearWithVertices(oobWaypoint, dirFromGraph, endpointVertices);
            dirFromGraph = oobWaypoint.get_OutOfBoundsDirectionFromGraph() & (10);
            this.ConnectToGraphAtPointsCollinearWithVertices(oobWaypoint, dirFromGraph, endpointVertices);
        },
        ConnectToGraphAtPointsCollinearWithVertices: function (oobWaypoint, dirFromGraph, endpointVertices){
            if (Microsoft.Msagl.Core.Geometry.Directions.None == dirFromGraph){
                return;
            }
            var dirToGraph = Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(dirFromGraph);
            var $it1084 = endpointVertices.GetEnumerator();
            while ($it1084.MoveNext()){
                var vertex = $it1084.get_Current();
                var graphBorderLocation = this.InBoundsGraphBoxIntersect(vertex.Point, dirFromGraph);
                var graphBorderVertex = this.get_VisGraph().FindVertex(graphBorderLocation);
                if (graphBorderVertex != null){
                    this.get_TransUtil().ConnectVertexToTargetVertex(oobWaypoint.get_Vertex(), graphBorderVertex, dirToGraph, 1);
                }
            }
        },
        SetAllAncestorsActive: function (edgeGeom, shapeToObstacleMap){
            if (0 == this.get_AncestorSets().get_Count()){
                return false;
            }
            this.get_ObstacleTree().AdjustSpatialAncestors();
            this.ClearActiveAncestors();
            var sourceOport,targetOport;
            var ssAncs = (function (){
                var $1 = {
                    Value: sourceOport
                };
                var $res = this.FindAncestorsAndObstaclePort(edgeGeom.get_SourcePort(), $1);
                sourceOport = $1.Value;
                return $res;
            }).call(this);
            var ttAncs = (function (){
                var $1 = {
                    Value: targetOport
                };
                var $res = this.FindAncestorsAndObstaclePort(edgeGeom.get_TargetPort(), $1);
                targetOport = $1.Value;
                return $res;
            }).call(this);
            if ((this.get_AncestorSets().get_Count() > 0) && (Microsoft.Msagl.Core.DataStructures.Set$1.op_Inequality(null, ssAncs)) && (Microsoft.Msagl.Core.DataStructures.Set$1.op_Inequality(null, ttAncs))){
                this.ActivateAncestors(ssAncs, ttAncs, shapeToObstacleMap);
                return true;
            }
            return false;
        },
        SetAllGroupsActive: function (){
            this.ClearActiveAncestors();
            var $it1085 = this.get_ObstacleTree().GetAllGroups().GetEnumerator();
            while ($it1085.MoveNext()){
                var group = $it1085.get_Current();
                group.set_IsTransparentAncestor(true);
                this.activeAncestors.Add(group);
            }
        },
        FindAncestorsAndObstaclePort: function (port, oport){
            oport.Value = this.FindObstaclePort(port);
            if (0 == this.get_AncestorSets().get_Count()){
                return null;
            }
            if (null != oport.Value){
                return this.get_AncestorSets().get_Item$$TKey(oport.Value.get_Obstacle().get_InputShape());
            }
            return new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Routing.Shape.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor, Microsoft.Msagl.Routing.Shape.ctor, this.get_ObstacleTree().get_Root().AllHitItems$$Rectangle$$Func$2(new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(port.get_Location(), port.get_Location()), $CreateAnonymousDelegate(this, function (shape){
                return shape.get_IsGroup();
            })), $CreateAnonymousDelegate(this, function (obs){
                return obs.get_InputShape();
            })));
        },
        ActivateAncestors: function (ssAncsToUse, ttAncsToUse, shapeToObstacleMap){
            var $it1086 = Microsoft.Msagl.Core.DataStructures.Set$1.op_Addition(ssAncsToUse, ttAncsToUse).GetEnumerator();
            while ($it1086.MoveNext()){
                var shape = $it1086.get_Current();
                var group = shapeToObstacleMap.get_Item$$TKey(shape);
                System.Diagnostics.Debug.Assert$$Boolean$$String(group.get_IsGroup(), "Ancestor shape is not a group");
                group.set_IsTransparentAncestor(true);
                this.activeAncestors.Add(group);
            }
        },
        ClearActiveAncestors: function (){
            var $it1087 = this.activeAncestors.GetEnumerator();
            while ($it1087.MoveNext()){
                var group = $it1087.get_Current();
                group.set_IsTransparentAncestor(false);
            }
            this.activeAncestors.Clear();
        },
        RemoveControlPointsFromGraph: function (){
            this.ClearActiveAncestors();
            this.RemoveObstaclePortsFromGraph();
            this.RemoveFreePointsFromGraph();
            this.get_TransUtil().RemoveFromGraph();
            this.portSpliceLimitRectangle = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
        },
        RemoveObstaclePortsFromGraph: function (){
            var $it1088 = this.obstaclePortsInGraph.GetEnumerator();
            while ($it1088.MoveNext()){
                var oport = $it1088.get_Current();
                oport.RemoveFromGraph();
            }
            this.obstaclePortsInGraph.Clear();
        },
        RemoveFreePointsFromGraph: function (){
            var $it1089 = this.freePointsInGraph.GetEnumerator();
            while ($it1089.MoveNext()){
                var freePoint = $it1089.get_Current();
                freePoint.RemoveFromGraph();
            }
            this.freePointsInGraph.Clear();
        },
        RemoveStaleFreePoints: function (){
            if (this.freePointMap.get_Count() > this.freePointLocationsUsedByRouteEdges.get_Count()){
                var staleFreePairs = System.Linq.Enumerable.ToArray$1(System.Collections.Generic.KeyValuePair$2.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(System.Collections.Generic.KeyValuePair$2.ctor, this.freePointMap, $CreateAnonymousDelegate(this, function (kvp){
                    return !this.freePointLocationsUsedByRouteEdges.Contains$$T(kvp.get_Key());
                })));
                for (var $i1091 = 0,$l1091 = staleFreePairs.length,staleFreePair = staleFreePairs[$i1091]; $i1091 < $l1091; $i1091++, staleFreePair = staleFreePairs[$i1091]){
                    this.freePointMap.Remove(staleFreePair.get_Key());
                }
            }
        },
        ClearVisibility: function (){
            this.freePointMap.Clear();
            var $it1091 = this.obstaclePortMap.get_Values().GetEnumerator();
            while ($it1091.MoveNext()){
                var oport = $it1091.get_Current();
                oport.ClearVisibility();
            }
        },
        BeginRouteEdges: function (){
            this.RemoveControlPointsFromGraph();
            this.freePointLocationsUsedByRouteEdges.Clear();
        },
        EndRouteEdges: function (){
            this.RemoveStaleFreePoints();
        },
        FindObstaclePort: function (port){
            var oport;
            if ((function (){
                var $1 = {
                    Value: oport
                };
                var $res = this.obstaclePortMap.TryGetValue(port, $1);
                oport = $1.Value;
                return $res;
            }).call(this)){
                var addedPorts,removedPorts;
                if ((function (){
                    var $1 = {
                        Value: addedPorts
                    };
                    var $2 = {
                        Value: removedPorts
                    };
                    var $res = oport.get_Obstacle().GetPortChanges($1, $2);
                    addedPorts = $1.Value;
                    removedPorts = $2.Value;
                    return $res;
                }).call(this)){
                    var $it1092 = addedPorts.GetEnumerator();
                    while ($it1092.MoveNext()){
                        var newPort = $it1092.get_Current();
                        this.CreateObstaclePort(oport.get_Obstacle(), newPort);
                    }
                    var $it1093 = removedPorts.GetEnumerator();
                    while ($it1093.MoveNext()){
                        var oldPort = $it1093.get_Current();
                        this.RemoveObstaclePort(oldPort);
                    }
                    if (!(function (){
                        var $1 = {
                            Value: oport
                        };
                        var $res = this.obstaclePortMap.TryGetValue(port, $1);
                        oport = $1.Value;
                        return $res;
                    }).call(this)){
                        oport = null;
                    }
                }
            }
            return oport;
        },
        AddPortToGraph: function (port, oport){
            if (null != oport){
                this.AddObstaclePortToGraph(oport);
                return;
            }
            this.AddFreePointToGraph(port.get_Location());
        },
        AddObstaclePortToGraph: function (oport){
            if (oport.get_LocationHasChanged()){
                this.RemoveObstaclePort(oport.get_Port());
                oport = this.CreateObstaclePort(oport.get_Obstacle(), oport.get_Port());
                if (null == oport){
                    return;
                }
            }
            oport.AddToGraph(this.get_TransUtil(), this.get_RouteToCenterOfObstacles());
            this.obstaclePortsInGraph.Add(oport);
            this.CreateObstaclePortEntrancesIfNeeded(oport);
            var $it1094 = oport.get_PortEntrances().GetEnumerator();
            while ($it1094.MoveNext()){
                var entrance = $it1094.get_Current();
                this.AddObstaclePortEntranceToGraph(entrance);
            }
            return;
        },
        CreateObstaclePortEntrancesIfNeeded: function (oport){
            if (0 != oport.get_PortEntrances().get_Count()){
                return;
            }
            if (null == oport.get_Port().get_PortEntry()){
                this.CreateObstaclePortEntrancesFromPoints(oport);
            }
            else {
                this.CreateObstaclePortEntrancesFromPortEntry(oport);
            }
        },
        GetPortVisibilityIntersection: function (edgeGeometry){
            var sourceOport = this.FindObstaclePort(edgeGeometry.get_SourcePort());
            var targetOport = this.FindObstaclePort(edgeGeometry.get_TargetPort());
            if ((sourceOport == null) || (targetOport == null)){
                return null;
            }
            if (sourceOport.get_Obstacle().get_IsInConvexHull() || targetOport.get_Obstacle().get_IsInConvexHull()){
                return null;
            }
            this.CreateObstaclePortEntrancesIfNeeded(sourceOport);
            this.CreateObstaclePortEntrancesIfNeeded(targetOport);
            if (!sourceOport.VisibilityRectangle.Intersects(targetOport.VisibilityRectangle)){
                return null;
            }
            var $it1095 = sourceOport.get_PortEntrances().GetEnumerator();
            while ($it1095.MoveNext()){
                var sourceEntrance = $it1095.get_Current();
                if (!sourceEntrance.get_WantVisibilityIntersection()){
                    continue;
                }
                var $it1096 = targetOport.get_PortEntrances().GetEnumerator();
                while ($it1096.MoveNext()){
                    var targetEntrance = $it1096.get_Current();
                    if (!targetEntrance.get_WantVisibilityIntersection()){
                        continue;
                    }
                    var points = (sourceEntrance.get_IsVertical() == targetEntrance.get_IsVertical()) ? Microsoft.Msagl.Routing.Rectilinear.PortManager.GetPathPointsFromOverlappingCollinearVisibility(sourceEntrance, targetEntrance) : Microsoft.Msagl.Routing.Rectilinear.PortManager.GetPathPointsFromIntersectingVisibility(sourceEntrance, targetEntrance);
                    if (points != null){
                        return points;
                    }
                }
            }
            return null;
        },
        CreateObstaclePortEntrancesFromPoints: function (oport){
            var graphBox = this.graphGenerator.ObstacleTree.get_GraphBox();
            var curveBox = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Point(oport.get_PortCurve().get_BoundingBox().get_LeftBottom()), Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Point(oport.get_PortCurve().get_BoundingBox().get_RightTop()));
            var location = Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Point(oport.get_PortLocation());
            var xx0,xx1;
            var found = false;
            if (!Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Double$$Double(location.get_Y(), curveBox.get_Top()) && !Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Double$$Double(location.get_Y(), curveBox.get_Bottom())){
                found = true;
                var hSeg = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Double$$Double$$Double$$Double(graphBox.get_Left(), location.get_Y(), graphBox.get_Right(), location.get_Y());
                (function (){
                    var $1 = {
                        Value: xx0
                    };
                    var $2 = {
                        Value: xx1
                    };
                    var $res = this.GetBorderIntersections(location, hSeg, oport.get_PortCurve(), $1, $2);
                    xx0 = $1.Value;
                    xx1 = $2.Value;
                    return $res;
                }).call(this);
                var wBorderIntersect = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(System.Math.Min$$Double$$Double(xx0.get_X(), xx1.get_X()), location.get_Y());
                if (wBorderIntersect.get_X() < curveBox.get_Left()){
                    wBorderIntersect.set_X(curveBox.get_Left());
                }
                var eBorderIntersect = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(System.Math.Max$$Double$$Double(xx0.get_X(), xx1.get_X()), location.get_Y());
                if (eBorderIntersect.get_X() > curveBox.get_Right()){
                    eBorderIntersect.set_X(curveBox.get_Right());
                }
                this.CreatePortEntrancesAtBorderIntersections(curveBox, oport, location, wBorderIntersect, eBorderIntersect);
            }
            if (!Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Double$$Double(location.get_X(), curveBox.get_Left()) && !Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Double$$Double(location.get_X(), curveBox.get_Right())){
                found = true;
                var vSeg = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Double$$Double$$Double$$Double(location.get_X(), graphBox.get_Bottom(), location.get_X(), graphBox.get_Top());
                (function (){
                    var $1 = {
                        Value: xx0
                    };
                    var $2 = {
                        Value: xx1
                    };
                    var $res = this.GetBorderIntersections(location, vSeg, oport.get_PortCurve(), $1, $2);
                    xx0 = $1.Value;
                    xx1 = $2.Value;
                    return $res;
                }).call(this);
                var sBorderIntersect = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(location.get_X(), System.Math.Min$$Double$$Double(xx0.get_Y(), xx1.get_Y()));
                if (sBorderIntersect.get_Y() < graphBox.get_Bottom()){
                    sBorderIntersect.set_Y(graphBox.get_Bottom());
                }
                var nBorderIntersect = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(location.get_X(), System.Math.Max$$Double$$Double(xx0.get_Y(), xx1.get_Y()));
                if (nBorderIntersect.get_Y() > graphBox.get_Top()){
                    nBorderIntersect.set_Y(graphBox.get_Top());
                }
                this.CreatePortEntrancesAtBorderIntersections(curveBox, oport, location, sBorderIntersect, nBorderIntersect);
            }
            if (!found){
                this.CreateEntrancesForCornerPort(curveBox, oport, location);
            }
        },
        CreateObstaclePortEntrancesFromPortEntry: function (oport){
            var $it1097 = oport.get_Port().get_PortEntry().GetEntryPoints().GetEnumerator();
            while ($it1097.MoveNext()){
                var midPoint = $it1097.get_Current();
                var borderPoint = Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Point(midPoint);
                var derivDirs = Microsoft.Msagl.Core.Geometry.CompassVector.VectorDirection$$Point(Microsoft.Msagl.Routing.Rectilinear.PortManager.GetDerivative(oport, borderPoint));
                var dir = derivDirs & (5);
                if (Microsoft.Msagl.Core.Geometry.Directions.None != dir){
                    oport.CreatePortEntrance(borderPoint, Microsoft.Msagl.Core.Geometry.CompassVector.RotateLeft(dir), this.get_ObstacleTree());
                }
                dir = derivDirs & (10);
                if (Microsoft.Msagl.Core.Geometry.Directions.None != dir){
                    oport.CreatePortEntrance(borderPoint, Microsoft.Msagl.Core.Geometry.CompassVector.RotateLeft(dir), this.get_ObstacleTree());
                }
            }
        },
        GetBorderIntersections: function (location, lineSeg, curve, xx0, xx1){
            var xxs = Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(lineSeg, curve, true);
            Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.Assert(2 == xxs.get_Count(), "Expected two intersections", this.get_ObstacleTree(), this.get_VisGraph());
            xx0.Value = Microsoft.Msagl.Routing.Rectilinear.SpliceUtility.RawIntersection(xxs.get_Item$$Int32(0), location);
            xx1.Value = Microsoft.Msagl.Routing.Rectilinear.SpliceUtility.RawIntersection(xxs.get_Item$$Int32(1), location);
        },
        CreatePortEntrancesAtBorderIntersections: function (curveBox, oport, location, unpaddedBorderIntersect0, unpaddedBorderIntersect1){
            var dir = Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$Point$$Point(unpaddedBorderIntersect0, unpaddedBorderIntersect1);
            if (!Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(unpaddedBorderIntersect0, location)){
                this.CreatePortEntrance(curveBox, oport, unpaddedBorderIntersect1, dir);
            }
            if (!Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(unpaddedBorderIntersect1, location)){
                this.CreatePortEntrance(curveBox, oport, unpaddedBorderIntersect0, Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(dir));
            }
        },
        CreatePortEntrance: function (curveBox, oport, unpaddedBorderIntersect, outDir){
            oport.CreatePortEntrance(unpaddedBorderIntersect, outDir, this.get_ObstacleTree());
            var scanDir = Microsoft.Msagl.Routing.Rectilinear.ScanDirection.GetInstance(outDir);
            var axisDistanceBetweenIntersections = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.GetRectangleBound(curveBox, outDir) - scanDir.Coord(unpaddedBorderIntersect);
            if (axisDistanceBetweenIntersections < 0){
                axisDistanceBetweenIntersections = -axisDistanceBetweenIntersections;
            }
            if (axisDistanceBetweenIntersections > Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_IntersectionEpsilon()){
                var perpDirs = Microsoft.Msagl.Core.Geometry.CompassVector.VectorDirection$$Point(Microsoft.Msagl.Routing.Rectilinear.PortManager.GetDerivative(oport, unpaddedBorderIntersect));
                var perpDir = perpDirs & ~(outDir | Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(outDir));
                if (Microsoft.Msagl.Core.Geometry.Directions.None != (outDir & perpDirs)){
                    perpDir = Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(perpDir);
                }
                oport.CreatePortEntrance(unpaddedBorderIntersect, perpDir, this.get_ObstacleTree());
            }
        },
        CreateEntrancesForCornerPort: function (curveBox, oport, location){
            var outDir = Microsoft.Msagl.Core.Geometry.Directions.North;
            if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(location, curveBox.get_LeftBottom())){
                outDir = Microsoft.Msagl.Core.Geometry.Directions.South;
            }
            else if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(location, curveBox.get_LeftTop())){
                outDir = Microsoft.Msagl.Core.Geometry.Directions.West;
            }
            else if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(location, curveBox.get_RightTop())){
                outDir = Microsoft.Msagl.Core.Geometry.Directions.North;
            }
            else if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(location, curveBox.get_RightBottom())){
                outDir = Microsoft.Msagl.Core.Geometry.Directions.East;
            }
            else {
                System.Diagnostics.Debug.Assert$$Boolean$$String(false, "Expected Port to be on corner of curveBox");
            }
            oport.CreatePortEntrance(location, outDir, this.get_ObstacleTree());
            oport.CreatePortEntrance(location, Microsoft.Msagl.Core.Geometry.CompassVector.RotateRight(outDir), this.get_ObstacleTree());
        },
        AddObstaclePortEntranceToGraph: function (entrance){
            var borderVertex = this.get_VisGraph().FindVertex(entrance.get_VisibilityBorderIntersect());
            if (null != borderVertex){
                entrance.ExtendFromBorderVertex(this.get_TransUtil(), borderVertex, this.portSpliceLimitRectangle, this.get_RouteToCenterOfObstacles());
                return;
            }
            var targetVertex;
            var weight = entrance.get_IsOverlapped() ? 500 : 1;
            var edge = (function (){
                var $1 = {
                    Value: targetVertex
                };
                var $res = this.FindorCreateNearestPerpEdge$$Point$$Point$$Directions$$Double$$VisibilityVertex(entrance.get_MaxVisibilitySegment().get_End(), entrance.get_VisibilityBorderIntersect(), entrance.get_OutwardDirection(), weight, $1);
                targetVertex = $1.Value;
                return $res;
            }).call(this);
            if (null != edge){
                entrance.AddToAdjacentVertex(this.get_TransUtil(), targetVertex, this.portSpliceLimitRectangle, this.get_RouteToCenterOfObstacles());
            }
        },
        InBoundsGraphBoxIntersect: function (point, dir){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.RectangleBorderIntersect(this.graphGenerator.ObstacleTree.get_GraphBox(), point, dir);
        },
        FindorCreateNearestPerpEdge$$Point$$Point$$Directions$$Double: function (first, second, dir, weight){
            var targetVertex;
            return (function (){
                var $1 = {
                    Value: targetVertex
                };
                var $res = this.FindorCreateNearestPerpEdge$$Point$$Point$$Directions$$Double$$VisibilityVertex(first, second, dir, weight, $1);
                targetVertex = $1.Value;
                return $res;
            }).call(this);
        },
        FindorCreateNearestPerpEdge$$Point$$Point$$Directions$$Double$$VisibilityVertex: function (first, second, dir, weight, targetVertex){
            var couple = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.SortAscending(first, second);
            var low = couple.get_Item1();
            var high = couple.get_Item2();
            var perpendicularScanSegments = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsVertical$$Directions(dir) ? this.get_HScanSegments() : this.get_VScanSegments();
            var nearestPerpSeg = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsAscending$$Directions(dir) ? perpendicularScanSegments.FindLowestIntersector(low, high) : perpendicularScanSegments.FindHighestIntersector(low, high);
            if (nearestPerpSeg == null){
                targetVertex.Value = null;
                return null;
            }
            var edgeIntersect = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.SegmentIntersection$$SegmentBase$$Point(nearestPerpSeg, low);
            return this.FindOrCreateNearestPerpEdgeFromNearestPerpSegment(Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsAscending$$Directions(dir) ? low : high, nearestPerpSeg, edgeIntersect, weight, targetVertex);
        },
        FindOrCreateNearestPerpEdgeFromNearestPerpSegment: function (pointLocation, scanSeg, edgeIntersect, weight, targetVertex){
            var segsegVertex = this.get_VisGraph().FindVertex(edgeIntersect);
            if (null == segsegVertex){
                var edge = (function (){
                    var $1 = {
                        Value: segsegVertex
                    };
                    var $res = this.FindOrCreateSegmentIntersectionVertexAndAssociatedEdge(pointLocation, edgeIntersect, scanSeg, weight, $1, targetVertex);
                    segsegVertex = $1.Value;
                    return $res;
                }).call(this);
                if (edge != null){
                    return edge;
                }
            }
            else if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(pointLocation, edgeIntersect)){
                targetVertex.Value = segsegVertex;
                return (this.get_TransUtil().FindNextEdge(targetVertex.Value, scanSeg.get_ScanDirection().get_Direction()) != null ? this.get_TransUtil().FindNextEdge(targetVertex.Value, scanSeg.get_ScanDirection().get_Direction()) : this.get_TransUtil().FindNextEdge(targetVertex.Value, Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(scanSeg.get_ScanDirection().get_Direction())));
            }
            var dirTowardLocation = Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$Point$$Point(edgeIntersect, pointLocation);
            var perpDir = Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(segsegVertex.Point, pointLocation);
            if (dirTowardLocation == perpDir){
                var bracketTarget;
                (function (){
                    var $1 = {
                        Value: bracketTarget
                    };
                    var $res = Microsoft.Msagl.Routing.Rectilinear.TransientGraphUtility.FindBracketingVertices(segsegVertex, pointLocation, dirTowardLocation, targetVertex, $1);
                    bracketTarget = $1.Value;
                    return $res;
                }).call(this);
                return (this.get_TransUtil().FindNextEdge(targetVertex.Value, Microsoft.Msagl.Core.Geometry.CompassVector.RotateLeft(dirTowardLocation)) != null ? this.get_TransUtil().FindNextEdge(targetVertex.Value, Microsoft.Msagl.Core.Geometry.CompassVector.RotateLeft(dirTowardLocation)) : this.get_TransUtil().FindNextEdge(targetVertex.Value, Microsoft.Msagl.Core.Geometry.CompassVector.RotateRight(dirTowardLocation)));
            }
            perpDir &= ~dirTowardLocation;
            Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.Assert(Microsoft.Msagl.Core.Geometry.Directions.None != perpDir, "pointLocation == initial segsegVertex.Point should already have exited", this.get_ObstacleTree(), this.get_VisGraph());
            var perpendicularEdge = this.get_TransUtil().FindNearestPerpendicularOrContainingEdge(segsegVertex, perpDir, pointLocation);
            if (null == perpendicularEdge){
                Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.Assert(Microsoft.Msagl.Core.Geometry.Point.op_GreaterThan(edgeIntersect, scanSeg.get_HighestVisibilityVertex().Point), "edgeIntersect is not > scanSeg.HighestVisibilityVertex", this.get_ObstacleTree(), this.get_VisGraph());
                targetVertex.Value = this.get_TransUtil().AddVertex(edgeIntersect);
                return this.get_TransUtil().FindOrAddEdge$$VisibilityVertex$$VisibilityVertex$$Double(targetVertex.Value, scanSeg.get_HighestVisibilityVertex(), scanSeg.get_Weight());
            }
            segsegVertex = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.GetVertex(perpendicularEdge, Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(perpDir));
            edgeIntersect = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.SegmentIntersection$$Point$$Point$$Point(pointLocation, edgeIntersect, segsegVertex.Point);
            if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(segsegVertex.Point, edgeIntersect)){
                targetVertex.Value = segsegVertex;
                return this.get_TransUtil().FindNextEdge(segsegVertex, perpDir);
            }
            targetVertex.Value = this.get_TransUtil().FindOrAddVertex(edgeIntersect);
            return this.get_TransUtil().FindOrAddEdge$$VisibilityVertex$$VisibilityVertex$$Double(segsegVertex, targetVertex.Value, weight);
        },
        FindOrCreateSegmentIntersectionVertexAndAssociatedEdge: function (pointLocation, edgeIntersect, scanSeg, weight, segsegVertex, targetVertex){
            var intersectingSegments = scanSeg.get_IsVertical() ? this.get_HScanSegments() : this.get_VScanSegments();
            var intSegBefore = intersectingSegments.FindHighestIntersector(scanSeg.get_Start(), edgeIntersect);
            if (null == intSegBefore){
                segsegVertex.Value = null;
                targetVertex.Value = this.get_TransUtil().AddVertex(edgeIntersect);
                return this.get_TransUtil().FindOrAddEdge$$VisibilityVertex$$VisibilityVertex$$Double(targetVertex.Value, scanSeg.get_LowestVisibilityVertex(), scanSeg.get_Weight());
            }
            var segsegIntersect = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.SegmentIntersection$$SegmentBase$$SegmentBase(scanSeg, intSegBefore);
            segsegVertex.Value = this.get_VisGraph().FindVertex(segsegIntersect);
            if (null == segsegVertex.Value){
                segsegVertex.Value = this.get_TransUtil().AddVertex(segsegIntersect);
                var newEdge = this.AddEdgeToClosestSegmentEnd(scanSeg, segsegVertex.Value, scanSeg.get_Weight());
                this.AddEdgeToClosestSegmentEnd(intSegBefore, segsegVertex.Value, intSegBefore.get_Weight());
                if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(segsegVertex.Value.Point, edgeIntersect)){
                    targetVertex.Value = segsegVertex.Value;
                    return newEdge;
                }
            }
            if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(pointLocation, edgeIntersect)){
                targetVertex.Value = this.get_TransUtil().FindOrAddVertex(edgeIntersect);
                return this.get_TransUtil().FindOrAddEdge$$VisibilityVertex$$VisibilityVertex$$Double(segsegVertex.Value, targetVertex.Value, weight);
            }
            targetVertex.Value = null;
            return null;
        },
        AddEdgeToClosestSegmentEnd: function (scanSeg, segsegVertex, weight){
            if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.IsPureLower(scanSeg.get_HighestVisibilityVertex().Point, segsegVertex.Point)){
                return this.get_TransUtil().FindOrAddEdge$$VisibilityVertex$$VisibilityVertex$$Double(scanSeg.get_HighestVisibilityVertex(), segsegVertex, weight);
            }
            if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.IsPureLower(segsegVertex.Point, scanSeg.get_LowestVisibilityVertex().Point)){
                return this.get_TransUtil().FindOrAddEdge$$VisibilityVertex$$VisibilityVertex$$Double(segsegVertex, scanSeg.get_LowestVisibilityVertex(), weight);
            }
            return this.get_TransUtil().FindOrAddEdge$$VisibilityVertex$$VisibilityVertex(scanSeg.get_LowestVisibilityVertex(), segsegVertex);
        },
        GetPortSpliceLimitRectangle: function (edgeGeom){
            if (!this.get_LimitPortVisibilitySpliceToEndpointBoundingBox()){
                this.portSpliceLimitRectangle = this.graphGenerator.ObstacleTree.get_GraphBox();
                return;
            }
            this.portSpliceLimitRectangle = this.GetPortRectangle(edgeGeom.get_SourcePort());
            this.portSpliceLimitRectangle.Add$$Rectangle(this.GetPortRectangle(edgeGeom.get_TargetPort()));
            if (null != edgeGeom.get_Waypoints()){
                var $it1098 = edgeGeom.get_Waypoints().GetEnumerator();
                while ($it1098.MoveNext()){
                    var waypoint = $it1098.get_Current();
                    this.AddToLimitRectangle(waypoint);
                }
            }
        },
        GetPortRectangle: function (port){
            var oport;
            (function (){
                var $1 = {
                    Value: oport
                };
                var $res = this.obstaclePortMap.TryGetValue(port, $1);
                oport = $1.Value;
                return $res;
            }).call(this);
            if (null != oport){
                return (oport.get_Obstacle().get_VisibilityBoundingBox());
            }
            return new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Point(port.get_Location()));
        },
        AddToLimitRectangle: function (location){
            if (this.graphGenerator.IsInBounds$$Point(location)){
                this.portSpliceLimitRectangle.Add$$Point(location);
            }
        },
        FindWaypointVertices: function (waypoints){
            return System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor, waypoints, $CreateAnonymousDelegate(this, function (w){
                return this.get_VisGraph().FindVertex(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Point(w));
            }));
        },
        FindOrCreateFreePoint: function (location){
            var freePoint;
            if (!(function (){
                var $1 = {
                    Value: freePoint
                };
                var $res = this.freePointMap.TryGetValue(location, $1);
                freePoint = $1.Value;
                return $res;
            }).call(this)){
                freePoint = new Microsoft.Msagl.Routing.Rectilinear.FreePoint.ctor(this.get_TransUtil(), location);
                this.freePointMap.set_Item$$TKey(location, freePoint);
            }
            else {
                freePoint.GetVertex(this.get_TransUtil(), location);
            }
            this.freePointsInGraph.Insert(freePoint);
            this.freePointLocationsUsedByRouteEdges.Insert(location);
            return freePoint;
        },
        AddFreePointToGraph: function (location){
            location = Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Point(location);
            var vertex = this.get_VisGraph().FindVertex(location);
            var freePoint = this.FindOrCreateFreePoint(location);
            if (null != vertex){
                return freePoint;
            }
            if (!this.graphGenerator.IsInBounds$$Point(location)){
                this.CreateOutOfBoundsFreePoint(freePoint);
                return freePoint;
            }
            var edge = null;
            freePoint.set_IsOverlapped(this.get_ObstacleTree().PointIsInsideAnObstacle$$Point$$ScanDirection(freePoint.get_Point(), this.get_HScanSegments().get_ScanDirection()));
            var scanSegment = (this.get_HScanSegments().FindSegmentContainingPoint(location, true) != null ? this.get_HScanSegments().FindSegmentContainingPoint(location, true) : this.get_VScanSegments().FindSegmentContainingPoint(location, true));
            if (null != scanSegment){
                var targetVertex;
                edge = (function (){
                    var $1 = {
                        Value: targetVertex
                    };
                    var $res = this.FindOrCreateNearestPerpEdgeFromNearestPerpSegment(location, scanSegment, location, freePoint.get_InitialWeight(), $1);
                    targetVertex = $1.Value;
                    return $res;
                }).call(this);
            }
            var edgeDir = Microsoft.Msagl.Core.Geometry.Directions.South;
            if (null != edge){
                edgeDir = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.EdgeDirection$$VisibilityEdge(edge);
                this.ConnectFreePointToLateralEdge(freePoint, Microsoft.Msagl.Core.Geometry.CompassVector.RotateLeft(edgeDir));
                this.ConnectFreePointToLateralEdge(freePoint, Microsoft.Msagl.Core.Geometry.CompassVector.RotateRight(edgeDir));
            }
            else {
                for (var ii = 0; ii < 4; ++ii){
                    this.ConnectFreePointToLateralEdge(freePoint, edgeDir);
                    edgeDir = Microsoft.Msagl.Core.Geometry.CompassVector.RotateLeft(edgeDir);
                }
            }
            return freePoint;
        },
        CreateOutOfBoundsFreePoint: function (freePoint){
            var oobLocation = freePoint.get_Point();
            var inboundsLocation = this.graphGenerator.MakeInBoundsLocation(oobLocation);
            var dirFromGraph = Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(inboundsLocation, oobLocation);
            freePoint.set_OutOfBoundsDirectionFromGraph(dirFromGraph);
            if (!Microsoft.Msagl.Routing.Rectilinear.PointComparer.IsPureDirection$$Directions(dirFromGraph)){
                Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.Assert(null != this.get_VisGraph().FindVertex(inboundsLocation), "graph corner vertex not found", this.get_ObstacleTree(), this.get_VisGraph());
                freePoint.AddOobEdgesFromGraphCorner(this.get_TransUtil(), inboundsLocation);
                return;
            }
            var inboundsVertex = this.get_VisGraph().FindVertex(inboundsLocation);
            var dirToGraph = Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(dirFromGraph);
            if (null != inboundsVertex){
                freePoint.AddToAdjacentVertex(this.get_TransUtil(), inboundsVertex, dirToGraph, this.portSpliceLimitRectangle);
            }
            else {
                var edge = this.FindorCreateNearestPerpEdge$$Point$$Point$$Directions$$Double(oobLocation, inboundsLocation, dirFromGraph, 1);
                if (null != edge){
                    inboundsVertex = freePoint.AddEdgeToAdjacentEdge(this.get_TransUtil(), edge, dirToGraph, this.portSpliceLimitRectangle);
                }
            }
            var inboundsLeftVertex = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.FindNextVertex(inboundsVertex, Microsoft.Msagl.Core.Geometry.CompassVector.RotateLeft(dirToGraph));
            if (inboundsLeftVertex != null){
                this.get_TransUtil().ConnectVertexToTargetVertex(freePoint.get_Vertex(), inboundsLeftVertex, dirToGraph, 1);
            }
            var inboundsRightVertex = Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.FindNextVertex(inboundsVertex, Microsoft.Msagl.Core.Geometry.CompassVector.RotateRight(dirToGraph));
            if (inboundsRightVertex != null){
                this.get_TransUtil().ConnectVertexToTargetVertex(freePoint.get_Vertex(), inboundsRightVertex, dirToGraph, 1);
            }
        },
        ConnectFreePointToLateralEdge: function (freePoint, lateralDir){
            var end = freePoint.get_IsOverlapped() ? this.InBoundsGraphBoxIntersect(freePoint.get_Point(), lateralDir) : freePoint.MaxVisibilityInDirectionForNonOverlappedFreePoint(lateralDir, this.get_TransUtil());
            var lateralEdge = this.FindorCreateNearestPerpEdge$$Point$$Point$$Directions$$Double(end, freePoint.get_Point(), lateralDir, freePoint.get_InitialWeight());
            if (null != lateralEdge){
                freePoint.AddEdgeToAdjacentEdge(this.get_TransUtil(), lateralEdge, lateralDir, this.portSpliceLimitRectangle);
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$PortManager);
var Microsoft$Msagl$Routing$Rectilinear$RectilinearInteractiveEditor = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.RectilinearInteractiveEditor",
    baseTypeName: "System.Object",
    staticDefinition: {
        CreatePortsAndRouteEdges$$Double$$Double$$IEnumerable$1$Node$$IEnumerable$1$Edge$$EdgeRoutingMode$$Boolean$$Boolean$$Double: function (cornerFitRadius, padding, obstacleNodes, geometryEdges, edgeRoutingMode, useSparseVisibilityGraph, useObstacleRectangles, bendPenaltyAsAPercentageOfDistance){
            var r = Microsoft.Msagl.Routing.Rectilinear.RectilinearInteractiveEditor.FillRouter(cornerFitRadius, padding, obstacleNodes, geometryEdges, edgeRoutingMode, useSparseVisibilityGraph, useObstacleRectangles, bendPenaltyAsAPercentageOfDistance);
            r.Run();
            Microsoft.Msagl.Routing.Rectilinear.RectilinearInteractiveEditor.CreateSelfEdges(System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, geometryEdges, function (e){
                return Microsoft.Msagl.Core.Geometry.Point.op_Equality(e.get_SourcePort().get_Location(), e.get_TargetPort().get_Location());
            }), cornerFitRadius);
        },
        CreatePortsAndRouteEdges$$Double$$Double$$IEnumerable$1$Node$$IEnumerable$1$Edge$$EdgeRoutingMode$$Boolean$$Boolean: function (cornerFitRadius, padding, obstacleNodes, geometryEdges, edgeRoutingMode, useSparseVisibilityGraph, useObstacleRectangles){
            Microsoft.Msagl.Routing.Rectilinear.RectilinearInteractiveEditor.CreatePortsAndRouteEdges$$Double$$Double$$IEnumerable$1$Node$$IEnumerable$1$Edge$$EdgeRoutingMode$$Boolean$$Boolean$$Double(cornerFitRadius, padding, obstacleNodes, geometryEdges, edgeRoutingMode, useSparseVisibilityGraph, useObstacleRectangles, 4);
        },
        CreatePortsAndRouteEdges$$Double$$Double$$IEnumerable$1$Node$$IEnumerable$1$Edge$$EdgeRoutingMode$$Boolean: function (cornerFitRadius, padding, obstacleNodes, geometryEdges, edgeRoutingMode, useSparseVisibilityGraph){
            Microsoft.Msagl.Routing.Rectilinear.RectilinearInteractiveEditor.CreatePortsAndRouteEdges$$Double$$Double$$IEnumerable$1$Node$$IEnumerable$1$Edge$$EdgeRoutingMode$$Boolean$$Boolean$$Double(cornerFitRadius, padding, obstacleNodes, geometryEdges, edgeRoutingMode, useSparseVisibilityGraph, false, 4);
        },
        FillRouter: function (cornerFitRadius, padding, obstacleNodes, geomEdges, edgeRoutingMode, useSparseVisibilityGraph, useObstacleRectangles, bendPenaltyAsAPercentageOfDistance){
            System.Diagnostics.Debug.Assert$$Boolean$$String((Microsoft.Msagl.Core.Routing.EdgeRoutingMode.Rectilinear == edgeRoutingMode) || (Microsoft.Msagl.Core.Routing.EdgeRoutingMode.RectilinearToCenter == edgeRoutingMode), "Non-rectilinear edgeRoutingMode");
            var nodeShapeMap = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Node.ctor, Microsoft.Msagl.Routing.Shape.ctor);
            var $it1099 = obstacleNodes.GetEnumerator();
            while ($it1099.MoveNext()){
                var node = $it1099.get_Current();
                var shape = Microsoft.Msagl.Routing.Rectilinear.RectilinearInteractiveEditor.CreateShapeWithRelativeNodeAtCenter(node);
                nodeShapeMap.Add(node, shape);
            }
            var router = (function (){
                var $v121 = new Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.ctor$$IEnumerable$1$Shape$$Double$$Double$$Boolean$$Boolean(nodeShapeMap.get_Values(), padding, cornerFitRadius, useSparseVisibilityGraph, useObstacleRectangles);
                $v121.set_RouteToCenterOfObstacles((edgeRoutingMode == Microsoft.Msagl.Core.Routing.EdgeRoutingMode.RectilinearToCenter));
                $v121.set_BendPenaltyAsAPercentageOfDistance(bendPenaltyAsAPercentageOfDistance);
                return $v121;
            })();
            var $it1100 = geomEdges.GetEnumerator();
            while ($it1100.MoveNext()){
                var geomEdge = $it1100.get_Current();
                var edgeGeom = geomEdge.get_EdgeGeometry();
                edgeGeom.set_SourcePort(System.Linq.Enumerable.First$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Port.ctor, nodeShapeMap.get_Item$$TKey(geomEdge.get_Source()).get_Ports()));
                edgeGeom.set_TargetPort(System.Linq.Enumerable.First$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Port.ctor, nodeShapeMap.get_Item$$TKey(geomEdge.get_Target()).get_Ports()));
                router.AddEdgeGeometryToRoute(edgeGeom);
            }
            return router;
        },
        CreateSelfEdges: function (selfEdges, cornerFitRadius){
            var $it1101 = selfEdges.GetEnumerator();
            while ($it1101.MoveNext()){
                var edge = $it1101.get_Current();
                Microsoft.Msagl.Routing.Rectilinear.RectilinearInteractiveEditor.CreateSimpleEdgeCurveWithGivenFitRadius(edge, cornerFitRadius);
            }
        },
        CreateSimpleEdgeCurveWithGivenFitRadius: function (edge, cornerFitRadius){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(edge, "edge");
            var a = edge.get_Source().get_Center();
            var b = edge.get_Target().get_Center();
            if (edge.get_Source() == edge.get_Target()){
                var dx = edge.get_Source().get_BoundaryCurve().get_BoundingBox().get_Width() / 2;
                var dy = edge.get_Source().get_BoundingBox().get_Height() / 4;
                edge.set_UnderlyingPolyline(Microsoft.Msagl.Routing.Rectilinear.RectilinearInteractiveEditor.CreateUnderlyingPolylineForSelfEdge(a, dx, dy));
                for (var site = edge.get_UnderlyingPolyline().get_HeadSite().get_Next(); site.get_Next() != null; site = site.get_Next())
                    Microsoft.Msagl.Routing.Rectilinear.RectilinearInteractiveEditor.CalculateCoefficiensUnderSite(site, cornerFitRadius);
                edge.set_Curve(edge.get_UnderlyingPolyline().CreateCurve());
            }
            else {
                edge.set_UnderlyingPolyline(Microsoft.Msagl.Core.Geometry.SmoothedPolyline.FromPoints([a, b]));
                edge.set_Curve(edge.get_UnderlyingPolyline().CreateCurve());
            }
            if (!Microsoft.Msagl.Core.Layout.Arrowheads.TrimSplineAndCalculateArrowheads$$EdgeGeometry$$ICurve$$ICurve$$ICurve$$Boolean$$Boolean(edge.get_EdgeGeometry(), edge.get_Source().get_BoundaryCurve(), edge.get_Target().get_BoundaryCurve(), edge.get_Curve(), true, false))
                Microsoft.Msagl.Core.Layout.Arrowheads.CreateBigEnoughSpline(edge);
        },
        CreateSimpleEdgeCurve: function (edge){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(edge, "edge");
            var a = edge.get_Source().get_Center();
            var b = edge.get_Target().get_Center();
            if (edge.get_Source() == edge.get_Target()){
                var dx = edge.get_Source().get_BoundaryCurve().get_BoundingBox().get_Width() / 2;
                var dy = edge.get_Source().get_BoundingBox().get_Height() / 4;
                edge.set_UnderlyingPolyline(Microsoft.Msagl.Routing.Rectilinear.RectilinearInteractiveEditor.CreateUnderlyingPolylineForSelfEdge(a, dx, dy));
                edge.set_Curve(edge.get_UnderlyingPolyline().CreateCurve());
            }
            else {
                edge.set_UnderlyingPolyline(Microsoft.Msagl.Core.Geometry.SmoothedPolyline.FromPoints([a, b]));
                edge.set_Curve(edge.get_UnderlyingPolyline().CreateCurve());
            }
            if (!Microsoft.Msagl.Core.Layout.Arrowheads.TrimSplineAndCalculateArrowheads$$EdgeGeometry$$ICurve$$ICurve$$ICurve$$Boolean$$Boolean(edge.get_EdgeGeometry(), edge.get_Source().get_BoundaryCurve(), edge.get_Target().get_BoundaryCurve(), edge.get_Curve(), true, false))
                Microsoft.Msagl.Core.Layout.Arrowheads.CreateBigEnoughSpline(edge);
        },
        CreateUnderlyingPolylineForSelfEdge: function (p0, dx, dy){
            var p1 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(p0, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, dy));
            var p2 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(p0, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(dx, dy));
            var p3 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(p0, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(dx, -dy));
            var p4 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(p0, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, -dy));
            var site = new Microsoft.Msagl.Core.Geometry.Site.ctor$$Point(p0);
            var polyline = new Microsoft.Msagl.Core.Geometry.SmoothedPolyline.ctor(site);
            site = new Microsoft.Msagl.Core.Geometry.Site.ctor$$Site$$Point(site, p1);
            site = new Microsoft.Msagl.Core.Geometry.Site.ctor$$Site$$Point(site, p2);
            site = new Microsoft.Msagl.Core.Geometry.Site.ctor$$Site$$Point(site, p3);
            site = new Microsoft.Msagl.Core.Geometry.Site.ctor$$Site$$Point(site, p4);
            new Microsoft.Msagl.Core.Geometry.Site.ctor$$Site$$Point(site, p0);
            return polyline;
        },
        CreateShapeWithRelativeNodeAtCenter: function (node){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(node, "node");
            var shape = new Microsoft.Msagl.Routing.RelativeShape.ctor(function (){
                return node.get_BoundaryCurve();
            });
            shape.get_Ports().Insert(new Microsoft.Msagl.Core.Layout.RelativeFloatingPort.ctor$$Func$1$ICurve$$Func$1$Point(function (){
                return node.get_BoundaryCurve();
            }, function (){
                return node.get_Center();
            }));
            return shape;
        },
        CalculateCoefficiensUnderSite: function (site, radius){
            var l = radius / (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(site.get_Point(), site.get_Previous().get_Point())).get_Length();
            l = System.Math.Min$$Double$$Double(0.5, l);
            site.set_PreviousBezierSegmentFitCoefficient(l);
            l = radius / (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(site.get_Next().get_Point(), site.get_Point())).get_Length();
            l = System.Math.Min$$Double$$Double(0.5, l);
            site.set_NextBezierSegmentFitCoefficient(l);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$RectilinearInteractiveEditor);
var Microsoft$Msagl$Routing$RelativeShape = {
    fullname: "Microsoft.Msagl.Routing.RelativeShape",
    baseTypeName: "Microsoft.Msagl.Routing.Shape",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (curveDelegate){
            this.curveDelegate = null;
            Microsoft.Msagl.Routing.Shape.ctor.call(this);
            this.curveDelegate = curveDelegate;
        },
        BoundaryCurve$$: "Microsoft.Msagl.Core.Geometry.Curves.ICurve",
        get_BoundaryCurve: function (){
            return this.curveDelegate();
        },
        set_BoundaryCurve: function (value){
            throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$RelativeShape);
var Microsoft$Msagl$Routing$Shape = {
    fullname: "Microsoft.Msagl.Routing.Shape",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.parents = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Routing.Shape.ctor);
            this.children = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Routing.Shape.ctor);
            this.boundaryCurve = null;
            this.ports = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Layout.Port.ctor);
            this._UserData = null;
            this._IsTransparent = false;
            Microsoft.Msagl.Routing.Shape.ctor$$ICurve.call(this, null);
        },
        Parents$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Routing.Shape]]",
        get_Parents: function (){
            return this.parents;
        },
        Children$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Routing.Shape]]",
        get_Children: function (){
            return this.children;
        },
        BoundaryCurve$$: "Microsoft.Msagl.Core.Geometry.Curves.ICurve",
        get_BoundaryCurve: function (){
            return this.boundaryCurve;
        },
        set_BoundaryCurve: function (value){
            this.boundaryCurve = value;
        },
        BoundingBox$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_BoundingBox: function (){
            return this.get_BoundaryCurve().get_BoundingBox();
        },
        Ports$$: "Microsoft.Msagl.Core.DataStructures.Set`1[[Microsoft.Msagl.Core.Layout.Port]]",
        get_Ports: function (){
            return this.ports;
        },
        UserData$$: "System.Object",
        get_UserData: function (){
            return this._UserData;
        },
        set_UserData: function (value){
            this._UserData = value;
        },
        ctor$$ICurve: function (boundaryCurve){
            this.parents = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Routing.Shape.ctor);
            this.children = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Routing.Shape.ctor);
            this.boundaryCurve = null;
            this.ports = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Layout.Port.ctor);
            this._UserData = null;
            this._IsTransparent = false;
            System.Object.ctor.call(this);
            this.boundaryCurve = boundaryCurve;
        },
        IsGroup$$: "System.Boolean",
        get_IsGroup: function (){
            return this.children.get_Count() > 0;
        },
        IsTransparent$$: "System.Boolean",
        get_IsTransparent: function (){
            return this._IsTransparent;
        },
        set_IsTransparent: function (value){
            this._IsTransparent = value;
        },
        Descendands$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Routing.Shape]]",
        get_Descendands: function (){
            var $yield = [];
            var q = new System.Collections.Generic.Queue$1.ctor(Microsoft.Msagl.Routing.Shape.ctor);
            var $it1102 = this.get_Children().GetEnumerator();
            while ($it1102.MoveNext()){
                var shape = $it1102.get_Current();
                q.Enqueue(shape);
            }
            while (q.get_Count() > 0){
                var sh = q.Dequeue();
                $yield.push(sh);
                var $it1103 = sh.get_Children().GetEnumerator();
                while ($it1103.MoveNext()){
                    var shape = $it1103.get_Current();
                    q.Enqueue(shape);
                }
            }
            return $yield;
        },
        Ancestors$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Routing.Shape]]",
        get_Ancestors: function (){
            var $yield = [];
            var q = new System.Collections.Generic.Queue$1.ctor(Microsoft.Msagl.Routing.Shape.ctor);
            var $it1104 = this.get_Parents().GetEnumerator();
            while ($it1104.MoveNext()){
                var shape = $it1104.get_Current();
                q.Enqueue(shape);
            }
            while (q.get_Count() > 0){
                var sh = q.Dequeue();
                $yield.push(sh);
                var $it1105 = sh.get_Parents().GetEnumerator();
                while ($it1105.MoveNext()){
                    var shape = $it1105.get_Current();
                    q.Enqueue(shape);
                }
            }
            return $yield;
        },
        AddParent: function (shape){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(shape, "shape");
            this.parents.Insert(shape);
            shape.children.Insert(this);
        },
        AddChild: function (shape){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(shape, "shape");
            shape.parents.Insert(this);
            this.children.Insert(shape);
        },
        RemoveChild: function (shape){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(shape, "shape");
            this.children.Remove(shape);
            shape.parents.Remove(this);
        },
        RemoveParent: function (shape){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(shape, "shape");
            this.parents.Remove(shape);
            shape.children.Remove(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Shape);
var Microsoft$Msagl$Routing$Rectilinear$Nudging$PathMerger = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.Nudging.PathMerger",
    baseTypeName: "System.Object",
    staticDefinition: {
        GetPointsInBetween: function (a, b){
            var $yield = [];
            for (var i = a.get_Next(); i != b; i = i.get_Next())
                $yield.push(i.get_Point());
            return $yield;
        },
        Before: function (a, b){
            for (a = a.get_Next(); a != null; a = a.get_Next())
                if (a == b)
                    return true;
            return false;
        },
        FindLinkedPointInPath: function (path, point){
            for (var linkedPoint = Cast(path.get_PathPoints(), Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint.ctor); ; linkedPoint = linkedPoint.get_Next())
                if (Microsoft.Msagl.Core.Geometry.Point.op_Equality(linkedPoint.get_Point(), point))
                    return linkedPoint;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (paths){
            this.verticesToPathOffsets = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Collections.Generic.Dictionary$2.ctor);
            this._Paths = null;
            System.Object.ctor.call(this);
            this.set_Paths(paths);
        },
        Paths$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Routing.Rectilinear.Nudging.Path]]",
        get_Paths: function (){
            return this._Paths;
        },
        set_Paths: function (value){
            this._Paths = value;
        },
        MergePaths: function (){
            this.InitVerticesToPathOffsetsAndRemoveSelfCycles();
            var $it1106 = this.get_Paths().GetEnumerator();
            while ($it1106.MoveNext()){
                var path = $it1106.get_Current();
                this.ProcessPath(path);
            }
        },
        ProcessPath: function (path){
            var departedPaths = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.ctor, Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint.ctor);
            var prevLocationPathOffsets = null;
            for (var linkedPoint = Cast(path.get_PathPoints(), Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint.ctor); linkedPoint != null; linkedPoint = linkedPoint.get_Next()){
                var pathOffsets = this.verticesToPathOffsets.get_Item$$TKey(linkedPoint.get_Point());
                if (prevLocationPathOffsets != null){
                    if (departedPaths.get_Count() > 0){
                        var $it1107 = pathOffsets.GetEnumerator();
                        while ($it1107.MoveNext()){
                            var pair = $it1107.get_Current();
                            var departerLinkedPoint;
                            var path0 = pair.get_Key();
                            if ((function (){
                                var $1 = {
                                    Value: departerLinkedPoint
                                };
                                var $res = departedPaths.TryGetValue(path0, $1);
                                departerLinkedPoint = $1.Value;
                                return $res;
                            }).call(this)){
                                this.CollapseLoopingPath(path0, departerLinkedPoint, pair.get_Value(), path, linkedPoint);
                                departedPaths.Remove(path0);
                            }
                        }
                    }
                    var $it1108 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(System.Collections.Generic.KeyValuePair$2.ctor, prevLocationPathOffsets, $CreateAnonymousDelegate(this, function (pair){
                        return !pathOffsets.ContainsKey(pair.get_Key());
                    })).GetEnumerator();
                    while ($it1108.MoveNext()){
                        var pair = $it1108.get_Current();
                        departedPaths.Add(pair.get_Key(), pair.get_Value());
                    }
                }
                prevLocationPathOffsets = pathOffsets;
            }
        },
        CollapseLoopingPath: function (loopingPath, departureFromLooping, arrivalToLooping, stemPath, arrivalToStem){
            var departurePointOnStem = Microsoft.Msagl.Routing.Rectilinear.Nudging.PathMerger.FindLinkedPointInPath(stemPath, departureFromLooping.get_Point());
            var pointsToInsert = Microsoft.Msagl.Routing.Rectilinear.Nudging.PathMerger.GetPointsInBetween(departurePointOnStem, arrivalToStem);
            if (Microsoft.Msagl.Routing.Rectilinear.Nudging.PathMerger.Before(departureFromLooping, arrivalToLooping)){
                this.CleanDisappearedPiece(departureFromLooping, arrivalToLooping, loopingPath);
                this.ReplacePiece(departureFromLooping, arrivalToLooping, pointsToInsert, loopingPath);
            }
            else {
                this.CleanDisappearedPiece(arrivalToLooping, departureFromLooping, loopingPath);
                this.ReplacePiece(arrivalToLooping, departureFromLooping, System.Linq.Enumerable.Reverse$1(Microsoft.Msagl.Core.Geometry.Point.ctor, pointsToInsert), loopingPath);
            }
        },
        ReplacePiece: function (a, b, points, loopingPath){
            var prevPoint = a;
            var $it1109 = points.GetEnumerator();
            while ($it1109.MoveNext()){
                var point = $it1109.get_Current();
                var lp = new Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint.ctor(point);
                prevPoint.set_Next(lp);
                prevPoint = lp;
                var pathOffset = this.verticesToPathOffsets.get_Item$$TKey(point);
                System.Diagnostics.Debug.Assert$$Boolean(!pathOffset.ContainsKey(loopingPath));
                pathOffset.set_Item$$TKey(loopingPath, prevPoint);
            }
            prevPoint.set_Next(b);
        },
        CleanDisappearedPiece: function (a, b, loopingPath){
            var $it1110 = Microsoft.Msagl.Routing.Rectilinear.Nudging.PathMerger.GetPointsInBetween(a, b).GetEnumerator();
            while ($it1110.MoveNext()){
                var point = $it1110.get_Current();
                var pathOffset = this.verticesToPathOffsets.get_Item$$TKey(point);
                System.Diagnostics.Debug.Assert$$Boolean(pathOffset.ContainsKey(loopingPath));
                pathOffset.Remove(loopingPath);
            }
        },
        InitVerticesToPathOffsetsAndRemoveSelfCycles: function (){
            var $it1111 = this.get_Paths().GetEnumerator();
            while ($it1111.MoveNext()){
                var path = $it1111.get_Current();
                for (var linkedPoint = Cast(path.get_PathPoints(), Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint.ctor); linkedPoint != null; linkedPoint = linkedPoint.get_Next()){
                    var pathOffsets;
                    if (!(function (){
                        var $1 = {
                            Value: pathOffsets
                        };
                        var $res = this.verticesToPathOffsets.TryGetValue(linkedPoint.get_Point(), $1);
                        pathOffsets = $1.Value;
                        return $res;
                    }).call(this))
                        this.verticesToPathOffsets.set_Item$$TKey(linkedPoint.get_Point(), pathOffsets = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.ctor, Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint.ctor));
                    var loopPoint;
                    if ((function (){
                        var $1 = {
                            Value: loopPoint
                        };
                        var $res = pathOffsets.TryGetValue(path, $1);
                        loopPoint = $1.Value;
                        return $res;
                    }).call(this)){
                        this.CleanDisappearedPiece(loopPoint, linkedPoint, path);
                        loopPoint.set_Next(linkedPoint.get_Next());
                    }
                    else
                        pathOffsets.set_Item$$TKey(path, linkedPoint);
                }
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$Nudging$PathMerger);
var Microsoft$Msagl$Routing$Rectilinear$SpliceUtility = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.SpliceUtility",
    baseTypeName: "System.Object",
    staticDefinition: {
        MungeClosestIntersectionInfo: function (rayOrigin, closestIntersection, isHorizontal){
            var bbox = closestIntersection.get_Segment1().get_BoundingBox();
            var closest = Microsoft.Msagl.Routing.Rectilinear.SpliceUtility.RawIntersection(closestIntersection, rayOrigin).Clone();
            if (isHorizontal){
                closest.set_X(Microsoft.Msagl.Routing.Rectilinear.SpliceUtility.MungeIntersect(rayOrigin.get_X(), closest.get_X(), bbox.get_Left(), bbox.get_Right()));
            }
            else {
                closest.set_Y(Microsoft.Msagl.Routing.Rectilinear.SpliceUtility.MungeIntersect(rayOrigin.get_Y(), closest.get_Y(), bbox.get_Bottom(), bbox.get_Top()));
            }
            return closest;
        },
        MungeIntersect: function (site, intersect, start, end){
            if (site < intersect){
                var min = System.Math.Min$$Double$$Double(start, end);
                if (intersect < min){
                    intersect = min;
                }
            }
            else if (site > intersect){
                var max = System.Math.Max$$Double$$Double(start, end);
                if (intersect > max){
                    intersect = max;
                }
            }
            return Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Double(intersect);
        },
        RawIntersection: function (xx, origin){
            System.Diagnostics.Debug.Assert$$Boolean$$String(Is(xx.get_Segment0(), Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor), "LineSegment was not first arg to GetAllIntersections");
            var point = xx.get_Segment0().get_Item$$Double(xx.get_Par0());
            var lineSeg = Cast(xx.get_Segment0(), Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor);
            if (Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsVertical$$Directions(Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(lineSeg.get_Start(), lineSeg.get_End()))){
                System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Double$$Double(point.get_X(), origin.get_X()), "segment0 obstacle intersection is off the vertical line");
            }
            else {
                System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Double$$Double(point.get_Y(), origin.get_Y()), "segment0 obstacle intersection is off the horizontal line");
            }
            return Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Point(point);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$SpliceUtility);
var Microsoft$Msagl$Routing$Rectilinear$SsstRectilinearPath = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.DefaultBendPenaltyAsAPercentageOfDistance = 4;
            Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.AddOneTurn = [Microsoft.Msagl.Core.Geometry.Directions.None, 11, 7, 15, 14, 15, 15, 15, 13, 15, 15, 15, 15, 15, 15, 15];
        },
        IsInDirs: function (direction, dirs){
            return direction == (direction & dirs);
        },
        GetBendsForNotPureDirection: function (dirToTarget, entryDirToVertex, entryDirectionsToTarget){
            var a = dirToTarget & entryDirToVertex;
            if (a == Microsoft.Msagl.Core.Geometry.Directions.None){
                return Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.GetBendsForNotPureDirection(dirToTarget, Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.AddOneTurn[entryDirToVertex], entryDirectionsToTarget) + 1;
            }
            var b = dirToTarget & entryDirectionsToTarget;
            if (b == Microsoft.Msagl.Core.Geometry.Directions.None){
                return Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.GetBendsForNotPureDirection(dirToTarget, entryDirToVertex, Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.AddOneTurn[entryDirectionsToTarget]) + 1;
            }
            return (a | b) == dirToTarget ? 1 : 2;
        },
        Left: function (direction){
            switch (direction){
                case Microsoft.Msagl.Core.Geometry.Directions.None:
                    return Microsoft.Msagl.Core.Geometry.Directions.None;
                case Microsoft.Msagl.Core.Geometry.Directions.North:
                    return Microsoft.Msagl.Core.Geometry.Directions.West;
                case Microsoft.Msagl.Core.Geometry.Directions.East:
                    return Microsoft.Msagl.Core.Geometry.Directions.North;
                case Microsoft.Msagl.Core.Geometry.Directions.South:
                    return Microsoft.Msagl.Core.Geometry.Directions.East;
                case Microsoft.Msagl.Core.Geometry.Directions.West:
                    return Microsoft.Msagl.Core.Geometry.Directions.South;
                default:
                    throw $CreateException(new System.ArgumentOutOfRangeException.ctor$$String("direction"), new Error());
            }
        },
        Right: function (direction){
            switch (direction){
                case Microsoft.Msagl.Core.Geometry.Directions.None:
                    return Microsoft.Msagl.Core.Geometry.Directions.None;
                case Microsoft.Msagl.Core.Geometry.Directions.North:
                    return Microsoft.Msagl.Core.Geometry.Directions.East;
                case Microsoft.Msagl.Core.Geometry.Directions.East:
                    return Microsoft.Msagl.Core.Geometry.Directions.South;
                case Microsoft.Msagl.Core.Geometry.Directions.South:
                    return Microsoft.Msagl.Core.Geometry.Directions.West;
                case Microsoft.Msagl.Core.Geometry.Directions.West:
                    return Microsoft.Msagl.Core.Geometry.Directions.North;
                default:
                    throw $CreateException(new System.ArgumentOutOfRangeException.ctor$$String("direction"), new Error());
            }
        },
        RestorePath$$VertexEntry: function (entry){
            return (function (){
                var $1 = {
                    Value: entry
                };
                var $res = Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.RestorePath$$VertexEntry$$VisibilityVertex($1, null);
                entry = $1.Value;
                return $res;
            })();
        },
        RestorePath$$VertexEntry$$VisibilityVertex: function (entry, firstVertexInStage){
            if (entry.Value == null){
                return null;
            }
            var list = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            var skippedCollinearEntry = false;
            var lastEntryDir = Microsoft.Msagl.Core.Geometry.Directions.None;
            while (true){
                if (lastEntryDir == entry.Value.get_Direction()){
                    skippedCollinearEntry = true;
                }
                else {
                    skippedCollinearEntry = false;
                    list.Add(entry.Value.get_Vertex().Point);
                    lastEntryDir = entry.Value.get_Direction();
                }
                var previousEntry = entry.Value.get_PreviousEntry();
                if ((previousEntry == null) || (entry.Value.get_Vertex() == firstVertexInStage)){
                    break;
                }
                entry.Value = previousEntry;
            }
            if (skippedCollinearEntry){
                list.Add(entry.Value.get_Vertex().Point);
            }
            list.Reverse();
            return list;
        },
        GetLengthAndNumberOfBendsToNeighborVertex: function (prevEntry, vertex, weight, numberOfBends, length){
            length.Value = prevEntry.get_Length() + Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.ManhattanDistance(prevEntry.get_Vertex().Point, vertex.Point) * weight;
            var directionToVertex = Microsoft.Msagl.Core.Geometry.CompassVector.PureDirectionFromPointToPoint(prevEntry.get_Vertex().Point, vertex.Point);
            numberOfBends.Value = prevEntry.get_NumberOfBends();
            if (prevEntry.get_Direction() != Microsoft.Msagl.Core.Geometry.Directions.None && directionToVertex != prevEntry.get_Direction()){
                numberOfBends.Value++;
            }
            return directionToVertex;
        },
        ManhattanDistance: function (a, b){
            return System.Math.Abs$$Double(b.get_X() - a.get_X()) + System.Math.Abs$$Double(b.get_Y() - a.get_Y());
        },
        IsPassable: function (edge){
            return edge.get_IsPassable() == null || edge.get_IsPassable()();
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.upperBoundOnCost = 0;
            this.sourceCostAdjustment = 0;
            this.targetCostAdjustment = 0;
            this.queue = null;
            this.visitedVertices = null;
            this.nextNeighbors = [new Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.NextNeighbor.ctor(), new Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.NextNeighbor.ctor(), new Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.NextNeighbor.ctor()];
            this._LengthImportance = 0;
            this._BendsImportance = 0;
            this._Target = null;
            this._Source = null;
            this._EntryDirectionsToTarget = Microsoft.Msagl.Core.Geometry.Directions.None;
            System.Object.ctor.call(this);
            this.set_LengthImportance(1);
            this.set_BendsImportance(1);
        },
        LengthImportance$$: "System.Double",
        get_LengthImportance: function (){
            return this._LengthImportance;
        },
        set_LengthImportance: function (value){
            this._LengthImportance = value;
        },
        BendsImportance$$: "System.Double",
        get_BendsImportance: function (){
            return this._BendsImportance;
        },
        set_BendsImportance: function (value){
            this._BendsImportance = value;
        },
        Target$$: "Microsoft.Msagl.Routing.Rectilinear.VisibilityVertexRectilinear",
        get_Target: function (){
            return this._Target;
        },
        set_Target: function (value){
            this._Target = value;
        },
        Source$$: "Microsoft.Msagl.Routing.Rectilinear.VisibilityVertexRectilinear",
        get_Source: function (){
            return this._Source;
        },
        set_Source: function (value){
            this._Source = value;
        },
        EntryDirectionsToTarget$$: "Microsoft.Msagl.Core.Geometry.Directions",
        get_EntryDirectionsToTarget: function (){
            return this._EntryDirectionsToTarget;
        },
        set_EntryDirectionsToTarget: function (value){
            this._EntryDirectionsToTarget = value;
        },
        CombinedCost: function (length, numberOfBends){
            return this.get_LengthImportance() * length + this.get_BendsImportance() * numberOfBends;
        },
        TotalCostFromSourceToVertex: function (length, numberOfBends){
            return this.CombinedCost(length, numberOfBends) + this.sourceCostAdjustment;
        },
        InitPath: function (sourceVertexEntries, source, target){
            if ((source == target) || !this.InitEntryDirectionsAtTarget(target)){
                return false;
            }
            this.set_Target(target);
            this.set_Source(source);
            var cost = this.TotalCostFromSourceToVertex(0, 0) + this.HeuristicDistanceFromVertexToTarget(source.Point, Microsoft.Msagl.Core.Geometry.Directions.None);
            if (cost >= this.upperBoundOnCost){
                return false;
            }
            this.queue = new Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueueWithTimestamp$1.ctor(Microsoft.Msagl.Routing.Rectilinear.VertexEntry.ctor);
            this.visitedVertices = (function (){
                var $v122 = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Rectilinear.VisibilityVertexRectilinear.ctor);
                $v122.Add(source);
                return $v122;
            }).call(this);
            if (sourceVertexEntries == null){
                this.EnqueueInitialVerticesFromSource(cost);
            }
            else {
                this.EnqueueInitialVerticesFromSourceEntries(sourceVertexEntries);
            }
            return this.queue.get_Count() > 0;
        },
        InitEntryDirectionsAtTarget: function (vert){
            this.set_EntryDirectionsToTarget(Microsoft.Msagl.Core.Geometry.Directions.None);
            var $it1112 = vert.get_OutEdges().GetEnumerator();
            while ($it1112.MoveNext()){
                var edge = $it1112.get_Current();
                this.get_EntryDirectionsToTarget() |= Microsoft.Msagl.Core.Geometry.CompassVector.DirectionsFromPointToPoint(edge.get_TargetPoint(), vert.Point);
            }
            var $it1113 = vert.get_InEdges().GetEnumerator();
            while ($it1113.MoveNext()){
                var edge = $it1113.get_Current();
                this.get_EntryDirectionsToTarget() |= Microsoft.Msagl.Core.Geometry.CompassVector.DirectionsFromPointToPoint(edge.get_SourcePoint(), vert.Point);
            }
            return this.get_EntryDirectionsToTarget() != Microsoft.Msagl.Core.Geometry.Directions.None;
        },
        MultistageAdjustedCostBound: function (bestCost){
            return !System.Double.IsPositiveInfinity(bestCost) ? bestCost + this.get_BendsImportance() : bestCost;
        },
        HeuristicDistanceFromVertexToTarget: function (point, entryDirToVertex){
            var vectorToTarget = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.get_Target().Point, point);
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(vectorToTarget.get_X(), 0) && Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(vectorToTarget.get_Y(), 0)){
                return this.targetCostAdjustment;
            }
            var dirToTarget = Microsoft.Msagl.Core.Geometry.CompassVector.VectorDirection$$Point(vectorToTarget);
            var numberOfBends;
            if (entryDirToVertex == Microsoft.Msagl.Core.Geometry.Directions.None){
                entryDirToVertex = 15;
                numberOfBends = this.GetNumberOfBends(entryDirToVertex, dirToTarget);
            }
            else {
                numberOfBends = this.GetNumberOfBends(entryDirToVertex, dirToTarget);
            }
            return this.CombinedCost(Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.ManhattanDistance(point, this.get_Target().Point), numberOfBends) + this.targetCostAdjustment;
        },
        GetNumberOfBends: function (entryDirToVertex, dirToTarget){
            return Microsoft.Msagl.Core.Geometry.CompassVector.IsPureDirection$$Directions(dirToTarget) ? this.GetNumberOfBendsForPureDirection(entryDirToVertex, dirToTarget) : Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.GetBendsForNotPureDirection(dirToTarget, entryDirToVertex, this.get_EntryDirectionsToTarget());
        },
        GetNumberOfBendsForPureDirection: function (entryDirToVertex, dirToTarget){
            if ((dirToTarget & entryDirToVertex) == dirToTarget){
                if (Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.IsInDirs(dirToTarget, this.get_EntryDirectionsToTarget())){
                    return 0;
                }
                if (Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.IsInDirs(Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.Left(dirToTarget), this.get_EntryDirectionsToTarget()) || Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.IsInDirs(Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.Right(dirToTarget), this.get_EntryDirectionsToTarget())){
                    return 2;
                }
                return 4;
            }
            return this.GetNumberOfBendsForPureDirection(Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.AddOneTurn[entryDirToVertex], dirToTarget) + 1;
        },
        QueueReversedEntryToNeighborVertexIfNeeded: function (bestEntry, entryFromNeighbor, weight){
            var numberOfBends;
            var length;
            var neigVer = entryFromNeighbor.get_PreviousVertex();
            var dirToNeighbor = (function (){
                var $1 = {
                    Value: numberOfBends
                };
                var $2 = {
                    Value: length
                };
                var $res = Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.GetLengthAndNumberOfBendsToNeighborVertex(bestEntry, neigVer, weight, $1, $2);
                numberOfBends = $1.Value;
                length = $2.Value;
                return $res;
            }).call(this);
            if ((this.CombinedCost(length, numberOfBends) < this.CombinedCost(entryFromNeighbor.get_Length(), entryFromNeighbor.get_NumberOfBends())) || (bestEntry.get_Vertex().get_Degree() == 1)){
                var cost = this.TotalCostFromSourceToVertex(length, numberOfBends) + this.HeuristicDistanceFromVertexToTarget(neigVer.Point, dirToNeighbor);
                this.EnqueueEntry(bestEntry, neigVer, length, numberOfBends, cost);
            }
        },
        UpdateEntryToNeighborVertexIfNeeded: function (bestEntry, neigEntry, weight){
            var numberOfBends;
            var length;
            var dirToNeighbor = (function (){
                var $1 = {
                    Value: numberOfBends
                };
                var $2 = {
                    Value: length
                };
                var $res = Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.GetLengthAndNumberOfBendsToNeighborVertex(bestEntry, neigEntry.get_Vertex(), weight, $1, $2);
                numberOfBends = $1.Value;
                length = $2.Value;
                return $res;
            }).call(this);
            if (this.CombinedCost(length, numberOfBends) < this.CombinedCost(neigEntry.get_Length(), neigEntry.get_NumberOfBends())){
                var newCost = this.TotalCostFromSourceToVertex(length, numberOfBends) + this.HeuristicDistanceFromVertexToTarget(neigEntry.get_Vertex().Point, dirToNeighbor);
                neigEntry.ResetEntry(bestEntry, length, numberOfBends, newCost);
                this.queue.DecreasePriority(neigEntry, newCost);
            }
        },
        CreateAndEnqueueEntryToNeighborVertex: function (bestEntry, neigVer, weight){
            var numberOfBends;
            var length;
            var dirToNeighbor = (function (){
                var $1 = {
                    Value: numberOfBends
                };
                var $2 = {
                    Value: length
                };
                var $res = Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.GetLengthAndNumberOfBendsToNeighborVertex(bestEntry, neigVer, weight, $1, $2);
                numberOfBends = $1.Value;
                length = $2.Value;
                return $res;
            }).call(this);
            var cost = this.TotalCostFromSourceToVertex(length, numberOfBends) + this.HeuristicDistanceFromVertexToTarget(neigVer.Point, dirToNeighbor);
            if (cost < this.upperBoundOnCost){
                if (neigVer.get_VertexEntries() == null){
                    this.visitedVertices.Add(neigVer);
                }
                this.EnqueueEntry(bestEntry, neigVer, length, numberOfBends, cost);
            }
        },
        EnqueueEntry: function (bestEntry, neigVer, length, numberOfBends, cost){
            var entry = new Microsoft.Msagl.Routing.Rectilinear.VertexEntry.ctor(neigVer, bestEntry, length, numberOfBends, cost);
            neigVer.SetVertexEntry(entry);
            this.queue.Enqueue(entry, entry.get_Cost());
        },
        GetPathWithCost: function (sourceVertexEntries, source, adjustmentToSourceCost, targetVertexEntries, target, adjustmentToTargetCost, priorBestCost){
            this.upperBoundOnCost = priorBestCost;
            this.sourceCostAdjustment = adjustmentToSourceCost;
            this.targetCostAdjustment = adjustmentToTargetCost;
            if (!this.InitPath(sourceVertexEntries, source, target)){
                return null;
            }
            while (this.queue.get_Count() > 0){
                var bestEntry = this.queue.Dequeue();
                var bestVertex = bestEntry.get_Vertex();
                if (bestVertex == this.get_Target()){
                    if (targetVertexEntries == null){
                        this.Cleanup();
                        return bestEntry;
                    }
                    this.get_EntryDirectionsToTarget() &= ~bestEntry.get_Direction();
                    if (this.get_EntryDirectionsToTarget() == Microsoft.Msagl.Core.Geometry.Directions.None){
                        this.get_Target().get_VertexEntries().CopyTo(targetVertexEntries, 0);
                        this.Cleanup();
                        return null;
                    }
                    this.upperBoundOnCost = System.Math.Min$$Double$$Double(this.MultistageAdjustedCostBound(bestEntry.get_Cost()), this.upperBoundOnCost);
                    continue;
                }
                bestEntry.set_IsClosed(true);
                for (var $i1115 = 0,$t1115 = this.nextNeighbors,$l1115 = $t1115.length,bendNeighbor = $t1115[$i1115]; $i1115 < $l1115; $i1115++, bendNeighbor = $t1115[$i1115]){
                    bendNeighbor.Clear();
                }
                var preferredBendDir = Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.Right(bestEntry.get_Direction());
                this.ExtendPathAlongInEdges(bestEntry, bestVertex.get_InEdges(), preferredBendDir);
                this.ExtendPathAlongOutEdges(bestEntry, bestVertex.get_OutEdges(), preferredBendDir);
                for (var $i1116 = 0,$t1116 = this.nextNeighbors,$l1116 = $t1116.length,bendNeighbor = $t1116[$i1116]; $i1116 < $l1116; $i1116++, bendNeighbor = $t1116[$i1116]){
                    if (bendNeighbor.Vertex != null){
                        this.ExtendPathToNeighborVertex(bestEntry, bendNeighbor.Vertex, bendNeighbor.Weight);
                    }
                }
            }
            if ((targetVertexEntries != null) && (this.get_Target().get_VertexEntries() != null)){
                this.get_Target().get_VertexEntries().CopyTo(targetVertexEntries, 0);
            }
            this.Cleanup();
            return null;
        },
        ExtendPathAlongInEdges: function (bestEntry, edges, preferredBendDir){
            var count = edges.get_Count();
            for (var ii = 0; ii < count; ++ii){
                var edge = edges.get_Item$$Int32(ii);
                this.ExtendPathAlongEdge(bestEntry, edge, true, preferredBendDir);
            }
        },
        ExtendPathAlongOutEdges: function (bestEntry, edges, preferredBendDir){
            var outEdgeNode = edges.IsEmpty() ? null : edges.TreeMinimum();
            for (; outEdgeNode != null; outEdgeNode = edges.Next(outEdgeNode)){
                this.ExtendPathAlongEdge(bestEntry, outEdgeNode.Item, false, preferredBendDir);
            }
        },
        ExtendPathAlongEdge: function (bestEntry, edge, isInEdges, preferredBendDir){
            if (!Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.IsPassable(edge)){
                return;
            }
            var neigVer = Cast((isInEdges ? edge.get_Source() : edge.get_Target()), Microsoft.Msagl.Routing.Rectilinear.VisibilityVertexRectilinear.ctor);
            if (neigVer == bestEntry.get_PreviousVertex()){
                if ((bestEntry.get_Vertex().get_Degree() > 1) || (bestEntry.get_Vertex() != this.get_Source())){
                    return;
                }
                this.ExtendPathToNeighborVertex(bestEntry, neigVer, edge.get_Weight());
                return;
            }
            var neigDir = Microsoft.Msagl.Core.Geometry.CompassVector.PureDirectionFromPointToPoint(bestEntry.get_Vertex().Point, neigVer.Point);
            var nextNeighbor = this.nextNeighbors[2];
            if (neigDir != bestEntry.get_Direction()){
                nextNeighbor = this.nextNeighbors[(neigDir == preferredBendDir) ? 1 : 0];
            }
            System.Diagnostics.Debug.Assert$$Boolean$$String(nextNeighbor.Vertex == null, "bend neighbor already exists");
            nextNeighbor.Set(neigVer, edge.get_Weight());
        },
        EnqueueInitialVerticesFromSource: function (cost){
            var bestEntry = (function (){
                var $v123 = new Microsoft.Msagl.Routing.Rectilinear.VertexEntry.ctor(this.get_Source(), null, 0, 0, cost);
                $v123.set_IsClosed(true);
                return $v123;
            }).call(this);
            var $it1116 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor, this.get_Source().get_OutEdges(), Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.IsPassable).GetEnumerator();
            while ($it1116.MoveNext()){
                var edge = $it1116.get_Current();
                this.ExtendPathToNeighborVertex(bestEntry, Cast(edge.get_Target(), Microsoft.Msagl.Routing.Rectilinear.VisibilityVertexRectilinear.ctor), edge.get_Weight());
            }
            var $it1117 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor, this.get_Source().get_InEdges(), Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.IsPassable).GetEnumerator();
            while ($it1117.MoveNext()){
                var edge = $it1117.get_Current();
                this.ExtendPathToNeighborVertex(bestEntry, Cast(edge.get_Source(), Microsoft.Msagl.Routing.Rectilinear.VisibilityVertexRectilinear.ctor), edge.get_Weight());
            }
        },
        EnqueueInitialVerticesFromSourceEntries: function (sourceEntries){
            for (var $i1119 = 0,$l1119 = sourceEntries.length,entry = sourceEntries[$i1119]; $i1119 < $l1119; $i1119++, entry = sourceEntries[$i1119]){
                if (entry != null){
                    this.queue.Enqueue(entry, entry.get_Cost());
                }
            }
        },
        ExtendPathToNeighborVertex: function (bestEntry, neigVer, weight){
            var dirToNeighbor = Microsoft.Msagl.Core.Geometry.CompassVector.PureDirectionFromPointToPoint(bestEntry.get_Vertex().Point, neigVer.Point);
            var neigEntry = (neigVer.get_VertexEntries() != null) ? neigVer.get_VertexEntries()[Microsoft.Msagl.Core.Geometry.CompassVector.ToIndex(dirToNeighbor)] : null;
            if (neigEntry == null){
                if (!this.CreateAndEnqueueReversedEntryToNeighborVertex(bestEntry, neigVer, weight)){
                    this.CreateAndEnqueueEntryToNeighborVertex(bestEntry, neigVer, weight);
                }
            }
            else if (!neigEntry.get_IsClosed()){
                this.UpdateEntryToNeighborVertexIfNeeded(bestEntry, neigEntry, weight);
            }
        },
        CreateAndEnqueueReversedEntryToNeighborVertex: function (bestEntry, neigVer, weight){
            if (bestEntry.get_Vertex().get_VertexEntries() != null){
                var dirFromNeighbor = Microsoft.Msagl.Core.Geometry.CompassVector.PureDirectionFromPointToPoint(neigVer.Point, bestEntry.get_Vertex().Point);
                var entryFromNeighbor = bestEntry.get_Vertex().get_VertexEntries()[Microsoft.Msagl.Core.Geometry.CompassVector.ToIndex(dirFromNeighbor)];
                if (entryFromNeighbor != null){
                    System.Diagnostics.Debug.Assert$$Boolean$$String(entryFromNeighbor.get_PreviousVertex() == neigVer, "mismatch in turnback PreviousEntry");
                    System.Diagnostics.Debug.Assert$$Boolean$$String(entryFromNeighbor.get_PreviousEntry().get_IsClosed(), "turnback PreviousEntry should be closed");
                    this.QueueReversedEntryToNeighborVertexIfNeeded(bestEntry, entryFromNeighbor, weight);
                    return true;
                }
            }
            return false;
        },
        Cleanup: function (){
            var $it1119 = this.visitedVertices.GetEnumerator();
            while ($it1119.MoveNext()){
                var v = $it1119.get_Current();
                v.RemoveVertexEntries();
            }
            this.visitedVertices.Clear();
            this.queue = null;
        },
        DevTraceShowAllPartialPaths: function (source, mostRecentlyExtendedPath){
        },
        DevTraceShowPath: function (source, lastEntry){
        },
        DevTracePrintSourceAndTarget: function (source, target){
        },
        TestPreDequeue: function (){
        },
        TestClearIterations: function (){
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$SsstRectilinearPath);
var Microsoft$Msagl$Routing$Rectilinear$SsstRectilinearPath$NextNeighbor = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.NextNeighbor",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.Vertex = null;
            this.Weight = 0;
            System.Object.ctor.call(this);
            this.Clear();
        },
        Set: function (v, w){
            this.Vertex = v;
            this.Weight = w;
        },
        Clear: function (){
            this.Vertex = null;
            this.Weight = NaN;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$SsstRectilinearPath$NextNeighbor);
var Microsoft$Msagl$Routing$Rectilinear$RectilinearEdgeRouter = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.DefaultPadding = 1;
            Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.DefaultCornerFitRadius = 3;
        },
        SplitEdgeGeomsWithWaypoints: function (edgeGeometries){
            var ret = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, System.Collections.Generic.IEnumerable$1.ctor);
            var $it1127 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, edgeGeometries, function (eg){
                return eg.get_HasWaypoints();
            }).GetEnumerator();
            while ($it1127.MoveNext()){
                var edgeGeometry = $it1127.get_Current();
                ret.set_Item$$TKey(edgeGeometry, Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.SplitEdgeGeomWithWaypoints(edgeGeometry, edgeGeometry.get_Waypoints()));
            }
            return ret;
        },
        SplitEdgeGeomWithWaypoints: function (edgeGeom, waypoints){
            var ret = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.ctor);
            var wp0 = waypoints.GetEnumerator();
            wp0.MoveNext();
            ret.Add(new Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.ctor(new Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor$$Port$$Port(edgeGeom.get_SourcePort(), new Microsoft.Msagl.Routing.Rectilinear.WaypointPort.ctor(wp0.get_Current()))));
            var wp1 = waypoints.GetEnumerator();
            wp1.MoveNext();
            while (wp1.MoveNext()){
                ret.Add(new Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.ctor(new Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor$$Port$$Port(new Microsoft.Msagl.Routing.Rectilinear.WaypointPort.ctor(wp0.get_Current()), new Microsoft.Msagl.Routing.Rectilinear.WaypointPort.ctor(wp1.get_Current()))));
                wp0.MoveNext();
            }
            ret.Add(new Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.ctor(new Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor$$Port$$Port(new Microsoft.Msagl.Routing.Rectilinear.WaypointPort.ctor(wp0.get_Current()), edgeGeom.get_TargetPort())));
            return ret;
        },
        GetSingleStagePath: function (edgePath, shortestPathRouter, sourceVertices, targetVertices, lastChance){
            edgePath.set_PathPoints(shortestPathRouter.GetPath$$IEnumerable$1$VisibilityVertex$$IEnumerable$1$VisibilityVertex(sourceVertices, targetVertices));
            if (lastChance){
                Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.EnsureNonNullPath(edgePath);
            }
            return (edgePath.get_PathPoints() != null);
        },
        EnsureNonNullPath: function (edgePath){
            if (null == edgePath.get_PathPoints()){
                if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.IsPureDirection$$Point$$Point(edgePath.get_EdgeGeometry().get_SourcePort().get_Location(), edgePath.get_EdgeGeometry().get_TargetPort().get_Location())){
                    edgePath.set_PathPoints([edgePath.get_EdgeGeometry().get_SourcePort().get_Location(), edgePath.get_EdgeGeometry().get_TargetPort().get_Location()]);
                    return;
                }
                edgePath.set_PathPoints([edgePath.get_EdgeGeometry().get_SourcePort().get_Location(), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(edgePath.get_EdgeGeometry().get_SourcePort().get_Location().get_X(), edgePath.get_EdgeGeometry().get_TargetPort().get_Location().get_Y()), edgePath.get_EdgeGeometry().get_TargetPort().get_Location()]);
            }
        },
        CalculateArrowheads: function (edgeGeom){
            Microsoft.Msagl.Core.Layout.Arrowheads.TrimSplineAndCalculateArrowheads$$EdgeGeometry$$ICurve$$ICurve$$ICurve$$Boolean$$Boolean(edgeGeom, edgeGeom.get_SourcePort().get_Curve(), edgeGeom.get_TargetPort().get_Curve(), edgeGeom.get_Curve(), true, false);
        },
        GetSourceBoundary: function (edgeGeom){
            return edgeGeom.get_SourcePort().get_Curve();
        },
        GetTargetBoundary: function (edgeGeom){
            return edgeGeom.get_TargetPort().get_Curve();
        },
        FitArcsIntoCorners: function (radius, polyline){
            var ellipses = Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.GetFittedArcSegs(radius, polyline);
            var curve = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor$$Int32(polyline.length);
            var prevEllipse = null;
            var $it1133 = ellipses.GetEnumerator();
            while ($it1133.MoveNext()){
                var ellipse = $it1133.get_Current();
                var ellipseIsAlmostCurve = Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.EllipseIsAlmostLineSegment(ellipse);
                if (prevEllipse != null){
                    if (ellipseIsAlmostCurve)
                        Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Point(curve, Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.CornerPoint(ellipse));
                    else {
                        Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Point(curve, ellipse.get_Start());
                        curve.AddSegment(ellipse);
                    }
                }
                else {
                    if (ellipseIsAlmostCurve)
                        Microsoft.Msagl.Core.Geometry.Curves.Curve.AddLineSegment$$Curve$$Point$$Point(curve, polyline[0], Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.CornerPoint(ellipse));
                    else {
                        Microsoft.Msagl.Core.Geometry.Curves.Curve.AddLineSegment$$Curve$$Point$$Point(curve, polyline[0], ellipse.get_Start());
                        curve.AddSegment(ellipse);
                    }
                }
                prevEllipse = ellipse;
            }
            if (curve.get_Segments().get_Count() > 0)
                Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Point(curve, polyline[polyline.length - 1]);
            else
                Microsoft.Msagl.Core.Geometry.Curves.Curve.AddLineSegment$$Curve$$Point$$Point(curve, polyline[0], polyline[polyline.length - 1]);
            return curve;
        },
        CornerPoint: function (ellipse){
            return Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Addition(ellipse.get_Center(), ellipse.get_AxisA()), ellipse.get_AxisB());
        },
        EllipseIsAlmostLineSegment: function (ellipse){
            return ellipse.get_AxisA().get_LengthSquared() < 0.0001 || ellipse.get_AxisB().get_LengthSquared() < 0.0001;
        },
        GetFittedArcSegs: function (radius, polyline){
            var $yield = [];
            var leg = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(polyline[1], polyline[0]);
            var dir = leg.Normalize();
            var rad0 = System.Math.Min$$Double$$Double(radius, leg.get_Length() / 2);
            for (var i = 1; i < polyline.length - 1; i++){
                var ret = null;
                leg = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(polyline[i + 1], polyline[i]);
                var legLength = leg.get_Length();
                if (legLength < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_IntersectionEpsilon())
                    ret = new Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor$$Double$$Double$$Point(0, 0, polyline[i]);
                var ndir = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(leg, legLength);
                if (System.Math.Abs$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(ndir, dir)) > 0.9)
                    ret = new Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor$$Double$$Double$$Point(0, 0, polyline[i]);
                var nrad0 = System.Math.Min$$Double$$Double(radius, leg.get_Length() / 2);
                var axis0 = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(-nrad0, ndir);
                var axis1 = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(rad0, dir);
                $yield.push((ret != null ? ret : (new Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor$$Double$$Double$$Point$$Point$$Point(0, 1.5707963267949, axis0, axis1, Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(polyline[i], axis1), axis0)))));
                dir = ndir;
                rad0 = nrad0;
            }
            return $yield;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.GraphGenerator = null;
            this.ShapeToObstacleMap = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor);
            this.EdgeGeometries = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor);
            this.PortManager = null;
            this.edgeGeomsToSplittedEdgePaths = null;
            this.removeStaircases = true;
            this.selfEdges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor);
            this._Padding = 0;
            this._CornerFitRadius = 0;
            this._BendPenaltyAsAPercentageOfDistance = 0;
            this._UseObstacleRectangles = false;
            this._AncestorsSets = null;
            Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.ctor$$IEnumerable$1$Shape.call(this, null);
        },
        Padding$$: "System.Double",
        get_Padding: function (){
            return this._Padding;
        },
        set_Padding: function (value){
            this._Padding = value;
        },
        CornerFitRadius$$: "System.Double",
        get_CornerFitRadius: function (){
            return this._CornerFitRadius;
        },
        set_CornerFitRadius: function (value){
            this._CornerFitRadius = value;
        },
        BendPenaltyAsAPercentageOfDistance$$: "System.Double",
        get_BendPenaltyAsAPercentageOfDistance: function (){
            return this._BendPenaltyAsAPercentageOfDistance;
        },
        set_BendPenaltyAsAPercentageOfDistance: function (value){
            this._BendPenaltyAsAPercentageOfDistance = value;
        },
        RouteToCenterOfObstacles$$: "System.Boolean",
        get_RouteToCenterOfObstacles: function (){
            return this.PortManager.get_RouteToCenterOfObstacles();
        },
        set_RouteToCenterOfObstacles: function (value){
            this.PortManager.set_RouteToCenterOfObstacles(value);
        },
        LimitPortVisibilitySpliceToEndpointBoundingBox$$: "System.Boolean",
        get_LimitPortVisibilitySpliceToEndpointBoundingBox: function (){
            return this.PortManager.get_LimitPortVisibilitySpliceToEndpointBoundingBox();
        },
        set_LimitPortVisibilitySpliceToEndpointBoundingBox: function (value){
            this.PortManager.set_LimitPortVisibilitySpliceToEndpointBoundingBox(value);
        },
        AddEdgeGeometryToRoute: function (edgeGeometry){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(edgeGeometry, "edgeGeometry");
            if (!Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Point(edgeGeometry.get_SourcePort().get_Location()), Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Point(edgeGeometry.get_TargetPort().get_Location()))){
                this.EdgeGeometries.Add(edgeGeometry);
            }
            else {
                this.selfEdges.Add(edgeGeometry);
            }
        },
        RemoveEdgeGeometryToRoute: function (edgeGeometry){
            this.EdgeGeometries.Remove(edgeGeometry);
        },
        EdgeGeometriesToRoute$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Layout.EdgeGeometry]]",
        get_EdgeGeometriesToRoute: function (){
            return this.EdgeGeometries;
        },
        RemoveAllEdgeGeometriesToRoute: function (){
            this.EdgeGeometries.Clear();
        },
        UseSparseVisibilityGraph$$: "System.Boolean",
        get_UseSparseVisibilityGraph: function (){
            return Is(this.GraphGenerator, Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ctor);
        },
        UseObstacleRectangles$$: "System.Boolean",
        get_UseObstacleRectangles: function (){
            return this._UseObstacleRectangles;
        },
        set_UseObstacleRectangles: function (value){
            this._UseObstacleRectangles = value;
        },
        Obstacles$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Routing.Shape]]",
        get_Obstacles: function (){
            return System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor, Microsoft.Msagl.Routing.Shape.ctor, this.ShapeToObstacleMap.get_Values(), $CreateAnonymousDelegate(this, function (obs){
                return obs.get_InputShape();
            }));
        },
        PaddedObstacles$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]",
        get_PaddedObstacles: function (){
            return System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, this.ShapeToObstacleMap.get_Values(), $CreateAnonymousDelegate(this, function (obs){
                return obs.get_PaddedPolyline();
            }));
        },
        AddObstacles: function (obstacles){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(obstacles, "obstacles");
            this.AddShapes(obstacles);
            this.RebuildTreeAndGraph();
        },
        AddShapes: function (obstacles){
            var $it1120 = obstacles.GetEnumerator();
            while ($it1120.MoveNext()){
                var shape = $it1120.get_Current();
                this.AddObstacleWithoutRebuild(shape);
            }
        },
        AddObstacle: function (shape){
            this.AddObstacleWithoutRebuild(shape);
            this.RebuildTreeAndGraph();
        },
        UpdateObstacles: function (obstacles){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(obstacles, "obstacles");
            var $it1121 = obstacles.GetEnumerator();
            while ($it1121.MoveNext()){
                var shape = $it1121.get_Current();
                this.UpdateObstacleWithoutRebuild(shape);
            }
            this.RebuildTreeAndGraph();
        },
        UpdateObstacle: function (obstacle){
            this.UpdateObstacleWithoutRebuild(obstacle);
            this.RebuildTreeAndGraph();
        },
        RemoveObstacles: function (obstacles){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(obstacles, "obstacles");
            var $it1122 = obstacles.GetEnumerator();
            while ($it1122.MoveNext()){
                var shape = $it1122.get_Current();
                this.RemoveObstacleWithoutRebuild(shape);
            }
            this.RebuildTreeAndGraph();
        },
        RemoveObstacle: function (obstacle){
            this.RemoveObstacleWithoutRebuild(obstacle);
            this.RebuildTreeAndGraph();
        },
        AddObstacleWithoutRebuild: function (shape){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(shape, "shape");
            if (null == shape.get_BoundaryCurve()){
                throw $CreateException(new System.InvalidOperationException.ctor$$String("Shape must have a BoundaryCurve"), new Error());
            }
            this.CreatePaddedObstacle(shape);
        },
        UpdateObstacleWithoutRebuild: function (shape){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(shape, "shape");
            if (null == shape.get_BoundaryCurve()){
                throw $CreateException(new System.InvalidOperationException.ctor$$String("Shape must have a BoundaryCurve"), new Error());
            }
            this.PortManager.RemoveObstaclePorts(this.ShapeToObstacleMap.get_Item$$TKey(shape));
            this.CreatePaddedObstacle(shape);
        },
        CreatePaddedObstacle: function (shape){
            var obstacle = new Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor$$Shape$$Boolean$$Double(shape, this.get_UseObstacleRectangles(), this.get_Padding());
            this.ShapeToObstacleMap.set_Item$$TKey(shape, obstacle);
            this.PortManager.CreateObstaclePorts(obstacle);
        },
        RemoveObstacleWithoutRebuild: function (shape){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(shape, "shape");
            var obstacle = this.ShapeToObstacleMap.get_Item$$TKey(shape);
            this.ShapeToObstacleMap.Remove(shape);
            this.PortManager.RemoveObstaclePorts(obstacle);
        },
        RemoveAllObstacles: function (){
            this.InternalClear(false);
        },
        RebuildTreeAndGraph: function (){
            var hadTree = (null != this.get_ObstacleTree().get_Root());
            var hadVg = (null != this.GraphGenerator.get_VisibilityGraph());
            this.InternalClear(true);
            if (hadTree){
                this.GenerateObstacleTree();
            }
            if (hadVg){
                this.GenerateVisibilityGraph();
            }
        },
        VisibilityGraph$$: "Microsoft.Msagl.Routing.Visibility.VisibilityGraph",
        get_VisibilityGraph: function (){
            this.GenerateVisibilityGraph();
            return this.GraphGenerator.get_VisibilityGraph();
        },
        Clear: function (){
            this.InternalClear(false);
        },
        AncestorsSets$$: "System.Collections.Generic.Dictionary`2[[Microsoft.Msagl.Routing.Shape],[Microsoft.Msagl.Core.DataStructures.Set`1[[Microsoft.Msagl.Routing.Shape]]]]",
        get_AncestorsSets: function (){
            return this._AncestorsSets;
        },
        set_AncestorsSets: function (value){
            this._AncestorsSets = value;
        },
        ctor$$IEnumerable$1$Shape: function (obstacles){
            this.GraphGenerator = null;
            this.ShapeToObstacleMap = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor);
            this.EdgeGeometries = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor);
            this.PortManager = null;
            this.edgeGeomsToSplittedEdgePaths = null;
            this.removeStaircases = true;
            this.selfEdges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor);
            this._Padding = 0;
            this._CornerFitRadius = 0;
            this._BendPenaltyAsAPercentageOfDistance = 0;
            this._UseObstacleRectangles = false;
            this._AncestorsSets = null;
            Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.ctor$$IEnumerable$1$Shape$$Double$$Double$$Boolean$$Boolean.call(this, obstacles, 1, 3, false, false);
        },
        ctor$$IEnumerable$1$Shape$$Double$$Double$$Boolean: function (obstacles, padding, cornerFitRadius, useSparseVisibilityGraph){
            this.GraphGenerator = null;
            this.ShapeToObstacleMap = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor);
            this.EdgeGeometries = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor);
            this.PortManager = null;
            this.edgeGeomsToSplittedEdgePaths = null;
            this.removeStaircases = true;
            this.selfEdges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor);
            this._Padding = 0;
            this._CornerFitRadius = 0;
            this._BendPenaltyAsAPercentageOfDistance = 0;
            this._UseObstacleRectangles = false;
            this._AncestorsSets = null;
            Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.ctor$$IEnumerable$1$Shape$$Double$$Double$$Boolean$$Boolean.call(this, obstacles, padding, cornerFitRadius, useSparseVisibilityGraph, false);
        },
        ctor$$IEnumerable$1$Shape$$Double$$Double$$Boolean$$Boolean: function (obstacles, padding, cornerFitRadius, useSparseVisibilityGraph, useObstacleRectangles){
            this.GraphGenerator = null;
            this.ShapeToObstacleMap = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor);
            this.EdgeGeometries = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor);
            this.PortManager = null;
            this.edgeGeomsToSplittedEdgePaths = null;
            this.removeStaircases = true;
            this.selfEdges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor);
            this._Padding = 0;
            this._CornerFitRadius = 0;
            this._BendPenaltyAsAPercentageOfDistance = 0;
            this._UseObstacleRectangles = false;
            this._AncestorsSets = null;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.set_Padding(padding);
            this.set_CornerFitRadius(cornerFitRadius);
            this.set_BendPenaltyAsAPercentageOfDistance(4);
            if (useSparseVisibilityGraph){
                this.GraphGenerator = new Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ctor();
            }
            else {
                this.GraphGenerator = new Microsoft.Msagl.Routing.Rectilinear.FullVisibilityGraphGenerator.ctor();
            }
            this.set_UseObstacleRectangles(useObstacleRectangles);
            this.PortManager = new Microsoft.Msagl.Routing.Rectilinear.PortManager.ctor(this.GraphGenerator);
            this.AddShapes(obstacles);
        },
        ctor$$GeometryGraph$$Double$$Double$$Boolean: function (graph, padding, cornerFitRadius, useSparseVisibilityGraph){
            this.GraphGenerator = null;
            this.ShapeToObstacleMap = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor);
            this.EdgeGeometries = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor);
            this.PortManager = null;
            this.edgeGeomsToSplittedEdgePaths = null;
            this.removeStaircases = true;
            this.selfEdges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor);
            this._Padding = 0;
            this._CornerFitRadius = 0;
            this._BendPenaltyAsAPercentageOfDistance = 0;
            this._UseObstacleRectangles = false;
            this._AncestorsSets = null;
            Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.ctor$$GeometryGraph$$Double$$Double$$Boolean$$Boolean.call(this, graph, padding, cornerFitRadius, useSparseVisibilityGraph, false);
        },
        ctor$$GeometryGraph$$Double$$Double$$Boolean$$Boolean: function (graph, padding, cornerFitRadius, useSparseVisibilityGraph, useObstacleRectangles){
            this.GraphGenerator = null;
            this.ShapeToObstacleMap = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Routing.Rectilinear.Obstacle.ctor);
            this.EdgeGeometries = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor);
            this.PortManager = null;
            this.edgeGeomsToSplittedEdgePaths = null;
            this.removeStaircases = true;
            this.selfEdges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor);
            this._Padding = 0;
            this._CornerFitRadius = 0;
            this._BendPenaltyAsAPercentageOfDistance = 0;
            this._UseObstacleRectangles = false;
            this._AncestorsSets = null;
            Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.ctor$$IEnumerable$1$Shape$$Double$$Double$$Boolean$$Boolean.call(this, Microsoft.Msagl.Routing.ShapeCreator.GetShapes(graph), padding, cornerFitRadius, useSparseVisibilityGraph, useObstacleRectangles);
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(graph, "graph");
            var $it1123 = graph.get_Edges().GetEnumerator();
            while ($it1123.MoveNext()){
                var edge = $it1123.get_Current();
                this.AddEdgeGeometryToRoute(edge.get_EdgeGeometry());
            }
        },
        RunInternal: function (){
            this.RouteEdges();
        },
        Test_ShowVisibilityGraph: function (){
        },
        Test_ShowPathsBeforeNudging: function (edgePaths){
        },
        Test_ShowPathsAfterNudging: function (edgePaths){
        },
        RouteEdges: function (){
            this.GenerateVisibilityGraph();
            this.GeneratePaths();
        },
        GeneratePaths: function (){
            this.edgeGeomsToSplittedEdgePaths = Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.SplitEdgeGeomsWithWaypoints(this.EdgeGeometries);
            var edgePathsForGeomsWithNoWaypoints = new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, this.EdgeGeometries, $CreateAnonymousDelegate(this, function (eg){
                return !eg.get_HasWaypoints();
            })), $CreateAnonymousDelegate(this, function (eg){
                return new Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.ctor(eg);
            })));
            var edgePathsForGeomsWithWaypoints = new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.ctor, this.edgeGeomsToSplittedEdgePaths.get_Keys(), $CreateAnonymousDelegate(this, function (eg){
                return new Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.ctor(eg);
            })));
            this.FillEdgePathsWithShortestPaths(System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.ctor, edgePathsForGeomsWithNoWaypoints, edgePathsForGeomsWithWaypoints));
            this.NudgePaths(System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.ctor, edgePathsForGeomsWithNoWaypoints, System.Linq.Enumerable.SelectMany$2$$IEnumerable$1$$Func$2(System.Collections.Generic.IEnumerable$1.ctor, Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.ctor, this.edgeGeomsToSplittedEdgePaths.get_Values(), $CreateAnonymousDelegate(this, function (path){
                return path;
            }))));
            this.UniteEdgeCurvesBetweenWaypoints();
            this.RouteSelfEdges();
            this.FinaliseEdgeGeometries();
        },
        RouteSelfEdges: function (){
            var $it1124 = this.selfEdges.GetEnumerator();
            while ($it1124.MoveNext()){
                var edge = $it1124.get_Current();
                var sp;
                edge.set_Curve((function (){
                    var $1 = {
                        Value: sp
                    };
                    var $res = Microsoft.Msagl.Core.Layout.Edge.RouteSelfEdge(edge.get_SourcePort().get_Curve(), System.Math.Max$$Double$$Double(this.get_Padding(), 2 * edge.GetMaxArrowheadLength()), $1);
                    sp = $1.Value;
                    return $res;
                }).call(this));
            }
        },
        UniteEdgeCurvesBetweenWaypoints: function (){
            var $it1125 = this.edgeGeomsToSplittedEdgePaths.GetEnumerator();
            while ($it1125.MoveNext()){
                var pair = $it1125.get_Current();
                var edgeGeom = pair.get_Key();
                var splittedPieces = pair.get_Value();
                var polyline = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor$$IEnumerable$1$Point(As(System.Linq.Enumerable.First$1$$IEnumerable$1(Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.ctor, splittedPieces).get_EdgeGeometry().get_Curve(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor));
                var $it1126 = System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.ctor, Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, System.Linq.Enumerable.Skip$1(Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.ctor, splittedPieces, 1), $CreateAnonymousDelegate(this, function (path){
                    return path.get_EdgeGeometry();
                })).GetEnumerator();
                while ($it1126.MoveNext()){
                    var piece = $it1126.get_Current();
                    polyline.AddRangeOfPoints(System.Linq.Enumerable.Skip$1(Microsoft.Msagl.Core.Geometry.Point.ctor, (As(piece.get_Curve(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor)), 1));
                }
                edgeGeom.set_Curve(polyline);
            }
        },
        FillEdgePathsWithShortestPaths: function (edgePaths){
            this.PortManager.BeginRouteEdges();
            var shortestPathRouter = new Microsoft.Msagl.Routing.Rectilinear.MsmtRectilinearPath.ctor(this.get_BendPenaltyAsAPercentageOfDistance());
            var $it1128 = edgePaths.GetEnumerator();
            while ($it1128.MoveNext()){
                var edgePath = $it1128.get_Current();
                this.ProgressStep();
                this.AddControlPointsAndGeneratePath(shortestPathRouter, edgePath);
            }
            this.PortManager.EndRouteEdges();
        },
        AddControlPointsAndGeneratePath: function (shortestPathRouter, edgePath){
            if (!edgePath.get_EdgeGeometry().get_HasWaypoints()){
                var intersectPoints = this.PortManager.GetPortVisibilityIntersection(edgePath.get_EdgeGeometry());
                if (intersectPoints != null){
                    this.GeneratePathThroughVisibilityIntersection(edgePath, intersectPoints);
                    return;
                }
            }
            this.SpliceVisibilityAndGeneratePath(shortestPathRouter, edgePath);
        },
        GeneratePathThroughVisibilityIntersection: function (edgePath, intersectPoints){
            edgePath.set_PathPoints(intersectPoints);
        },
        SpliceVisibilityAndGeneratePath: function (shortestPathRouter, edgePath){
            this.PortManager.AddControlPointsToGraph(edgePath.get_EdgeGeometry(), this.ShapeToObstacleMap);
            if (!this.GeneratePath(shortestPathRouter, edgePath, false)){
                this.RetryPathsWithAdditionalGroupsEnabled(shortestPathRouter, edgePath);
            }
            this.PortManager.RemoveControlPointsFromGraph();
        },
        GeneratePath: function (shortestPathRouter, edgePath, lastChance){
            var sourceVertices = this.PortManager.FindVertices(edgePath.get_EdgeGeometry().get_SourcePort());
            var targetVertices = this.PortManager.FindVertices(edgePath.get_EdgeGeometry().get_TargetPort());
            return edgePath.get_EdgeGeometry().get_HasWaypoints() ? this.GetMultiStagePath(edgePath, shortestPathRouter, sourceVertices, targetVertices, lastChance) : Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.GetSingleStagePath(edgePath, shortestPathRouter, sourceVertices, targetVertices, lastChance);
        },
        GetMultiStagePath: function (edgePath, shortestPathRouter, sourceVertices, targetVertices, lastChance){
            var waypointVertices = this.PortManager.FindWaypointVertices(edgePath.get_EdgeGeometry().get_Waypoints());
            var paths = shortestPathRouter.GetPath$$IEnumerable$1$VisibilityVertex$$IEnumerable$1$VisibilityVertex$$IEnumerable$1$VisibilityVertex(sourceVertices, waypointVertices, targetVertices);
            if (paths == null){
                if (!lastChance){
                    return false;
                }
                var $it1129 = this.edgeGeomsToSplittedEdgePaths.get_Item$$TKey(edgePath.get_EdgeGeometry()).GetEnumerator();
                while ($it1129.MoveNext()){
                    var stagePath = $it1129.get_Current();
                    var stageGeom = stagePath.get_EdgeGeometry();
                    Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.GetSingleStagePath(stagePath, shortestPathRouter, this.PortManager.FindVertices(stageGeom.get_SourcePort()), this.PortManager.FindVertices(stageGeom.get_TargetPort()), true);
                }
                return true;
            }
            var pathsEnum = paths.GetEnumerator();
            var $it1130 = this.edgeGeomsToSplittedEdgePaths.get_Item$$TKey(edgePath.get_EdgeGeometry()).GetEnumerator();
            while ($it1130.MoveNext()){
                var stagePath = $it1130.get_Current();
                pathsEnum.MoveNext();
                stagePath.set_PathPoints(pathsEnum.get_Current());
            }
            return true;
        },
        RetryPathsWithAdditionalGroupsEnabled: function (shortestPathRouter, edgePath){
            if (!this.PortManager.SetAllAncestorsActive(edgePath.get_EdgeGeometry(), this.ShapeToObstacleMap) || !this.GeneratePath(shortestPathRouter, edgePath, false)){
                this.PortManager.SetAllGroupsActive();
                this.GeneratePath(shortestPathRouter, edgePath, true);
            }
        },
        NudgePaths: function (edgePaths){
            var ancestorSets = this.get_ObstacleTree().SpatialAncestorsAdjusted ? Microsoft.Msagl.Routing.SplineRouter.GetAncestorSetsMap(this.get_Obstacles()) : this.get_AncestorsSets();
            Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.NudgePaths(edgePaths, this.get_CornerFitRadius(), this.get_PaddedObstacles(), ancestorSets, this.get_RemoveStaircases());
        },
        RemoveStaircases$$: "System.Boolean",
        get_RemoveStaircases: function (){
            return this.removeStaircases;
        },
        set_RemoveStaircases: function (value){
            this.removeStaircases = value;
        },
        FinaliseEdgeGeometries: function (){
            var $it1131 = System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, this.EdgeGeometries, this.selfEdges).GetEnumerator();
            while ($it1131.MoveNext()){
                var edgeGeom = $it1131.get_Current();
                if (null == edgeGeom.get_Curve()){
                    continue;
                }
                var poly = (As(edgeGeom.get_Curve(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor));
                if (poly != null){
                    edgeGeom.set_Curve(Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.FitArcsIntoCorners(this.get_CornerFitRadius(), System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Geometry.Point.ctor, poly)));
                }
                Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.CalculateArrowheads(edgeGeom);
            }
        },
        CreateVisibilityGraph: function (){
            this.GraphGenerator.Clear();
            this.InitObstacleTree();
            this.GraphGenerator.GenerateVisibilityGraph();
        },
        ObstacleTree$$: "Microsoft.Msagl.Routing.Rectilinear.ObstacleTree",
        get_ObstacleTree: function (){
            return this.GraphGenerator.ObstacleTree;
        },
        GenerateObstacleTree: function (){
            if ((null == this.get_Obstacles()) || !System.Linq.Enumerable.Any$1$$IEnumerable$1(Microsoft.Msagl.Routing.Shape.ctor, this.get_Obstacles())){
                throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            }
            if (null == this.get_ObstacleTree().get_Root()){
                this.InitObstacleTree();
            }
        },
        InitObstacleTree: function (){
            this.set_AncestorsSets(Microsoft.Msagl.Routing.SplineRouter.GetAncestorSetsMap(this.get_Obstacles()));
            this.get_ObstacleTree().Init(this.ShapeToObstacleMap.get_Values(), this.get_AncestorsSets(), this.ShapeToObstacleMap);
        },
        InternalClear: function (retainObstacles){
            this.GraphGenerator.Clear();
            this.ClearShortestPaths();
            if (retainObstacles){
                this.PortManager.ClearVisibility();
            }
            else {
                this.PortManager.Clear();
                this.ShapeToObstacleMap.Clear();
                this.EdgeGeometries.Clear();
            }
        },
        ClearShortestPaths: function (){
            var $it1132 = this.EdgeGeometries.GetEnumerator();
            while ($it1132.MoveNext()){
                var edgeGeom = $it1132.get_Current();
                edgeGeom.set_Curve(null);
            }
        },
        GenerateVisibilityGraph: function (){
            if ((null == this.get_Obstacles()) || !System.Linq.Enumerable.Any$1$$IEnumerable$1(Microsoft.Msagl.Routing.Shape.ctor, this.get_Obstacles())){
                throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            }
            if (this.GraphGenerator.get_VisibilityGraph() == null){
                this.CreateVisibilityGraph();
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$RectilinearEdgeRouter);
var Microsoft$Msagl$Routing$Rectilinear$HighReflectionEvent = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.HighReflectionEvent",
    baseTypeName: "Microsoft.Msagl.Routing.Rectilinear.BasicReflectionEvent",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (previousSite, targetSide, site){
            this._Side = null;
            Microsoft.Msagl.Routing.Rectilinear.BasicReflectionEvent.ctor$$BasicReflectionEvent$$Obstacle$$Point.call(this, previousSite, targetSide.get_Obstacle(), site);
            this.set_Side(targetSide);
        },
        Side$$: "Microsoft.Msagl.Routing.Rectilinear.HighObstacleSide",
        get_Side: function (){
            return this._Side;
        },
        set_Side: function (value){
            this._Side = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$HighReflectionEvent);
var Microsoft$Msagl$Routing$Rectilinear$ScanDirection = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.ScanDirection",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Routing.Rectilinear.ScanDirection.horizontalInstance = new Microsoft.Msagl.Routing.Rectilinear.ScanDirection.ctor(Microsoft.Msagl.Core.Geometry.Directions.East);
            Microsoft.Msagl.Routing.Rectilinear.ScanDirection.verticalInstance = new Microsoft.Msagl.Routing.Rectilinear.ScanDirection.ctor(Microsoft.Msagl.Core.Geometry.Directions.North);
        },
        HorizontalInstance$$: "Microsoft.Msagl.Routing.Rectilinear.ScanDirection",
        get_HorizontalInstance: function (){
            return Microsoft.Msagl.Routing.Rectilinear.ScanDirection.horizontalInstance;
        },
        VerticalInstance$$: "Microsoft.Msagl.Routing.Rectilinear.ScanDirection",
        get_VerticalInstance: function (){
            return Microsoft.Msagl.Routing.Rectilinear.ScanDirection.verticalInstance;
        },
        GetInstance: function (dir){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsVertical$$Directions(dir) ? Microsoft.Msagl.Routing.Rectilinear.ScanDirection.get_VerticalInstance() : Microsoft.Msagl.Routing.Rectilinear.ScanDirection.get_HorizontalInstance();
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (directionAlongScanLine){
            this._Direction = Microsoft.Msagl.Core.Geometry.Directions.None;
            this._DirectionAsPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._PerpDirection = Microsoft.Msagl.Core.Geometry.Directions.None;
            this._PerpDirectionAsPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._OppositeDirection = Microsoft.Msagl.Core.Geometry.Directions.None;
            System.Object.ctor.call(this);
            System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsAscending$$Directions(directionAlongScanLine), "directionAlongScanLine must be ascending");
            this.set_Direction(directionAlongScanLine);
            this.set_DirectionAsPoint(Microsoft.Msagl.Core.Geometry.CompassVector.ToPoint$$Directions(this.get_Direction()));
            this.set_PerpDirection((Microsoft.Msagl.Core.Geometry.Directions.North == directionAlongScanLine) ? Microsoft.Msagl.Core.Geometry.Directions.East : Microsoft.Msagl.Core.Geometry.Directions.North);
            this.set_PerpDirectionAsPoint(Microsoft.Msagl.Core.Geometry.CompassVector.ToPoint$$Directions(this.get_PerpDirection()));
            this.set_OppositeDirection(Microsoft.Msagl.Core.Geometry.CompassVector.OppositeDir(directionAlongScanLine));
        },
        Direction$$: "Microsoft.Msagl.Core.Geometry.Directions",
        get_Direction: function (){
            return this._Direction;
        },
        set_Direction: function (value){
            this._Direction = value;
        },
        DirectionAsPoint$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_DirectionAsPoint: function (){
            return this._DirectionAsPoint;
        },
        set_DirectionAsPoint: function (value){
            this._DirectionAsPoint = value;
        },
        PerpDirection$$: "Microsoft.Msagl.Core.Geometry.Directions",
        get_PerpDirection: function (){
            return this._PerpDirection;
        },
        set_PerpDirection: function (value){
            this._PerpDirection = value;
        },
        PerpDirectionAsPoint$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_PerpDirectionAsPoint: function (){
            return this._PerpDirectionAsPoint;
        },
        set_PerpDirectionAsPoint: function (value){
            this._PerpDirectionAsPoint = value;
        },
        OppositeDirection$$: "Microsoft.Msagl.Core.Geometry.Directions",
        get_OppositeDirection: function (){
            return this._OppositeDirection;
        },
        set_OppositeDirection: function (value){
            this._OppositeDirection = value;
        },
        IsHorizontal$$: "System.Boolean",
        get_IsHorizontal: function (){
            return Microsoft.Msagl.Core.Geometry.Directions.East == this.get_Direction();
        },
        IsVertical$$: "System.Boolean",
        get_IsVertical: function (){
            return Microsoft.Msagl.Core.Geometry.Directions.North == this.get_Direction();
        },
        Compare: function (lhs, rhs){
            var cmp = this.ComparePerpCoord(lhs, rhs);
            return (0 != cmp) ? cmp : this.CompareScanCoord(lhs, rhs);
        },
        CompareScanCoord: function (lhs, rhs){
            return Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Double$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(lhs, rhs)), this.get_DirectionAsPoint()), 0);
        },
        ComparePerpCoord: function (lhs, rhs){
            return Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Double$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(lhs, rhs)), this.get_PerpDirectionAsPoint()), 0);
        },
        IsEqualScanCoord: function (first, second){
            return 0 == this.CompareScanCoord(first, second);
        },
        IsEqualPerpCoord: function (first, second){
            return 0 == this.ComparePerpCoord(first, second);
        },
        IsFlat$$SegmentBase: function (seg){
            return this.IsFlat$$Point$$Point(seg.get_Start(), seg.get_End());
        },
        IsFlat$$Point$$Point: function (start, end){
            return Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Double$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(end, start)), this.get_PerpDirectionAsPoint()), 0);
        },
        IsPerpendicular$$SegmentBase: function (seg){
            return this.IsPerpendicular$$Point$$Point(seg.get_Start(), seg.get_End());
        },
        IsPerpendicular$$Point$$Point: function (start, end){
            return Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Double$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(end, start)), this.get_DirectionAsPoint()), 0);
        },
        Mask: function (point){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(point.get_X() * this.get_DirectionAsPoint().get_X(), point.get_Y() * this.get_DirectionAsPoint().get_Y());
        },
        PerpMask: function (point){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(point.get_X() * this.get_PerpDirectionAsPoint().get_X(), point.get_Y() * this.get_PerpDirectionAsPoint().get_Y());
        },
        Coord: function (point){
            return Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(point, this.get_DirectionAsPoint());
        },
        PerpCoord: function (point){
            return Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(point, this.get_PerpDirectionAsPoint());
        },
        Min: function (first, second){
            return (this.Compare(first, second) <= 0) ? first : second;
        },
        Max: function (first, second){
            return (this.Compare(first, second) >= 0) ? first : second;
        },
        PerpendicularInstance$$: "Microsoft.Msagl.Routing.Rectilinear.ScanDirection",
        get_PerpendicularInstance: function (){
            return this.get_IsHorizontal() ? Microsoft.Msagl.Routing.Rectilinear.ScanDirection.get_VerticalInstance() : Microsoft.Msagl.Routing.Rectilinear.ScanDirection.get_HorizontalInstance();
        },
        toString: function (){
            return this.get_Direction().toString();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$ScanDirection);
var Microsoft$Msagl$Routing$Rectilinear$RectilinearScanLine = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.RectilinearScanLine",
    baseTypeName: "System.Object",
    staticDefinition: {
        Debug_VerifySidesDoNotIntersect: function (side1, side2){
            var intersect;
            if (!(function (){
                var $1 = {
                    Value: intersect
                };
                var $res = Microsoft.Msagl.Core.Geometry.Point.LineLineIntersection(side1.get_Start(), side1.get_End(), side2.get_Start(), side2.get_End(), $1);
                intersect = $1.Value;
                return $res;
            })()){
                return;
            }
            var isInterior = (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(side1.get_Start(), intersect)), (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(intersect, side1.get_End()))) >= -Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon) && (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(side2.get_Start(), intersect)), (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(intersect, side2.get_End()))) >= -Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon);
            System.Diagnostics.Debug.Assert$$Boolean$$String(!isInterior, "Shouldn\'t have interior intersections except sides of the same obstacle");
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IComparer$1"],
    Kind: "Class",
    definition: {
        ctor: function (scanDir, start){
            this.scanDirection = null;
            this.linePositionAtLastInsertOrRemove = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._SideTree = null;
            System.Object.ctor.call(this);
            this.scanDirection = scanDir;
            this.set_SideTree(new Microsoft.Msagl.Core.DataStructures.RbTree$1.ctor$$IComparer$1(Microsoft.Msagl.Routing.Rectilinear.BasicObstacleSide.ctor, this));
            this.linePositionAtLastInsertOrRemove = start;
        },
        SideTree$$: "Microsoft.Msagl.Core.DataStructures.RbTree`1[[Microsoft.Msagl.Routing.Rectilinear.BasicObstacleSide]]",
        get_SideTree: function (){
            return this._SideTree;
        },
        set_SideTree: function (value){
            this._SideTree = value;
        },
        Insert: function (side, scanPos){
            this.Assert(!this.scanDirection.IsFlat$$SegmentBase(side), "Flat sides are not allowed in the scanline");
            this.Assert(null == this.Find(side), "side already exists in the ScanLine");
            this.linePositionAtLastInsertOrRemove = scanPos;
            var node = this.get_SideTree().Insert(side);
            return node;
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this.get_SideTree().get_Count();
        },
        Remove: function (side, scanPos){
            this.Assert(null != this.Find(side), "side does not exist in the ScanLine");
            this.linePositionAtLastInsertOrRemove = scanPos;
            this.get_SideTree().Remove(side);
        },
        Find: function (side){
            if (-1 == this.scanDirection.ComparePerpCoord(this.linePositionAtLastInsertOrRemove, side.get_Start())){
                return null;
            }
            return this.get_SideTree().Find$$T(side);
        },
        NextLow$$BasicObstacleSide: function (side){
            return this.NextLow$$RBNode$1$BasicObstacleSide(this.Find(side));
        },
        NextLow$$RBNode$1$BasicObstacleSide: function (sideNode){
            var pred = this.get_SideTree().Previous(sideNode);
            return pred;
        },
        NextHigh$$BasicObstacleSide: function (side){
            return this.NextHigh$$RBNode$1$BasicObstacleSide(this.Find(side));
        },
        NextHigh$$RBNode$1$BasicObstacleSide: function (sideNode){
            var succ = this.get_SideTree().Next(sideNode);
            return succ;
        },
        Next$$Directions$$BasicObstacleSide: function (dir, side){
            return this.Next$$Directions$$RBNode$1$BasicObstacleSide(dir, this.Find(side));
        },
        Next$$Directions$$RBNode$1$BasicObstacleSide: function (dir, sideNode){
            var succ = (Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsAscending$$Directions(dir)) ? this.get_SideTree().Next(sideNode) : this.get_SideTree().Previous(sideNode);
            return succ;
        },
        Lowest: function (){
            return this.get_SideTree().TreeMinimum();
        },
        DevTrace_VerifyConsistency: function (descFormat, descArgs){
        },
        Compare: function (first, second){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(first, "first");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(second, "second");
            if (first.get_Obstacle() == second.get_Obstacle()){
                if (first == second){
                    return 0;
                }
                return (Is(first, Microsoft.Msagl.Routing.Rectilinear.LowObstacleSide.ctor)) ? -1 : 1;
            }
            Microsoft.Msagl.Routing.Rectilinear.RectilinearScanLine.Debug_VerifySidesDoNotIntersect(first, second);
            var firstIntersect = Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.ScanLineIntersectSide$$Point$$BasicObstacleSide$$ScanDirection(this.linePositionAtLastInsertOrRemove, first, this.scanDirection);
            var secondIntersect = Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.ScanLineIntersectSide$$Point$$BasicObstacleSide$$ScanDirection(this.linePositionAtLastInsertOrRemove, second, this.scanDirection);
            var cmp = firstIntersect.CompareTo(secondIntersect);
            if (0 == cmp){
                var firstIsLow = Is(first, Microsoft.Msagl.Routing.Rectilinear.LowObstacleSide.ctor);
                var secondIsLow = Is(second, Microsoft.Msagl.Routing.Rectilinear.LowObstacleSide.ctor);
                cmp = firstIsLow.CompareTo$$Boolean(secondIsLow);
                if (0 == cmp){
                    cmp = first.get_Obstacle().get_Ordinal().CompareTo$$Int32(second.get_Obstacle().get_Ordinal());
                }
            }
            return cmp;
        },
        toString: function (){
            return this.linePositionAtLastInsertOrRemove + " " + this.scanDirection;
        },
        Assert: function (condition, message){
            System.Diagnostics.Debug.Assert$$Boolean$$String(condition, message);
        },
        DevTraceInfo: function (verboseLevel, format, args){
        },
        DevTraceDump: function (verboseLevel){
        },
        Test_ShowScanLine: function (){
        },
        Test_DumpScanLine: function (){
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$RectilinearScanLine);
var Microsoft$Msagl$Routing$Rectilinear$ScanSegment = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.ScanSegment",
    baseTypeName: "Microsoft.Msagl.Routing.Visibility.SegmentBase",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Routing.Rectilinear.ScanSegment.NormalWeight = 1;
            Microsoft.Msagl.Routing.Rectilinear.ScanSegment.ReflectionWeight = 5;
            Microsoft.Msagl.Routing.Rectilinear.ScanSegment.OverlappedWeight = 500;
        },
        IsVerticalSegment: function (start, end){
            return start.get_X() == end.get_X();
        },
        Subsume: function (seg, newStart, newEnd, weight, gbcList, scanDir, tree, extendStart, extendEnd){
            extendStart.Value = true;
            extendEnd.Value = true;
            if (null == seg.Value){
                return false;
            }
            if (!Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IntervalsOverlap$$Point$$Point$$Point$$Point(seg.Value.get_Start(), seg.Value.get_End(), newStart, newEnd)){
                return false;
            }
            if (seg.Value.get_Weight() != weight){
                if ((Microsoft.Msagl.Core.Geometry.Point.op_Equality(seg.Value.get_Start(), newStart)) && (Microsoft.Msagl.Core.Geometry.Point.op_Equality(seg.Value.get_End(), newEnd))){
                    seg.Value.set_Weight(System.Math.Min$$Double$$Double(seg.Value.get_Weight(), weight));
                    return true;
                }
                System.Diagnostics.Debug.Assert$$Boolean$$String((seg.Value.get_Weight() == 500) == (weight == 500) || Microsoft.Msagl.Core.Geometry.ApproximateComparer.CloseIntersections(seg.Value.get_End(), newStart) || Microsoft.Msagl.Core.Geometry.ApproximateComparer.CloseIntersections(seg.Value.get_Start(), newEnd), "non-equal overlap-mismatched ScanSegments overlap by more than just Start/End");
                return false;
            }
            extendStart.Value = (-1 == scanDir.CompareScanCoord(newStart, seg.Value.get_Start()));
            extendEnd.Value = (1 == scanDir.CompareScanCoord(newEnd, seg.Value.get_End()));
            if (extendStart.Value || extendEnd.Value){
                tree.Remove(seg.Value);
                seg.Value.startPoint = scanDir.Min(seg.Value.get_Start(), newStart);
                seg.Value.endPoint = scanDir.Max(seg.Value.get_End(), newEnd);
                seg.Value = tree.InsertUnique(seg.Value).Item;
                seg.Value.MergeGroupBoundaryCrossingList(gbcList);
            }
            return true;
        },
        GetCrossingInteriorVertex: function (vg, crossingVertex, crossing){
            var interiorPoint = crossing.GetInteriorVertexPoint(crossingVertex.Point);
            return (vg.FindVertex(interiorPoint) != null ? vg.FindVertex(interiorPoint) : vg.AddVertex$$Point(interiorPoint));
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$Point$$Point: function (start, end){
            this.GroupBoundaryPointAndCrossingsList = null;
            this.endPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.startPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.sparsePerpendicularCoords = null;
            this._Weight = 0;
            this._NextSegment = null;
            this._LowestVisibilityVertex = null;
            this._HighestVisibilityVertex = null;
            this._NeedStartOverlapVertex = false;
            this._NeedEndOverlapVertex = false;
            Microsoft.Msagl.Routing.Rectilinear.ScanSegment.ctor$$Point$$Point$$Double$$PointAndCrossingsList.call(this, start, end, 1, null);
        },
        Weight$$: "System.Double",
        get_Weight: function (){
            return this._Weight;
        },
        set_Weight: function (value){
            this._Weight = value;
        },
        NextSegment$$: "Microsoft.Msagl.Routing.Rectilinear.ScanSegment",
        get_NextSegment: function (){
            return this._NextSegment;
        },
        set_NextSegment: function (value){
            this._NextSegment = value;
        },
        ctor$$Point$$Point$$Double$$PointAndCrossingsList: function (start, end, weight, gbcList){
            this.GroupBoundaryPointAndCrossingsList = null;
            this.endPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.startPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.sparsePerpendicularCoords = null;
            this._Weight = 0;
            this._NextSegment = null;
            this._LowestVisibilityVertex = null;
            this._HighestVisibilityVertex = null;
            this._NeedStartOverlapVertex = false;
            this._NeedEndOverlapVertex = false;
            Microsoft.Msagl.Routing.Visibility.SegmentBase.ctor.call(this);
            this.Update(start, end);
            this.set_Weight(weight);
            this.GroupBoundaryPointAndCrossingsList = gbcList;
        },
        Start$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Start: function (){
            return this.startPoint;
        },
        End$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_End: function (){
            return this.endPoint;
        },
        IsVertical$$: "System.Boolean",
        get_IsVertical: function (){
            return Microsoft.Msagl.Routing.Rectilinear.ScanSegment.IsVerticalSegment(this.get_Start(), this.get_End());
        },
        ScanDirection$$: "Microsoft.Msagl.Routing.Rectilinear.ScanDirection",
        get_ScanDirection: function (){
            return this.get_IsVertical() ? Microsoft.Msagl.Routing.Rectilinear.ScanDirection.get_VerticalInstance() : Microsoft.Msagl.Routing.Rectilinear.ScanDirection.get_HorizontalInstance();
        },
        LowestVisibilityVertex$$: "Microsoft.Msagl.Routing.Visibility.VisibilityVertex",
        get_LowestVisibilityVertex: function (){
            return this._LowestVisibilityVertex;
        },
        set_LowestVisibilityVertex: function (value){
            this._LowestVisibilityVertex = value;
        },
        HighestVisibilityVertex$$: "Microsoft.Msagl.Routing.Visibility.VisibilityVertex",
        get_HighestVisibilityVertex: function (){
            return this._HighestVisibilityVertex;
        },
        set_HighestVisibilityVertex: function (value){
            this._HighestVisibilityVertex = value;
        },
        IsOverlapped$$: "System.Boolean",
        get_IsOverlapped: function (){
            return 500 == this.get_Weight();
        },
        IsReflection$$: "System.Boolean",
        get_IsReflection: function (){
            return 5 == this.get_Weight();
        },
        NeedStartOverlapVertex$$: "System.Boolean",
        get_NeedStartOverlapVertex: function (){
            return this._NeedStartOverlapVertex;
        },
        set_NeedStartOverlapVertex: function (value){
            this._NeedStartOverlapVertex = value;
        },
        NeedEndOverlapVertex$$: "System.Boolean",
        get_NeedEndOverlapVertex: function (){
            return this._NeedEndOverlapVertex;
        },
        set_NeedEndOverlapVertex: function (value){
            this._NeedEndOverlapVertex = value;
        },
        MergeGroupBoundaryCrossingList: function (other){
            if (null != other){
                if (null == this.GroupBoundaryPointAndCrossingsList){
                    this.GroupBoundaryPointAndCrossingsList = new Microsoft.Msagl.Routing.Rectilinear.PointAndCrossingsList.ctor();
                }
                this.GroupBoundaryPointAndCrossingsList.MergeFrom(other);
            }
        },
        TrimGroupBoundaryCrossingList: function (){
            if (null != this.GroupBoundaryPointAndCrossingsList){
                this.GroupBoundaryPointAndCrossingsList.Trim(this.get_Start(), this.get_End());
            }
        },
        Update: function (start, end){
            System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(start, end) || Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IsAscending$$Directions(Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$Point$$Point(start, end)), "non-ascending segment");
            this.startPoint = start;
            this.endPoint = end;
        },
        SetInitialVisibilityVertex: function (newVertex){
            this.set_LowestVisibilityVertex(newVertex);
            this.set_HighestVisibilityVertex(newVertex);
        },
        AppendVisibilityVertex: function (vg, newVertex){
            System.Diagnostics.Debug.Assert$$Boolean$$String(null != newVertex, "newVertex must not be null");
            System.Diagnostics.Debug.Assert$$Boolean$$String((null == this.get_LowestVisibilityVertex()) == (null == this.get_HighestVisibilityVertex()), "Mismatched null Lowest/HighestVisibilityVertex");
            System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.PointIsOnSegment$$SegmentBase$$Point(this, newVertex.Point), "newVertex is out of segment range");
            if (null == this.get_HighestVisibilityVertex()){
                if (!this.AddGroupCrossingsBeforeHighestVisibilityVertex(vg, newVertex)){
                    this.SetInitialVisibilityVertex(newVertex);
                }
            }
            else {
                if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.IsPureLower(newVertex.Point, this.get_HighestVisibilityVertex().Point)){
                    System.Diagnostics.Debug.Assert$$Boolean$$String(null != vg.FindEdge$$Point$$Point(newVertex.Point, this.get_HighestVisibilityVertex().Point), "unexpected low/middle insertion to ScanSegment");
                    return;
                }
                if (!this.AddGroupCrossingsBeforeHighestVisibilityVertex(vg, newVertex)){
                    this.AppendHighestVisibilityVertex(newVertex);
                }
            }
        },
        AddVisibilityEdge: function (source, target){
            System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Core.Geometry.Point.op_Inequality(source.Point, target.Point), "Self-edges are not allowed");
            System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Routing.Rectilinear.PointComparer.IsPureLower(source.Point, target.Point), "Impure or reversed direction encountered");
            System.Diagnostics.Debug.Assert$$Boolean$$String(null == Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.FindNextVertex(source, Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.EdgeDirection$$VisibilityVertex$$VisibilityVertex(source, target)), "Duplicate outEdge from Source vertex");
            System.Diagnostics.Debug.Assert$$Boolean$$String(null == Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.FindNextVertex(target, Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.EdgeDirection$$VisibilityVertex$$VisibilityVertex(target, source)), "Duplicate inEdge to Target vertex");
            var edge = new Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor$$VisibilityVertex$$VisibilityVertex$$Double(source, target, this.get_Weight());
            Microsoft.Msagl.Routing.Visibility.VisibilityGraph.AddEdge$$VisibilityEdge(edge);
            return edge;
        },
        AppendHighestVisibilityVertex: function (newVertex){
            if (!Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(this.get_HighestVisibilityVertex().Point, newVertex.Point)){
                this.AddVisibilityEdge(this.get_HighestVisibilityVertex(), newVertex);
                this.set_HighestVisibilityVertex(newVertex);
            }
        },
        LoadStartOverlapVertexIfNeeded: function (vg){
            if (this.get_NeedStartOverlapVertex()){
                var vertex = vg.FindVertex(this.get_Start());
                this.AppendVisibilityVertex(vg, (vertex != null ? vertex : vg.AddVertex$$Point(this.get_Start())));
            }
        },
        LoadEndOverlapVertexIfNeeded: function (vg){
            if (this.get_NeedEndOverlapVertex()){
                var vertex = vg.FindVertex(this.get_End());
                this.AppendVisibilityVertex(vg, (vertex != null ? vertex : vg.AddVertex$$Point(this.get_End())));
            }
        },
        OnSegmentIntersectorBegin: function (vg){
            if (!this.AppendGroupCrossingsThroughPoint(vg, this.get_Start())){
                this.LoadStartOverlapVertexIfNeeded(vg);
            }
        },
        OnSegmentIntersectorEnd: function (vg){
            this.AppendGroupCrossingsThroughPoint(vg, this.get_End());
            this.GroupBoundaryPointAndCrossingsList = null;
            if ((null == this.get_HighestVisibilityVertex()) || (Microsoft.Msagl.Routing.Rectilinear.PointComparer.IsPureLower(this.get_HighestVisibilityVertex().Point, this.get_End()))){
                this.LoadEndOverlapVertexIfNeeded(vg);
            }
        },
        GetIntersection: function (seg){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.SegmentIntersection$$SegmentBase$$SegmentBase(this, seg);
        },
        IntersectsSegment: function (seg){
            return Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.SegmentsIntersect$$SegmentBase$$SegmentBase(this, seg);
        },
        toString: function (){
            return "[" + this.get_Start() + " -> " + this.get_End() + (this.get_IsOverlapped() ? " olap" : " free") + "]";
        },
        ContainsPoint: function (test){
            return Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(this.get_Start(), test) || Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(this.get_End(), test) || (Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(this.get_Start(), test) == Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(test, this.get_End()));
        },
        HasSparsePerpendicularCoords$$: "System.Boolean",
        get_HasSparsePerpendicularCoords: function (){
            return (Microsoft.Msagl.Core.DataStructures.Set$1.op_Equality(this.sparsePerpendicularCoords, null)) ? false : (this.sparsePerpendicularCoords.get_Count() > 0);
        },
        CreatePointFromPerpCoord: function (perpCoord){
            return this.get_IsVertical() ? new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.get_Start().get_X(), perpCoord) : new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(perpCoord, this.get_Start().get_Y());
        },
        AddSparseVertexCoord: function (perpCoord){
            System.Diagnostics.Debug.Assert$$Boolean$$String(this.ContainsPoint(this.CreatePointFromPerpCoord(perpCoord)), "vertexLocation is not on Segment");
            if (Microsoft.Msagl.Core.DataStructures.Set$1.op_Equality(this.sparsePerpendicularCoords, null)){
                this.sparsePerpendicularCoords = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(System.Double.ctor);
            }
            this.sparsePerpendicularCoords.Insert(perpCoord);
        },
        AddSparseEndpoint: function (coord){
            if (!this.sparsePerpendicularCoords.Contains$$T(coord)){
                this.sparsePerpendicularCoords.Insert(coord);
                return true;
            }
            return false;
        },
        CreateSparseVerticesAndEdges: function (vg){
            if (Microsoft.Msagl.Core.DataStructures.Set$1.op_Equality(this.sparsePerpendicularCoords, null)){
                return;
            }
            this.AppendGroupCrossingsThroughPoint(vg, this.get_Start());
            var $it1134 = System.Linq.Enumerable.OrderBy$2$$IEnumerable$1$$Func$2(System.Double.ctor, System.Double.ctor, this.sparsePerpendicularCoords, $CreateAnonymousDelegate(this, function (d){
                return d;
            })).GetEnumerator();
            while ($it1134.MoveNext()){
                var perpCoord = $it1134.get_Current();
                var vertexLocation = this.CreatePointFromPerpCoord(perpCoord);
                System.Diagnostics.Debug.Assert$$Boolean$$String(this.ContainsPoint(vertexLocation), "vertexLocation is not on Segment");
                this.AppendVisibilityVertex(vg, (vg.FindVertex(vertexLocation) != null ? vg.FindVertex(vertexLocation) : vg.AddVertex$$Point(vertexLocation)));
            }
            this.AppendGroupCrossingsThroughPoint(vg, this.get_End());
            this.GroupBoundaryPointAndCrossingsList = null;
            this.sparsePerpendicularCoords.Clear();
            this.sparsePerpendicularCoords = null;
        },
        HasVisibility: function (){
            return (null != this.get_LowestVisibilityVertex());
        },
        AddGroupCrossingsBeforeHighestVisibilityVertex: function (vg, newVertex){
            if (this.AppendGroupCrossingsThroughPoint(vg, newVertex.Point)){
                if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.IsPureLower(this.get_HighestVisibilityVertex().Point, newVertex.Point)){
                    this.AddVisibilityEdge(this.get_HighestVisibilityVertex(), newVertex);
                    this.set_HighestVisibilityVertex(newVertex);
                }
                return true;
            }
            return false;
        },
        AppendGroupCrossingsThroughPoint: function (vg, lastPoint){
            if (null == this.GroupBoundaryPointAndCrossingsList){
                return false;
            }
            var found = false;
            while (this.GroupBoundaryPointAndCrossingsList.CurrentIsBeforeOrAt(lastPoint)){
                var pac = this.GroupBoundaryPointAndCrossingsList.Pop();
                var lowDirCrossings = null;
                var highDirCrossings = null;
                if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Point$$Point(pac.get_Location(), this.get_Start()) > 0){
                    lowDirCrossings = Microsoft.Msagl.Routing.Rectilinear.PointAndCrossingsList.ToCrossingArray(pac.get_Crossings(), this.get_ScanDirection().get_OppositeDirection());
                }
                if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Point$$Point(pac.get_Location(), this.get_End()) < 0){
                    highDirCrossings = Microsoft.Msagl.Routing.Rectilinear.PointAndCrossingsList.ToCrossingArray(pac.get_Crossings(), this.get_ScanDirection().get_Direction());
                }
                found = true;
                var crossingVertex = (vg.FindVertex(pac.get_Location()) != null ? vg.FindVertex(pac.get_Location()) : vg.AddVertex$$Point(pac.get_Location()));
                if ((null != lowDirCrossings) || (null != highDirCrossings)){
                    this.AddLowCrossings(vg, crossingVertex, lowDirCrossings);
                    this.AddHighCrossings(vg, crossingVertex, highDirCrossings);
                }
                else {
                    if (null == this.get_LowestVisibilityVertex()){
                        this.SetInitialVisibilityVertex(crossingVertex);
                    }
                    else {
                        System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(this.get_End(), crossingVertex.Point), "Expected this.End crossingVertex");
                        this.AppendHighestVisibilityVertex(crossingVertex);
                    }
                }
            }
            return found;
        },
        AddCrossingEdge: function (vg, lowVertex, highVertex, crossings){
            var edge = null;
            if (null != this.get_HighestVisibilityVertex()){
                if (Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Point$$Point(this.get_HighestVisibilityVertex().Point, highVertex.Point)){
                    edge = vg.FindEdge$$Point$$Point(lowVertex.Point, highVertex.Point);
                    System.Diagnostics.Debug.Assert$$Boolean$$String(edge != null, "Inconsistent forward-backward sequencing in HighVisibilityVertex");
                }
                else {
                    this.AppendHighestVisibilityVertex(lowVertex);
                }
            }
            if (edge == null){
                edge = this.AddVisibilityEdge(lowVertex, highVertex);
            }
            var crossingsArray = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Routing.Shape.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Rectilinear.GroupBoundaryCrossing.ctor, Microsoft.Msagl.Routing.Shape.ctor, crossings, $CreateAnonymousDelegate(this, function (c){
                return c.get_Group().get_InputShape();
            })));
            var prevIsPassable = edge.get_IsPassable();
            if (prevIsPassable == null){
                edge.set_IsPassable($CreateAnonymousDelegate(this, function (){
                    return System.Linq.Enumerable.Any$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, crossingsArray, $CreateAnonymousDelegate(this, function (s){
                        return s.get_IsTransparent();
                    }));
                }));
            }
            else {
                edge.set_IsPassable($CreateAnonymousDelegate(this, function (){
                    return System.Linq.Enumerable.Any$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, crossingsArray, $CreateAnonymousDelegate(this, function (s){
                        return s.get_IsTransparent();
                    })) || prevIsPassable();
                }));
            }
            if (null == this.get_LowestVisibilityVertex()){
                this.SetInitialVisibilityVertex(lowVertex);
            }
            this.set_HighestVisibilityVertex(highVertex);
        },
        AddLowCrossings: function (vg, crossingVertex, crossings){
            if (null != crossings){
                var interiorVertex = Microsoft.Msagl.Routing.Rectilinear.ScanSegment.GetCrossingInteriorVertex(vg, crossingVertex, crossings[0]);
                this.AddCrossingEdge(vg, interiorVertex, crossingVertex, crossings);
            }
        },
        AddHighCrossings: function (vg, crossingVertex, crossings){
            if (null != crossings){
                var interiorVertex = Microsoft.Msagl.Routing.Rectilinear.ScanSegment.GetCrossingInteriorVertex(vg, crossingVertex, crossings[0]);
                this.AddCrossingEdge(vg, crossingVertex, interiorVertex, crossings);
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$ScanSegment);
var Microsoft$Msagl$Routing$Rectilinear$SegmentIntersector = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.SegmentIntersector",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IComparer$1", "System.Collections.Generic.IComparer$1"],
    Kind: "Class",
    definition: {
        ctor: function (){
            this.eventList = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Rectilinear.SegmentIntersector.SegEvent.ctor);
            this.findFirstPred = null;
            this.segmentsWithoutVisibility = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Rectilinear.ScanSegment.ctor);
            this.verticalSegmentsScanLine = null;
            this.findFirstHSeg = null;
            this.visGraph = null;
            System.Object.ctor.call(this);
            this.verticalSegmentsScanLine = new Microsoft.Msagl.Core.DataStructures.RbTree$1.ctor$$IComparer$1(Microsoft.Msagl.Routing.Rectilinear.ScanSegment.ctor, this);
            this.findFirstPred = $CreateDelegate(this, this.IsVSegInHSegRange);
        },
        IsVSegInHSegRange: function (v){
            return Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Double$$Double(v.get_Start().get_X(), this.findFirstHSeg.get_Start().get_X()) >= 0;
        },
        Generate: function (hSegments, vSegments){
            var $it1135 = vSegments.GetEnumerator();
            while ($it1135.MoveNext()){
                var seg = $it1135.get_Current();
                this.eventList.Add(new Microsoft.Msagl.Routing.Rectilinear.SegmentIntersector.SegEvent.ctor(Microsoft.Msagl.Routing.Rectilinear.SegmentIntersector.SegEventType.VOpen, seg));
                this.eventList.Add(new Microsoft.Msagl.Routing.Rectilinear.SegmentIntersector.SegEvent.ctor(Microsoft.Msagl.Routing.Rectilinear.SegmentIntersector.SegEventType.VClose, seg));
            }
            var $it1136 = hSegments.GetEnumerator();
            while ($it1136.MoveNext()){
                var seg = $it1136.get_Current();
                this.eventList.Add(new Microsoft.Msagl.Routing.Rectilinear.SegmentIntersector.SegEvent.ctor(Microsoft.Msagl.Routing.Rectilinear.SegmentIntersector.SegEventType.HOpen, seg));
            }
            if (0 == this.eventList.get_Count()){
                return null;
            }
            this.eventList.Sort$$IComparer$1(this);
            this.visGraph = Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.NewVisibilityGraph();
            var $it1137 = this.eventList.GetEnumerator();
            while ($it1137.MoveNext()){
                var evt = $it1137.get_Current();
                switch (evt.get_EventType()){
                    case Microsoft.Msagl.Routing.Rectilinear.SegmentIntersector.SegEventType.VOpen:
                        this.OnSegmentOpen(evt.get_Segment());
                        this.ScanInsert(evt.get_Segment());
                        break;
                    case Microsoft.Msagl.Routing.Rectilinear.SegmentIntersector.SegEventType.VClose:
                        this.OnSegmentClose(evt.get_Segment());
                        this.ScanRemove(evt.get_Segment());
                        break;
                    case Microsoft.Msagl.Routing.Rectilinear.SegmentIntersector.SegEventType.HOpen:
                        this.OnSegmentOpen(evt.get_Segment());
                        this.ScanIntersect(evt.get_Segment());
                        break;
                    default:
                        System.Diagnostics.Debug.Assert$$Boolean$$String(false, "Unknown SegEventType");
                        break;
                }
            }
            return this.visGraph;
        },
        OnSegmentOpen: function (seg){
            seg.OnSegmentIntersectorBegin(this.visGraph);
        },
        OnSegmentClose: function (seg){
            seg.OnSegmentIntersectorEnd(this.visGraph);
            if (null == seg.get_LowestVisibilityVertex()){
                this.segmentsWithoutVisibility.Add(seg);
            }
        },
        RemoveSegmentsWithNoVisibility: function (horizontalScanSegments, verticalScanSegments){
            var $it1138 = this.segmentsWithoutVisibility.GetEnumerator();
            while ($it1138.MoveNext()){
                var seg = $it1138.get_Current();
                (seg.get_IsVertical() ? verticalScanSegments : horizontalScanSegments).Remove(seg);
            }
        },
        ScanInsert: function (seg){
            System.Diagnostics.Debug.Assert$$Boolean$$String(null == this.verticalSegmentsScanLine.Find$$T(seg), "seg already exists in the rbtree");
            this.verticalSegmentsScanLine.Insert(seg);
        },
        ScanRemove: function (seg){
            this.verticalSegmentsScanLine.Remove(seg);
        },
        ScanIntersect: function (hSeg){
            this.findFirstHSeg = hSeg;
            var segNode = this.verticalSegmentsScanLine.FindFirst$$Func$2(this.findFirstPred);
            for (; null != segNode; segNode = this.verticalSegmentsScanLine.Next(segNode)){
                var vSeg = segNode.Item;
                if (1 == Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Double$$Double(vSeg.get_Start().get_X(), hSeg.get_End().get_X())){
                    break;
                }
                var newVertex = this.visGraph.AddVertex$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(vSeg.get_Start().get_X(), hSeg.get_Start().get_Y()));
                hSeg.AppendVisibilityVertex(this.visGraph, newVertex);
                vSeg.AppendVisibilityVertex(this.visGraph, newVertex);
            }
            this.OnSegmentClose(hSeg);
        },
        Compare$$SegEvent$$SegEvent: function (first, second){
            if (first == second){
                return 0;
            }
            if (first == null){
                return -1;
            }
            if (second == null){
                return 1;
            }
            var cmp = Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Double$$Double(first.get_Site().get_Y(), second.get_Site().get_Y());
            if (0 != cmp){
                return cmp;
            }
            if (first.get_IsVertical() && second.get_IsVertical()){
                System.Diagnostics.Debug.Assert$$Boolean$$String(!Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IntervalsOverlap$$SegmentBase$$SegmentBase(first.get_Segment(), second.get_Segment()) || (0 == Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Point$$Point(first.get_Segment().get_Start(), second.get_Segment().get_End())) || (0 == Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Point$$Point(first.get_Segment().get_End(), second.get_Segment().get_Start())), "V subsumption failure detected in SegEvent comparison");
                if (0 == cmp){
                    cmp = (Microsoft.Msagl.Routing.Rectilinear.SegmentIntersector.SegEventType.VClose == first.get_EventType()).CompareTo$$Boolean(Microsoft.Msagl.Routing.Rectilinear.SegmentIntersector.SegEventType.VClose == second.get_EventType());
                }
                return cmp;
            }
            if (!first.get_IsVertical() && !second.get_IsVertical()){
                System.Diagnostics.Debug.Assert$$Boolean$$String(!Microsoft.Msagl.Routing.Rectilinear.StaticGraphUtility.IntervalsOverlap$$SegmentBase$$SegmentBase(first.get_Segment(), second.get_Segment()) || (0 == Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Point$$Point(first.get_Segment().get_Start(), second.get_Segment().get_End())) || (0 == Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Point$$Point(first.get_Segment().get_End(), second.get_Segment().get_Start())), "H subsumption failure detected in SegEvent comparison");
                cmp = Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Double$$Double(first.get_Site().get_X(), second.get_Site().get_X());
                return cmp;
            }
            var vEvent = first.get_IsVertical() ? first : second;
            cmp = -1;
            if (Microsoft.Msagl.Routing.Rectilinear.SegmentIntersector.SegEventType.VClose == vEvent.get_EventType()){
                cmp = 1;
            }
            if (vEvent != first){
                cmp *= -1;
            }
            return cmp;
        },
        Compare$$ScanSegment$$ScanSegment: function (first, second){
            if (first == second){
                return 0;
            }
            if (first == null){
                return -1;
            }
            if (second == null){
                return 1;
            }
            var cmp = Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Double$$Double(first.get_Start().get_X(), second.get_Start().get_X());
            if (0 == cmp){
                cmp = Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Double$$Double(first.get_Start().get_Y(), second.get_Start().get_Y());
            }
            return cmp;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$SegmentIntersector);
var Microsoft$Msagl$Routing$Rectilinear$SegmentIntersector$SegEvent = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.SegmentIntersector.SegEvent",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (eventType, seg){
            this._EventType = Microsoft.Msagl.Routing.Rectilinear.SegmentIntersector.SegEventType.VOpen;
            this._Segment = null;
            System.Object.ctor.call(this);
            this.set_EventType(eventType);
            this.set_Segment(seg);
        },
        EventType$$: "Microsoft.Msagl.Routing.Rectilinear.SegmentIntersector+SegEventType",
        get_EventType: function (){
            return this._EventType;
        },
        set_EventType: function (value){
            this._EventType = value;
        },
        Segment$$: "Microsoft.Msagl.Routing.Rectilinear.ScanSegment",
        get_Segment: function (){
            return this._Segment;
        },
        set_Segment: function (value){
            this._Segment = value;
        },
        IsVertical$$: "System.Boolean",
        get_IsVertical: function (){
            return (Microsoft.Msagl.Routing.Rectilinear.SegmentIntersector.SegEventType.HOpen != this.get_EventType());
        },
        Site$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Site: function (){
            return (Microsoft.Msagl.Routing.Rectilinear.SegmentIntersector.SegEventType.VClose == this.get_EventType()) ? this.get_Segment().get_End() : this.get_Segment().get_Start();
        },
        toString: function (){
            return System.String.Format$$String$$Object$Array("{0} {1} {2} {3}", [this.get_EventType(), this.get_IsVertical(), this.get_Site(), this.get_Segment()]);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$SegmentIntersector$SegEvent);
var Microsoft$Msagl$Routing$Rectilinear$SegmentIntersector$SegEventType = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.SegmentIntersector.SegEventType",
    staticDefinition: {
        VOpen: 0,
        VClose: 1,
        HOpen: 2
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$SegmentIntersector$SegEventType);
var Microsoft$Msagl$Routing$Rectilinear$WaypointPort = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.WaypointPort",
    baseTypeName: "Microsoft.Msagl.Core.Layout.FloatingPort",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (location){
            this.location = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            Microsoft.Msagl.Core.Layout.FloatingPort.ctor.call(this, null, location);
            this.location = location;
        },
        Location$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Location: function (){
            return this.location;
        },
        Curve$$: "Microsoft.Msagl.Core.Geometry.Curves.ICurve",
        get_Curve: function (){
            return null;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$WaypointPort);
var Microsoft$Msagl$Routing$RelaxedPolylinePoint = {
    fullname: "Microsoft.Msagl.Routing.RelaxedPolylinePoint",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (polylinePoint, originalPosition){
            this.polylinePoint = null;
            this.originalPosition = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.next = null;
            this.prev = null;
            System.Object.ctor.call(this);
            this.set_PolylinePoint(polylinePoint);
            this.set_OriginalPosition(originalPosition);
        },
        PolylinePoint$$: "Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint",
        get_PolylinePoint: function (){
            return this.polylinePoint;
        },
        set_PolylinePoint: function (value){
            this.polylinePoint = value;
        },
        OriginalPosition$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_OriginalPosition: function (){
            return this.originalPosition;
        },
        set_OriginalPosition: function (value){
            this.originalPosition = value;
        },
        Next$$: "Microsoft.Msagl.Routing.RelaxedPolylinePoint",
        get_Next: function (){
            return this.next;
        },
        set_Next: function (value){
            this.next = value;
        },
        Prev$$: "Microsoft.Msagl.Routing.RelaxedPolylinePoint",
        get_Prev: function (){
            return this.prev;
        },
        set_Prev: function (value){
            this.prev = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$RelaxedPolylinePoint);
var Microsoft$Msagl$Layout$Layered$HierarchyCalculator = {
    fullname: "Microsoft.Msagl.Layout.Layered.HierarchyCalculator",
    baseTypeName: "System.Object",
    staticDefinition: {
        Calculate$$List$1$ParallelogramNode$$Int32: function (nodes, groupSplitThresholdPar){
            var calc = new Microsoft.Msagl.Layout.Layered.HierarchyCalculator.ctor(nodes, groupSplitThresholdPar);
            return calc.Calculate();
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (nodes, groupSplitThresholdPar){
            this.initialNodes = null;
            this.groupSplitThreshold = 2;
            System.Object.ctor.call(this);
            this.initialNodes = nodes;
            this.groupSplitThreshold = groupSplitThresholdPar;
        },
        Calculate: function (){
            return this.Calc(this.initialNodes);
        },
        Calc: function (nodes){
            if (nodes.get_Count() == 0)
                return null;
            if (nodes.get_Count() == 1)
                return nodes.get_Item$$Int32(0);
            var b0 = nodes.get_Item$$Int32(0).get_Parallelogram();
            var seed0 = 1;
            var area = new Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.ctor$$Parallelogram$$Parallelogram(b0, nodes.get_Item$$Int32(seed0).get_Parallelogram()).get_Area();
            for (var i = 2; i < nodes.get_Count(); i++){
                var area0 = new Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.ctor$$Parallelogram$$Parallelogram(b0, nodes.get_Item$$Int32(i).get_Parallelogram()).get_Area();
                if (area0 > area){
                    seed0 = i;
                    area = area0;
                }
            }
            var seed1 = 0;
            for (var i = 0; i < nodes.get_Count(); i++){
                if (i != seed0){
                    seed1 = i;
                    break;
                }
            }
            area = new Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.ctor$$Parallelogram$$Parallelogram(nodes.get_Item$$Int32(seed0).get_Parallelogram(), nodes.get_Item$$Int32(seed1).get_Parallelogram()).get_Area();
            for (var i = 0; i < nodes.get_Count(); i++){
                if (i == seed0)
                    continue;
                var area1 = new Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.ctor$$Parallelogram$$Parallelogram(nodes.get_Item$$Int32(seed0).get_Parallelogram(), nodes.get_Item$$Int32(i).get_Parallelogram()).get_Area();
                if (area1 > area){
                    seed1 = i;
                    area = area1;
                }
            }
            var gr0 = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNode.ctor);
            var gr1 = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNode.ctor);
            gr0.Add(nodes.get_Item$$Int32(seed0));
            gr1.Add(nodes.get_Item$$Int32(seed1));
            var box0 = nodes.get_Item$$Int32(seed0).get_Parallelogram();
            var box1 = nodes.get_Item$$Int32(seed1).get_Parallelogram();
            for (var i = 0; i < nodes.get_Count(); i++){
                if (i == seed0 || i == seed1)
                    continue;
                var box0_ = new Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.ctor$$Parallelogram$$Parallelogram(box0, nodes.get_Item$$Int32(i).get_Parallelogram());
                var delta0 = box0_.get_Area() - box0.get_Area();
                var box1_ = new Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.ctor$$Parallelogram$$Parallelogram(box1, nodes.get_Item$$Int32(i).get_Parallelogram());
                var delta1 = box1_.get_Area() - box1.get_Area();
                if (gr0.get_Count() * this.groupSplitThreshold < gr1.get_Count()){
                    gr0.Add(nodes.get_Item$$Int32(i));
                    box0 = box0_;
                }
                else if (gr1.get_Count() * this.groupSplitThreshold < gr0.get_Count()){
                    gr1.Add(nodes.get_Item$$Int32(i));
                    box1 = box1_;
                }
                else if (delta0 < delta1){
                    gr0.Add(nodes.get_Item$$Int32(i));
                    box0 = box0_;
                }
                else {
                    gr1.Add(nodes.get_Item$$Int32(i));
                    box1 = box1_;
                }
            }
            var ret = new Microsoft.Msagl.Core.Geometry.Curves.ParallelogramBinaryTreeNode.ctor();
            ret.set_Parallelogram(new Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.ctor$$Parallelogram$$Parallelogram(box0, box1));
            ret.set_LeftSon(this.Calc(gr0));
            ret.set_RightSon(this.Calc(gr1));
            return ret;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$HierarchyCalculator);
var Microsoft$Msagl$Routing$NodeKind = {
    fullname: "Microsoft.Msagl.Routing.NodeKind",
    staticDefinition: {
        Top: 0,
        Internal: 1,
        Bottom: 2
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Routing$NodeKind);
var Microsoft$Msagl$Layout$Layered$Points = {
    fullname: "Microsoft.Msagl.Layout.Layered.Points",
    Kind: "Delegate",
    definition: {
        ctor: function (obj, func){
            System.MulticastDelegate.ctor.call(this, obj, func);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$Points);
var Microsoft$Msagl$Layout$Layered$RefinerBetweenTwoLayers = {
    fullname: "Microsoft.Msagl.Layout.Layered.RefinerBetweenTwoLayers",
    baseTypeName: "System.Object",
    staticDefinition: {
        Refine$$Int32$$Int32$$Site$$Anchor$Array$$LayerArrays$$ProperLayeredGraph$$GeometryGraph$$Double: function (topNodeP, bottomNode, topSiteP, anchors, layerArraysP, layeredGraph, originalGraph, layerSeparation){
            var refiner = new Microsoft.Msagl.Layout.Layered.RefinerBetweenTwoLayers.ctor(topNodeP, bottomNode, topSiteP, layerArraysP, layeredGraph, originalGraph, anchors, layerSeparation);
            refiner.Refine();
        },
        AbsCotan: function (mainSeg){
            return System.Math.Abs$$Double(mainSeg.get_X() / mainSeg.get_Y());
        },
        PossibleCorner: function (leftMost, rightMost, p){
            return p.get_X() > leftMost && p.get_X() < rightMost;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (topNodeP, bottomNodeP, topSiteP, layerArraysP, layeredGraphP, originalGraphP, anchorsP, layerSeparation){
            this.topNode = 0;
            this.bottomNode = 0;
            this.topSite = null;
            this.bottomSite = null;
            this.currentTopSite = null;
            this.currentBottomSite = null;
            this.layerArrays = null;
            this.layeredGraph = null;
            this.originalGraph = null;
            this.topCorners = null;
            this.bottomCorners = null;
            this.anchors = null;
            this.random = new System.Random.ctor$$Int32(1);
            this.layerSeparation = 0;
            System.Object.ctor.call(this);
            this.topNode = topNodeP;
            this.bottomNode = bottomNodeP;
            this.topSite = topSiteP;
            this.bottomSite = topSiteP.get_Next();
            this.currentTopSite = topSiteP;
            this.currentBottomSite = topSiteP.get_Next();
            this.layerArrays = layerArraysP;
            this.layeredGraph = layeredGraphP;
            this.originalGraph = originalGraphP;
            this.anchors = anchorsP;
            this.layerSeparation = layerSeparation;
        },
        Refine: function (){
            this.Init();
            while (this.InsertSites())
                ;},
        FixCorner: function (start, corner, end){
            if (Microsoft.Msagl.Core.Geometry.Point.op_Equality(start, corner))
                return corner;
            var a = Microsoft.Msagl.Core.Geometry.Point.ClosestPointAtLineSegment(corner, start, end);
            var offsetInTheChannel = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(corner, a);
            var y = System.Math.Abs$$Double(offsetInTheChannel.get_Y());
            var sep = this.layerSeparation / 2;
            if (y > sep)
                offsetInTheChannel = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(offsetInTheChannel, (sep / (y * 2)));
            return Microsoft.Msagl.Core.Geometry.Point.op_Addition(offsetInTheChannel, corner);
        },
        InsertSites: function (){
            if (this.random.Next$$Int32(2) == 0)
                return this.CalculateNewTopSite() | this.CalculateNewBottomSite();
            else
                return this.CalculateNewBottomSite() | this.CalculateNewTopSite();
        },
        CalculateNewBottomSite: function (){
            var mainSeg = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.currentBottomSite.get_Point(), this.currentTopSite.get_Point());
            var cotan = Microsoft.Msagl.Layout.Layered.RefinerBetweenTwoLayers.AbsCotan(mainSeg);
            var vOfNewSite = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            var $it1139 = this.bottomCorners().GetEnumerator();
            while ($it1139.MoveNext()){
                var p = $it1139.get_Current();
                var cornerCotan = Microsoft.Msagl.Layout.Layered.RefinerBetweenTwoLayers.AbsCotan(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(p, this.currentBottomSite.get_Point()));
                if (cornerCotan < cotan){
                    cotan = cornerCotan;
                    vOfNewSite = p;
                }
            }
            if (!Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(cotan, Microsoft.Msagl.Layout.Layered.RefinerBetweenTwoLayers.AbsCotan(mainSeg))){
                this.currentBottomSite = new Microsoft.Msagl.Core.Geometry.Site.ctor$$Site$$Point$$Site(this.currentTopSite, this.FixCorner(this.currentTopSite.get_Point(), vOfNewSite, this.currentBottomSite.get_Point()), this.currentBottomSite);
                return true;
            }
            return false;
        },
        CalculateNewTopSite: function (){
            var mainSeg = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.currentBottomSite.get_Point(), this.currentTopSite.get_Point());
            var cotan = Microsoft.Msagl.Layout.Layered.RefinerBetweenTwoLayers.AbsCotan(mainSeg);
            var vOfNewSite = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            var $it1140 = this.topCorners().GetEnumerator();
            while ($it1140.MoveNext()){
                var p = $it1140.get_Current();
                var cornerCotan = Microsoft.Msagl.Layout.Layered.RefinerBetweenTwoLayers.AbsCotan(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(p, this.currentTopSite.get_Point()));
                if (cornerCotan < cotan){
                    cotan = cornerCotan;
                    vOfNewSite = p;
                }
            }
            if (!Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(cotan, Microsoft.Msagl.Layout.Layered.RefinerBetweenTwoLayers.AbsCotan(mainSeg))){
                this.currentTopSite = new Microsoft.Msagl.Core.Geometry.Site.ctor$$Site$$Point$$Site(this.currentTopSite, this.FixCorner(this.currentTopSite.get_Point(), vOfNewSite, this.currentBottomSite.get_Point()), this.currentBottomSite);
                return true;
            }
            return false;
        },
        Init: function (){
            if (this.IsTopToTheLeftOfBottom()){
                this.topCorners = $CreateDelegate(this, this.CornersToTheRightOfTop);
                this.bottomCorners = $CreateDelegate(this, this.CornersToTheLeftOfBottom);
            }
            else {
                this.topCorners = $CreateDelegate(this, this.CornersToTheLeftOfTop);
                this.bottomCorners = $CreateDelegate(this, this.CornersToTheRightOfBottom);
            }
        },
        IsTopToTheLeftOfBottom: function (){
            return (this.topSite.get_Point().get_X() < this.topSite.get_Next().get_Point().get_X());
        },
        InitLeftmostSites: function (){
            if (this.IsTopToTheLeftOfBottom()){
                this.topCorners = System.Linq.Enumerable.Empty$1;
                this.bottomCorners = $CreateDelegate(this, this.CornersToTheLeftOfBottom);
            }
            else {
                this.topCorners = $CreateDelegate(this, this.CornersToTheLeftOfTop);
                this.bottomCorners = System.Linq.Enumerable.Empty$1;
            }
        },
        InitRightmostSites: function (){
            if (this.IsTopToTheLeftOfBottom()){
                this.topCorners = $CreateDelegate(this, this.CornersToTheRightOfTop);
                this.bottomCorners = System.Linq.Enumerable.Empty$1;
            }
            else {
                this.topCorners = System.Linq.Enumerable.Empty$1;
                this.bottomCorners = $CreateDelegate(this, this.CornersToTheRightOfBottom);
            }
        },
        MoveBundledSites: function (fromEdge, toEdge){
            this.MoveBundledEdge(this.anchors[toEdge.get_Source()].get_X() - this.anchors[fromEdge.get_Source()].get_X(), this.anchors[toEdge.get_Target()].get_X() - this.anchors[fromEdge.get_Target()].get_X());
        },
        MoveBundledEdge: function (upperMove, downMove){
            var site = this.topSite;
            site.set_Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(site.get_Point().get_X() + upperMove, site.get_Point().get_Y()));
            site = site.get_Next();
            while (site != this.bottomSite){
                var K = (site.get_Point().get_Y() - this.bottomSite.get_Point().get_Y()) / (this.topSite.get_Point().get_Y() - this.bottomSite.get_Point().get_Y());
                site.set_Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(site.get_Point().get_X() + K * upperMove + (1 - K) * downMove, site.get_Point().get_Y()));
                site = site.get_Next();
            }
            site.set_Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(site.get_Point().get_X() + downMove, site.get_Point().get_Y()));
        },
        NodeCorners: function (node){
            var $yield = [];
            var $it1141 = this.NodeAnchor(node).get_PolygonalBoundary().GetEnumerator();
            while ($it1141.MoveNext()){
                var p = $it1141.get_Current();
                $yield.push(p);
            }
            return $yield;
        },
        NodeAnchor: function (node){
            return this.anchors[node];
        },
        CornersToTheLeftOfBottom: function (){
            var $yield = [];
            var bottomPosition = this.layerArrays.get_X()[this.bottomNode];
            var leftMost = this.currentTopSite.get_Point().get_X();
            var rightMost = this.currentBottomSite.get_Point().get_X();
            var $it1142 = this.LeftFromTheNode(this.NodeLayer(this.bottomNode), bottomPosition, Microsoft.Msagl.Routing.NodeKind.Bottom, leftMost, rightMost).GetEnumerator();
            while ($it1142.MoveNext()){
                var node = $it1142.get_Current();
                var $it1143 = this.NodeCorners(node).GetEnumerator();
                while ($it1143.MoveNext()){
                    var p = $it1143.get_Current();
                    if (p.get_Y() > this.currentBottomSite.get_Point().get_Y() && Microsoft.Msagl.Layout.Layered.RefinerBetweenTwoLayers.PossibleCorner(leftMost, rightMost, p))
                        $yield.push(p);
                }
            }
            return $yield;
        },
        CornersToTheLeftOfTop: function (){
            var $yield = [];
            var topPosition = this.layerArrays.get_X()[this.topNode];
            var leftMost = this.currentBottomSite.get_Point().get_X();
            var rightMost = this.currentTopSite.get_Point().get_X();
            var $it1144 = this.LeftFromTheNode(this.NodeLayer(this.topNode), topPosition, Microsoft.Msagl.Routing.NodeKind.Top, leftMost, rightMost).GetEnumerator();
            while ($it1144.MoveNext()){
                var node = $it1144.get_Current();
                var $it1145 = this.NodeCorners(node).GetEnumerator();
                while ($it1145.MoveNext()){
                    var p = $it1145.get_Current();
                    if (p.get_Y() < this.currentTopSite.get_Point().get_Y() && Microsoft.Msagl.Layout.Layered.RefinerBetweenTwoLayers.PossibleCorner(leftMost, rightMost, p))
                        $yield.push(p);
                }
            }
            return $yield;
        },
        CornersToTheRightOfBottom: function (){
            var $yield = [];
            var bottomPosition = this.layerArrays.get_X()[this.bottomNode];
            var leftMost = this.currentBottomSite.get_Point().get_X();
            var rightMost = this.currentTopSite.get_Point().get_X();
            var $it1146 = this.RightFromTheNode(this.NodeLayer(this.bottomNode), bottomPosition, Microsoft.Msagl.Routing.NodeKind.Bottom, leftMost, rightMost).GetEnumerator();
            while ($it1146.MoveNext()){
                var node = $it1146.get_Current();
                var $it1147 = this.NodeCorners(node).GetEnumerator();
                while ($it1147.MoveNext()){
                    var p = $it1147.get_Current();
                    if (p.get_Y() > this.currentBottomSite.get_Point().get_Y() && Microsoft.Msagl.Layout.Layered.RefinerBetweenTwoLayers.PossibleCorner(leftMost, rightMost, p))
                        $yield.push(p);
                }
            }
            return $yield;
        },
        CornersToTheRightOfTop: function (){
            var $yield = [];
            var topPosition = this.layerArrays.get_X()[this.topNode];
            var leftMost = this.currentTopSite.get_Point().get_X();
            var rightMost = this.currentBottomSite.get_Point().get_X();
            var $it1148 = this.RightFromTheNode(this.NodeLayer(this.topNode), topPosition, Microsoft.Msagl.Routing.NodeKind.Top, leftMost, rightMost).GetEnumerator();
            while ($it1148.MoveNext()){
                var node = $it1148.get_Current();
                var $it1149 = this.NodeCorners(node).GetEnumerator();
                while ($it1149.MoveNext()){
                    var p = $it1149.get_Current();
                    if (p.get_Y() < this.currentTopSite.get_Point().get_Y() && Microsoft.Msagl.Layout.Layered.RefinerBetweenTwoLayers.PossibleCorner(leftMost, rightMost, p))
                        $yield.push(p);
                }
            }
            return $yield;
        },
        NodeLayer: function (j){
            return this.layerArrays.get_Layers()[this.layerArrays.Y[j]];
        },
        IsLabel: function (u){
            return this.anchors[u].get_RepresentsLabel();
        },
        NodeUCanBeCrossedByNodeV: function (u, v){
            if (this.IsLabel(u) || this.IsLabel(v))
                return false;
            if (this.IsVirtualVertex(u) && this.IsVirtualVertex(v) && this.AdjacentEdgesIntersect(u, v))
                return true;
            return false;
        },
        AdjacentEdgesIntersect: function (u, v){
            return this.Intersect(this.IncomingEdge(u), this.IncomingEdge(v)) || this.Intersect(this.OutcomingEdge(u), this.OutcomingEdge(v));
        },
        Intersect: function (e, m){
            return (this.layerArrays.get_X()[e.get_Source()] - this.layerArrays.get_X()[m.get_Source()]) * (this.layerArrays.get_X()[e.get_Target()] - this.layerArrays.get_X()[m.get_Target()]) < 0;
        },
        IncomingEdge: function (u){
            var $it1150 = this.layeredGraph.InEdges(u).GetEnumerator();
            while ($it1150.MoveNext()){
                var le = $it1150.get_Current();
                return le;
            }
            throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
        },
        OutcomingEdge: function (u){
            var $it1151 = this.layeredGraph.OutEdges(u).GetEnumerator();
            while ($it1151.MoveNext()){
                var le = $it1151.get_Current();
                return le;
            }
            throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
        },
        IsVirtualVertex: function (v){
            return v >= this.originalGraph.get_Nodes().get_Count();
        },
        RightFromTheNode: function (layer, vPosition, nodeKind, leftMostX, rightMostX){
            var $yield = [];
            var t = 0,b = 0;
            if (nodeKind == Microsoft.Msagl.Routing.NodeKind.Bottom)
                b = 3.40282346638529E+38;
            else if (nodeKind == Microsoft.Msagl.Routing.NodeKind.Top)
                t = 3.40282346638529E+38;
            var v = layer[vPosition];
            for (var i = vPosition + 1; i < layer.length; i++){
                var u = layer[i];
                if (this.NodeUCanBeCrossedByNodeV(u, v))
                    continue;
                var anchor = this.anchors[u];
                if (anchor.get_Left() >= rightMostX)
                    break;
                if (anchor.get_Right() > leftMostX){
                    if (anchor.get_TopAnchor() > t + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                        t = anchor.get_TopAnchor();
                        $yield.push(u);
                    }
                    else if (anchor.get_BottomAnchor() > b + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                        b = anchor.get_BottomAnchor();
                        $yield.push(u);
                    }
                }
            }
            return $yield;
        },
        LeftFromTheNode: function (layer, vPosition, nodeKind, leftMostX, rightMostX){
            var $yield = [];
            var t = 0,b = 0;
            if (nodeKind == Microsoft.Msagl.Routing.NodeKind.Bottom)
                b = 3.40282346638529E+38;
            else if (nodeKind == Microsoft.Msagl.Routing.NodeKind.Top)
                t = 3.40282346638529E+38;
            var v = layer[vPosition];
            for (var i = vPosition - 1; i > -1; i--){
                var u = layer[i];
                if (this.NodeUCanBeCrossedByNodeV(u, v))
                    continue;
                var anchor = this.anchors[u];
                if (anchor.get_Right() <= leftMostX)
                    break;
                if (anchor.get_Left() < rightMostX){
                    if (anchor.get_TopAnchor() > t + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                        t = anchor.get_TopAnchor();
                        $yield.push(u);
                    }
                    else if (anchor.get_BottomAnchor() > b + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                        b = anchor.get_BottomAnchor();
                        $yield.push(u);
                    }
                }
            }
            return $yield;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$RefinerBetweenTwoLayers);
var Microsoft$Msagl$Layout$Layered$Routing = {
    fullname: "Microsoft.Msagl.Layout.Layered.Routing",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        },
        UpdateLabel: function (e, anchor){
            var labelSide = null;
            if (anchor.get_LabelToTheRightOfAnchorCenter()){
                e.get_Label().set_Center(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(anchor.get_X() + anchor.get_RightAnchor() / 2, anchor.get_Y()));
                labelSide = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(e.get_LabelBBox().get_LeftTop(), e.get_LabelBBox().get_LeftBottom());
            }
            else if (anchor.get_LabelToTheLeftOfAnchorCenter()){
                e.get_Label().set_Center(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(anchor.get_X() - anchor.get_LeftAnchor() / 2, anchor.get_Y()));
                labelSide = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(e.get_LabelBBox().get_RightTop(), e.get_LabelBBox().get_RightBottom());
            }
            var segmentInFrontOfLabel = Microsoft.Msagl.Layout.Layered.Routing.GetSegmentInFrontOfLabel(e.get_Curve(), e.get_Label().get_Center().get_Y());
            if (segmentInFrontOfLabel == null)
                return;
            if (Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(e.get_Curve(), Microsoft.Msagl.Core.Geometry.Curves.Curve.PolyFromBox(e.get_LabelBBox()), false).get_Count() == 0){
                var curveClosestPoint;
                var labelSideClosest;
                if ((function (){
                    var $1 = {
                        Value: curveClosestPoint
                    };
                    var $2 = {
                        Value: labelSideClosest
                    };
                    var $res = Microsoft.Msagl.Layout.Layered.Routing.FindClosestPoints($1, $2, segmentInFrontOfLabel, labelSide);
                    curveClosestPoint = $1.Value;
                    labelSideClosest = $2.Value;
                    return $res;
                })()){
                    (function (){
                        var $1 = {
                            Value: curveClosestPoint
                        };
                        var $2 = {
                            Value: labelSideClosest
                        };
                        var $res = Microsoft.Msagl.Layout.Layered.Routing.ShiftLabel(e, $1, $2);
                        curveClosestPoint = $1.Value;
                        labelSideClosest = $2.Value;
                        return $res;
                    })();
                }
                else {
                    var u = segmentInFrontOfLabel.ClosestParameter(labelSide.get_Start());
                    var v = segmentInFrontOfLabel.ClosestParameter(labelSide.get_End());
                    if ((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(segmentInFrontOfLabel.get_Item$$Double(u), labelSide.get_Start())).get_Length() < (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(segmentInFrontOfLabel.get_Item$$Double(v), labelSide.get_End())).get_Length()){
                        curveClosestPoint = segmentInFrontOfLabel.get_Item$$Double(u);
                        labelSideClosest = labelSide.get_Start();
                    }
                    else {
                        curveClosestPoint = segmentInFrontOfLabel.get_Item$$Double(v);
                        labelSideClosest = labelSide.get_End();
                    }
                    (function (){
                        var $1 = {
                            Value: curveClosestPoint
                        };
                        var $2 = {
                            Value: labelSideClosest
                        };
                        var $res = Microsoft.Msagl.Layout.Layered.Routing.ShiftLabel(e, $1, $2);
                        curveClosestPoint = $1.Value;
                        labelSideClosest = $2.Value;
                        return $res;
                    })();
                }
            }
        },
        ShiftLabel: function (e, curveClosestPoint, labelSideClosest){
            var w = e.get_LineWidth() / 2;
            var shift = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(curveClosestPoint.Value, labelSideClosest.Value);
            var shiftLength = shift.get_Length();
            if (shiftLength > w)
                e.get_Label().set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Addition(e.get_Label().get_Center(), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(shift, shiftLength), (shiftLength - w))));
        },
        FindClosestPoints: function (curveClosestPoint, labelSideClosest, segmentInFrontOfLabel, labelSide){
            var u,v;
            return (function (){
                var $1 = {
                    Value: u
                };
                var $2 = {
                    Value: v
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.MinDistWithinIntervals(segmentInFrontOfLabel, labelSide, segmentInFrontOfLabel.get_ParStart(), segmentInFrontOfLabel.get_ParEnd(), labelSide.get_ParStart(), labelSide.get_ParEnd(), (segmentInFrontOfLabel.get_ParStart() + segmentInFrontOfLabel.get_ParEnd()) / 2, (labelSide.get_ParStart() + labelSide.get_ParEnd()) / 2, $1, $2, curveClosestPoint, labelSideClosest);
                u = $1.Value;
                v = $2.Value;
                return $res;
            })();
        },
        GetSegmentInFrontOfLabel: function (edgeCurve, labelY){
            var curve = As(edgeCurve, Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor);
            if (curve != null){
                var $it1155 = curve.get_Segments().GetEnumerator();
                while ($it1155.MoveNext()){
                    var seg = $it1155.get_Current();
                    if ((seg.get_Start().get_Y() - labelY) * (seg.get_End().get_Y() - labelY) <= 0)
                        return seg;
                }
            }
            else
                System.Diagnostics.Debug.Assert$$Boolean(false);
            return null;
        },
        GetNodeKind: function (vertexOffset, edgePath){
            return vertexOffset == 0 ? Microsoft.Msagl.Routing.NodeKind.Top : (vertexOffset < edgePath.get_Count() ? Microsoft.Msagl.Routing.NodeKind.Internal : Microsoft.Msagl.Routing.NodeKind.Bottom);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (settings, originalGraph, dbP, yLayerArrays, properLayeredGraph, intGraph){
            this.settings = null;
            this.Database = null;
            this.IntGraph = null;
            this.LayerArrays = null;
            this.OriginalGraph = null;
            this.ProperLayeredGraph = null;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.settings = settings;
            this.OriginalGraph = originalGraph;
            this.Database = dbP;
            this.ProperLayeredGraph = properLayeredGraph;
            this.LayerArrays = yLayerArrays;
            this.IntGraph = intGraph;
        },
        RunInternal: function (){
            this.CreateSplines();
        },
        CreateSplines: function (){
            this.CreateRegularSplines();
            this.CreateSelfSplines();
            if (this.IntGraph != null)
                this.RouteFlatEdges();
        },
        RouteFlatEdges: function (){
            var flatEdgeRouter = new Microsoft.Msagl.Layout.Layered.FlatEdgeRouter.ctor(this.settings, this);
            flatEdgeRouter.Run();
        },
        CreateRegularSplines: function (){
            var $it1152 = this.Database.get_RegularMultiedges().GetEnumerator();
            while ($it1152.MoveNext()){
                var intEdgeList = $it1152.get_Current();
                var m = intEdgeList.get_Count();
                for (var i = (m / 2) | 0; i < m; i++)
                    this.CreateSplineForNonSelfEdge(intEdgeList.get_Item$$Int32(i));
                for (var i = ((m / 2) | 0) - 1; i >= 0; i--)
                    this.CreateSplineForNonSelfEdge(intEdgeList.get_Item$$Int32(i));
            }
        },
        CreateSelfSplines: function (){
            var $it1153 = this.Database.get_Multiedges().GetEnumerator();
            while ($it1153.MoveNext()){
                var kv = $it1153.get_Current();
                this.ProgressStep();
                var ip = kv.get_Key();
                if (ip.x == ip.y){
                    var anchor = this.Database.get_Anchors()[ip.x];
                    var offset = anchor.get_LeftAnchor();
                    var $it1154 = kv.get_Value().GetEnumerator();
                    while ($it1154.MoveNext()){
                        var intEdge = $it1154.get_Current();
                        this.ProgressStep();
                        var dx = this.settings.get_NodeSeparation() + this.settings.get_MinNodeWidth() + offset;
                        var dy = anchor.get_BottomAnchor() / 2;
                        var p0 = anchor.get_Origin();
                        var p1 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(p0, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, dy));
                        var p2 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(p0, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(dx, dy));
                        var p3 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(p0, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(dx, -dy));
                        var p4 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(p0, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, -dy));
                        var s = new Microsoft.Msagl.Core.Geometry.Site.ctor$$Point(p0);
                        var polyline = new Microsoft.Msagl.Core.Geometry.SmoothedPolyline.ctor(s);
                        s = new Microsoft.Msagl.Core.Geometry.Site.ctor$$Site$$Point(s, p1);
                        s = new Microsoft.Msagl.Core.Geometry.Site.ctor$$Site$$Point(s, p2);
                        s = new Microsoft.Msagl.Core.Geometry.Site.ctor$$Site$$Point(s, p3);
                        s = new Microsoft.Msagl.Core.Geometry.Site.ctor$$Site$$Point(s, p4);
                        new Microsoft.Msagl.Core.Geometry.Site.ctor$$Site$$Point(s, p0);
                        var c;
                        intEdge.set_Curve(c = polyline.CreateCurve());
                        intEdge.get_Edge().set_UnderlyingPolyline(polyline);
                        offset = dx;
                        if (intEdge.get_Edge().get_Label() != null){
                            offset += intEdge.get_Edge().get_Label().get_Width();
                            var center = (function ($p48){
                                intEdge.get_Edge().get_Label().set_Center($p48);
                                return $p48;
                            }).call(this, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(c.get_Item$$Double((c.get_ParStart() + c.get_ParEnd()) / 2).get_X() + intEdge.get_LabelWidth() / 2, anchor.get_Y()));
                            var del = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(intEdge.get_Edge().get_Label().get_Width() / 2, intEdge.get_Edge().get_Label().get_Height() / 2);
                            var box = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Addition(center, del), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(center, del));
                            intEdge.get_Edge().get_Label().set_BoundingBox(box);
                        }
                        Microsoft.Msagl.Core.Layout.Arrowheads.TrimSplineAndCalculateArrowheads$$EdgeGeometry$$ICurve$$ICurve$$ICurve$$Boolean$$Boolean(intEdge.get_Edge().get_EdgeGeometry(), intEdge.get_Edge().get_Source().get_BoundaryCurve(), intEdge.get_Edge().get_Target().get_BoundaryCurve(), c, false, this.settings.get_EdgeRoutingSettings().get_KeepOriginalSpline());
                    }
                }
            }
        },
        CreateSplineForNonSelfEdge: function (es){
            this.ProgressStep();
            if (es.get_LayerEdges() != null){
                this.DrawSplineBySmothingThePolyline(es);
                if (!es.get_IsVirtualEdge()){
                    es.UpdateEdgeLabelPosition(this.Database.get_Anchors());
                    Microsoft.Msagl.Core.Layout.Arrowheads.TrimSplineAndCalculateArrowheads$$EdgeGeometry$$ICurve$$ICurve$$ICurve$$Boolean$$Boolean(es.get_Edge().get_EdgeGeometry(), es.get_Edge().get_Source().get_BoundaryCurve(), es.get_Edge().get_Target().get_BoundaryCurve(), es.get_Curve(), true, this.settings.get_EdgeRoutingSettings().get_KeepOriginalSpline());
                }
            }
        },
        DrawSplineBySmothingThePolyline: function (edgePath){
            var smoothedPolyline = new Microsoft.Msagl.Layout.Layered.SmoothedPolylineCalculator.ctor(edgePath, this.Database.get_Anchors(), this.OriginalGraph, this.settings, this.LayerArrays, this.ProperLayeredGraph, this.Database);
            var spline = smoothedPolyline.GetSpline();
            if (edgePath.get_Reversed()){
                edgePath.set_Curve(spline.Reverse());
                edgePath.set_UnderlyingPolyline(smoothedPolyline.Reverse().get_GetPolyline());
            }
            else {
                edgePath.set_Curve(spline);
                edgePath.set_UnderlyingPolyline(smoothedPolyline.get_GetPolyline());
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$Routing);
var Microsoft$Msagl$Routing$SplineRouter = {
    fullname: "Microsoft.Msagl.Routing.SplineRouter",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        },
        EdgesAttachedToPortAvoidTheNode: function (port){
            return Is(port, Microsoft.Msagl.Core.Layout.CurvePort.ctor) || Is(port, Microsoft.Msagl.Routing.ClusterBoundaryPort.ctor);
        },
        RegisterInPortLocationsToEdges: function (eg, portLocationPairsToEdges){
            var list;
            var pp = new Microsoft.Msagl.Core.Geometry.PointPair.ctor(eg.get_SourcePort().get_Location(), eg.get_TargetPort().get_Location());
            if (!(function (){
                var $1 = {
                    Value: list
                };
                var $res = portLocationPairsToEdges.TryGetValue(pp, $1);
                list = $1.Value;
                return $res;
            })())
                portLocationPairsToEdges.set_Item$$TKey(pp, list = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor));
            list.Add(eg);
        },
        IsEdgeToParent: function (e){
            return Is(e.get_SourcePort(), Microsoft.Msagl.Core.Layout.HookUpAnywhereFromInsidePort.ctor) || Is(e.get_TargetPort(), Microsoft.Msagl.Core.Layout.HookUpAnywhereFromInsidePort.ctor);
        },
        SetTransparency: function (shapes, v){
            var $it1191 = shapes.GetEnumerator();
            while ($it1191.MoveNext()){
                var shape = $it1191.get_Current();
                shape.set_IsTransparent(v);
            }
        },
        CreateLooseObstacleHierarachy: function (loosePolys){
            return Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnEnumeration(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, loosePolys, function (poly){
                return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, poly, poly.get_BoundingBox());
            }));
        },
        FindPointOnPolylineToInsertAfter: function (boundary, point){
            for (var p = boundary.get_StartPoint(); ;){
                var pn = p.get_NextOnPolyline();
                if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(point, p.get_Point()) || Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(point, pn.get_Point()))
                    return null;
                var par;
                if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double((function (){
                    var $1 = {
                        Value: par
                    };
                    var $res = Microsoft.Msagl.Core.Geometry.Point.DistToLineSegment(point, p.get_Point(), pn.get_Point(), $1);
                    par = $1.Value;
                    return $res;
                })(), 0))
                    return p;
                p = pn;
                if (p == boundary.get_StartPoint())
                    throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            }
        },
        GetAncestorSetsMap: function (shapes){
            var ancSets = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Core.DataStructures.Set$1.ctor);
            var $it1199 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, shapes, function (child){
                return !ancSets.ContainsKey(child);
            }).GetEnumerator();
            while ($it1199.MoveNext()){
                var child = $it1199.get_Current();
                ancSets.set_Item$$TKey(child, Microsoft.Msagl.Routing.SplineRouter.GetAncestorSet(child, ancSets));
            }
            return ancSets;
        },
        GetAncestorSet: function (child, ancSets){
            var ret = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Routing.Shape.ctor, child.get_Parents());
            var $it1200 = child.get_Parents().GetEnumerator();
            while ($it1200.MoveNext()){
                var parent = $it1200.get_Current();
                var grandParents;
                ret = Microsoft.Msagl.Core.DataStructures.Set$1.op_Addition(ret, (function (){
                    var $1 = {
                        Value: grandParents
                    };
                    var $res = ancSets.TryGetValue(parent, $1);
                    grandParents = $1.Value;
                    return $res;
                })() ? grandParents : (function ($p49){
                    ancSets.set_Item$$TKey(parent, $p49);
                    return $p49;
                })(Microsoft.Msagl.Routing.SplineRouter.GetAncestorSet(parent, ancSets)));
            }
            return ret;
        },
        CreatePortsIfNeeded: function (edges){
            var $it1201 = edges.GetEnumerator();
            while ($it1201.MoveNext()){
                var edge = $it1201.get_Current();
                if (edge.get_SourcePort() == null){
                    var e = edge;
                    edge.set_SourcePort((function (ed){
                        return new Microsoft.Msagl.Core.Layout.RelativeFloatingPort.ctor$$Func$1$ICurve$$Func$1$Point(function (){
                            return ed.get_Source().get_BoundaryCurve();
                        }, function (){
                            return ed.get_Source().get_Center();
                        });
                    })(e));
                }
                if (edge.get_TargetPort() == null){
                    var e = edge;
                    edge.set_TargetPort((function (ed){
                        return new Microsoft.Msagl.Core.Layout.RelativeFloatingPort.ctor$$Func$1$ICurve$$Func$1$Point(function (){
                            return ed.get_Target().get_BoundaryCurve();
                        }, function (){
                            return ed.get_Target().get_Center();
                        });
                    })(e));
                }
            }
        },
        ComputeLooseSplinePadding: function (nodeSeparation, edgePadding){
            System.Diagnostics.Debug.Assert$$Boolean$$String(edgePadding > 0, "require EdgePadding > 0");
            var twicePadding = 2 * edgePadding;
            System.Diagnostics.Debug.Assert$$Boolean$$String(nodeSeparation > twicePadding, "require OverlapSeparation > 2*EdgePadding");
            var loosePadding = (nodeSeparation - twicePadding) / 8;
            System.Diagnostics.Debug.Assert$$Boolean$$String(loosePadding > 0, "require LoosePadding > 0");
            System.Diagnostics.Debug.Assert$$Boolean$$String(twicePadding + (2 * loosePadding) < nodeSeparation, "EdgePadding too big!");
            return loosePadding;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$GeometryGraph$$EdgeRoutingSettings: function (graph, edgeRoutingSettings){
            this.continueOnOverlaps = true;
            this.rootShapes = null;
            this.coneAngle = 0;
            this.tightPadding = 0;
            this.rootWasCreated = false;
            this.root = null;
            this.visGraph = null;
            this.ancestorSets = null;
            this.shapesToTightLooseCouples = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Routing.TightLooseCouple.ctor);
            this.portsToShapes = null;
            this.portsToEnterableShapes = null;
            this.portRTree = null;
            this.portLocationsToLoosePolylines = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            this.looseRoot = null;
            this.enterableLoose = null;
            this.enterableTight = null;
            this.geometryGraph = null;
            this.multiEdgesSeparation = 5;
            this.routeMultiEdgesAsBundles = true;
            this.UseEdgeLengthMultiplier = false;
            this.UsePolylineEndShortcutting = true;
            this.UseInnerPolylingShortcutting = true;
            this.AllowedShootingStraightLines = true;
            this._edges = null;
            this.ReplaceEdgeByRails = null;
            this._LoosePadding = 0;
            this._BundlingSettings = null;
            this._OverlapsDetected = false;
            this._CacheCornersForSmoothing = false;
            this._KeepOriginalSpline = false;
            this._ArrowHeadRatio = 0;
            this._LineSweeperPorts = null;
            this._Bidirectional = false;
            Microsoft.Msagl.Routing.SplineRouter.ctor$$GeometryGraph$$Double$$Double$$Double$$BundlingSettings.call(this, graph, edgeRoutingSettings.get_Padding(), edgeRoutingSettings.get_PolylinePadding(), edgeRoutingSettings.get_ConeAngle(), edgeRoutingSettings.get_BundlingSettings());
        },
        ContinueOnOverlaps$$: "System.Boolean",
        get_ContinueOnOverlaps: function (){
            return this.continueOnOverlaps;
        },
        set_ContinueOnOverlaps: function (value){
            this.continueOnOverlaps = value;
        },
        edgeGeometriesEnumeration$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Layout.EdgeGeometry]]",
        get_edgeGeometriesEnumeration: function (){
            return System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, this._edges, $CreateAnonymousDelegate(this, function (e){
                return e.get_EdgeGeometry();
            }));
        },
        LoosePadding$$: "System.Double",
        get_LoosePadding: function (){
            return this._LoosePadding;
        },
        set_LoosePadding: function (value){
            this._LoosePadding = value;
        },
        BundlingSettings$$: "Microsoft.Msagl.Core.Routing.BundlingSettings",
        get_BundlingSettings: function (){
            return this._BundlingSettings;
        },
        set_BundlingSettings: function (value){
            this._BundlingSettings = value;
        },
        MultiEdgesSeparation$$: "System.Double",
        get_MultiEdgesSeparation: function (){
            return this.multiEdgesSeparation;
        },
        set_MultiEdgesSeparation: function (value){
            this.multiEdgesSeparation = value;
        },
        ctor$$GeometryGraph$$Double$$Double$$Double: function (graph, tightTightPadding, loosePadding, coneAngle){
            this.continueOnOverlaps = true;
            this.rootShapes = null;
            this.coneAngle = 0;
            this.tightPadding = 0;
            this.rootWasCreated = false;
            this.root = null;
            this.visGraph = null;
            this.ancestorSets = null;
            this.shapesToTightLooseCouples = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Routing.TightLooseCouple.ctor);
            this.portsToShapes = null;
            this.portsToEnterableShapes = null;
            this.portRTree = null;
            this.portLocationsToLoosePolylines = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            this.looseRoot = null;
            this.enterableLoose = null;
            this.enterableTight = null;
            this.geometryGraph = null;
            this.multiEdgesSeparation = 5;
            this.routeMultiEdgesAsBundles = true;
            this.UseEdgeLengthMultiplier = false;
            this.UsePolylineEndShortcutting = true;
            this.UseInnerPolylingShortcutting = true;
            this.AllowedShootingStraightLines = true;
            this._edges = null;
            this.ReplaceEdgeByRails = null;
            this._LoosePadding = 0;
            this._BundlingSettings = null;
            this._OverlapsDetected = false;
            this._CacheCornersForSmoothing = false;
            this._KeepOriginalSpline = false;
            this._ArrowHeadRatio = 0;
            this._LineSweeperPorts = null;
            this._Bidirectional = false;
            Microsoft.Msagl.Routing.SplineRouter.ctor$$GeometryGraph$$IEnumerable$1$Edge$$Double$$Double$$Double$$BundlingSettings.call(this, graph, graph.get_Edges(), tightTightPadding, loosePadding, coneAngle, null);
        },
        ctor$$GeometryGraph$$Double$$Double$$Double$$BundlingSettings: function (graph, tightTightPadding, loosePadding, coneAngle, bundlingSettings){
            this.continueOnOverlaps = true;
            this.rootShapes = null;
            this.coneAngle = 0;
            this.tightPadding = 0;
            this.rootWasCreated = false;
            this.root = null;
            this.visGraph = null;
            this.ancestorSets = null;
            this.shapesToTightLooseCouples = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Routing.TightLooseCouple.ctor);
            this.portsToShapes = null;
            this.portsToEnterableShapes = null;
            this.portRTree = null;
            this.portLocationsToLoosePolylines = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            this.looseRoot = null;
            this.enterableLoose = null;
            this.enterableTight = null;
            this.geometryGraph = null;
            this.multiEdgesSeparation = 5;
            this.routeMultiEdgesAsBundles = true;
            this.UseEdgeLengthMultiplier = false;
            this.UsePolylineEndShortcutting = true;
            this.UseInnerPolylingShortcutting = true;
            this.AllowedShootingStraightLines = true;
            this._edges = null;
            this.ReplaceEdgeByRails = null;
            this._LoosePadding = 0;
            this._BundlingSettings = null;
            this._OverlapsDetected = false;
            this._CacheCornersForSmoothing = false;
            this._KeepOriginalSpline = false;
            this._ArrowHeadRatio = 0;
            this._LineSweeperPorts = null;
            this._Bidirectional = false;
            Microsoft.Msagl.Routing.SplineRouter.ctor$$GeometryGraph$$IEnumerable$1$Edge$$Double$$Double$$Double$$BundlingSettings.call(this, graph, graph.get_Edges(), tightTightPadding, loosePadding, coneAngle, bundlingSettings);
        },
        ctor$$GeometryGraph$$IEnumerable$1$Edge$$Double$$Double$$Double$$BundlingSettings: function (graph, edges, tightPadding, loosePadding, coneAngle, bundlingSettings){
            this.continueOnOverlaps = true;
            this.rootShapes = null;
            this.coneAngle = 0;
            this.tightPadding = 0;
            this.rootWasCreated = false;
            this.root = null;
            this.visGraph = null;
            this.ancestorSets = null;
            this.shapesToTightLooseCouples = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Routing.TightLooseCouple.ctor);
            this.portsToShapes = null;
            this.portsToEnterableShapes = null;
            this.portRTree = null;
            this.portLocationsToLoosePolylines = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            this.looseRoot = null;
            this.enterableLoose = null;
            this.enterableTight = null;
            this.geometryGraph = null;
            this.multiEdgesSeparation = 5;
            this.routeMultiEdgesAsBundles = true;
            this.UseEdgeLengthMultiplier = false;
            this.UsePolylineEndShortcutting = true;
            this.UseInnerPolylingShortcutting = true;
            this.AllowedShootingStraightLines = true;
            this._edges = null;
            this.ReplaceEdgeByRails = null;
            this._LoosePadding = 0;
            this._BundlingSettings = null;
            this._OverlapsDetected = false;
            this._CacheCornersForSmoothing = false;
            this._KeepOriginalSpline = false;
            this._ArrowHeadRatio = 0;
            this._LineSweeperPorts = null;
            this._Bidirectional = false;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(graph, "graph");
            Microsoft.Msagl.Core.ValidateArg.IsPositive(tightPadding, "tightPadding");
            Microsoft.Msagl.Core.ValidateArg.IsPositive(loosePadding, "loosePadding");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(edges, "edges");
            this._edges = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Layout.Edge.ctor, edges);
            this.set_BundlingSettings(bundlingSettings);
            this.geometryGraph = graph;
            this.set_LoosePadding(loosePadding);
            this.tightPadding = tightPadding;
            var obstacles = Microsoft.Msagl.Routing.ShapeCreator.GetShapes(this.geometryGraph);
            this.Initialize(obstacles, coneAngle);
        },
        ctor$$GeometryGraph$$Double$$Double$$Double$$List$1$Edge$$List$1$Edge: function (graph, tightPadding, loosePadding, coneAngle, inParentEdges, outParentEdges){
            this.continueOnOverlaps = true;
            this.rootShapes = null;
            this.coneAngle = 0;
            this.tightPadding = 0;
            this.rootWasCreated = false;
            this.root = null;
            this.visGraph = null;
            this.ancestorSets = null;
            this.shapesToTightLooseCouples = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Routing.TightLooseCouple.ctor);
            this.portsToShapes = null;
            this.portsToEnterableShapes = null;
            this.portRTree = null;
            this.portLocationsToLoosePolylines = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            this.looseRoot = null;
            this.enterableLoose = null;
            this.enterableTight = null;
            this.geometryGraph = null;
            this.multiEdgesSeparation = 5;
            this.routeMultiEdgesAsBundles = true;
            this.UseEdgeLengthMultiplier = false;
            this.UsePolylineEndShortcutting = true;
            this.UseInnerPolylingShortcutting = true;
            this.AllowedShootingStraightLines = true;
            this._edges = null;
            this.ReplaceEdgeByRails = null;
            this._LoosePadding = 0;
            this._BundlingSettings = null;
            this._OverlapsDetected = false;
            this._CacheCornersForSmoothing = false;
            this._KeepOriginalSpline = false;
            this._ArrowHeadRatio = 0;
            this._LineSweeperPorts = null;
            this._Bidirectional = false;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.geometryGraph = graph;
            this.set_LoosePadding(loosePadding);
            this.tightPadding = tightPadding;
            var obstacles = Microsoft.Msagl.Routing.ShapeCreatorForRoutingToParents.GetShapes(inParentEdges, outParentEdges);
            this.Initialize(obstacles, coneAngle);
        },
        Initialize: function (obstacles, coneAngleValue){
            this.rootShapes = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Routing.Shape.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, obstacles, $CreateAnonymousDelegate(this, function (s){
                return s.get_Parents() == null || !System.Linq.Enumerable.Any$1$$IEnumerable$1(Microsoft.Msagl.Routing.Shape.ctor, s.get_Parents());
            })));
            this.coneAngle = coneAngleValue;
            if (this.coneAngle == 0)
                this.coneAngle = 0.523598775598299;
        },
        RunInternal: function (){
            if (!System.Linq.Enumerable.Any$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, this.get_edgeGeometriesEnumeration()))
                return;
            this.GetOrCreateRoot();
            this.RouteOnRoot();
            this.RemoveRoot();
        },
        RouteOnRoot: function (){
            this.CalculatePortsToShapes();
            this.CalculatePortsToEnterableShapes();
            this.CalculateShapeToBoundaries(this.root);
            if (this.get_OverlapsDetected() && !this.get_ContinueOnOverlaps())
                return;
            this.BindLooseShapes();
            this.SetLoosePolylinesForAnywherePorts();
            this.CalculateVisibilityGraph();
            this.RouteOnVisGraph();
        },
        CalculatePortsToEnterableShapes: function (){
            this.portsToEnterableShapes = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Port.ctor, Microsoft.Msagl.Core.DataStructures.Set$1.ctor);
            var $it1156 = this.portsToShapes.GetEnumerator();
            while ($it1156.MoveNext()){
                var portsToShape = $it1156.get_Current();
                var port = portsToShape.get_Key();
                var set = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Routing.Shape.ctor);
                if (!(Microsoft.Msagl.Routing.SplineRouter.EdgesAttachedToPortAvoidTheNode(port)))
                    set.Insert(portsToShape.get_Value());
                this.portsToEnterableShapes.set_Item$$TKey(port, set);
            }
            for (var $i1158 = 0,$t1158 = this.rootShapes,$l1158 = $t1158.length,rootShape = $t1158[$i1158]; $i1158 < $l1158; $i1158++, rootShape = $t1158[$i1158]){
                var $it1158 = rootShape.get_Descendands().GetEnumerator();
                while ($it1158.MoveNext()){
                    var sh = $it1158.get_Current();
                    var $it1159 = sh.get_Ports().GetEnumerator();
                    while ($it1159.MoveNext()){
                        var port = $it1159.get_Current();
                        var enterableSet = this.portsToEnterableShapes.get_Item$$TKey(port);
                        enterableSet.InsertRange(System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, sh.get_Ancestors(), $CreateAnonymousDelegate(this, function (s){
                            return s.get_BoundaryCurve() != null;
                        })));
                    }
                }
            }
        },
        SetLoosePolylinesForAnywherePorts: function (){
            var $it1160 = this.shapesToTightLooseCouples.GetEnumerator();
            while ($it1160.MoveNext()){
                var shapesToTightLooseCouple = $it1160.get_Current();
                var shape = shapesToTightLooseCouple.get_Key();
                var $it1161 = shape.get_Ports().GetEnumerator();
                while ($it1161.MoveNext()){
                    var port = $it1161.get_Current();
                    var aport = As(port, Microsoft.Msagl.Core.Layout.HookUpAnywhereFromInsidePort.ctor);
                    if (aport != null)
                        aport.set_LoosePolyline(Cast(shapesToTightLooseCouple.get_Value().get_LooseShape().get_BoundaryCurve(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor));
                    var clusterBoundaryPort = As(port, Microsoft.Msagl.Routing.ClusterBoundaryPort.ctor);
                    if (clusterBoundaryPort != null)
                        clusterBoundaryPort.set_LoosePolyline(Cast(shapesToTightLooseCouple.get_Value().get_LooseShape().get_BoundaryCurve(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor));
                }
            }
        },
        BindLooseShapes: function (){
            this.looseRoot = new Microsoft.Msagl.Routing.Shape.ctor();
            var $it1162 = this.root.get_Children().GetEnumerator();
            while ($it1162.MoveNext()){
                var shape = $it1162.get_Current();
                var looseShape = this.shapesToTightLooseCouples.get_Item$$TKey(shape).get_LooseShape();
                this.BindLooseShapesUnderShape(shape);
                this.looseRoot.AddChild(looseShape);
            }
        },
        BindLooseShapesUnderShape: function (shape){
            var loose = this.shapesToTightLooseCouples.get_Item$$TKey(shape).get_LooseShape();
            var $it1163 = shape.get_Children().GetEnumerator();
            while ($it1163.MoveNext()){
                var child = $it1163.get_Current();
                var childLooseShape = this.shapesToTightLooseCouples.get_Item$$TKey(child).get_LooseShape();
                loose.AddChild(childLooseShape);
                this.BindLooseShapesUnderShape(child);
            }
        },
        CalculateShapeToBoundaries: function (shape){
            this.ProgressStep();
            if (!System.Linq.Enumerable.Any$1$$IEnumerable$1(Microsoft.Msagl.Routing.Shape.ctor, shape.get_Children()))
                return;
            var $it1164 = shape.get_Children().GetEnumerator();
            while ($it1164.MoveNext()){
                var child = $it1164.get_Current();
                this.CalculateShapeToBoundaries(child);
            }
            var obstacleCalculator = new Microsoft.Msagl.Routing.ShapeObstacleCalculator.ctor(shape, this.tightPadding, this.get_AdjustedLoosePadding(), this.shapesToTightLooseCouples);
            obstacleCalculator.Calculate();
            this.set_OverlapsDetected(this.get_OverlapsDetected() | obstacleCalculator.get_OverlapsDetected());
        },
        OverlapsDetected$$: "System.Boolean",
        get_OverlapsDetected: function (){
            return this._OverlapsDetected;
        },
        set_OverlapsDetected: function (value){
            this._OverlapsDetected = value;
        },
        AdjustedLoosePadding$$: "System.Double",
        get_AdjustedLoosePadding: function (){
            return this.get_BundlingSettings() == null ? this.get_LoosePadding() : this.get_LoosePadding() * 1.1;
        },
        RouteOnVisGraph: function (){
            this.ancestorSets = Microsoft.Msagl.Routing.SplineRouter.GetAncestorSetsMap(this.root.get_Descendands());
            if (this.get_BundlingSettings() == null){
                var $it1165 = System.Linq.Enumerable.GroupBy$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Edge.ctor, Microsoft.Msagl.Core.DataStructures.Set$1.ctor, this._edges, $CreateDelegate(this, this.EdgePassport)).GetEnumerator();
                while ($it1165.MoveNext()){
                    var edgeGroup = $it1165.get_Current();
                    var passport = edgeGroup.get_Key();
                    var obstacleShapes = this.GetObstaclesFromPassport(passport);
                    var interactiveEdgeRouter = this.CreateInteractiveEdgeRouter(obstacleShapes);
                    this.RouteEdgesWithTheSamePassport(edgeGroup, interactiveEdgeRouter, obstacleShapes);
                }
            }
            else
                this.RouteBundles();
        },
        RouteEdgesWithTheSamePassport: function (edgeGeometryGroup, interactiveEdgeRouter, obstacleShapes){
            var regularEdges;
            var multiEdges;
            if (this.get_RouteMultiEdgesAsBundles()){
                (function (){
                    var $1 = {
                        Value: regularEdges
                    };
                    var $2 = {
                        Value: multiEdges
                    };
                    var $res = this.SplitOnRegularAndMultiedges(edgeGeometryGroup, $1, $2);
                    regularEdges = $1.Value;
                    multiEdges = $2.Value;
                    return $res;
                }).call(this);
                var $it1166 = regularEdges.GetEnumerator();
                while ($it1166.MoveNext()){
                    var edge = $it1166.get_Current();
                    this.RouteEdge(interactiveEdgeRouter, edge);
                }
                if (multiEdges != null){
                    this.ScaleDownLooseHierarchy(interactiveEdgeRouter, obstacleShapes);
                    this.RouteMultiEdges(multiEdges, interactiveEdgeRouter, edgeGeometryGroup.get_Key());
                }
            }
            else {
                var $it1167 = edgeGeometryGroup.GetEnumerator();
                while ($it1167.MoveNext()){
                    var eg = $it1167.get_Current();
                    this.RouteEdge(interactiveEdgeRouter, eg);
                }
            }
        },
        RouteMultiEdgesAsBundles$$: "System.Boolean",
        get_RouteMultiEdgesAsBundles: function (){
            return this.routeMultiEdgesAsBundles;
        },
        set_RouteMultiEdgesAsBundles: function (value){
            this.routeMultiEdgesAsBundles = value;
        },
        RouteEdge: function (interactiveEdgeRouter, edge){
            var transparentShapes = this.MakeTransparentShapesOfEdgeGeometryAndGetTheShapes(edge.get_EdgeGeometry());
            this.ProgressStep();
            this.RouteEdgeGeometry(edge, interactiveEdgeRouter);
            Microsoft.Msagl.Routing.SplineRouter.SetTransparency(transparentShapes, false);
        },
        ScaleDownLooseHierarchy: function (interactiveEdgeRouter, obstacleShapes){
            var loosePolys = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            var $it1168 = obstacleShapes.GetEnumerator();
            while ($it1168.MoveNext()){
                var obstacleShape = $it1168.get_Current();
                var tl = this.shapesToTightLooseCouples.get_Item$$TKey(obstacleShape);
                loosePolys.Add(Microsoft.Msagl.Routing.InteractiveObstacleCalculator.LoosePolylineWithFewCorners(tl.get_TightPolyline(), tl.get_Distance() / 1.1));
            }
            interactiveEdgeRouter.set_LooseHierarchy(Microsoft.Msagl.Routing.SplineRouter.CreateLooseObstacleHierarachy(loosePolys));
            interactiveEdgeRouter.ClearActivePolygons();
            interactiveEdgeRouter.AddActivePolygons(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, Microsoft.Msagl.Routing.Visibility.Polygon.ctor, loosePolys, $CreateAnonymousDelegate(this, function (polyline){
                return new Microsoft.Msagl.Routing.Visibility.Polygon.ctor(polyline);
            })));
        },
        RouteMultiEdges: function (multiEdges, interactiveEdgeRouter, parents){
            var mer = new Microsoft.Msagl.Routing.MultiEdgeRouter.ctor(multiEdges, interactiveEdgeRouter, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor, System.Linq.Enumerable.SelectMany$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Routing.Shape.ctor, parents, $CreateAnonymousDelegate(this, function (p){
                return p.get_Children();
            })), $CreateAnonymousDelegate(this, function (s){
                return s.get_BoundaryCurve();
            })), (function (){
                var $v124 = new Microsoft.Msagl.Core.Routing.BundlingSettings.ctor();
                $v124.set_InkImportance(1E-05);
                $v124.set_EdgeSeparation(this.get_MultiEdgesSeparation());
                return $v124;
            }).call(this), $CreateDelegate(this, this.MakeTransparentShapesOfEdgeGeometryAndGetTheShapes));
            mer.Run();
        },
        SplitOnRegularAndMultiedges: function (edges, regularEdges, multiEdges){
            regularEdges.Value = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Layout.Edge.ctor);
            var portLocationPairsToEdges = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.PointPair.ctor, System.Collections.Generic.List$1.ctor);
            var $it1169 = edges.GetEnumerator();
            while ($it1169.MoveNext()){
                var eg = $it1169.get_Current();
                if (Microsoft.Msagl.Routing.SplineRouter.IsEdgeToParent(eg.get_EdgeGeometry()))
                    regularEdges.Value.Add(eg);
                else
                    Microsoft.Msagl.Routing.SplineRouter.RegisterInPortLocationsToEdges(eg, portLocationPairsToEdges);
            }
            multiEdges.Value = null;
            var $it1170 = portLocationPairsToEdges.get_Values().GetEnumerator();
            while ($it1170.MoveNext()){
                var edgeGroup = $it1170.get_Current();
                if (edgeGroup.get_Count() == 1 || this.get_OverlapsDetected())
                    regularEdges.Value.AddRange(edgeGroup);
                else {
                    if (multiEdges.Value == null)
                        multiEdges.Value = new System.Collections.Generic.List$1.ctor(Array);
                    multiEdges.Value.Add(edgeGroup.ToArray());
                }
            }
        },
        CreateInteractiveEdgeRouter: function (obstacleShapes){
            var loosePolys = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, obstacleShapes, $CreateAnonymousDelegate(this, function (sh){
                return As(this.shapesToTightLooseCouples.get_Item$$TKey(sh).get_LooseShape().get_BoundaryCurve(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            })));
            var router = (function (){
                var $v125 = new Microsoft.Msagl.Routing.InteractiveEdgeRouter.ctor();
                $v125.set_VisibilityGraph(this.visGraph);
                $v125.set_TightHierarchy(this.CreateTightObstacleHierarachy(obstacleShapes));
                $v125.set_LooseHierarchy(Microsoft.Msagl.Routing.SplineRouter.CreateLooseObstacleHierarachy(loosePolys));
                $v125.set_UseSpanner(true);
                $v125.set_LookForRoundedVertices(true);
                $v125.set_TightPadding(this.tightPadding);
                $v125.set_LoosePadding(this.get_LoosePadding());
                $v125.UseEdgeLengthMultiplier = this.UseEdgeLengthMultiplier;
                $v125.UsePolylineEndShortcutting = this.UsePolylineEndShortcutting;
                $v125.UseInnerPolylingShortcutting = this.UseInnerPolylingShortcutting;
                $v125.AllowedShootingStraightLines = this.AllowedShootingStraightLines;
                $v125.set_CacheCorners(this.get_CacheCornersForSmoothing());
                return $v125;
            }).call(this);
            router.AddActivePolygons(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, Microsoft.Msagl.Routing.Visibility.Polygon.ctor, loosePolys, $CreateAnonymousDelegate(this, function (polyline){
                return new Microsoft.Msagl.Routing.Visibility.Polygon.ctor(polyline);
            })));
            return router;
        },
        CacheCornersForSmoothing$$: "System.Boolean",
        get_CacheCornersForSmoothing: function (){
            return this._CacheCornersForSmoothing;
        },
        set_CacheCornersForSmoothing: function (value){
            this._CacheCornersForSmoothing = value;
        },
        GetObstaclesFromPassport: function (passport){
            if (passport.get_Count() == 0)
                return new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Routing.Shape.ctor, this.root.get_Children());
            var commonAncestors = this.GetCommonAncestorsAbovePassport(passport);
            var allAncestors = this.GetAllAncestors(passport);
            var ret = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Routing.Shape.ctor, System.Linq.Enumerable.SelectMany$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Routing.Shape.ctor, passport, $CreateAnonymousDelegate(this, function (p){
                return System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, p.get_Children(), $CreateAnonymousDelegate(this, function (child){
                    return !allAncestors.Contains$$T(child);
                }));
            })));
            var enqueued = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Routing.Shape.ctor, System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Routing.Shape.ctor, passport, ret));
            var queue = new System.Collections.Generic.Queue$1.ctor(Microsoft.Msagl.Routing.Shape.ctor);
            var $it1171 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, passport, $CreateAnonymousDelegate(this, function (shape){
                return !commonAncestors.Contains$$T(shape);
            })).GetEnumerator();
            while ($it1171.MoveNext()){
                var shape = $it1171.get_Current();
                queue.Enqueue(shape);
            }
            while (queue.get_Count() > 0){
                var a = queue.Dequeue();
                var $it1172 = a.get_Parents().GetEnumerator();
                while ($it1172.MoveNext()){
                    var parent = $it1172.get_Current();
                    var $it1173 = parent.get_Children().GetEnumerator();
                    while ($it1173.MoveNext()){
                        var sibling = $it1173.get_Current();
                        if (!allAncestors.Contains$$T(sibling))
                            ret.Insert(sibling);
                    }
                    if (!commonAncestors.Contains$$T(parent) && !enqueued.Contains$$T(parent)){
                        queue.Enqueue(parent);
                        enqueued.Insert(parent);
                    }
                }
            }
            return ret;
        },
        GetAllAncestors: function (passport){
            if (!System.Linq.Enumerable.Any$1$$IEnumerable$1(Microsoft.Msagl.Routing.Shape.ctor, passport))
                return new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Routing.Shape.ctor);
            var ret = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Routing.Shape.ctor, passport);
            var $it1174 = passport.GetEnumerator();
            while ($it1174.MoveNext()){
                var shape = $it1174.get_Current();
                ret = Microsoft.Msagl.Core.DataStructures.Set$1.op_Addition(ret, this.ancestorSets.get_Item$$TKey(shape));
            }
            return ret;
        },
        GetCommonAncestorsAbovePassport: function (passport){
            if (!System.Linq.Enumerable.Any$1$$IEnumerable$1(Microsoft.Msagl.Routing.Shape.ctor, passport))
                return new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Routing.Shape.ctor);
            var ret = this.ancestorSets.get_Item$$TKey(System.Linq.Enumerable.First$1$$IEnumerable$1(Microsoft.Msagl.Routing.Shape.ctor, passport));
            var $it1175 = System.Linq.Enumerable.Skip$1(Microsoft.Msagl.Routing.Shape.ctor, passport, 1).GetEnumerator();
            while ($it1175.MoveNext()){
                var shape = $it1175.get_Current();
                ret = Microsoft.Msagl.Core.DataStructures.Set$1.op_Multiply(ret, this.ancestorSets.get_Item$$TKey(shape));
            }
            return ret;
        },
        RouteBundles: function (){
            this.ScaleLooseShapesDown();
            this.CalculateEdgeEnterablePolylines();
            var looseHierarchy = this.GetLooseHierarchy();
            var cdt = Microsoft.Msagl.Routing.Spline.Bundling.BundleRouter.CreateConstrainedDelaunayTriangulation(looseHierarchy);
            var shortestPath = new Microsoft.Msagl.Routing.Spline.Bundling.SdShortestPath.ctor($CreateDelegate(this, this.MakeTransparentShapesOfEdgeGeometryAndGetTheShapes), cdt, this.FindCdtGates(cdt));
            var bundleRouter = new Microsoft.Msagl.Routing.Spline.Bundling.BundleRouter.ctor(this.geometryGraph, shortestPath, this.visGraph, this.get_BundlingSettings(), this.get_LoosePadding(), this.GetTightHierarchy(), looseHierarchy, this.enterableLoose, this.enterableTight, $CreateAnonymousDelegate(this, function (port){
                return this.LoosePolyOfOriginalShape(this.portsToShapes.get_Item$$TKey(port));
            }));
            bundleRouter.Run();
        },
        CreateTheMapToParentLooseShapes: function (shape, loosePolylinesToLooseParentShapeMap){
            var $it1176 = shape.get_Children().GetEnumerator();
            while ($it1176.MoveNext()){
                var childShape = $it1176.get_Current();
                var tightLooseCouple = this.shapesToTightLooseCouples.get_Item$$TKey(childShape);
                var poly = tightLooseCouple.get_LooseShape().get_BoundaryCurve();
                loosePolylinesToLooseParentShapeMap.set_Item$$TKey(poly, shape);
                this.CreateTheMapToParentLooseShapes(childShape, loosePolylinesToLooseParentShapeMap);
            }
        },
        FindCdtGates: function (cdt){
            var loosePolylinesToLooseParentShapeMap = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor, Microsoft.Msagl.Routing.Shape.ctor);
            this.CreateTheMapToParentLooseShapes(this.root, loosePolylinesToLooseParentShapeMap);
            var gates = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Routing.CdtEdge.ctor);
            var $it1177 = cdt.PointsToSites.get_Values().GetEnumerator();
            while ($it1177.MoveNext()){
                var cdtSite = $it1177.get_Current();
                var $it1178 = cdtSite.Edges.GetEnumerator();
                while ($it1178.MoveNext()){
                    var cdtEdge = $it1178.get_Current();
                    if (cdtEdge.get_CwTriangle() == null && cdtEdge.get_CcwTriangle() == null)
                        continue;
                    var a = Cast(cdtSite.get_Owner(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
                    var b = Cast(cdtEdge.lowerSite.get_Owner(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
                    if (a == b)
                        continue;
                    var aParent;
                    var bParent;
                    if ((function (){
                        var $1 = {
                            Value: aParent
                        };
                        var $res = loosePolylinesToLooseParentShapeMap.TryGetValue(a, $1);
                        aParent = $1.Value;
                        return $res;
                    }).call(this) && (function (){
                        var $1 = {
                            Value: bParent
                        };
                        var $res = loosePolylinesToLooseParentShapeMap.TryGetValue(b, $1);
                        bParent = $1.Value;
                        return $res;
                    }).call(this) && aParent == bParent)
                        gates.Insert(cdtEdge);
                }
            }
            return gates;
        },
        CalculateEdgeEnterablePolylines: function (){
            this.enterableLoose = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, Microsoft.Msagl.Core.DataStructures.Set$1.ctor);
            this.enterableTight = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.EdgeGeometry.ctor, Microsoft.Msagl.Core.DataStructures.Set$1.ctor);
            var $it1179 = this.get_edgeGeometriesEnumeration().GetEnumerator();
            while ($it1179.MoveNext()){
                var edgeGeometry = $it1179.get_Current();
                var looseSet;
                var tightSet;
                (function (){
                    var $1 = {
                        Value: looseSet
                    };
                    var $2 = {
                        Value: tightSet
                    };
                    var $res = this.GetEdgeEnterablePolylines(edgeGeometry, $1, $2);
                    looseSet = $1.Value;
                    tightSet = $2.Value;
                    return $res;
                }).call(this);
                this.enterableLoose.set_Item$$TKey(edgeGeometry, looseSet);
                this.enterableTight.set_Item$$TKey(edgeGeometry, tightSet);
            }
        },
        GetEdgeEnterablePolylines: function (edgeGeometry, looseEnterable, tightEnterable){
            looseEnterable.Value = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            tightEnterable.Value = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            var sourceShape = this.portsToShapes.get_Item$$TKey(edgeGeometry.get_SourcePort());
            var targetShape = this.portsToShapes.get_Item$$TKey(edgeGeometry.get_TargetPort());
            if (sourceShape != this.root){
                looseEnterable.Value.InsertRange(System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, this.ancestorSets.get_Item$$TKey(sourceShape), $CreateDelegate(this, this.LoosePolyOfOriginalShape)), $CreateAnonymousDelegate(this, function (p){
                    return p != null;
                })));
                tightEnterable.Value.InsertRange(System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, this.ancestorSets.get_Item$$TKey(sourceShape), $CreateDelegate(this, this.TightPolyOfOriginalShape)), $CreateAnonymousDelegate(this, function (p){
                    return p != null;
                })));
            }
            if (targetShape != this.root){
                looseEnterable.Value.InsertRange(System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, this.ancestorSets.get_Item$$TKey(targetShape), $CreateDelegate(this, this.LoosePolyOfOriginalShape)), $CreateAnonymousDelegate(this, function (p){
                    return p != null;
                })));
                tightEnterable.Value.InsertRange(System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, this.ancestorSets.get_Item$$TKey(targetShape), $CreateDelegate(this, this.TightPolyOfOriginalShape)), $CreateAnonymousDelegate(this, function (p){
                    return p != null;
                })));
            }
        },
        GetTightHierarchy: function (){
            return Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnEnumeration(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.TightLooseCouple.ctor, Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, this.shapesToTightLooseCouples.get_Values(), $CreateAnonymousDelegate(this, function (tl){
                return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, tl.get_TightPolyline(), tl.get_TightPolyline().get_BoundingBox());
            })));
        },
        GetLooseHierarchy: function (){
            var loosePolylines = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.TightLooseCouple.ctor, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, this.shapesToTightLooseCouples.get_Values(), $CreateAnonymousDelegate(this, function (tl){
                return Cast((tl.get_LooseShape().get_BoundaryCurve()), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            })));
            return Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnEnumeration(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, loosePolylines, $CreateAnonymousDelegate(this, function (p){
                return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, p, p.get_BoundingBox());
            })));
        },
        ScaleLooseShapesDown: function (){
            var $it1180 = this.shapesToTightLooseCouples.GetEnumerator();
            while ($it1180.MoveNext()){
                var shapesToTightLooseCouple = $it1180.get_Current();
                var tl = shapesToTightLooseCouple.get_Value();
                tl.get_LooseShape().set_BoundaryCurve(Microsoft.Msagl.Routing.InteractiveObstacleCalculator.LoosePolylineWithFewCorners(tl.get_TightPolyline(), tl.get_Distance() / 1.1));
            }
        },
        EdgePassport: function (edge){
            var edgeGeometry = edge.get_EdgeGeometry();
            var ret = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Routing.Shape.ctor);
            var sourceShape = this.portsToShapes.get_Item$$TKey(edgeGeometry.get_SourcePort());
            var targetShape = this.portsToShapes.get_Item$$TKey(edgeGeometry.get_TargetPort());
            if (this.IsAncestor(sourceShape, targetShape)){
                ret.InsertRange(targetShape.get_Parents());
                ret.Insert(sourceShape);
                return ret;
            }
            if (this.IsAncestor(targetShape, sourceShape)){
                ret.InsertRange(sourceShape.get_Parents());
                ret.Insert(targetShape);
                return ret;
            }
            if (sourceShape != this.looseRoot)
                ret.InsertRange(sourceShape.get_Parents());
            if (targetShape != this.looseRoot)
                ret.InsertRange(targetShape.get_Parents());
            return ret;
        },
        AllPorts: function (){
            var $yield = [];
            var $it1181 = this.get_edgeGeometriesEnumeration().GetEnumerator();
            while ($it1181.MoveNext()){
                var edgeGeometry = $it1181.get_Current();
                $yield.push(edgeGeometry.get_SourcePort());
                $yield.push(edgeGeometry.get_TargetPort());
            }
            return $yield;
        },
        CalculatePortsToShapes: function (){
            this.portsToShapes = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Port.ctor, Microsoft.Msagl.Routing.Shape.ctor);
            var $it1182 = this.root.get_Descendands().GetEnumerator();
            while ($it1182.MoveNext()){
                var shape = $it1182.get_Current();
                var $it1183 = shape.get_Ports().GetEnumerator();
                while ($it1183.MoveNext()){
                    var port = $it1183.get_Current();
                    this.portsToShapes.set_Item$$TKey(port, shape);
                }
            }
            var $it1184 = System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Port.ctor, this.AllPorts(), $CreateAnonymousDelegate(this, function (p){
                return !this.portsToShapes.ContainsKey(p);
            })).GetEnumerator();
            while ($it1184.MoveNext()){
                var port = $it1184.get_Current();
                this.root.get_Ports().Insert(port);
                this.portsToShapes.set_Item$$TKey(port, this.root);
            }
        },
        RouteEdgeGeometry: function (edge, iRouter){
            var edgeGeometry = edge.get_EdgeGeometry();
            var addedEdges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor);
            if (!(Is(edgeGeometry.get_SourcePort(), Microsoft.Msagl.Core.Layout.HookUpAnywhereFromInsidePort.ctor)))
                addedEdges.AddRange(this.AddVisibilityEdgesFromPort(edgeGeometry.get_SourcePort()));
            if (!(Is(edgeGeometry.get_TargetPort(), Microsoft.Msagl.Core.Layout.HookUpAnywhereFromInsidePort.ctor)))
                addedEdges.AddRange(this.AddVisibilityEdgesFromPort(edgeGeometry.get_TargetPort()));
            var smoothedPolyline;
            if (!Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(edgeGeometry.get_SourcePort().get_Location(), edgeGeometry.get_TargetPort().get_Location()))
                edgeGeometry.set_Curve((function (){
                    var $1 = {
                        Value: smoothedPolyline
                    };
                    var $res = iRouter.RouteSplineFromPortToPortWhenTheWholeGraphIsReady(edgeGeometry.get_SourcePort(), edgeGeometry.get_TargetPort(), true, $1);
                    smoothedPolyline = $1.Value;
                    return $res;
                }).call(this));
            else {
                edgeGeometry.set_Curve((function (){
                    var $1 = {
                        Value: smoothedPolyline
                    };
                    var $res = Microsoft.Msagl.Core.Layout.Edge.RouteSelfEdge(edgeGeometry.get_SourcePort().get_Curve(), System.Math.Max$$Double$$Double(this.get_LoosePadding() * 2, edgeGeometry.GetMaxArrowheadLength()), $1);
                    smoothedPolyline = $1.Value;
                    return $res;
                }).call(this));
            }
            edgeGeometry.set_SmoothedPolyline(smoothedPolyline);
            if (edgeGeometry.get_Curve() == null)
                throw $CreateException(new System.NotImplementedException.ctor(), new Error());
            var $it1185 = addedEdges.GetEnumerator();
            while ($it1185.MoveNext()){
                var visibilityEdge = $it1185.get_Current();
                Microsoft.Msagl.Routing.Visibility.VisibilityGraph.RemoveEdge$$VisibilityEdge(visibilityEdge);
            }
            Microsoft.Msagl.Core.Layout.Arrowheads.TrimSplineAndCalculateArrowheads$$EdgeGeometry$$ICurve$$ICurve$$ICurve$$Boolean$$Boolean(edgeGeometry, edgeGeometry.get_SourcePort().get_Curve(), edgeGeometry.get_TargetPort().get_Curve(), edgeGeometry.get_Curve(), false, this.get_KeepOriginalSpline());
            if (this.ReplaceEdgeByRails != null)
                this.ReplaceEdgeByRails(edge);
        },
        KeepOriginalSpline$$: "System.Boolean",
        get_KeepOriginalSpline: function (){
            return this._KeepOriginalSpline;
        },
        set_KeepOriginalSpline: function (value){
            this._KeepOriginalSpline = value;
        },
        ArrowHeadRatio$$: "System.Double",
        get_ArrowHeadRatio: function (){
            return this._ArrowHeadRatio;
        },
        set_ArrowHeadRatio: function (value){
            this._ArrowHeadRatio = value;
        },
        LineSweeperPorts$$: "Microsoft.Msagl.Core.Geometry.Point[]",
        get_LineSweeperPorts: function (){
            return this._LineSweeperPorts;
        },
        set_LineSweeperPorts: function (value){
            this._LineSweeperPorts = value;
        },
        AddVisibilityEdgesFromPort: function (port){
            var portShape;
            var boundaryCouple;
            if (Is(port, Microsoft.Msagl.Core.Layout.CurvePort.ctor) || !(function (){
                var $1 = {
                    Value: portShape
                };
                var $res = this.portsToShapes.TryGetValue(port, $1);
                portShape = $1.Value;
                return $res;
            }).call(this) || !(function (){
                var $1 = {
                    Value: boundaryCouple
                };
                var $res = this.shapesToTightLooseCouples.TryGetValue(portShape, $1);
                boundaryCouple = $1.Value;
                return $res;
            }).call(this))
                return new Array(0);
            var portLoosePoly = boundaryCouple.get_LooseShape();
            return (System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Point.ctor, As(portLoosePoly.get_BoundaryCurve(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor), $CreateAnonymousDelegate(this, function (point){
                return this.visGraph.FindEdge$$Point$$Point(port.get_Location(), point) == null;
            })), $CreateAnonymousDelegate(this, function (point){
                return this.visGraph.AddEdge$$Point$$Point(port.get_Location(), point);
            })));
        },
        MakeTransparentShapesOfEdgeGeometryAndGetTheShapes: function (edgeGeometry){
            var sourceShape = this.portsToShapes.get_Item$$TKey(edgeGeometry.get_SourcePort());
            var targetShape = this.portsToShapes.get_Item$$TKey(edgeGeometry.get_TargetPort());
            var transparentLooseShapes = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Shape.ctor);
            for (var $i1187 = 0,$t1187 = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Routing.Shape.ctor, this.GetTransparentShapes(edgeGeometry.get_SourcePort(), edgeGeometry.get_TargetPort(), sourceShape, targetShape)),$l1187 = $t1187.length,shape = $t1187[$i1187]; $i1187 < $l1187; $i1187++, shape = $t1187[$i1187])
                if (shape != null)
                    transparentLooseShapes.Add(this.LooseShapeOfOriginalShape(shape));
            var $it1187 = this.portsToEnterableShapes.get_Item$$TKey(edgeGeometry.get_SourcePort()).GetEnumerator();
            while ($it1187.MoveNext()){
                var shape = $it1187.get_Current();
                transparentLooseShapes.Add(this.LooseShapeOfOriginalShape(shape));
            }
            var $it1188 = this.portsToEnterableShapes.get_Item$$TKey(edgeGeometry.get_TargetPort()).GetEnumerator();
            while ($it1188.MoveNext()){
                var shape = $it1188.get_Current();
                transparentLooseShapes.Add(this.LooseShapeOfOriginalShape(shape));
            }
            Microsoft.Msagl.Routing.SplineRouter.SetTransparency(transparentLooseShapes, true);
            return transparentLooseShapes;
        },
        LooseShapeOfOriginalShape: function (s){
            if (s == this.root)
                return this.looseRoot;
            return this.shapesToTightLooseCouples.get_Item$$TKey(s).get_LooseShape();
        },
        LoosePolyOfOriginalShape: function (s){
            return Cast((this.LooseShapeOfOriginalShape(s).get_BoundaryCurve()), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
        },
        TightPolyOfOriginalShape: function (s){
            if (s == this.root)
                return null;
            return this.shapesToTightLooseCouples.get_Item$$TKey(s).get_TightPolyline();
        },
        GetTransparentShapes: function (sourcePort, targetPort, sourceShape, targetShape){
            var $yield = [];
            var $it1189 = this.ancestorSets.get_Item$$TKey(sourceShape).GetEnumerator();
            while ($it1189.MoveNext()){
                var s = $it1189.get_Current();
                $yield.push(s);
            }
            var $it1190 = this.ancestorSets.get_Item$$TKey(targetShape).GetEnumerator();
            while ($it1190.MoveNext()){
                var s = $it1190.get_Current();
                $yield.push(s);
            }
            var routingOutsideOfSourceBoundary = Microsoft.Msagl.Routing.SplineRouter.EdgesAttachedToPortAvoidTheNode(sourcePort);
            var routingOutsideOfTargetBoundary = Microsoft.Msagl.Routing.SplineRouter.EdgesAttachedToPortAvoidTheNode(targetPort);
            if (!routingOutsideOfSourceBoundary && !routingOutsideOfTargetBoundary){
                $yield.push(sourceShape);
                $yield.push(targetShape);
            }
            else if (routingOutsideOfSourceBoundary){
                if (this.IsAncestor(sourceShape, targetShape))
                    $yield.push(sourceShape);
            }
            else {
                if (this.IsAncestor(targetShape, sourceShape))
                    $yield.push(targetShape);
            }
            return $yield;
        },
        IsAncestor: function (possibleAncestor, possiblePredecessor){
            var ancestors;
            return possiblePredecessor != null && (function (){
                var $1 = {
                    Value: ancestors
                };
                var $res = this.ancestorSets.TryGetValue(possiblePredecessor, $1);
                ancestors = $1.Value;
                return $res;
            }).call(this) && Microsoft.Msagl.Core.DataStructures.Set$1.op_Inequality(ancestors, null) && ancestors.Contains$$T(possibleAncestor);
        },
        CreateTightObstacleHierarachy: function (obstacles){
            var tightPolys = System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, obstacles, $CreateAnonymousDelegate(this, function (sh){
                return this.shapesToTightLooseCouples.get_Item$$TKey(sh).get_TightPolyline();
            }));
            return Microsoft.Msagl.Core.Geometry.RectangleNode$1.CreateRectangleNodeOnEnumeration(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor, tightPolys, $CreateAnonymousDelegate(this, function (tightPoly){
                return new Microsoft.Msagl.Core.Geometry.RectangleNode$1.ctor$$TData$$Rectangle(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, tightPoly, tightPoly.get_BoundingBox());
            })));
        },
        CalculateVisibilityGraph: function (){
            var setOfPortLocations = this.get_LineSweeperPorts() != null ? new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Point.ctor, this.get_LineSweeperPorts()) : new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            var $it1192 = this.get_edgeGeometriesEnumeration().GetEnumerator();
            while ($it1192.MoveNext()){
                var edgeGeometry = $it1192.get_Current();
                if (!(Is(edgeGeometry.get_SourcePort(), Microsoft.Msagl.Core.Layout.HookUpAnywhereFromInsidePort.ctor) || Is(edgeGeometry.get_SourcePort(), Microsoft.Msagl.Routing.ClusterBoundaryPort.ctor)))
                    setOfPortLocations.Insert(edgeGeometry.get_SourcePort().get_Location());
                if (!(Is(edgeGeometry.get_TargetPort(), Microsoft.Msagl.Core.Layout.HookUpAnywhereFromInsidePort.ctor) || Is(edgeGeometry.get_TargetPort(), Microsoft.Msagl.Routing.ClusterBoundaryPort.ctor)))
                    setOfPortLocations.Insert(edgeGeometry.get_TargetPort().get_Location());
            }
            this.portRTree = new Microsoft.Msagl.Core.Geometry.RTree$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Point.ctor, System.Collections.Generic.KeyValuePair$2.ctor, setOfPortLocations, $CreateAnonymousDelegate(this, function (p){
                return new System.Collections.Generic.KeyValuePair$2.ctor$$TKey$$TValue(Microsoft.Msagl.Core.Geometry.Rectangle.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor, new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point(p), p);
            })));
            this.visGraph = new Microsoft.Msagl.Routing.Visibility.VisibilityGraph.ctor();
            this.FillVisibilityGraphUnderShape(this.root);
        },
        FillVisibilityGraphUnderShape: function (shape){
            var children = shape.get_Children();
            var $it1193 = children.GetEnumerator();
            while ($it1193.MoveNext()){
                var child = $it1193.get_Current();
                this.FillVisibilityGraphUnderShape(child);
            }
            var tightLooseCouple;
            var looseBoundary = (function (){
                var $1 = {
                    Value: tightLooseCouple
                };
                var $res = this.shapesToTightLooseCouples.TryGetValue(shape, $1);
                tightLooseCouple = $1.Value;
                return $res;
            }).call(this) ? As(tightLooseCouple.get_LooseShape().get_BoundaryCurve(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor) : null;
            var looseShape = tightLooseCouple != null ? tightLooseCouple.get_LooseShape() : this.looseRoot;
            var obstacles = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Shape.ctor, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, looseShape.get_Children(), $CreateAnonymousDelegate(this, function (c){
                return As(c.get_BoundaryCurve(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            })));
            var portLocations = this.RemoveInsidePortsAndSplitBoundaryIfNeeded(looseBoundary);
            var tmpVisGraph = new Microsoft.Msagl.Routing.Visibility.VisibilityGraph.ctor();
            var coneSpanner = new Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSpanner.ctor$$IEnumerable$1$Polyline$$VisibilityGraph$$Double$$Set$1$Point$$Polyline(new Array(0), tmpVisGraph, this.coneAngle, portLocations, looseBoundary);
            coneSpanner.Run();
            tmpVisGraph = new Microsoft.Msagl.Routing.Visibility.VisibilityGraph.ctor();
            coneSpanner = (function (){
                var $v126 = new Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSpanner.ctor$$IEnumerable$1$Polyline$$VisibilityGraph$$Double$$Set$1$Point$$Polyline(obstacles, tmpVisGraph, this.coneAngle, portLocations, looseBoundary);
                $v126.set_Bidirectional(this.get_Bidirectional() && obstacles.get_Count() > 0);
                return $v126;
            }).call(this);
            coneSpanner.Run();
            this.ProgressStep();
            var $it1194 = tmpVisGraph.get_Edges().GetEnumerator();
            while ($it1194.MoveNext()){
                var edge = $it1194.get_Current();
                this.TryToCreateNewEdgeAndSetIsPassable(edge, looseShape);
            }
            this.AddBoundaryEdgesToVisGraph(looseBoundary);
        },
        Bidirectional$$: "System.Boolean",
        get_Bidirectional: function (){
            return this._Bidirectional;
        },
        set_Bidirectional: function (value){
            this._Bidirectional = value;
        },
        TryToCreateNewEdgeAndSetIsPassable: function (edge, looseShape){
            var e = this.visGraph.FindEdge$$Point$$Point(edge.get_SourcePoint(), edge.get_TargetPoint());
            if (e != null)
                return;
            e = this.visGraph.AddEdge$$Point$$Point(edge.get_SourcePoint(), edge.get_TargetPoint());
            if (looseShape != null)
                e.set_IsPassable($CreateAnonymousDelegate(this, function (){
                    return looseShape.get_IsTransparent();
                }));
        },
        AddBoundaryEdgesToVisGraph: function (boundary){
            if (boundary == null)
                return;
            var p = boundary.get_StartPoint();
            do{
                var pn = p.get_NextOnPolyline();
                this.visGraph.AddEdge$$Point$$Point(p.get_Point(), pn.get_Point());
                if (pn == boundary.get_StartPoint())
                    break;
                p = pn;
            }
            while (true)
        },
        RemoveInsidePortsAndSplitBoundaryIfNeeded: function (boundary){
            var ret = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor);
            if (boundary == null){
                var $it1195 = this.portRTree.GetAllLeaves().GetEnumerator();
                while ($it1195.MoveNext()){
                    var point = $it1195.get_Current();
                    ret.Insert(point);
                }
                this.portRTree.Clean();
                return ret;
            }
            var boundaryBox = boundary.get_BoundingBox();
            var portLocationsInQuestion = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.Geometry.Point.ctor, this.portRTree.GetAllIntersecting(boundaryBox));
            for (var $i1197 = 0,$l1197 = portLocationsInQuestion.length,point = portLocationsInQuestion[$i1197]; $i1197 < $l1197; $i1197++, point = portLocationsInQuestion[$i1197]){
                switch (Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(point, boundary)){
                    case Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Inside:
                        ret.Insert(point);
                        this.portLocationsToLoosePolylines.set_Item$$TKey(point, boundary);
                        this.portRTree.Remove(new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point(point), point);
                        break;
                    case Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Boundary:
                        this.portRTree.Remove(new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point(point), point);
                        this.portLocationsToLoosePolylines.set_Item$$TKey(point, boundary);
                        var polylinePoint = Microsoft.Msagl.Routing.SplineRouter.FindPointOnPolylineToInsertAfter(boundary, point);
                        if (polylinePoint != null)
                        Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeper.InsertPointIntoPolylineAfter(boundary, polylinePoint, point);
                        else
                        throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
                        break;
                }
            }
            return ret;
        },
        GetOrCreateRoot: function (){
            if (System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Routing.Shape.ctor, this.rootShapes) == 0)
                return;
            if (System.Linq.Enumerable.Count$1$$IEnumerable$1(Microsoft.Msagl.Routing.Shape.ctor, this.rootShapes) == 1){
                var r = System.Linq.Enumerable.First$1$$IEnumerable$1(Microsoft.Msagl.Routing.Shape.ctor, this.rootShapes);
                if (r.get_BoundaryCurve() == null){
                    this.root = r;
                    return;
                }
            }
            this.rootWasCreated = true;
            this.root = new Microsoft.Msagl.Routing.Shape.ctor();
            for (var $i1198 = 0,$t1198 = this.rootShapes,$l1198 = $t1198.length,rootShape = $t1198[$i1198]; $i1198 < $l1198; $i1198++, rootShape = $t1198[$i1198])
                this.root.AddChild(rootShape);
        },
        RemoveRoot: function (){
            if (this.rootWasCreated)
                for (var $i1199 = 0,$t1199 = this.rootShapes,$l1199 = $t1199.length,rootShape = $t1199[$i1199]; $i1199 < $l1199; $i1199++, rootShape = $t1199[$i1199])
                    rootShape.RemoveParent(this.root);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$SplineRouter);
var Microsoft$Msagl$Routing$SingleSourceSingleTargetShortestPathOnVisibilityGraph = {
    fullname: "Microsoft.Msagl.Routing.SingleSourceSingleTargetShortestPathOnVisibilityGraph",
    baseTypeName: "System.Object",
    staticDefinition: {
        IsForbidden: function (e){
            return e.get_IsPassable() != null && !e.get_IsPassable()() || Is(e, Microsoft.Msagl.Routing.Visibility.TollFreeVisibilityEdge.ctor);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (visGraph, sourceVisVertex, targetVisVertex){
            this.source = null;
            this.target = null;
            this._visGraph = null;
            System.Object.ctor.call(this);
            this._visGraph = visGraph;
            this.source = sourceVisVertex;
            this.target = targetVisVertex;
            this.source.set_Distance(0);
        },
        GetPath: function (shrinkEdgeLength){
            var pq = new Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueue$1.ctor(Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor);
            this.source.set_Distance(0);
            this.target.set_Distance(Infinity);
            pq.Enqueue(this.source, this.H(this.source));
            while (!pq.IsEmpty()){
                var hu;
                var u = (function (){
                    var $1 = {
                        Value: hu
                    };
                    var $res = pq.Dequeue$$Double($1);
                    hu = $1.Value;
                    return $res;
                }).call(this);
                if (hu >= this.target.get_Distance())
                    break;
                var $it1202 = u.get_OutEdges().GetEnumerator();
                while ($it1202.MoveNext()){
                    var e = $it1202.get_Current();
                    if (this.PassableOutEdge(e)){
                        var v = e.get_Target();
                        this.ProcessNeighbor(pq, u, e, v);
                    }
                }
                var $it1203 = u.get_InEdges().GetEnumerator();
                while ($it1203.MoveNext()){
                    var e = $it1203.get_Current();
                    if (this.PassableInEdge(e)){
                        var v = e.get_Source();
                        this.ProcessNeighbor(pq, u, e, v);
                    }
                }
            }
            return this._visGraph.PreviosVertex(this.target) == null ? null : this.CalculatePath(shrinkEdgeLength);
        },
        PassableOutEdge: function (e){
            return e.get_Source() == this.source || e.get_Target() == this.target || !Microsoft.Msagl.Routing.SingleSourceSingleTargetShortestPathOnVisibilityGraph.IsForbidden(e);
        },
        PassableInEdge: function (e){
            return e.get_Source() == this.target || e.get_Target() == this.source || !Microsoft.Msagl.Routing.SingleSourceSingleTargetShortestPathOnVisibilityGraph.IsForbidden(e);
        },
        ProcessNeighbor: function (pq, u, l, v){
            var len = l.get_Length();
            var c = u.get_Distance() + len;
            if (v != this.source && this._visGraph.PreviosVertex(v) == null){
                v.set_Distance(c);
                this._visGraph.SetPreviousEdge(v, l);
                if (v != this.target)
                    pq.Enqueue(v, this.H(v));
            }
            else if (c < v.get_Distance()){
                v.set_Distance(c);
                this._visGraph.SetPreviousEdge(v, l);
                if (v != this.target)
                    pq.DecreasePriority(v, this.H(v));
            }
        },
        H: function (visibilityVertex){
            return visibilityVertex.get_Distance() + (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(visibilityVertex.Point, this.target.Point)).get_Length();
        },
        CalculatePath: function (shrinkEdgeLength){
            var $yield = [];
            var ret = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor);
            var v = this.target;
            do{
                ret.Add(v);
                if (shrinkEdgeLength)
                    this._visGraph.ShrinkLengthOfPrevEdge(v);
                v = this._visGraph.PreviosVertex(v);
            }
            while (v != this.source)
            ret.Add(this.source);
            for (var i = ret.get_Count() - 1; i >= 0; i--)
                $yield.push(ret.get_Item$$Int32(i));
            return $yield;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$SingleSourceSingleTargetShortestPathOnVisibilityGraph);
var Microsoft$Msagl$Layout$Layered$SmoothedPolylineCalculator = {
    fullname: "Microsoft.Msagl.Layout.Layered.SmoothedPolylineCalculator",
    baseTypeName: "System.Object",
    staticDefinition: {
        SegIntersectsBound: function (a, b, hierarchy){
            return Microsoft.Msagl.Layout.Layered.SmoothedPolylineCalculator.CurveIntersectsHierarchy(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(a.get_Point(), b.get_Point()), hierarchy);
        },
        CurveIntersectsHierarchy: function (lineSeg, hierarchy){
            if (hierarchy == null)
                return false;
            if (!Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.Intersect(lineSeg.get_ParallelogramNodeOverICurve().get_Parallelogram(), hierarchy.get_Parallelogram()))
                return false;
            var n = As(hierarchy, Microsoft.Msagl.Core.Geometry.Curves.ParallelogramBinaryTreeNode.ctor);
            if (n != null)
                return Microsoft.Msagl.Layout.Layered.SmoothedPolylineCalculator.CurveIntersectsHierarchy(lineSeg, n.get_LeftSon()) || Microsoft.Msagl.Layout.Layered.SmoothedPolylineCalculator.CurveIntersectsHierarchy(lineSeg, n.get_RightSon());
            return Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(lineSeg, (Cast(hierarchy, Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.ctor)).get_Seg(), false).get_Count() > 0;
        },
        Flat: function (i){
            return Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(i.get_Previous().get_Point(), i.get_Point(), i.get_Next().get_Point()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Collinear;
        },
        BezierSegIntersectsBoundary$$CubicBezierSegment$$ICurve: function (seg, curve){
            var $it1210 = Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(seg, curve, false).GetEnumerator();
            while ($it1210.MoveNext()){
                var x = $it1210.get_Current();
                var c = As(curve, Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor);
                if (c != null){
                    if (Microsoft.Msagl.Core.Geometry.Curves.Curve.RealCutWithClosedCurve(x, c, false))
                        return true;
                }
                else {
                    return true;
                }
            }
            return false;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (edgePathPar, anchorsP, origGraph, settings, la, layerGraph, databaseP){
            this.headSite = null;
            this.edgePath = null;
            this.anchors = null;
            this.originalGraph = null;
            this.rightHierarchy = null;
            this.leftHierarchy = null;
            this.thinRightHierarchy = null;
            this.thinLeftHierarchy = null;
            this.thinRightNodes = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNode.ctor);
            this.thinLefttNodes = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNode.ctor);
            this.database = null;
            this.layeredGraph = null;
            this.layerArrays = null;
            this.settings = null;
            System.Object.ctor.call(this);
            this.database = databaseP;
            this.edgePath = edgePathPar;
            this.anchors = anchorsP;
            this.layerArrays = la;
            this.originalGraph = origGraph;
            this.settings = settings;
            this.layeredGraph = layerGraph;
            this.rightHierarchy = this.BuildRightHierarchy();
            this.leftHierarchy = this.BuildLeftHierarchy();
        },
        BuildRightHierarchy: function (){
            var boundaryAnchorsCurves = this.FindRightBoundaryAnchorCurves();
            var l = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNode.ctor);
            var $it1204 = boundaryAnchorsCurves.GetEnumerator();
            while ($it1204.MoveNext()){
                var c = $it1204.get_Current();
                l.Add(c.get_ParallelogramNodeOverICurve());
            }
            this.thinRightHierarchy = Microsoft.Msagl.Layout.Layered.HierarchyCalculator.Calculate$$List$1$ParallelogramNode$$Int32(this.thinRightNodes, this.settings.get_GroupSplit());
            return Microsoft.Msagl.Layout.Layered.HierarchyCalculator.Calculate$$List$1$ParallelogramNode$$Int32(l, this.settings.get_GroupSplit());
        },
        BuildLeftHierarchy: function (){
            var boundaryAnchorCurves = this.FindLeftBoundaryAnchorCurves();
            var l = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNode.ctor);
            var $it1205 = boundaryAnchorCurves.GetEnumerator();
            while ($it1205.MoveNext()){
                var a = $it1205.get_Current();
                l.Add(a.get_ParallelogramNodeOverICurve());
            }
            this.thinLeftHierarchy = Microsoft.Msagl.Layout.Layered.HierarchyCalculator.Calculate$$List$1$ParallelogramNode$$Int32(this.thinLefttNodes, this.settings.get_GroupSplit());
            return Microsoft.Msagl.Layout.Layered.HierarchyCalculator.Calculate$$List$1$ParallelogramNode$$Int32(l, this.settings.get_GroupSplit());
        },
        FindRightBoundaryAnchorCurves: function (){
            var ret = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            var uOffset = 0;
            var $it1206 = this.edgePath.GetEnumerator();
            while ($it1206.MoveNext()){
                var u = $it1206.get_Current();
                var rightMostAnchor = null;
                var $it1207 = this.LeftBoundaryNodesOfANode(u, Microsoft.Msagl.Layout.Layered.Routing.GetNodeKind(uOffset, this.edgePath)).GetEnumerator();
                while ($it1207.MoveNext()){
                    var v = $it1207.get_Current();
                    var a = this.anchors[v];
                    if (rightMostAnchor == null || rightMostAnchor.get_Origin().get_X() < a.get_Origin().get_X())
                        rightMostAnchor = a;
                    ret.Add(a.get_PolygonalBoundary());
                }
                if (rightMostAnchor != null)
                    this.thinRightNodes.Add(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Double$$Double(rightMostAnchor.get_Origin(), this.originalGraph.get_Left(), rightMostAnchor.get_Y()).get_ParallelogramNodeOverICurve());
                uOffset++;
            }
            return ret;
        },
        FindLeftBoundaryAnchorCurves: function (){
            var ret = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            var uOffset = 0;
            var $it1208 = this.edgePath.GetEnumerator();
            while ($it1208.MoveNext()){
                var u = $it1208.get_Current();
                var leftMost = -1;
                var $it1209 = this.RightBoundaryNodesOfANode(u, Microsoft.Msagl.Layout.Layered.Routing.GetNodeKind(uOffset, this.edgePath)).GetEnumerator();
                while ($it1209.MoveNext()){
                    var v = $it1209.get_Current();
                    if (leftMost == -1 || this.layerArrays.get_X()[v] < this.layerArrays.get_X()[leftMost])
                        leftMost = v;
                    ret.Add(this.anchors[v].get_PolygonalBoundary());
                }
                if (leftMost != -1){
                    var a = this.anchors[leftMost];
                    this.thinLefttNodes.Add(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Double$$Double(a.get_Origin(), this.originalGraph.get_Right(), a.get_Origin().get_Y()).get_ParallelogramNodeOverICurve());
                }
                uOffset++;
            }
            return ret;
        },
        FillRightTopAndBottomVerts: function (layer, vPosition, nodeKind){
            var $yield = [];
            var t = 0,b = 0;
            if (nodeKind == Microsoft.Msagl.Routing.NodeKind.Bottom){
                b = 3.40282346638529E+38;
            }
            else if (nodeKind == Microsoft.Msagl.Routing.NodeKind.Top){
                t = 3.40282346638529E+38;
            }
            var v = layer[vPosition];
            for (var i = vPosition + 1; i < layer.length; i++){
                var u = layer[i];
                var anchor = this.anchors[u];
                if (anchor.get_TopAnchor() > t){
                    if (!this.NodeUCanBeCrossedByNodeV(u, v)){
                        t = anchor.get_TopAnchor();
                        if (anchor.get_BottomAnchor() > b)
                            b = anchor.get_BottomAnchor();
                        $yield.push(u);
                    }
                }
                else if (anchor.get_BottomAnchor() > b){
                    if (!this.NodeUCanBeCrossedByNodeV(u, v)){
                        b = anchor.get_BottomAnchor();
                        if (anchor.get_TopAnchor() > t)
                            t = anchor.get_TopAnchor();
                        $yield.push(u);
                    }
                }
            }
            return $yield;
        },
        FillLeftTopAndBottomVerts: function (layer, vPosition, nodeKind){
            var $yield = [];
            var t = 0,b = 0;
            if (nodeKind == Microsoft.Msagl.Routing.NodeKind.Top)
                t = 3.40282346638529E+38;
            else if (nodeKind == Microsoft.Msagl.Routing.NodeKind.Bottom)
                b = 3.40282346638529E+38;
            var v = layer[vPosition];
            for (var i = vPosition - 1; i >= 0; i--){
                var u = layer[i];
                var anchor = this.anchors[u];
                if (anchor.get_TopAnchor() > t + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                    if (!this.NodeUCanBeCrossedByNodeV(u, v)){
                        t = anchor.get_TopAnchor();
                        b = System.Math.Max$$Double$$Double(b, anchor.get_BottomAnchor());
                        $yield.push(u);
                    }
                }
                else if (anchor.get_BottomAnchor() > b + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                    if (!this.NodeUCanBeCrossedByNodeV(u, v)){
                        t = System.Math.Max$$Double$$Double(t, anchor.get_TopAnchor());
                        b = anchor.get_BottomAnchor();
                        $yield.push(u);
                    }
                }
            }
            return $yield;
        },
        IsVirtualVertex: function (v){
            return v >= this.originalGraph.get_Nodes().get_Count();
        },
        IsLabel: function (u){
            return this.anchors[u].get_RepresentsLabel();
        },
        NodeUCanBeCrossedByNodeV: function (u, v){
            if (this.IsLabel(u))
                return false;
            if (this.IsLabel(v))
                return false;
            if (this.IsVirtualVertex(u) && this.IsVirtualVertex(v) && this.EdgesIntersectSomewhere(u, v))
                return true;
            return false;
        },
        EdgesIntersectSomewhere: function (u, v){
            if (this.UVAreMiddlesOfTheSameMultiEdge(u, v))
                return false;
            return this.IntersectAbove(u, v) || this.IntersectBelow(u, v);
        },
        UVAreMiddlesOfTheSameMultiEdge: function (u, v){
            if (this.database.get_MultipleMiddles().Contains$$T(u) && this.database.get_MultipleMiddles().Contains$$T(v) && this.SourceOfTheOriginalEdgeContainingAVirtualNode(u) == this.SourceOfTheOriginalEdgeContainingAVirtualNode(v))
                return true;
            return false;
        },
        SourceOfTheOriginalEdgeContainingAVirtualNode: function (u){
            while (this.IsVirtualVertex(u))
                u = this.IncomingEdge(u).get_Source();
            return u;
        },
        IntersectBelow: function (u, v){
            while (true){
                var eu = this.OutcomingEdge(u);
                var ev = this.OutcomingEdge(v);
                if (this.Intersect(eu, ev))
                    return true;
                u = eu.get_Target();
                v = ev.get_Target();
                if (!(this.IsVirtualVertex(u) && this.IsVirtualVertex(v))){
                    if (v == u)
                        return true;
                    return false;
                }
            }
        },
        IntersectAbove: function (u, v){
            while (true){
                var eu = this.IncomingEdge(u);
                var ev = this.IncomingEdge(v);
                if (this.Intersect(eu, ev))
                    return true;
                u = eu.get_Source();
                v = ev.get_Source();
                if (!(this.IsVirtualVertex(u) && this.IsVirtualVertex(v))){
                    if (u == v)
                        return true;
                    return false;
                }
            }
        },
        Intersect: function (e, m){
            var a = this.layerArrays.get_X()[e.get_Source()] - this.layerArrays.get_X()[m.get_Source()];
            var b = this.layerArrays.get_X()[e.get_Target()] - this.layerArrays.get_X()[m.get_Target()];
            return a > 0 && b < 0 || a < 0 && b > 0;
        },
        IncomingEdge: function (u){
            return this.layeredGraph.InEdgeOfVirtualNode(u);
        },
        OutcomingEdge: function (u){
            return this.layeredGraph.OutEdgeOfVirtualNode(u);
        },
        RightBoundaryNodesOfANode: function (i, nodeKind){
            return this.FillRightTopAndBottomVerts(this.NodeLayer(i), this.layerArrays.get_X()[i], nodeKind);
        },
        NodeLayer: function (i){
            return this.layerArrays.get_Layers()[this.layerArrays.Y[i]];
        },
        LeftBoundaryNodesOfANode: function (i, nodeKind){
            return this.FillLeftTopAndBottomVerts(this.NodeLayer(i), this.layerArrays.get_X()[i], nodeKind);
        },
        GetSpline: function (){
            this.CreateRefinedPolyline();
            return this.CreateSmoothedPolyline();
        },
        CreatePolyTest: function (){
            var c = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor();
            var e = new Microsoft.Msagl.Core.Geometry.PointNodesList.ctor$$Site(this.headSite);
            e.MoveNext();
            var p = e.get_Current();
            while (e.MoveNext()){
                Microsoft.Msagl.Core.Geometry.Curves.Curve.AddLineSegment$$Curve$$Point$$Point(c, p, e.get_Current());
                p = e.get_Current();
            }
            return c;
        },
        GetPolyline$$: "Microsoft.Msagl.Core.Geometry.SmoothedPolyline",
        get_GetPolyline: function (){
            System.Diagnostics.Debug.Assert$$Boolean(this.headSite != null);
            return new Microsoft.Msagl.Core.Geometry.SmoothedPolyline.ctor(this.headSite);
        },
        SegIntersectRightBound: function (a, b){
            return Microsoft.Msagl.Layout.Layered.SmoothedPolylineCalculator.SegIntersectsBound(a, b, this.leftHierarchy) || Microsoft.Msagl.Layout.Layered.SmoothedPolylineCalculator.SegIntersectsBound(a, b, this.thinLeftHierarchy);
        },
        SegIntersectLeftBound: function (a, b){
            return Microsoft.Msagl.Layout.Layered.SmoothedPolylineCalculator.SegIntersectsBound(a, b, this.rightHierarchy) || Microsoft.Msagl.Layout.Layered.SmoothedPolylineCalculator.SegIntersectsBound(a, b, this.thinRightHierarchy);
        },
        TryToRemoveInflectionEdge: function (s){
            if (s.Value.get_Next().get_Next() == null)
                return false;
            if (s.Value.get_Previous() == null)
                return false;
            if (s.Value.get_Turn() < 0){
                if (!this.SegIntersectRightBound(s.Value, s.Value.get_Next().get_Next()) && !this.SegIntersectLeftBound(s.Value, s.Value.get_Next().get_Next())){
                    var n = s.Value.get_Next().get_Next();
                    s.Value.set_Next(n);
                    n.set_Previous(s.Value);
                    s.Value = n;
                    return true;
                }
                if (!this.SegIntersectLeftBound(s.Value.get_Previous(), s.Value.get_Next()) && !this.SegIntersectRightBound(s.Value.get_Previous(), s.Value.get_Next())){
                    var a = s.Value.get_Previous();
                    var b = s.Value.get_Next();
                    a.set_Next(b);
                    b.set_Previous(a);
                    s.Value = b;
                    return true;
                }
            }
            else {
                if (!this.SegIntersectLeftBound(s.Value, s.Value.get_Next().get_Next()) && !this.SegIntersectRightBound(s.Value, s.Value.get_Next().get_Next())){
                    var n = s.Value.get_Next().get_Next();
                    s.Value.set_Next(n);
                    n.set_Previous(s.Value);
                    s.Value = n;
                    return true;
                }
                if (!this.SegIntersectRightBound(s.Value.get_Previous(), s.Value.get_Next()) && this.SegIntersectLeftBound(s.Value.get_Previous(), s.Value.get_Next())){
                    var a = s.Value.get_Previous();
                    var b = s.Value.get_Next();
                    a.set_Next(b);
                    b.set_Previous(a);
                    s.Value = b;
                    return true;
                }
            }
            return false;
        },
        Reverse: function (){
            var ret = new Microsoft.Msagl.Layout.Layered.SmoothedPolylineCalculator.ctor(this.edgePath, this.anchors, this.originalGraph, this.settings, this.layerArrays, this.layeredGraph, this.database);
            var site = this.headSite;
            var v = null;
            while (site != null){
                ret.headSite = site.Clone();
                ret.headSite.set_Next(v);
                if (v != null)
                    v.set_Previous(ret.headSite);
                v = ret.headSite;
                site = site.get_Next();
            }
            return ret;
        },
        CreateRefinedPolyline: function (){
            this.CreateInitialListOfSites();
            var topSite = this.headSite;
            var bottomSite;
            for (var i = 0; i < this.edgePath.get_Count(); i++){
                bottomSite = topSite.get_Next();
                this.RefineBeetweenNeighborLayers(topSite, this.EdgePathNode(i), this.EdgePathNode(i + 1));
                topSite = bottomSite;
            }
            this.TryToRemoveInflections();
        },
        RefineBeetweenNeighborLayers: function (topSite, topNode, bottomNode){
            Microsoft.Msagl.Layout.Layered.RefinerBetweenTwoLayers.Refine$$Int32$$Int32$$Site$$Anchor$Array$$LayerArrays$$ProperLayeredGraph$$GeometryGraph$$Double(topNode, bottomNode, topSite, this.anchors, this.layerArrays, this.layeredGraph, this.originalGraph, this.settings.get_LayerSeparation());
        },
        CreateInitialListOfSites: function (){
            var currentSite = this.headSite = new Microsoft.Msagl.Core.Geometry.Site.ctor$$Point(this.EdgePathPoint(0));
            for (var i = 1; i <= this.edgePath.get_Count(); i++)
                currentSite = new Microsoft.Msagl.Core.Geometry.Site.ctor$$Site$$Point(currentSite, this.EdgePathPoint(i));
        },
        TryToRemoveInflections: function (){
            if (this.TurningAlwaySameDirection())
                return;
            var progress = true;
            while (progress){
                progress = false;
                for (var s = this.headSite; s != null && s.get_Next() != null; s = s.get_Next()){
                    progress = (function (){
                        var $1 = {
                            Value: s
                        };
                        var $res = this.TryToRemoveInflectionEdge($1);
                        s = $1.Value;
                        return $res;
                    }).call(this) || progress;
                }
            }
        },
        TurningAlwaySameDirection: function (){
            var sign = 0;
            for (var s = this.headSite.get_Next(); s != null && s.get_Next() != null; s = s.get_Next()){
                var nsign = s.get_Turn();
                if (sign == 0){
                    if (nsign > 0)
                        sign = 1;
                    else if (nsign < 0)
                        sign = -1;
                }
                else {
                    if (sign * nsign < 0)
                        return false;
                }
            }
            return true;
        },
        EdgePathPoint: function (i){
            return this.anchors[this.EdgePathNode(i)].get_Origin();
        },
        EdgePathNode: function (i){
            var v;
            if (i == this.edgePath.get_Count())
                v = this.edgePath.get_Item$$Int32(this.edgePath.get_Count() - 1).get_Target();
            else
                v = this.edgePath.get_Item$$Int32(i).get_Source();
            return v;
        },
        CreateSmoothedPolyline: function (){
            this.RemoveVerticesWithNoTurns();
            var curve = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor();
            var a = this.headSite;
            var b;
            var c;
            if ((function (){
                var $1 = {
                    Value: b
                };
                var $2 = {
                    Value: c
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.FindCorner(a, $1, $2);
                b = $1.Value;
                c = $2.Value;
                return $res;
            }).call(this)){
                (function (){
                    var $1 = {
                        Value: a
                    };
                    var $2 = {
                        Value: b
                    };
                    var $3 = {
                        Value: c
                    };
                    var $res = this.CreateFilletCurve(curve, $1, $2, $3);
                    a = $1.Value;
                    b = $2.Value;
                    c = $3.Value;
                    return $res;
                }).call(this);
                curve = this.ExtendCurveToEndpoints(curve);
            }
            else
                curve.AddSegment(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(this.EdgePathPoint(0), this.EdgePathPoint(this.edgePath.get_Count())));
            return curve;
        },
        RemoveVerticesWithNoTurns: function (){
            while (this.RemoveVerticesWithNoTurnsOnePass())
                ;},
        RemoveVerticesWithNoTurnsOnePass: function (){
            var ret = false;
            for (var s = this.headSite; s.get_Next() != null && s.get_Next().get_Next() != null; s = s.get_Next())
                if (Microsoft.Msagl.Layout.Layered.SmoothedPolylineCalculator.Flat(s.get_Next())){
                    ret = true;
                    s.set_Next(s.get_Next().get_Next());
                    s.get_Next().set_Previous(s);
                }
            return ret;
        },
        ExtendCurveToEndpoints: function (curve){
            var p = this.EdgePathPoint(0);
            if (!Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(p, curve.get_Start())){
                var nc = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor();
                nc.AddSegs$$ICurve$$ICurve(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(p, curve.get_Start()), curve);
                curve = nc;
            }
            p = this.EdgePathPoint(this.edgePath.get_Count());
            if (!Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(p, curve.get_End()))
                curve.AddSegment(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(curve.get_End(), p));
            return curve;
        },
        CreateFilletCurve: function (curve, a, b, c){
            do{
                this.AddSmoothedCorner(a.Value, b.Value, c.Value, curve);
                a.Value = b.Value;
                b.Value = c.Value;
                if (b.Value.get_Next() != null)
                    c.Value = b.Value.get_Next();
                else
                    break;
            }
            while (true)
        },
        AddSmoothedCorner: function (a, b, c, curve){
            var k = 0.5;
            var seg;
            do{
                seg = Microsoft.Msagl.Core.Geometry.Curves.Curve.CreateBezierSeg$$Double$$Double$$Site$$Site$$Site(k, k, a, b, c);
                b.set_PreviousBezierSegmentFitCoefficient(k);
                k /= 2;
            }
            while (this.BezierSegIntersectsBoundary$$CubicBezierSegment(seg))
            k *= 2;
            if (k < 0.5){
                k = 0.5 * (k + k * 2);
                var nseg = Microsoft.Msagl.Core.Geometry.Curves.Curve.CreateBezierSeg$$Double$$Double$$Site$$Site$$Site(k, k, a, b, c);
                if (!this.BezierSegIntersectsBoundary$$CubicBezierSegment(nseg)){
                    b.set_PreviousBezierSegmentFitCoefficient((function ($p50){
                        b.set_NextBezierSegmentFitCoefficient($p50);
                        return $p50;
                    }).call(this, k));
                    seg = nseg;
                }
            }
            if (curve.get_Segments().get_Count() > 0 && !Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(curve.get_End(), seg.get_Start()))
                curve.AddSegment(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(curve.get_End(), seg.get_Start()));
            curve.AddSegment(seg);
        },
        BezierSegIntersectsBoundary$$CubicBezierSegment: function (seg){
            var side = Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(seg.B(0), seg.B(1), seg.B(2));
            if (side > 0)
                return this.BezierSegIntersectsTree(seg, this.thinLeftHierarchy) || this.BezierSegIntersectsTree(seg, this.leftHierarchy);
            else
                return this.BezierSegIntersectsTree(seg, this.thinRightHierarchy) || this.BezierSegIntersectsTree(seg, this.rightHierarchy);
        },
        BezierSegIntersectsTree: function (seg, tree){
            if (tree == null)
                return false;
            if (Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.Intersect(seg.get_ParallelogramNodeOverICurve().get_Parallelogram(), tree.get_Parallelogram())){
                var n = As(tree, Microsoft.Msagl.Core.Geometry.Curves.ParallelogramBinaryTreeNode.ctor);
                if (n != null){
                    return this.BezierSegIntersectsTree(seg, n.get_LeftSon()) || this.BezierSegIntersectsTree(seg, n.get_RightSon());
                }
                else
                    return Microsoft.Msagl.Layout.Layered.SmoothedPolylineCalculator.BezierSegIntersectsBoundary$$CubicBezierSegment$$ICurve(seg, (Cast(tree, Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.ctor)).get_Seg());
            }
            else
                return false;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$SmoothedPolylineCalculator);
var Microsoft$Msagl$Layout$Layered$TwoLayerFlatEdgeRouter = {
    fullname: "Microsoft.Msagl.Layout.Layered.TwoLayerFlatEdgeRouter",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        },
        CreatObstaceOnLabel: function (label){
            var c = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor();
            var obstacleBottom = label.get_Center().get_Y() - label.get_Height() / 4;
            c.AddSegment(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(label.get_BoundingBox().get_Left(), obstacleBottom), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(label.get_BoundingBox().get_Right(), obstacleBottom)));
            Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Point(c, label.get_BoundingBox().get_RightTop());
            Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Point(c, label.get_BoundingBox().get_LeftTop());
            Microsoft.Msagl.Core.Geometry.Curves.Curve.CloseCurve(c);
            return c;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (settings, routing, bottomLayer, topLayer){
            this.bottomLayer = null;
            this.interactiveEdgeRouter = null;
            this.labelCenters = null;
            this.labelsToLabelObstacles = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Label.ctor, Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor);
            this.pairArray = null;
            this.routing = null;
            this.topLayer = null;
            this.settings = null;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.settings = settings;
            this.topLayer = topLayer;
            this.bottomLayer = bottomLayer;
            this.routing = routing;
            this.InitLabelsInfo();
        },
        Database$$: "Microsoft.Msagl.Layout.Layered.Database",
        get_Database: function (){
            return this.routing.Database;
        },
        Layering$$: "System.Int32[]",
        get_Layering: function (){
            return this.routing.LayerArrays.Y;
        },
        IntGraph$$: "Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph`1[[Microsoft.Msagl.Layout.Layered.IntEdge]]",
        get_IntGraph: function (){
            return this.routing.IntGraph;
        },
        LayerArrays$$: "Microsoft.Msagl.Layout.Layered.LayerArrays",
        get_LayerArrays: function (){
            return this.routing.LayerArrays;
        },
        PaddingForEdges$$: "System.Double",
        get_PaddingForEdges: function (){
            return this.settings.get_LayerSeparation() / 8;
        },
        InitLabelsInfo: function (){
            this.pairArray = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, new Microsoft.Msagl.Core.DataStructures.Set$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(null, Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(null, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(null, System.Linq.Enumerable.SelectMany$3$$IEnumerable$1$$Func$2$$Func$3(System.Int32.ctor, Microsoft.Msagl.Layout.Layered.IntEdge.ctor, null, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(System.Int32.ctor, this.bottomLayer, $CreateAnonymousDelegate(this, function (v){
                return v < this.get_IntGraph().get_NodeCount();
            })), $CreateAnonymousDelegate(this, function (v){
                return this.get_IntGraph().OutEdges(v);
            }), $CreateAnonymousDelegate(this, function (v, edge){
                return $CreateAnonymousObject({
                    v: v,
                    edge: edge
                });
            })), $CreateAnonymousDelegate(this, function ($$x0){
                return $$x0.get_edge().get_Source() != $$x0.get_edge().get_Target();
            })), $CreateAnonymousDelegate(this, function ($$x1){
                return this.get_Layering()[$$x1.get_edge().get_Target()] == this.get_Layering()[$$x1.get_edge().get_Source()];
            })), $CreateAnonymousDelegate(this, function ($$x2){
                return new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor($$x2.get_edge().get_Source(), $$x2.get_edge().get_Target());
            }))));
            this.labelCenters = new Float64Array(this.pairArray.length);
            var i = 0;
            for (var $i1212 = 0,$t1212 = this.pairArray,$l1212 = $t1212.length,p = $t1212[$i1212]; $i1212 < $l1212; $i1212++, p = $t1212[$i1212]){
                var leftNode,rightNode;
                if (this.get_LayerArrays().get_X()[p.get_First()] < this.get_LayerArrays().get_X()[p.get_Second()]){
                    leftNode = p.get_First();
                    rightNode = p.get_Second();
                }
                else {
                    leftNode = p.get_Second();
                    rightNode = p.get_First();
                }
                this.labelCenters[i++] = (this.get_Database().get_Anchors()[leftNode].get_Right() + this.get_Database().get_Anchors()[rightNode].get_Left()) / 2;
            }
            this.InitLabelsToLabelObstacles();
        },
        InitLabelsToLabelObstacles: function (){
            this.labelsToLabelObstacles = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Layout.Label.ctor, Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor);
            var labels = System.Linq.Enumerable.SelectMany$3$$IEnumerable$1$$Func$2$$Func$3(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, Microsoft.Msagl.Core.Layout.Label.ctor, Microsoft.Msagl.Core.Layout.Label.ctor, this.pairArray, $CreateAnonymousDelegate(this, function (p){
                return this.PairLabels(p);
            }), $CreateAnonymousDelegate(this, function (p, label){
                return label;
            }));
            var $it1212 = labels.GetEnumerator();
            while ($it1212.MoveNext()){
                var label = $it1212.get_Current();
                this.labelsToLabelObstacles.set_Item$$TKey(label, Microsoft.Msagl.Layout.Layered.TwoLayerFlatEdgeRouter.CreatObstaceOnLabel(label));
            }
        },
        GetMaxLabelWidth: function (intPair){
            var multiEdgeLabels = this.PairLabels(intPair);
            if (System.Linq.Enumerable.Any$1$$IEnumerable$1(Microsoft.Msagl.Core.Layout.Label.ctor, multiEdgeLabels))
                return System.Linq.Enumerable.Max$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Layout.Label.ctor, multiEdgeLabels, $CreateAnonymousDelegate(this, function (label){
                    return label.get_Width();
                }));
            return 0;
        },
        PairLabels: function (intPair){
            return System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(null, Microsoft.Msagl.Core.Layout.Label.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(null, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Layout.Layered.IntEdge.ctor, null, this.get_Database().GetMultiedge$$IntPair(intPair), $CreateAnonymousDelegate(this, function (edge){
                return $CreateAnonymousObject({
                    edge: edge,
                    label: edge.get_Edge().get_Label()
                });
            })), $CreateAnonymousDelegate(this, function ($$x3){
                return $$x3.get_label() != null;
            })), $CreateAnonymousDelegate(this, function ($$x4){
                return $$x4.get_label();
            }));
        },
        RunInternal: function (){
            if (this.pairArray.length > 0){
                this.PositionLabelsOfFlatEdges();
                this.interactiveEdgeRouter = new Microsoft.Msagl.Routing.InteractiveEdgeRouter.ctor$$IEnumerable$1$ICurve$$Double$$Double$$Double(this.GetObstacles(), this.get_PaddingForEdges(), this.get_PaddingForEdges() / 3, 0.523598775598299);
                var $it1213 = this.IntEdges().GetEnumerator();
                while ($it1213.MoveNext()){
                    var intEdge = $it1213.get_Current();
                    this.ProgressStep();
                    this.RouteEdge(intEdge);
                }
            }
        },
        GetObstacles: function (){
            return System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor, (System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(System.Int32.ctor, Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(System.Int32.ctor, System.Linq.Enumerable.Concat$1(System.Int32.ctor, this.topLayer, this.bottomLayer), $CreateAnonymousDelegate(this, function (v){
                return v < this.routing.OriginalGraph.get_Nodes().get_Count();
            })), $CreateAnonymousDelegate(this, function (v){
                return this.routing.IntGraph.get_Nodes().get_Item$$Int32(v).get_BoundaryCurve();
            }))), this.LabelCurves());
        },
        LabelCurves: function (){
            return System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(null, Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(null, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Layout.Layered.IntEdge.ctor, null, this.IntEdges(), $CreateAnonymousDelegate(this, function (edge){
                return $CreateAnonymousObject({
                    edge: edge,
                    label: edge.get_Edge().get_Label()
                });
            })), $CreateAnonymousDelegate(this, function ($$x5){
                return $$x5.get_label() != null;
            })), $CreateAnonymousDelegate(this, function ($$x6){
                return Microsoft.Msagl.Layout.Layered.TwoLayerFlatEdgeRouter.CreatObstaceOnLabel($$x6.get_label());
            }));
        },
        IntEdges: function (){
            return System.Linq.Enumerable.SelectMany$3$$IEnumerable$1$$Func$2$$Func$3(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, Microsoft.Msagl.Layout.Layered.IntEdge.ctor, Microsoft.Msagl.Layout.Layered.IntEdge.ctor, this.pairArray, $CreateAnonymousDelegate(this, function (pair){
                return this.get_Database().GetMultiedge$$IntPair(pair);
            }), $CreateAnonymousDelegate(this, function (pair, edge){
                return edge;
            }));
        },
        RouteEdge: function (edge){
            if (edge.get_HasLabel())
                this.RouteEdgeWithLabel(edge, edge.get_Edge().get_Label());
            else
                this.RouteEdgeWithNoLabel(edge);
        },
        RouteEdgeWithLabel: function (intEdge, label){
            var sourceNode = this.routing.IntGraph.get_Nodes().get_Item$$Int32(intEdge.get_Source());
            var targetNode = this.routing.IntGraph.get_Nodes().get_Item$$Int32(intEdge.get_Target());
            var sourcePort = new Microsoft.Msagl.Core.Layout.FloatingPort.ctor(sourceNode.get_BoundaryCurve(), sourceNode.get_Center());
            var targetPort = new Microsoft.Msagl.Core.Layout.FloatingPort.ctor(targetNode.get_BoundaryCurve(), targetNode.get_Center());
            var labelObstacle = this.labelsToLabelObstacles.get_Item$$TKey(label);
            var labelPort = new Microsoft.Msagl.Core.Layout.FloatingPort.ctor(labelObstacle, label.get_Center());
            var poly0;
            (function (){
                var $1 = {
                    Value: poly0
                };
                var $res = this.interactiveEdgeRouter.RouteSplineFromPortToPortWhenTheWholeGraphIsReady(sourcePort, labelPort, true, $1);
                poly0 = $1.Value;
                return $res;
            }).call(this);
            var poly1;
            (function (){
                var $1 = {
                    Value: poly1
                };
                var $res = this.interactiveEdgeRouter.RouteSplineFromPortToPortWhenTheWholeGraphIsReady(labelPort, targetPort, true, $1);
                poly1 = $1.Value;
                return $res;
            }).call(this);
            var site = poly1.get_HeadSite().get_Next();
            var lastSite = poly0.get_LastSite();
            lastSite.set_Next(site);
            site.set_Previous(lastSite);
            var eg = intEdge.get_Edge().get_EdgeGeometry();
            eg.SetSmoothedPolylineAndCurve(poly0);
            Microsoft.Msagl.Core.Layout.Arrowheads.TrimSplineAndCalculateArrowheads$$EdgeGeometry$$ICurve$$ICurve$$ICurve$$Boolean$$Boolean(eg, intEdge.get_Edge().get_Source().get_BoundaryCurve(), intEdge.get_Edge().get_Target().get_BoundaryCurve(), eg.get_Curve(), false, this.settings.get_EdgeRoutingSettings().get_KeepOriginalSpline());
        },
        RouteEdgeWithNoLabel: function (intEdge){
            var sourceNode = this.routing.IntGraph.get_Nodes().get_Item$$Int32(intEdge.get_Source());
            var targetNode = this.routing.IntGraph.get_Nodes().get_Item$$Int32(intEdge.get_Target());
            var sourcePort = new Microsoft.Msagl.Core.Layout.FloatingPort.ctor(sourceNode.get_BoundaryCurve(), sourceNode.get_Center());
            var targetPort = new Microsoft.Msagl.Core.Layout.FloatingPort.ctor(targetNode.get_BoundaryCurve(), targetNode.get_Center());
            var eg = intEdge.get_Edge().get_EdgeGeometry();
            var sp;
            eg.set_Curve((function (){
                var $1 = {
                    Value: sp
                };
                var $res = this.interactiveEdgeRouter.RouteSplineFromPortToPortWhenTheWholeGraphIsReady(sourcePort, targetPort, true, $1);
                sp = $1.Value;
                return $res;
            }).call(this));
            Microsoft.Msagl.Core.Layout.Arrowheads.TrimSplineAndCalculateArrowheads$$EdgeGeometry$$ICurve$$ICurve$$ICurve$$Boolean$$Boolean(eg, intEdge.get_Edge().get_Source().get_BoundaryCurve(), intEdge.get_Edge().get_Target().get_BoundaryCurve(), eg.get_Curve(), false, this.settings.get_EdgeRoutingSettings().get_KeepOriginalSpline());
            intEdge.get_Edge().set_EdgeGeometry(eg);
        },
        PositionLabelsOfFlatEdges: function (){
            if (this.labelCenters == null || this.labelCenters.length == 0)
                return;
            this.SortLabelsByX();
            this.CalculateLabelsX();
        },
        CalculateLabelsX: function (){
            var i;
            var solver = Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.CreateSolver();
            for (i = 0; i < this.pairArray.length; i++)
                solver.AddVariableWithIdealPosition$$Int32$$Double$$Double(i, this.labelCenters[i], this.GetLabelWeight(this.pairArray[i]));
            var prevLabelWidth = this.GetMaxLabelWidth(this.pairArray[0]);
            for (i = 0; i < this.pairArray.length - 1; i++)
                solver.AddLeftRightSeparationConstraint$$Int32$$Int32$$Double(i, i + 1, (prevLabelWidth + (prevLabelWidth = this.GetMaxLabelWidth(this.pairArray[i + 1]))) / 2 + this.settings.get_NodeSeparation());
            for (i = 0; i < this.labelCenters.length; i++){
                var x = this.labelCenters[i] = solver.GetVariableResolvedPosition(i);
                var $it1214 = this.PairLabels(this.pairArray[i]).GetEnumerator();
                while ($it1214.MoveNext()){
                    var label = $it1214.get_Current();
                    label.set_Center(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x, label.get_Center().get_Y()));
                }
            }
        },
        GetLabelWeight: function (intPair){
            return this.get_Database().GetMultiedge$$IntPair(intPair).get_Count();
        },
        SortLabelsByX: function (){
            System.Array.Sort$2$$TKey$Array$$TValue$Array(System.Double.ctor, Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor, this.labelCenters, this.pairArray);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$TwoLayerFlatEdgeRouter);
var Microsoft$Msagl$DebugHelpers$DevTrace = {
    fullname: "Microsoft.Msagl.DebugHelpers.DevTrace",
    baseTypeName: "System.Object",
    staticDefinition: {
        Assert: function (condition, format, args){
            System.Diagnostics.Trace.Assert$$Boolean$$String(condition, System.String.Format$$String$$Object$Array(format, args));
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$DebugHelpers$DevTrace);
var Microsoft$Msagl$Routing$Spline$ConeSpanner$Cone = {
    fullname: "Microsoft.Msagl.Routing.Spline.ConeSpanner.Cone",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (apex, coneSweeper){
            this.removed = false;
            this.apex = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.coneSweeper = null;
            this.rightSide = null;
            this.leftSide = null;
            System.Object.ctor.call(this);
            this.apex = apex;
            this.coneSweeper = coneSweeper;
        },
        Removed$$: "System.Boolean",
        get_Removed: function (){
            return this.removed;
        },
        set_Removed: function (value){
            this.removed = value;
        },
        Apex$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Apex: function (){
            return this.apex;
        },
        set_Apex: function (value){
            this.apex = value;
        },
        RightSideDirection$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_RightSideDirection: function (){
            return this.coneSweeper.get_ConeRightSideDirection();
        },
        LeftSideDirection$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_LeftSideDirection: function (){
            return this.coneSweeper.get_ConeLeftSideDirection();
        },
        RightSide$$: "Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSide",
        get_RightSide: function (){
            return this.rightSide;
        },
        set_RightSide: function (value){
            this.rightSide = value;
            this.rightSide.set_Cone(this);
        },
        LeftSide$$: "Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSide",
        get_LeftSide: function (){
            return this.leftSide;
        },
        set_LeftSide: function (value){
            this.leftSide = value;
            this.leftSide.set_Cone(this);
        },
        PointIsInside: function (p){
            return Microsoft.Msagl.Core.Geometry.Point.PointToTheRightOfLineOrOnLine(p, this.get_Apex(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.get_Apex(), this.get_LeftSideDirection())) && Microsoft.Msagl.Core.Geometry.Point.PointToTheLeftOfLineOrOnLine(p, this.get_Apex(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.get_Apex(), this.get_RightSideDirection()));
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$ConeSpanner$Cone);
var Microsoft$Msagl$Routing$Spline$ConeSpanner$ConeClosureEvent = {
    fullname: "Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeClosureEvent",
    baseTypeName: "Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (site, cone){
            this.coneToClose = null;
            this.site = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent.ctor.call(this);
            this.site = site;
            this.coneToClose = cone;
        },
        ConeToClose$$: "Microsoft.Msagl.Routing.Spline.ConeSpanner.Cone",
        get_ConeToClose: function (){
            return this.coneToClose;
        },
        Site$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Site: function (){
            return this.site;
        },
        toString: function (){
            return "ConeClosureEvent " + this.site;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$ConeSpanner$ConeClosureEvent);
var Microsoft$Msagl$Routing$Spline$ConeSpanner$ConeLeftSide = {
    fullname: "Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeLeftSide",
    baseTypeName: "Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSide",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (cone){
            Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSide.ctor.call(this);
            this.set_Cone(cone);
        },
        Start$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Start: function (){
            return this.get_Cone().get_Apex();
        },
        Direction$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Direction: function (){
            return this.get_Cone().get_LeftSideDirection();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$ConeSpanner$ConeLeftSide);
var Microsoft$Msagl$Routing$Spline$ConeSpanner$ConeRightSide = {
    fullname: "Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeRightSide",
    baseTypeName: "Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSide",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (cone){
            Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSide.ctor.call(this);
            this.set_Cone(cone);
        },
        Start$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Start: function (){
            return this.get_Cone().get_Apex();
        },
        Direction$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Direction: function (){
            return this.get_Cone().get_RightSideDirection();
        },
        toString: function (){
            return "ConeRightSide " + this.get_Start() + " " + this.get_Direction();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$ConeSpanner$ConeRightSide);
var Microsoft$Msagl$Routing$Spline$ConeSpanner$ConeSpanner = {
    fullname: "Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSpanner",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        },
        GetTotalSteps: function (coneAngle){
            return ((((6.28318530717959 - coneAngle / 2) / coneAngle)) | 0) + 1;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor$$IEnumerable$1$Polyline$$VisibilityGraph: function (obstacles, visibilityGraph){
            this._obstacles = null;
            this._visibilityGraph = null;
            this.coneAngle = 0.523598775598299;
            this._bidirectional = false;
            this._Ports = null;
            this._BorderPolyline = null;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this._obstacles = Microsoft.Msagl.Routing.Visibility.VisibilityGraph.OrientHolesClockwise(obstacles);
            this._visibilityGraph = visibilityGraph;
        },
        ctor$$IEnumerable$1$Polyline$$VisibilityGraph$$Double$$Set$1$Point$$Polyline: function (obstacles, visibilityGraph, coneAngle, ports, borderPolyline){
            this._obstacles = null;
            this._visibilityGraph = null;
            this.coneAngle = 0.523598775598299;
            this._bidirectional = false;
            this._Ports = null;
            this._BorderPolyline = null;
            Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSpanner.ctor$$IEnumerable$1$Polyline$$VisibilityGraph.call(this, obstacles, visibilityGraph);
            System.Diagnostics.Debug.Assert$$Boolean(borderPolyline == null || System.Linq.Enumerable.All$1(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, obstacles, $CreateAnonymousDelegate(this, function (o){
                return Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveIsInsideOther(o, borderPolyline);
            })));
            System.Diagnostics.Debug.Assert$$Boolean(borderPolyline == null || System.Linq.Enumerable.All$1(Microsoft.Msagl.Core.Geometry.Point.ctor, ports, $CreateAnonymousDelegate(this, function (o){
                return Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(o, borderPolyline) == Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Inside;
            })));
            System.Diagnostics.Debug.Assert$$Boolean(coneAngle > 0.0349065850398866 && coneAngle <= 1.5707963267949);
            this.set_Ports(ports);
            this.set_BorderPolyline(borderPolyline);
            this.set_ConeAngle(coneAngle);
        },
        ConeAngle$$: "System.Double",
        get_ConeAngle: function (){
            return this.coneAngle;
        },
        set_ConeAngle: function (value){
            this.coneAngle = value;
        },
        Ports$$: "Microsoft.Msagl.Core.DataStructures.Set`1[[Microsoft.Msagl.Core.Geometry.Point]]",
        get_Ports: function (){
            return this._Ports;
        },
        set_Ports: function (value){
            this._Ports = value;
        },
        BorderPolyline$$: "Microsoft.Msagl.Core.Geometry.Curves.Polyline",
        get_BorderPolyline: function (){
            return this._BorderPolyline;
        },
        set_BorderPolyline: function (value){
            this._BorderPolyline = value;
        },
        Bidirectional$$: "System.Boolean",
        get_Bidirectional: function (){
            return this._bidirectional;
        },
        set_Bidirectional: function (value){
            this._bidirectional = value;
        },
        RunInternal: function (){
            var offset = 6.28318530717959 - this.coneAngle / 2;
            if (!this.get_Bidirectional()){
                var angle;
                for (var i = 0; (angle = this.coneAngle * i) <= offset; i++){
                    this.ProgressStep();
                    this.AddDirection(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(System.Math.Cos(angle), System.Math.Sin(angle)), this.get_BorderPolyline(), this._visibilityGraph);
                }
            }
            else
                this.HandleBideractionalCase();
        },
        HandleBideractionalCase: function (){
            var k = ((3.14159265358979 / this.coneAngle)) | 0;
            for (var i = 0; i < k; i++){
                var angle = i * this.coneAngle;
                var vg0 = new Microsoft.Msagl.Routing.Visibility.VisibilityGraph.ctor();
                this.AddDirection(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(System.Math.Cos(angle), System.Math.Sin(angle)), this.get_BorderPolyline(), vg0);
                var vg1 = new Microsoft.Msagl.Routing.Visibility.VisibilityGraph.ctor();
                this.AddDirection(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-System.Math.Cos(angle), -System.Math.Sin(angle)), this.get_BorderPolyline(), vg1);
                this.AddIntersectionOfBothDirectionSweepsToTheResult(vg0, vg1);
            }
        },
        AddIntersectionOfBothDirectionSweepsToTheResult: function (vg0, vg1){
            var $it1215 = vg0.get_Edges().GetEnumerator();
            while ($it1215.MoveNext()){
                var edge = $it1215.get_Current();
                if (vg1.FindEdge$$Point$$Point(edge.get_SourcePoint(), edge.get_TargetPoint()) != null)
                    this._visibilityGraph.AddEdge$$Point$$Point(edge.get_SourcePoint(), edge.get_TargetPoint());
            }
        },
        AddDirection: function (direction, borderPolyline, visibilityGraph){
            Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeper.Sweep(this._obstacles, direction, this.coneAngle, visibilityGraph, this.get_Ports(), borderPolyline);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$ConeSpanner$ConeSpanner);
var Microsoft$Msagl$Core$Geometry$Curves$ClosestPointOnCurve = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.ClosestPointOnCurve",
    baseTypeName: "System.Object",
    staticDefinition: {
        ClosestPoint: function (curve, a, hint, low, high){
            var numberOfIterationsMax = 5;
            var numberOfOverShootsMax = 5;
            var t = hint;
            var numberOfIteration = 0;
            var numberOfOvershoots = 0;
            var dt;
            var abort = false;
            do{
                var c = curve.get_Item$$Double(t);
                var ct = curve.Derivative(t);
                var ctt = curve.SecondDerivative(t);
                var secondDerivative = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(ct, ct) + Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(c, a)), ctt);
                if (System.Math.Abs$$Double(secondDerivative) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                    return t;
                dt = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(c, a)), ct) / secondDerivative;
                t -= dt;
                if (t > high + Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance()){
                    t = high;
                    numberOfOvershoots++;
                }
                else if (t < low - Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance()){
                    t = low;
                    numberOfOvershoots++;
                }
                numberOfIteration++;
            }
            while (System.Math.Abs$$Double(dt) > Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance() && !(abort = (numberOfIteration >= numberOfIterationsMax || numberOfOvershoots >= numberOfOverShootsMax)))
            if (abort && (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(curve.get_Item$$Double(hint), a)).get_Length() < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                t = hint;
            return t;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$ClosestPointOnCurve);
var Microsoft$Msagl$Core$Geometry$Curves$CubicBezierSegment = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment",
    baseTypeName: "System.Object",
    staticDefinition: {
        AdjustParamTo01: function (u){
            if (u.Value > 1)
                u.Value = 1;
            else if (u.Value < 0)
                u.Value = 0;
        },
        LengthOnControlPolygon: function (b0, b1, b2, b3){
            var innerCordLength = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b3, b0)).get_Length();
            var controlPointPolygonLength = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b1, b0)).get_Length() + (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b2, b1)).get_Length() + (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b3, b2)).get_Length();
            if (controlPointPolygonLength - innerCordLength > Microsoft.Msagl.Core.Geometry.Curves.Curve.get_LineSegmentThreshold()){
                var mb0 = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Addition(b0, b1)), 2);
                var mb1 = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Addition(b1, b2)), 2);
                var mb2 = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Addition(b2, b3)), 2);
                var mmb0 = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Addition(mb0, mb1)), 2);
                var mmb1 = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Addition(mb2, mb1)), 2);
                var mmmb0 = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Addition(mmb0, mmb1)), 2);
                return Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.LengthOnControlPolygon(b0, mb0, mmb0, mmmb0) + Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.LengthOnControlPolygon(mmmb0, mmb1, mb2, b3);
            }
            return (controlPointPolygonLength + innerCordLength) / 2;
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Core.Geometry.Curves.ICurve"],
    Kind: "Class",
    definition: {
        ctor: function (b0, b1, b2, b3){
            this.b = new Array(4);
            this.l = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.e = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.c = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.pBoxNode = null;
            this.parStart = 0;
            this.parEnd = 1;
            System.Object.ctor.call(this);
            this.b[0] = b0;
            this.b[1] = b1;
            this.b[2] = b2;
            this.b[3] = b3;
            this.c = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(3, (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.b[1], this.b[0])));
            this.e = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(3, (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.b[2], this.b[1]))), this.c);
            this.l = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.b[3], this.b[0]), this.c), this.e);
        },
        LeftDerivative: function (t){
            return this.Derivative(t);
        },
        RightDerivative: function (t){
            return this.Derivative(t);
        },
        B: function (controlPointIndex){
            return this.b[controlPointIndex];
        },
        toString: function (){
            return System.String.Format$$IFormatProvider$$String$$Object$Array(System.Globalization.CultureInfo.get_InvariantCulture(), "(Bezie{0},{1},{2},{3})", [this.b[0], this.b[1], this.b[2], this.b[3]]);
        },
        ParallelogramNodeOverICurve$$: "Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve",
        get_ParallelogramNodeOverICurve: function (){
            if (this.pBoxNode != null)
                return this.pBoxNode;
            return this.pBoxNode = Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.CreateParallelogramNodeForCurveSegment(this);
        },
        Item$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Item$$Double: function (t){
            var t2 = t * t;
            var t3 = t2 * t;
            return Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(this.l, t3), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(this.e, t2)), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(this.c, t)), this.b[0]);
        },
        Trim: function (u, v){
            (function (){
                var $1 = {
                    Value: u
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.AdjustParamTo01($1);
                u = $1.Value;
                return $res;
            }).call(this);
            (function (){
                var $1 = {
                    Value: v
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.AdjustParamTo01($1);
                v = $1.Value;
                return $res;
            }).call(this);
            if (u > v)
                return this.Trim(v, u);
            if (u > 1 - Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                return new Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ctor(this.b[3], this.b[3], this.b[3], this.b[3]);
            var b1 = new Array(3);
            var b2 = new Array(2);
            var pv = this.Casteljau(u, b1, b2);
            var trimByU = new Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ctor(pv, b2[1], b1[2], this.b[3]);
            var pu = trimByU.Casteljau((v - u) / (1 - u), b1, b2);
            return new Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ctor(trimByU.b[0], b1[0], b2[0], pu);
        },
        TrimWithWrap: function (start, end){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        Casteljau: function (t, b1, b2){
            var f = 1 - t;
            for (var i = 0; i < 3; i++)
                b1[i] = Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(this.b[i], f), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(this.b[i + 1], t));
            for (var i = 0; i < 2; i++)
                b2[i] = Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(b1[i], f), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(b1[i + 1], t));
            return Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(b2[0], f), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(b2[1], t));
        },
        Derivative: function (t){
            return Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(3, this.l), t), t), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(2, this.e), t)), this.c);
        },
        SecondDerivative: function (t){
            return Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(6, this.l), t), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(2, this.e));
        },
        ThirdDerivative: function (t){
            return Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(6, this.l);
        },
        Start$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Start: function (){
            return this.b[0];
        },
        End$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_End: function (){
            return this.b[3];
        },
        ParStart$$: "System.Double",
        get_ParStart: function (){
            return this.parStart;
        },
        set_ParStart: function (value){
            this.parStart = value;
        },
        ParEnd$$: "System.Double",
        get_ParEnd: function (){
            return this.parEnd;
        },
        set_ParEnd: function (value){
            this.parEnd = value;
        },
        Reverse: function (){
            return new Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ctor(this.b[3], this.b[2], this.b[1], this.b[0]);
        },
        Translate: function (delta){
            this.b[0] = Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.b[0], delta);
            this.b[1] = Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.b[1], delta);
            this.b[2] = Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.b[2], delta);
            this.b[3] = Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.b[3], delta);
            this.c = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(3, (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.b[1], this.b[0])));
            this.e = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(3, (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.b[2], this.b[1]))), this.c);
            this.l = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.b[3], this.b[0]), this.c), this.e);
            this.pBoxNode = null;
        },
        ScaleFromOrigin: function (xScale, yScale){
            return new Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ctor(Microsoft.Msagl.Core.Geometry.Point.Scale(xScale, yScale, this.b[0]), Microsoft.Msagl.Core.Geometry.Point.Scale(xScale, yScale, this.b[1]), Microsoft.Msagl.Core.Geometry.Point.Scale(xScale, yScale, this.b[2]), Microsoft.Msagl.Core.Geometry.Point.Scale(xScale, yScale, this.b[3]));
        },
        OffsetCurve: function (offset, dir){
            return null;
        },
        LengthPartial: function (start, end){
            return this.Trim(start, end).get_Length();
        },
        Length$$: "System.Double",
        get_Length: function (){
            return Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.LengthOnControlPolygon(this.b[0], this.b[1], this.b[2], this.b[3]);
        },
        BoundingBox$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_BoundingBox: function (){
            var ret = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(this.b[0], this.b[1]);
            ret.Add$$Point(this.b[2]);
            ret.Add$$Point(this.b[3]);
            return ret;
        },
        Transform: function (transformation){
            return new Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ctor(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(transformation, this.b[0]), Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(transformation, this.b[1]), Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(transformation, this.b[2]), Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(transformation, this.b[3]));
        },
        ClosestParameterWithinBounds: function (targetPoint, low, high){
            System.Diagnostics.Debug.Assert$$Boolean(high <= 1 && low >= 0);
            System.Diagnostics.Debug.Assert$$Boolean(low <= high);
            var t = (high - low) / 8;
            var closest = 0;
            var minDist = 1.79769313486232E+308;
            for (var i = 0; i < 9; i++){
                var p = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(targetPoint, this.get_Item$$Double(i * t + low));
                var d = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(p, p);
                if (d < minDist){
                    minDist = d;
                    closest = i * t + low;
                }
            }
            return Microsoft.Msagl.Core.Geometry.Curves.ClosestPointOnCurve.ClosestPoint(this, targetPoint, closest, low, high);
        },
        Clone: function (){
            return new Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ctor(this.b[0], this.b[1], this.b[2], this.b[3]);
        },
        Curvature: function (t){
            System.Diagnostics.Debug.Assert$$Boolean(t >= this.get_ParStart() && t <= this.get_ParEnd());
            var den = this.G(t);
            System.Diagnostics.Debug.Assert$$Boolean(System.Math.Abs$$Double(den) > 1E-05);
            return this.F(t) / den;
        },
        F: function (t){
            return this.Xp(t) * this.Ypp(t) - this.Yp(t) * this.Xpp(t);
        },
        G: function (t){
            var xp = this.Xp(t);
            var yp = this.Yp(t);
            var den = (xp * xp + yp * yp);
            return System.Math.Sqrt(den * den * den);
        },
        Xp: function (t){
            return 3 * this.l.get_X() * t * t + 2 * this.e.get_X() * t + this.c.get_X();
        },
        Ypp: function (t){
            return 6 * this.l.get_Y() * t + 2 * this.e.get_Y();
        },
        Yp: function (t){
            return 3 * this.l.get_Y() * t * t + 2 * this.e.get_Y() * t + this.c.get_Y();
        },
        Xpp: function (t){
            return 6 * this.l.get_X() * t + 2 * this.e.get_X();
        },
        Xppp: function (t){
            return 6 * this.l.get_X();
        },
        Yppp: function (t){
            return 6 * this.l.get_Y();
        },
        CurvatureDerivative: function (t){
            var h = this.G(t);
            return (this.Fp(t) * h - this.Gp(t) * this.F(t)) / (h * h);
        },
        Fp: function (t){
            return this.Xp(t) * this.Yppp(t) - this.Yp(t) * this.Xppp(t);
        },
        Fpp: function (t){
            return this.Xpp(t) * this.Yppp(t) - this.Ypp(t) * this.Xppp(t);
        },
        ClosestParameter: function (targetPoint){
            var t = 0.125;
            var closest = 0;
            var minDist = 1.79769313486232E+308;
            for (var i = 0; i < 9; i++){
                var p = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(targetPoint, this.get_Item$$Double(i * t));
                var d = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(p, p);
                if (d < minDist){
                    minDist = d;
                    closest = i * t;
                }
            }
            return Microsoft.Msagl.Core.Geometry.Curves.ClosestPointOnCurve.ClosestPoint(this, targetPoint, closest, 0, 1);
        },
        MaximalCurvaturePoints$$: "System.Collections.Generic.IEnumerable`1[[System.Tuple`2[[System.Double],[System.Double]]]]",
        get_MaximalCurvaturePoints: function (){
            var maxCurveCandidates = new System.Collections.Generic.List$1.ctor(System.Tuple$2.ctor);
            var n = 8;
            var d = 1 / n;
            var prev = -1;
            for (var i = 0; i < n; i++){
                var start = i * d;
                var end = start + d;
                var x;
                if ((function (){
                    var $1 = {
                        Value: x
                    };
                    var $res = Microsoft.Msagl.Core.Geometry.Curves.RootFinder.TryToFindRoot(new Microsoft.Msagl.Core.Geometry.Curves.CurvatureDerivative.ctor(this, start, end), start, end, (start + end) / 2, $1);
                    x = $1.Value;
                    return $res;
                }).call(this)){
                    if (x != prev){
                        prev = x;
                        maxCurveCandidates.Add(new System.Tuple$2.ctor(System.Double.ctor, System.Double.ctor, x, this.Curvature(x)));
                    }
                }
            }
            maxCurveCandidates.Add(new System.Tuple$2.ctor(System.Double.ctor, System.Double.ctor, this.get_ParStart(), this.Curvature(this.get_ParStart())));
            maxCurveCandidates.Add(new System.Tuple$2.ctor(System.Double.ctor, System.Double.ctor, this.get_ParEnd(), this.Curvature(this.get_ParEnd())));
            var maxCur = System.Linq.Enumerable.Max$1$$IEnumerable$1$$Func$2(System.Tuple$2.ctor, maxCurveCandidates, $CreateAnonymousDelegate(this, function (l){
                return System.Math.Abs$$Double(l.get_Item2());
            }));
            return System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(System.Tuple$2.ctor, maxCurveCandidates, $CreateAnonymousDelegate(this, function (v){
                return System.Math.Abs$$Double(v.get_Item2()) == maxCur;
            }));
        },
        CurvatureSecondDerivative: function (t){
            var g = this.G(t);
            return (this.Qp(t) * g - 2 * this.Q(t) * this.Gp(t)) / (g * g * g);
        },
        Q: function (t){
            return this.Fp(t) * this.G(t) - this.Gp(t) * this.F(t);
        },
        Qp: function (t){
            return this.Fpp(t) * this.G(t) - this.Gpp(t) * this.F(t);
        },
        Gpp: function (t){
            var xp = this.Xp(t);
            var yp = this.Yp(t);
            var xpp = this.Xpp(t);
            var ypp = this.Ypp(t);
            var xppp = this.Xppp(t);
            var yppp = this.Yppp(t);
            var u = System.Math.Sqrt(xp * xp + yp * yp);
            var v = xp * xpp + yp * ypp;
            return 3 * ((v * v) / u + u * (xpp * xpp + xp * xppp + ypp * ypp + yp * yppp));
        },
        Gp: function (t){
            var xp = this.Xp(t);
            var yp = this.Yp(t);
            var xpp = this.Xpp(t);
            var ypp = this.Ypp(t);
            return 3 * System.Math.Sqrt(xp * xp + yp * yp) * (xp * xpp + yp * ypp);
        },
        GetParameterAtLength: function (length){
            var low = 0;
            var upper = 1;
            while (upper - low > Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance()){
                var middle = (upper + low) / 2;
                var err = this.EvaluateError(length, middle);
                if (err > 0)
                    upper = middle;
                else if (err < 0)
                    low = middle;
                else
                    return middle;
            }
            return (low + upper) / 2;
        },
        EvaluateError: function (length, t){
            var f = 1 - t;
            var mb0 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(f, this.b[0]), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(t, this.b[1]));
            var mb1 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(f, this.b[1]), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(t, this.b[2]));
            var mb2 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(f, this.b[2]), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(t, this.b[3]));
            var mmb0 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(f, mb0), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(t, mb1));
            var mmb1 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(f, mb1), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(t, mb2));
            var mmmb0 = Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(f, mmb0), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(t, mmb1));
            var lengthAtT = Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.LengthOnControlPolygon(this.b[0], mb0, mmb0, mmmb0);
            if (lengthAtT > length + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return 1;
            if (lengthAtT < length - Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return -1;
            return 0;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$CubicBezierSegment);
var Microsoft$Msagl$Core$Geometry$Curves$CurvatureDerivative = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.CurvatureDerivative",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Core.Geometry.Curves.IFunction"],
    Kind: "Class",
    definition: {
        ctor: function (curve, start, end){
            this.curve = null;
            this.start = 0;
            this.end = 0;
            System.Object.ctor.call(this);
            this.curve = curve;
            this.start = start;
            this.end = end;
        },
        Item$$: "System.Double",
        get_Item$$Double: function (t){
            return this.curve.CurvatureDerivative(t);
        },
        Derivative: function (t){
            return this.curve.CurvatureSecondDerivative(t);
        },
        SecondDerivative: function (t){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        ThirdDerivative: function (t){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        ParStart$$: "System.Double",
        get_ParStart: function (){
            return this.start;
        },
        ParEnd$$: "System.Double",
        get_ParEnd: function (){
            return this.end;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$CurvatureDerivative);
var Microsoft$Msagl$Core$Geometry$Curves$Curve = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.Curve",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Core.Geometry.Curves.Curve.lineSegThreshold = 0.05;
        },
        IsCloseToLineSeg: function (a, ap, b, bp, s, e){
            var x = 0.333333333333333;
            var p = a * x + b * (0.666666666666667);
            var delta = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(s.get_Item$$Double(p), (Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(ap.Value, x), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(bp.Value, (0.666666666666667)))));
            if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(delta, delta) > e)
                return false;
            p = a * (0.666666666666667) + b * x;
            delta = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(s.get_Item$$Double(p), (Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(ap.Value, (0.666666666666667)), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(bp.Value, x))));
            if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(delta, delta) > e)
                return false;
            p = a * 0.5 + b * 0.5;
            delta = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(s.get_Item$$Double(p), (Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(ap.Value, 0.5), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(bp.Value, 0.5))));
            if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(delta, delta) > e)
                return false;
            return true;
        },
        Interpolate$$Double$$Point$$Double$$Point$$ICurve$$Double: function (a, ap, b, bp, s, eps){
            var r = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor);
            if (Microsoft.Msagl.Core.Geometry.Curves.Curve.IsCloseToLineSeg(a, ap, b, bp, s, eps))
                r.Add(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(ap.Value, bp.Value));
            else {
                var m = 0.5 * (a + b);
                var mp = s.get_Item$$Double(m);
                r.AddRange((function (){
                    var $1 = {
                        Value: mp
                    };
                    var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.Interpolate$$Double$$Point$$Double$$Point$$ICurve$$Double(a, ap, m, $1, s, eps);
                    mp = $1.Value;
                    return $res;
                })());
                r.AddRange((function (){
                    var $1 = {
                        Value: mp
                    };
                    var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.Interpolate$$Double$$Point$$Double$$Point$$ICurve$$Double(m, $1, b, bp, s, eps);
                    mp = $1.Value;
                    return $res;
                })());
            }
            return r;
        },
        Interpolate$$Double$$Double$$Point$$Double$$Point$$ICurve: function (eps, a, ap, b, bp, s){
            var m = (a + b) / 2;
            var mp = s.get_Item$$Double(m);
            var ret = (function (){
                var $1 = {
                    Value: mp
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.Interpolate$$Double$$Point$$Double$$Point$$ICurve$$Double(a, ap, m, $1, s, eps * eps);
                mp = $1.Value;
                return $res;
            })();
            ret.AddRange((function (){
                var $1 = {
                    Value: mp
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.Interpolate$$Double$$Point$$Double$$Point$$ICurve$$Double(m, $1, b, bp, s, eps * eps);
                mp = $1.Value;
                return $res;
            })());
            return ret;
        },
        Interpolate$$ICurve$$Double: function (s, eps){
            var start = s.get_Start();
            var end = s.get_End();
            return (function (){
                var $1 = {
                    Value: start
                };
                var $2 = {
                    Value: end
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.Interpolate$$Double$$Double$$Point$$Double$$Point$$ICurve(eps, s.get_ParStart(), $1, s.get_ParEnd(), $2, s);
                start = $1.Value;
                end = $2.Value;
                return $res;
            })();
        },
        CurveCurveIntersectionOne: function (curve0, curve1, liftIntersection){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(curve0, "curve0");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(curve1, "curve1");
            System.Diagnostics.Debug.Assert$$Boolean$$String(curve0 != curve1, "curve0 == curve1");
            var ret = Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveXWithParallelogramNodesOne(curve0.get_ParallelogramNodeOverICurve(), curve1.get_ParallelogramNodeOverICurve());
            if (liftIntersection && ret != null)
                ret = Microsoft.Msagl.Core.Geometry.Curves.Curve.LiftIntersectionToCurves$$ICurve$$ICurve$$IntersectionInfo(curve0, curve1, ret);
            return ret;
        },
        GetAllIntersections: function (curve0, curve1, liftIntersections){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(curve0, "curve0");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(curve1, "curve1");
            System.Diagnostics.Debug.Assert$$Boolean(curve0 != curve1);
            var lineSeg = As(curve0, Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor);
            if (lineSeg != null)
                return Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersectionsOfLineAndICurve(lineSeg, curve1, liftIntersections);
            return Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersectionsInternal(curve0, curve1, liftIntersections);
        },
        GetAllIntersectionsInternal: function (curve0, curve1, liftIntersections){
            var intersections = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.ctor);
            (function (){
                var $1 = {
                    Value: intersections
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveXWithParallelogramNodes(curve0.get_ParallelogramNodeOverICurve(), curve1.get_ParallelogramNodeOverICurve(), $1);
                intersections = $1.Value;
                return $res;
            })();
            if (liftIntersections)
                for (var i = 0; i < intersections.get_Count(); i++)
                    intersections.set_Item$$Int32(i, Microsoft.Msagl.Core.Geometry.Curves.Curve.LiftIntersectionToCurves$$ICurve$$ICurve$$IntersectionInfo(curve0, curve1, intersections.get_Item$$Int32(i)));
            return intersections;
        },
        GetAllIntersectionsOfLineAndICurve: function (lineSeg, iCurve, liftIntersections){
            var poly = As(iCurve, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            if (poly != null)
                return Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersectionsOfLineAndPolyline(lineSeg, poly);
            var curve = As(iCurve, Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor);
            if (curve != null)
                return Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersectionsOfLineAndCurve(lineSeg, curve, liftIntersections);
            var roundedRect = As(iCurve, Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.ctor);
            if (roundedRect != null)
                return Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersectionsOfLineAndRoundedRect(lineSeg, roundedRect, liftIntersections);
            var ellipse = As(iCurve, Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor);
            if (ellipse != null && ellipse.IsArc())
                return Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersectionsOfLineAndArc(lineSeg, ellipse);
            return Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersectionsInternal(lineSeg, iCurve, liftIntersections);
        },
        GetAllIntersectionsOfLineAndRoundedRect: function (lineSeg, roundedRect, liftIntersections){
            var ret = Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersectionsOfLineAndCurve(lineSeg, roundedRect.get_Curve(), liftIntersections);
            if (liftIntersections){
                var $it1219 = ret.GetEnumerator();
                while ($it1219.MoveNext()){
                    var intersectionInfo = $it1219.get_Current();
                    intersectionInfo.set_Segment1(roundedRect);
                }
            }
            return ret;
        },
        GetAllIntersectionsOfLineAndCurve: function (lineSeg, curve, liftIntersections){
            var ret = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.ctor);
            var lineParallelogram = lineSeg.get_ParallelogramNodeOverICurve();
            var curveParallelogramRoot = curve.get_ParallelogramNodeOverICurve();
            if (Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.Intersect(lineParallelogram.get_Parallelogram(), curveParallelogramRoot.get_Parallelogram()) == false)
                return ret;
            var parOffset = 0;
            var $it1220 = curve.get_Segments().GetEnumerator();
            while ($it1220.MoveNext()){
                var seg = $it1220.get_Current();
                var iiList = Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(lineSeg, seg, false);
                if (liftIntersections){
                    var $it1221 = iiList.GetEnumerator();
                    while ($it1221.MoveNext()){
                        var intersectionInfo = $it1221.get_Current();
                        intersectionInfo.set_Par1(intersectionInfo.get_Par1() + parOffset - seg.get_ParStart());
                        intersectionInfo.set_Segment1(curve);
                    }
                    parOffset += seg.get_ParEnd() - seg.get_ParStart();
                }
                var $it1222 = iiList.GetEnumerator();
                while ($it1222.MoveNext()){
                    var intersectionInfo = $it1222.get_Current();
                    if (!Microsoft.Msagl.Core.Geometry.Curves.Curve.AlreadyInside(ret, intersectionInfo))
                        ret.Add(intersectionInfo);
                }
            }
            return ret;
        },
        AlreadyInside: function (ret, intersectionInfo){
            for (var i = 0; i < ret.get_Count(); i++){
                var ii = ret.get_Item$$Int32(i);
                if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.CloseIntersections(ii.get_IntersectionPoint(), intersectionInfo.get_IntersectionPoint()))
                    return true;
            }
            return false;
        },
        GetAllIntersectionsOfLineAndArc: function (lineSeg, ellipse){
            var lineDir = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(lineSeg.get_End(), lineSeg.get_Start());
            var ret = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.ctor);
            var segLength = lineDir.get_Length();
            if (segLength < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(lineSeg.get_Start(), ellipse.get_Center())).get_Length(), ellipse.get_AxisA().get_Length())){
                    var angle = Microsoft.Msagl.Core.Geometry.Point.Angle$$Point$$Point(ellipse.get_AxisA(), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(lineSeg.get_Start(), ellipse.get_Center()));
                    if (ellipse.get_ParStart() - Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance() <= angle){
                        angle = System.Math.Max$$Double$$Double(angle, ellipse.get_ParStart());
                        if (angle <= ellipse.get_ParEnd() + Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance()){
                            angle = System.Math.Min$$Double$$Double(ellipse.get_ParEnd(), angle);
                            ret.Add(new Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.ctor(0, angle, lineSeg.get_Start(), lineSeg, ellipse));
                        }
                    }
                }
                return ret;
            }
            var perp = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(lineDir.Rotate90Ccw(), segLength);
            var segProjection = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(lineSeg.get_Start(), ellipse.get_Center())), perp);
            var closestPointOnLine = Microsoft.Msagl.Core.Geometry.Point.op_Addition(ellipse.get_Center(), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(perp, segProjection));
            var rad = ellipse.get_AxisA().get_Length();
            var absSegProj = System.Math.Abs$$Double(segProjection);
            if (rad < absSegProj - Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return ret;
            lineDir = perp.Rotate90Cw();
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(rad, absSegProj))
                Microsoft.Msagl.Core.Geometry.Curves.Curve.TryToAddPointToLineCircleCrossing(lineSeg, ellipse, ret, closestPointOnLine, segLength, lineDir);
            else {
                System.Diagnostics.Debug.Assert$$Boolean(rad > absSegProj);
                var otherLeg = System.Math.Sqrt(rad * rad - segProjection * segProjection);
                Microsoft.Msagl.Core.Geometry.Curves.Curve.TryToAddPointToLineCircleCrossing(lineSeg, ellipse, ret, Microsoft.Msagl.Core.Geometry.Point.op_Addition(closestPointOnLine, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(otherLeg, lineDir)), segLength, lineDir);
                Microsoft.Msagl.Core.Geometry.Curves.Curve.TryToAddPointToLineCircleCrossing(lineSeg, ellipse, ret, Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(closestPointOnLine, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(otherLeg, lineDir)), segLength, lineDir);
            }
            return ret;
        },
        TryToAddPointToLineCircleCrossing: function (lineSeg, ellipse, ret, point, segLength, lineDir){
            var ds = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(point, lineSeg.get_Start());
            var de = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(point, lineSeg.get_End());
            var t = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(ds, lineDir);
            if (t < -Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return;
            t = System.Math.Max$$Double$$Double(t, 0);
            if (t > segLength + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return;
            t = System.Math.Min$$Double$$Double(t, segLength);
            t /= segLength;
            var angle = Microsoft.Msagl.Core.Geometry.Point.Angle$$Point$$Point(ellipse.get_AxisA(), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(point, ellipse.get_Center()));
            if (ellipse.get_ParStart() - Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance() <= angle){
                angle = System.Math.Max$$Double$$Double(angle, ellipse.get_ParStart());
                if (angle <= ellipse.get_ParEnd() + Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance()){
                    angle = System.Math.Min$$Double$$Double(ellipse.get_ParEnd(), angle);
                    ret.Add(new Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.ctor(t, angle, point, lineSeg, ellipse));
                }
            }
        },
        GetAllIntersectionsOfLineAndPolyline: function (lineSeg, poly){
            var ret = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.ctor);
            var offset = 0;
            var par0,par1;
            var x;
            var polyPoint = poly.get_StartPoint();
            for (; polyPoint != null && polyPoint.get_Next() != null; polyPoint = polyPoint.get_Next()){
                if ((function (){
                    var $1 = {
                        Value: par0
                    };
                    var $2 = {
                        Value: par1
                    };
                    var $3 = {
                        Value: x
                    };
                    var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.CrossTwoLineSegs(lineSeg.get_Start(), lineSeg.get_End(), polyPoint.get_Point(), polyPoint.get_Next().get_Point(), 0, 1, 0, 1, $1, $2, $3);
                    par0 = $1.Value;
                    par1 = $2.Value;
                    x = $3.Value;
                    return $res;
                })()){
                    (function (){
                        var $1 = {
                            Value: par0
                        };
                        var $2 = {
                            Value: par1
                        };
                        var $3 = {
                            Value: x
                        };
                        var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.AdjustSolution(lineSeg.get_Start(), lineSeg.get_End(), polyPoint.get_Point(), polyPoint.get_Next().get_Point(), $1, $2, $3);
                        par0 = $1.Value;
                        par1 = $2.Value;
                        x = $3.Value;
                        return $res;
                    })();
                    if (!(function (){
                        var $1 = {
                            Value: x
                        };
                        var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.OldIntersection(ret, $1);
                        x = $1.Value;
                        return $res;
                    })())
                        ret.Add(new Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.ctor(par0, offset + par1, x, lineSeg, poly));
                }
                offset++;
            }
            if (poly.get_Closed())if ((function (){
                var $1 = {
                    Value: par0
                };
                var $2 = {
                    Value: par1
                };
                var $3 = {
                    Value: x
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.CrossTwoLineSegs(lineSeg.get_Start(), lineSeg.get_End(), polyPoint.get_Point(), poly.get_Start(), 0, 1, 0, 1, $1, $2, $3);
                par0 = $1.Value;
                par1 = $2.Value;
                x = $3.Value;
                return $res;
            })()){
                (function (){
                    var $1 = {
                        Value: par0
                    };
                    var $2 = {
                        Value: par1
                    };
                    var $3 = {
                        Value: x
                    };
                    var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.AdjustSolution(lineSeg.get_Start(), lineSeg.get_End(), polyPoint.get_Point(), poly.get_Start(), $1, $2, $3);
                    par0 = $1.Value;
                    par1 = $2.Value;
                    x = $3.Value;
                    return $res;
                })();
                if (!(function (){
                    var $1 = {
                        Value: x
                    };
                    var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.OldIntersection(ret, $1);
                    x = $1.Value;
                    return $res;
                })())
                    ret.Add(new Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.ctor(par0, offset + par1, x, lineSeg, poly));
            }
            return ret;
        },
        AdjustSolution: function (aStart, aEnd, bStart, bEnd, par0, par1, x){
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.CloseIntersections(x.Value, aStart)){
                x.Value = aStart;
                par0.Value = 0;
            }
            else if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.CloseIntersections(x.Value, aEnd)){
                x.Value = aEnd;
                par0.Value = 1;
            }
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.CloseIntersections(x.Value, bStart)){
                x.Value = bStart;
                par1.Value = System.Math.Floor$$Double(par1.Value);
            }
            else if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.CloseIntersections(x.Value, bEnd)){
                x.Value = bEnd;
                par1.Value = System.Math.Ceiling$$Double(par1.Value);
            }
        },
        CurveCurveXWithParallelogramNodesOne: function (n0, n1){
            if (!Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.Intersect(n0.get_Parallelogram(), n1.get_Parallelogram()))
                return null;
            var n0Pb = As(n0, Microsoft.Msagl.Core.Geometry.Curves.ParallelogramInternalTreeNode.ctor);
            var n1Pb = As(n1, Microsoft.Msagl.Core.Geometry.Curves.ParallelogramInternalTreeNode.ctor);
            if (n0Pb != null && n1Pb != null){
                var $it1223 = n0Pb.get_Children().GetEnumerator();
                while ($it1223.MoveNext()){
                    var n00 = $it1223.get_Current();
                    var $it1224 = n1Pb.get_Children().GetEnumerator();
                    while ($it1224.MoveNext()){
                        var n11 = $it1224.get_Current();
                        var x = Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveXWithParallelogramNodesOne(n00, n11);
                        if (x != null)
                            return x;
                    }
                }
            }
            else if (n1Pb != null){
                var $it1225 = n1Pb.get_Children().GetEnumerator();
                while ($it1225.MoveNext()){
                    var n = $it1225.get_Current();
                    var x = Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveXWithParallelogramNodesOne(n0, n);
                    if (x != null)
                        return x;
                }
            }
            else if (n0Pb != null){
                var $it1226 = n0Pb.get_Children().GetEnumerator();
                while ($it1226.MoveNext()){
                    var n = $it1226.get_Current();
                    var x = Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveXWithParallelogramNodesOne(n, n1);
                    if (x != null)
                        return x;
                }
            }
            else
                return Microsoft.Msagl.Core.Geometry.Curves.Curve.CrossOverIntervalsOne(n0, n1);
            return null;
        },
        CurveCurveXWithParallelogramNodes: function (n0, n1, intersections){
            if (!Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.Intersect(n0.get_Parallelogram(), n1.get_Parallelogram()))
                return;
            var n0Pb = As(n0, Microsoft.Msagl.Core.Geometry.Curves.ParallelogramInternalTreeNode.ctor);
            var n1Pb = As(n1, Microsoft.Msagl.Core.Geometry.Curves.ParallelogramInternalTreeNode.ctor);
            if (n0Pb != null && n1Pb != null){
                var $it1227 = n0Pb.get_Children().GetEnumerator();
                while ($it1227.MoveNext()){
                    var n00 = $it1227.get_Current();
                    var $it1228 = n1Pb.get_Children().GetEnumerator();
                    while ($it1228.MoveNext()){
                        var n11 = $it1228.get_Current();
                        Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveXWithParallelogramNodes(n00, n11, intersections);
                    }
                }
            }
            else if (n1Pb != null){
                var $it1229 = n1Pb.get_Children().GetEnumerator();
                while ($it1229.MoveNext()){
                    var n = $it1229.get_Current();
                    Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveXWithParallelogramNodes(n0, n, intersections);
                }
            }
            else if (n0Pb != null){
                var $it1230 = n0Pb.get_Children().GetEnumerator();
                while ($it1230.MoveNext()){
                    var n = $it1230.get_Current();
                    Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveXWithParallelogramNodes(n, n1, intersections);
                }
            }
            else
                intersections.Value = Microsoft.Msagl.Core.Geometry.Curves.Curve.CrossOverIntervals(n0, n1, intersections.Value);
        },
        CrossOverIntervalsOne: function (n0, n1){
            var l0 = As(n0, Microsoft.Msagl.Core.Geometry.Curves.ParallelogramLeaf.ctor);
            var l1 = As(n1, Microsoft.Msagl.Core.Geometry.Curves.ParallelogramLeaf.ctor);
            var d0 = (l0.get_High() - l0.get_Low()) / 2;
            var d1 = (l1.get_High() - l1.get_Low()) / 2;
            for (var i = 1; i < 2; i++){
                var p0 = i * d0 + l0.get_Low();
                for (var j = 1; j < 2; j++){
                    var p1 = j * d1 + l1.get_Low();
                    var aSol,bSol;
                    var x;
                    var r;
                    if (l0.get_Chord() == null && l1.get_Chord() == null)
                        r = (function (){
                            var $1 = {
                                Value: aSol
                            };
                            var $2 = {
                                Value: bSol
                            };
                            var $3 = {
                                Value: x
                            };
                            var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.CrossWithinIntervalsWithGuess(n0.get_Seg(), n1.get_Seg(), l0.get_Low(), l0.get_High(), l1.get_Low(), l1.get_High(), p0, p1, $1, $2, $3);
                            aSol = $1.Value;
                            bSol = $2.Value;
                            x = $3.Value;
                            return $res;
                        })();
                    else if (l0.get_Chord() != null && l1.get_Chord() == null){
                        r = (function (){
                            var $1 = {
                                Value: aSol
                            };
                            var $2 = {
                                Value: bSol
                            };
                            var $3 = {
                                Value: x
                            };
                            var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.CrossWithinIntervalsWithGuess(l0.get_Chord(), n1.get_Seg(), 0, 1, l1.get_Low(), l1.get_High(), 0.5 * i, p1, $1, $2, $3);
                            aSol = $1.Value;
                            bSol = $2.Value;
                            x = $3.Value;
                            return $res;
                        })();
                        if (r)
                            aSol = l0.get_Low() + aSol * (l0.get_High() - l0.get_Low());
                    }
                    else if (l0.get_Chord() == null){
                        r = (function (){
                            var $1 = {
                                Value: aSol
                            };
                            var $2 = {
                                Value: bSol
                            };
                            var $3 = {
                                Value: x
                            };
                            var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.CrossWithinIntervalsWithGuess(n0.get_Seg(), l1.get_Chord(), l0.get_Low(), l0.get_High(), 0, 1, p0, 0.5 * j, $1, $2, $3);
                            aSol = $1.Value;
                            bSol = $2.Value;
                            x = $3.Value;
                            return $res;
                        })();
                        if (r)
                            bSol = l1.get_Low() + bSol * (l1.get_High() - l1.get_Low());
                    }
                    else {
                        r = (function (){
                            var $1 = {
                                Value: aSol
                            };
                            var $2 = {
                                Value: bSol
                            };
                            var $3 = {
                                Value: x
                            };
                            var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.CrossWithinIntervalsWithGuess(l0.get_Chord(), l1.get_Chord(), 0, 1, 0, 1, 0.5 * i, 0.5 * j, $1, $2, $3);
                            aSol = $1.Value;
                            bSol = $2.Value;
                            x = $3.Value;
                            return $res;
                        })();
                        if (r){
                            bSol = l1.get_Low() + bSol * (l1.get_High() - l1.get_Low());
                            aSol = l0.get_Low() + aSol * (l0.get_High() - l0.get_Low());
                        }
                    }
                    if (r)
                        return Microsoft.Msagl.Core.Geometry.Curves.Curve.CreateIntersectionOne(l0, l1, aSol, bSol, x);
                }
            }
            return Microsoft.Msagl.Core.Geometry.Curves.Curve.GoDeeperOne(l0, l1);
        },
        CrossOverIntervals: function (n0, n1, intersections){
            var l0 = As(n0, Microsoft.Msagl.Core.Geometry.Curves.ParallelogramLeaf.ctor);
            var l1 = As(n1, Microsoft.Msagl.Core.Geometry.Curves.ParallelogramLeaf.ctor);
            var d0 = (l0.get_High() - l0.get_Low()) / 2;
            var d1 = (l1.get_High() - l1.get_Low()) / 2;
            var found = false;
            for (var i = 1; i < 2; i++){
                var p0 = i * d0 + l0.get_Low();
                for (var j = 1; j < 2; j++){
                    var p1 = j * d1 + l1.get_Low();
                    var aSol,bSol;
                    var x;
                    var r;
                    if (l0.get_Chord() == null && l1.get_Chord() == null)
                        r = (function (){
                            var $1 = {
                                Value: aSol
                            };
                            var $2 = {
                                Value: bSol
                            };
                            var $3 = {
                                Value: x
                            };
                            var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.CrossWithinIntervalsWithGuess(n0.get_Seg(), n1.get_Seg(), l0.get_Low(), l0.get_High(), l1.get_Low(), l1.get_High(), p0, p1, $1, $2, $3);
                            aSol = $1.Value;
                            bSol = $2.Value;
                            x = $3.Value;
                            return $res;
                        })();
                    else if (l0.get_Chord() != null && l1.get_Chord() == null){
                        r = (function (){
                            var $1 = {
                                Value: aSol
                            };
                            var $2 = {
                                Value: bSol
                            };
                            var $3 = {
                                Value: x
                            };
                            var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.CrossWithinIntervalsWithGuess(l0.get_Chord(), n1.get_Seg(), 0, 1, l1.get_Low(), l1.get_High(), 0.5 * i, p1, $1, $2, $3);
                            aSol = $1.Value;
                            bSol = $2.Value;
                            x = $3.Value;
                            return $res;
                        })();
                        if (r)
                            aSol = l0.get_Low() + aSol * (l0.get_High() - l0.get_Low());
                    }
                    else if (l0.get_Chord() == null){
                        r = (function (){
                            var $1 = {
                                Value: aSol
                            };
                            var $2 = {
                                Value: bSol
                            };
                            var $3 = {
                                Value: x
                            };
                            var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.CrossWithinIntervalsWithGuess(n0.get_Seg(), l1.get_Chord(), l0.get_Low(), l0.get_High(), 0, 1, p0, 0.5 * j, $1, $2, $3);
                            aSol = $1.Value;
                            bSol = $2.Value;
                            x = $3.Value;
                            return $res;
                        })();
                        if (r)
                            bSol = l1.get_Low() + bSol * (l1.get_High() - l1.get_Low());
                    }
                    else {
                        r = (function (){
                            var $1 = {
                                Value: aSol
                            };
                            var $2 = {
                                Value: bSol
                            };
                            var $3 = {
                                Value: x
                            };
                            var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.CrossWithinIntervalsWithGuess(l0.get_Chord(), l1.get_Chord(), 0, 1, 0, 1, 0.5 * i, 0.5 * j, $1, $2, $3);
                            aSol = $1.Value;
                            bSol = $2.Value;
                            x = $3.Value;
                            return $res;
                        })();
                        if (r){
                            bSol = l1.get_Low() + bSol * (l1.get_High() - l1.get_Low());
                            aSol = l0.get_Low() + aSol * (l0.get_High() - l0.get_Low());
                        }
                    }
                    if (r){
                        Microsoft.Msagl.Core.Geometry.Curves.Curve.AddIntersection(l0, l1, intersections, aSol, bSol, x);
                        found = true;
                    }
                }
            }
            if (!found)
                (function (){
                    var $1 = {
                        Value: intersections
                    };
                    var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.GoDeeper($1, l0, l1);
                    intersections = $1.Value;
                    return $res;
                })();
            return intersections;
        },
        AddIntersection: function (n0, n1, intersections, aSol, bSol, x){
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.CloseIntersections(x, n0.get_Seg().get_Item$$Double(n0.get_Low()))){
                x = n0.get_Seg().get_Item$$Double(n0.get_Low());
                aSol = n0.get_Low();
            }
            else if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.CloseIntersections(x, n0.get_Seg().get_Item$$Double(n0.get_High()))){
                x = n0.get_Seg().get_Item$$Double(n0.get_High());
                aSol = n0.get_High();
            }
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.CloseIntersections(x, n1.get_Seg().get_Item$$Double(n1.get_Low()))){
                x = n1.get_Seg().get_Item$$Double(n1.get_Low());
                bSol = n1.get_Low();
            }
            else if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.CloseIntersections(x, n1.get_Seg().get_Item$$Double(n1.get_High()))){
                x = n1.get_Seg().get_Item$$Double(n1.get_High());
                bSol = n1.get_High();
            }
            var oldIntersection = (function (){
                var $1 = {
                    Value: x
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.OldIntersection(intersections, $1);
                x = $1.Value;
                return $res;
            })();
            if (!oldIntersection){
                var xx = new Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.ctor(aSol, bSol, x, n0.get_Seg(), n1.get_Seg());
                intersections.Add(xx);
            }
            return;
        },
        OldIntersection: function (intersections, x){
            var oldIntersection = false;
            var $it1231 = intersections.GetEnumerator();
            while ($it1231.MoveNext()){
                var ii = $it1231.get_Current();
                if ((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(x.Value, ii.get_IntersectionPoint())).get_Length() < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon * 100){
                    oldIntersection = true;
                    break;
                }
            }
            return oldIntersection;
        },
        CreateIntersectionOne: function (n0, n1, aSol, bSol, x){
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.CloseIntersections(x, n0.get_Seg().get_Item$$Double(n0.get_Low()))){
                x = n0.get_Seg().get_Item$$Double(n0.get_Low());
                aSol = n0.get_Low();
            }
            else if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.CloseIntersections(x, n0.get_Seg().get_Item$$Double(n0.get_High()))){
                x = n0.get_Seg().get_Item$$Double(n0.get_High());
                aSol = n0.get_High();
            }
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.CloseIntersections(x, n1.get_Seg().get_Item$$Double(n1.get_Low()))){
                x = n1.get_Seg().get_Item$$Double(n1.get_Low());
                bSol = n1.get_Low();
            }
            else if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.CloseIntersections(x, n1.get_Seg().get_Item$$Double(n1.get_High()))){
                x = n1.get_Seg().get_Item$$Double(n1.get_High());
                bSol = n1.get_High();
            }
            return new Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.ctor(aSol, bSol, x, n0.get_Seg(), n1.get_Seg());
        },
        LiftIntersectionToCurves$$ICurve$$ICurve$$Double$$Double$$Point$$ICurve$$ICurve: function (c0, c1, aSol, bSol, x, seg0, seg1){
            var a = Microsoft.Msagl.Core.Geometry.Curves.Curve.LiftParameterToCurve(c0, aSol - seg0.get_ParStart(), seg0);
            var b = Microsoft.Msagl.Core.Geometry.Curves.Curve.LiftParameterToCurve(c1, bSol - seg1.get_ParStart(), seg1);
            return new Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.ctor(a, b, x, c0, c1);
        },
        DropIntersectionToSegs: function (xx){
            var seg0;
            var par0;
            if (Is(xx.get_Segment0(), Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor))
                (function (){
                    var $1 = {
                        Value: par0
                    };
                    var $2 = {
                        Value: seg0
                    };
                    var $res = (As(xx.get_Segment0(), Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor)).GetSegmentAndParameter$$Double$$Double$$ICurve(xx.get_Par0(), $1, $2);
                    par0 = $1.Value;
                    seg0 = $2.Value;
                    return $res;
                })();
            else {
                par0 = xx.get_Par0();
                seg0 = xx.get_Segment0();
            }
            var seg1;
            var par1;
            if (Is(xx.get_Segment1(), Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor))
                (function (){
                    var $1 = {
                        Value: par1
                    };
                    var $2 = {
                        Value: seg1
                    };
                    var $res = (As(xx.get_Segment1(), Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor)).GetSegmentAndParameter$$Double$$Double$$ICurve(xx.get_Par1(), $1, $2);
                    par1 = $1.Value;
                    seg1 = $2.Value;
                    return $res;
                })();
            else {
                par1 = xx.get_Par1();
                seg1 = xx.get_Segment1();
            }
            return new Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.ctor(par0, par1, xx.get_IntersectionPoint(), seg0, seg1);
        },
        LiftIntersectionToCurves$$ICurve$$ICurve$$IntersectionInfo: function (c0, c1, xx){
            return Microsoft.Msagl.Core.Geometry.Curves.Curve.LiftIntersectionToCurves$$ICurve$$ICurve$$Double$$Double$$Point$$ICurve$$ICurve(c0, c1, xx.get_Par0(), xx.get_Par1(), xx.get_IntersectionPoint(), xx.get_Segment0(), xx.get_Segment1());
        },
        LiftParameterToCurve: function (curve, par, seg){
            if (curve == seg)
                return par;
            var c = As(curve, Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor);
            if (c != null){
                var offset = 0;
                var $it1232 = c.get_Segments().GetEnumerator();
                while ($it1232.MoveNext()){
                    var s = $it1232.get_Current();
                    if (s == seg)
                        return par + offset;
                    offset += Microsoft.Msagl.Core.Geometry.Curves.Curve.ParamSpan(s);
                }
            }
            var roundedRect = As(curve, Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.ctor);
            if (roundedRect != null)
                return Microsoft.Msagl.Core.Geometry.Curves.Curve.LiftParameterToCurve(roundedRect.get_Curve(), par, seg);
            throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
        },
        ParamSpan: function (s){
            return s.get_ParEnd() - s.get_ParStart();
        },
        GoDeeperOne: function (l0, l1){
            var eps = Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon;
            if (l0.get_LeafBoxesOffset() > eps && l1.get_LeafBoxesOffset() > eps){
                var nn0 = Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.CreateParallelogramNodeForCurveSeg(l0.get_Low(), l0.get_High(), l0.get_Seg(), l0.get_LeafBoxesOffset() / 2);
                var nn1 = Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.CreateParallelogramNodeForCurveSeg(l1.get_Low(), l1.get_High(), l1.get_Seg(), l1.get_LeafBoxesOffset() / 2);
                return Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveXWithParallelogramNodesOne(nn0, nn1);
            }
            if (l0.get_LeafBoxesOffset() > eps){
                var nn0 = Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.CreateParallelogramNodeForCurveSeg(l0.get_Low(), l0.get_High(), l0.get_Seg(), l0.get_LeafBoxesOffset() / 2);
                return Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveXWithParallelogramNodesOne(nn0, l1);
            }
            if (l1.get_LeafBoxesOffset() > eps){
                var nn1 = Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.CreateParallelogramNodeForCurveSeg(l1.get_Low(), l1.get_High(), l1.get_Seg(), l1.get_LeafBoxesOffset() / 2);
                return Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveXWithParallelogramNodesOne(l0, nn1);
            }
            var l0Low = l0.get_Seg().get_Item$$Double(l0.get_Low());
            var l0High = l0.get_Seg().get_Item$$Double(l0.get_High());
            if (!Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(l0Low, l0High)){
                var l1Low = l1.get_Seg().get_Item$$Double(l1.get_Low());
                var l1High = l1.get_Seg().get_Item$$Double(l1.get_High());
                if (!Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(l1Low, l1High)){
                    var ls0 = Is(l0.get_Seg(), Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor) ? As(l0.get_Seg(), Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor) : new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(l0Low, l0High);
                    var ls1 = Is(l1.get_Seg(), Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor) ? As(l1.get_Seg(), Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor) : new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(l1Low, l1High);
                    var asol,bsol;
                    var x;
                    var r = (function (){
                        var $1 = {
                            Value: asol
                        };
                        var $2 = {
                            Value: bsol
                        };
                        var $3 = {
                            Value: x
                        };
                        var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.CrossWithinIntervalsWithGuess(ls0, ls1, 0, 1, 0, 1, 0.5, 0.5, $1, $2, $3);
                        asol = $1.Value;
                        bsol = $2.Value;
                        x = $3.Value;
                        return $res;
                    })();
                    if (r){
                        (function (){
                            var $1 = {
                                Value: asol
                            };
                            var $2 = {
                                Value: bsol
                            };
                            var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.AdjustParameters(l0, ls0, l1, ls1, x, $1, $2);
                            asol = $1.Value;
                            bsol = $2.Value;
                            return $res;
                        })();
                        return Microsoft.Msagl.Core.Geometry.Curves.Curve.CreateIntersectionOne(l0, l1, asol, bsol, x);
                    }
                }
            }
            return null;
        },
        GoDeeper: function (intersections, l0, l1){
            var eps = Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon;
            if (l0.get_LeafBoxesOffset() > eps && l1.get_LeafBoxesOffset() > eps){
                var nn0 = Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.CreateParallelogramNodeForCurveSeg(l0.get_Low(), l0.get_High(), l0.get_Seg(), l0.get_LeafBoxesOffset() / 2);
                var nn1 = Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.CreateParallelogramNodeForCurveSeg(l1.get_Low(), l1.get_High(), l1.get_Seg(), l1.get_LeafBoxesOffset() / 2);
                Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveXWithParallelogramNodes(nn0, nn1, intersections);
            }
            else if (l0.get_LeafBoxesOffset() > eps){
                var nn0 = Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.CreateParallelogramNodeForCurveSeg(l0.get_Low(), l0.get_High(), l0.get_Seg(), l0.get_LeafBoxesOffset() / 2);
                Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveXWithParallelogramNodes(nn0, l1, intersections);
            }
            else if (l1.get_LeafBoxesOffset() > eps){
                var nn1 = Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.CreateParallelogramNodeForCurveSeg(l1.get_Low(), l1.get_High(), l1.get_Seg(), l1.get_LeafBoxesOffset() / 2);
                Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveXWithParallelogramNodes(l0, nn1, intersections);
            }
            else {
                var l0Low = l0.get_Seg().get_Item$$Double(l0.get_Low());
                var l0High = l0.get_Seg().get_Item$$Double(l0.get_High());
                if (!Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(l0Low, l0High)){
                    var l1Low = l1.get_Seg().get_Item$$Double(l1.get_Low());
                    var l1High = l1.get_Seg().get_Item$$Double(l1.get_High());
                    if (!Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(l1Low, l1High)){
                        var ls0 = Is(l0.get_Seg(), Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor) ? As(l0.get_Seg(), Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor) : new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(l0Low, l0High);
                        var ls1 = Is(l1.get_Seg(), Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor) ? As(l1.get_Seg(), Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor) : new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(l1Low, l1High);
                        var asol,bsol;
                        var x;
                        var r = (function (){
                            var $1 = {
                                Value: asol
                            };
                            var $2 = {
                                Value: bsol
                            };
                            var $3 = {
                                Value: x
                            };
                            var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.CrossWithinIntervalsWithGuess(ls0, ls1, 0, 1, 0, 1, 0.5, 0.5, $1, $2, $3);
                            asol = $1.Value;
                            bsol = $2.Value;
                            x = $3.Value;
                            return $res;
                        })();
                        if (r){
                            (function (){
                                var $1 = {
                                    Value: asol
                                };
                                var $2 = {
                                    Value: bsol
                                };
                                var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.AdjustParameters(l0, ls0, l1, ls1, x, $1, $2);
                                asol = $1.Value;
                                bsol = $2.Value;
                                return $res;
                            })();
                            Microsoft.Msagl.Core.Geometry.Curves.Curve.AddIntersection(l0, l1, intersections.Value, asol, bsol, x);
                        }
                    }
                }
            }
        },
        AdjustParameters: function (l0, ls0, l1, ls1, x, asol, bsol){
            if (ls0 != l0.get_Seg() && Is(l0.get_Seg(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor) == false)
                asol.Value = l0.get_Seg().ClosestParameter(x);
            else
                asol.Value = l0.get_Low() + asol.Value * (l0.get_High() - l0.get_Low());
            if (ls1 != l1.get_Seg() && Is(l1.get_Seg(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor) == false)
                bsol.Value = l1.get_Seg().ClosestParameter(x);
            else
                bsol.Value = l1.get_Low() + bsol.Value * (l1.get_High() - l1.get_Low());
        },
        LineSegmentThreshold$$: "System.Double",
        get_LineSegmentThreshold: function (){
            return Microsoft.Msagl.Core.Geometry.Curves.Curve.lineSegThreshold;
        },
        set_LineSegmentThreshold: function (value){
            Microsoft.Msagl.Core.Geometry.Curves.Curve.lineSegThreshold = value;
        },
        CrossWithinIntervalsWithGuess: function (a, b, amin, amax, bmin, bmax, aGuess, bGuess, aSolution, bSolution, x){
            var r;
            if (Is(a, Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor) && Is(b, Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor))if (Microsoft.Msagl.Core.Geometry.Curves.Curve.CrossTwoLineSegs(a.get_Start(), a.get_End(), b.get_Start(), b.get_End(), amin, amax, bmin, bmax, aSolution, bSolution, x))
                return true;
            var aPoint;
            var bPoint;
            r = (function (){
                var $1 = {
                    Value: aPoint
                };
                var $2 = {
                    Value: bPoint
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.MinDistWithinIntervals(a, b, amin, amax, bmin, bmax, aGuess, bGuess, aSolution, bSolution, $1, $2);
                aPoint = $1.Value;
                bPoint = $2.Value;
                return $res;
            })();
            x.Value = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(0.5, (Microsoft.Msagl.Core.Geometry.Point.op_Addition(aPoint, bPoint)));
            var aMinusB = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(aPoint, bPoint);
            var ret = r && Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(aMinusB, aMinusB) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon * Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon;
            return ret;
        },
        CrossTwoLineSegs: function (aStart, aEnd, bStart, bEnd, amin, amax, bmin, bmax, aSolution, bSolution, x){
            var u = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(aEnd, aStart);
            var v = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(bStart, bEnd);
            var w = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(bStart, aStart);
            var r = Microsoft.Msagl.Core.Geometry.Curves.LinearSystem2.Solve(u.get_X(), v.get_X(), w.get_X(), u.get_Y(), v.get_Y(), w.get_Y(), aSolution, bSolution);
            x.Value = Microsoft.Msagl.Core.Geometry.Point.op_Addition(aStart, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(aSolution.Value, u));
            if (r){
                if (aSolution.Value < amin - Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                    return false;
                aSolution.Value = System.Math.Max$$Double$$Double(aSolution.Value, amin);
                if (aSolution.Value > amax + Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                    return false;
                aSolution.Value = System.Math.Min$$Double$$Double(aSolution.Value, amax);
                if (bSolution.Value < bmin - Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                    return false;
                bSolution.Value = System.Math.Max$$Double$$Double(bSolution.Value, bmin);
                if (bSolution.Value > bmax + Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                    return false;
                bSolution.Value = System.Math.Min$$Double$$Double(bSolution.Value, bmax);
                return true;
            }
            return false;
        },
        PointRelativeToCurveLocation: function (point, curve){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(curve, "curve");
            if (!curve.get_BoundingBox().Contains$$Point(point))
                return Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside;
            var l = 2 * curve.get_BoundingBox().get_Diagonal();
            var degree = 0.0174532925199433;
            var inside = 0;
            for (var i = 13; i < 360; i += 13){
                var lineDir = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(System.Math.Cos(i * degree), System.Math.Sin(i * degree));
                var ls = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(point, Microsoft.Msagl.Core.Geometry.Point.op_Addition(point, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(l, lineDir)));
                var intersections = Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(ls, curve, true);
                if (Microsoft.Msagl.Core.Geometry.Curves.Curve.AllIntersectionsAreGood(intersections, curve)){
                    var $it1234 = intersections.GetEnumerator();
                    while ($it1234.MoveNext()){
                        var xx = $it1234.get_Current();
                        if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(xx.get_IntersectionPoint(), point))
                            return Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Boundary;
                    }
                    var insideThisTime = intersections.get_Count() % 2 == 1;
                    if (insideThisTime)
                        inside++;
                    else
                        inside--;
                    if (inside >= 2)
                        return Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Inside;
                    if (inside <= -2)
                        return Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside;
                }
            }
            return Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Boundary;
        },
        AllIntersectionsAreGood: function (intersections, polygon){
            var polyCurve = As(polygon, Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor);
            if (null == polyCurve){
                var polyLine = As(polygon, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
                if (null != polyLine)
                    polyCurve = polyLine.ToCurve();
            }
            if (null != polyCurve){
                var $it1235 = intersections.GetEnumerator();
                while ($it1235.MoveNext()){
                    var xx = $it1235.get_Current();
                    if (!Microsoft.Msagl.Core.Geometry.Curves.Curve.RealCut(Microsoft.Msagl.Core.Geometry.Curves.Curve.DropIntersectionToSegs(xx), polyCurve, false))
                        return false;
                }
            }
            return true;
        },
        RealCutWithClosedCurve: function (xx, polygon, onlyFromInsideCuts){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(xx, "xx");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(polygon, "polygon");
            var sseg = xx.get_Segment0();
            var pseg = xx.get_Segment1();
            var spar = xx.get_Par0();
            var ppar = xx.get_Par1();
            var x = xx.get_IntersectionPoint();
            var ts = sseg.Derivative(spar).Normalize();
            var pn = pseg.Derivative(ppar).Normalize().Rotate(1.5707963267949);
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(x, pseg.get_End())){
                var exitSeg = null;
                for (var i = 0; i < polygon.get_Segments().get_Count(); i++)
                    if (polygon.get_Segments().get_Item$$Int32(i) == pseg){
                        exitSeg = polygon.get_Segments().get_Item$$Int32((i + 1) % polygon.get_Segments().get_Count());
                        break;
                    }
                if (exitSeg == null)
                    throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
                var tsn = ts.Rotate((1.5707963267949));
                var touch = (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(tsn, pseg.Derivative(pseg.get_ParEnd()))) * (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(tsn, exitSeg.Derivative(exitSeg.get_ParStart()))) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance();
                return !touch;
            }
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(x, pseg.get_Start())){
                var enterSeg = null;
                for (var i = 0; i < polygon.get_Segments().get_Count(); i++)
                    if (polygon.get_Segments().get_Item$$Int32(i) == pseg){
                        enterSeg = polygon.get_Segments().get_Item$$Int32(i > 0 ? (i - 1) : polygon.get_Segments().get_Count() - 1);
                        break;
                    }
                var tsn = ts.Rotate((1.5707963267949));
                var touch = (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(tsn, pseg.Derivative(pseg.get_ParStart()))) * (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(tsn, enterSeg.Derivative(enterSeg.get_ParEnd()))) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance();
                return !touch;
            }
            var d = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(ts, pn);
            if (onlyFromInsideCuts)
                return d > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon;
            return System.Math.Abs$$Double(d) > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon;
        },
        RealCut: function (xx, polyline, onlyFromInsideCuts){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(xx, "xx");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(polyline, "polyline");
            var sseg = xx.get_Segment0();
            var pseg = xx.get_Segment1();
            var spar = xx.get_Par0();
            var ppar = xx.get_Par1();
            var x = xx.get_IntersectionPoint();
            var ts = sseg.Derivative(spar).Normalize();
            var pn = pseg.Derivative(ppar).Normalize().Rotate(1.5707963267949);
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(x, pseg.get_End())){
                var exitSeg = null;
                for (var i = 0; i < polyline.get_Segments().get_Count() - 1; i++)
                    if (polyline.get_Segments().get_Item$$Int32(i) == pseg){
                        exitSeg = polyline.get_Segments().get_Item$$Int32(i + 1);
                        break;
                    }
                if (exitSeg == null)
                    return false;
                var tsn = ts.Rotate((1.5707963267949));
                var touch = (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(tsn, pseg.Derivative(pseg.get_ParEnd()))) * (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(tsn, exitSeg.Derivative(exitSeg.get_ParStart()))) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance();
                return !touch;
            }
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(x, pseg.get_Start())){
                var enterSeg = null;
                for (var i = polyline.segs.get_Count() - 1; i > 0; i--)
                    if (polyline.get_Segments().get_Item$$Int32(i) == pseg){
                        enterSeg = polyline.get_Segments().get_Item$$Int32(i - 1);
                        break;
                    }
                if (enterSeg == null)
                    return false;
                var tsn = ts.Rotate((1.5707963267949));
                var touch = (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(tsn, pseg.Derivative(pseg.get_ParStart()))) * (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(tsn, enterSeg.Derivative(enterSeg.get_ParEnd()))) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance();
                return !touch;
            }
            var d = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(ts, pn);
            if (onlyFromInsideCuts)
                return d > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon;
            return System.Math.Abs$$Double(d) > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon;
        },
        MinDistWithinIntervals: function (a, b, aMin, aMax, bMin, bMax, aGuess, bGuess, aSolution, bSolution, aPoint, bPoint){
            var md = new Microsoft.Msagl.Core.Geometry.Curves.MinDistCurveCurve.ctor(a, b, aMin, aMax, bMin, bMax, aGuess, bGuess);
            md.Solve();
            aSolution.Value = md.get_ASolution();
            aPoint.Value = md.get_APoint();
            bSolution.Value = md.get_BSolution();
            bPoint.Value = md.get_BPoint();
            return md.get_Status();
        },
        AddLineSegment$$Curve$$Point$$Point: function (curve, pointA, pointB){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(curve, "curve");
            return curve.AddSegment(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(pointA, pointB));
        },
        AddLineSegment$$Curve$$Double$$Double$$Double$$Double: function (curve, x0, y0, x1, y1){
            Microsoft.Msagl.Core.Geometry.Curves.Curve.AddLineSegment$$Curve$$Point$$Point(curve, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x0, y0), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x1, y1));
        },
        ContinueWithLineSegment$$Curve$$Double$$Double: function (c, x, y){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(c, "c");
            Microsoft.Msagl.Core.Geometry.Curves.Curve.AddLineSegment$$Curve$$Point$$Point(c, c.get_End(), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x, y));
        },
        ContinueWithLineSegment$$Curve$$Point: function (c, x){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(c, "c");
            Microsoft.Msagl.Core.Geometry.Curves.Curve.AddLineSegment$$Curve$$Point$$Point(c, c.get_End(), x);
        },
        CloseCurve: function (curve){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(curve, "curve");
            Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Point(curve, curve.get_Start());
        },
        ClosestParameterWithPoint: function (curve, location, pointOnCurve){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(curve, "curve");
            var t = curve.ClosestParameter(location);
            pointOnCurve.Value = curve.get_Item$$Double(t);
            return t;
        },
        ClosestPoint: function (curve, location){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(curve, "curve");
            return curve.get_Item$$Double(curve.ClosestParameter(location));
        },
        CurveIsInsideOther: function (innerCurve, outerCurve){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(innerCurve, "innerCurve");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(outerCurve, "outerCurve");
            if (!outerCurve.get_BoundingBox().Contains$$Rectangle(innerCurve.get_BoundingBox()))
                return false;
            var xx = Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(innerCurve, outerCurve, true);
            if (xx.get_Count() == 0)
                return Microsoft.Msagl.Core.Geometry.Curves.Curve.NonIntersectingCurveIsInsideOther(innerCurve, outerCurve);
            if (xx.get_Count() == 1)
                return Microsoft.Msagl.Core.Geometry.Point.op_Inequality(innerCurve.get_Start(), xx.get_Item$$Int32(0).get_IntersectionPoint()) ? Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(innerCurve.get_Start(), outerCurve) == Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Inside : Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(innerCurve.get_Item$$Double((innerCurve.get_ParStart() + innerCurve.get_ParEnd()) / 2), outerCurve) == Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Inside;
            return System.Linq.Enumerable.All$1(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Curves.Curve.PointsBetweenIntersections(innerCurve, xx), function (p){
                return Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(p, outerCurve) != Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside;
            });
        },
        PointsBetweenIntersections: function (a, xx){
            var $yield = [];
            System.Linq.Enumerable.OrderBy$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.ctor, System.Double.ctor, xx, function (x){
                return x.get_Par0();
            });
            for (var i = 0; i < xx.get_Count() - 1; i++)
                $yield.push(a.get_Item$$Double((xx.get_Item$$Int32(i).get_Par0() + xx.get_Item$$Int32(i + 1).get_Par0()) / 2));
            var start = xx.get_Item$$Int32(xx.get_Count() - 1).get_Par0();
            var end = xx.get_Item$$Int32(0).get_Par0();
            var len = a.get_ParEnd() - start + end - a.get_ParStart();
            var middle = start + len / 2;
            if (middle > a.get_ParEnd())
                middle = a.get_ParStart() + middle - a.get_ParEnd();
            $yield.push(a.get_Item$$Double(middle));
            return $yield;
        },
        NonIntersectingCurveIsInsideOther: function (a, b){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(a, "a");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(b, "b");
            for (var par = a.get_ParStart(); par < a.get_ParEnd(); par += 0.5){
                var parLoc = Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(a.get_Item$$Double(par), b);
                if (Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Boundary != parLoc)
                    return Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Inside == parLoc;
            }
            return Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside != Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(a.get_End(), b);
        },
        ClosedCurveInteriorsIntersect: function (curve1, curve2){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(curve1, "curve1");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(curve2, "curve2");
            if (!curve2.get_BoundingBox().Intersects(curve1.get_BoundingBox()))
                return false;
            var xx = Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(curve1, curve2, true);
            if (xx.get_Count() == 0)
                return Microsoft.Msagl.Core.Geometry.Curves.Curve.NonIntersectingCurveIsInsideOther(curve1, curve2) || Microsoft.Msagl.Core.Geometry.Curves.Curve.NonIntersectingCurveIsInsideOther(curve2, curve1);
            if (xx.get_Count() == 1)
                return Microsoft.Msagl.Core.Geometry.Point.op_Inequality(curve1.get_Start(), xx.get_Item$$Int32(0).get_IntersectionPoint()) ? Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(curve1.get_Start(), curve2) == Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Inside : Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(curve1.get_Item$$Double((curve1.get_ParStart() + curve1.get_ParEnd()) / 2), curve2) == Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Inside || Microsoft.Msagl.Core.Geometry.Point.op_Inequality(curve2.get_Start(), xx.get_Item$$Int32(0).get_IntersectionPoint()) ? Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(curve2.get_Start(), curve1) == Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Inside : Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(curve2.get_Item$$Double((curve2.get_ParStart() + curve2.get_ParEnd()) / 2), curve1) == Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Inside;
            return System.Linq.Enumerable.Any$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Core.Geometry.Curves.Curve.PointsBetweenIntersections(curve1, xx), function (p){
                return Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(p, curve2) == Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Inside;
            });
        },
        CurvesIntersect: function (curve1, curve2){
            return curve1 == curve2 || (Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveIntersectionOne(curve1, curve2, false) != null);
        },
        CreateBezierSeg$$Double$$Double$$Site$$Site$$Site: function (kPrev, kNext, a, b, c){
            var s = Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(kPrev, a.get_Point()), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point((1 - kPrev), b.get_Point()));
            var e = Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(kNext, c.get_Point()), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point((1 - kNext), b.get_Point()));
            var t = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point((0.666666666666667), b.get_Point());
            return new Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ctor(s, Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(s, 3), t), Microsoft.Msagl.Core.Geometry.Point.op_Addition(t, Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(e, 3)), e);
        },
        CreateBezierSeg$$Point$$Point$$Point$$Int32: function (a, b, perp, i){
            var d = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(perp, i);
            return new Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ctor(a, Microsoft.Msagl.Core.Geometry.Point.op_Addition(a, d), Microsoft.Msagl.Core.Geometry.Point.op_Addition(b, d), b);
        },
        FindCorner: function (a, b, c){
            c.Value = null;
            b.Value = a.get_Next();
            if (b.Value.get_Next() == null)
                return false;
            c.Value = b.Value.get_Next();
            return c.Value != null;
        },
        TrimEdgeSplineWithNodeBoundaries: function (sourceBoundary, targetBoundary, spline, narrowestInterval){
            var start = spline.get_ParStart();
            var end = spline.get_ParEnd();
            if (sourceBoundary != null)
                (function (){
                    var $1 = {
                        Value: start
                    };
                    var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.FindNewStart(spline, $1, sourceBoundary, narrowestInterval);
                    start = $1.Value;
                    return $res;
                })();
            if (targetBoundary != null)
                (function (){
                    var $1 = {
                        Value: end
                    };
                    var $res = Microsoft.Msagl.Core.Geometry.Curves.Curve.FindNewEnd(spline, targetBoundary, narrowestInterval, $1);
                    end = $1.Value;
                    return $res;
                })();
            var st = System.Math.Min$$Double$$Double(start, end);
            var en = System.Math.Max$$Double$$Double(start, end);
            return st < en ? spline.Trim(st, en) : spline;
        },
        FindNewEnd: function (spline, targetBoundary, narrowestInterval, end){
            var intersections = Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(spline, targetBoundary, true);
            if (intersections.get_Count() == 0){
                end.Value = spline.get_ParEnd();
                return;
            }
            if (narrowestInterval){
                end.Value = spline.get_ParEnd();
                var $it1242 = intersections.GetEnumerator();
                while ($it1242.MoveNext()){
                    var xx = $it1242.get_Current();
                    if (xx.get_Par0() < end.Value)
                        end.Value = xx.get_Par0();
                }
            }
            else {
                end.Value = spline.get_ParStart();
                var $it1243 = intersections.GetEnumerator();
                while ($it1243.MoveNext()){
                    var xx = $it1243.get_Current();
                    if (xx.get_Par0() > end.Value)
                        end.Value = xx.get_Par0();
                }
            }
        },
        FindNewStart: function (spline, start, sourceBoundary, narrowestInterval){
            var intersections = Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(spline, sourceBoundary, true);
            if (intersections.get_Count() == 0){
                start.Value = spline.get_ParStart();
                return;
            }
            if (narrowestInterval){
                start.Value = spline.get_ParStart();
                var $it1244 = intersections.GetEnumerator();
                while ($it1244.MoveNext()){
                    var xx = $it1244.get_Current();
                    if (xx.get_Par0() > start.Value)
                        start.Value = xx.get_Par0();
                }
            }
            else {
                start.Value = spline.get_ParEnd();
                var $it1245 = intersections.GetEnumerator();
                while ($it1245.MoveNext()){
                    var xx = $it1245.get_Current();
                    if (xx.get_Par0() < start.Value)
                        start.Value = xx.get_Par0();
                }
            }
        },
        PolylineAroundClosedCurve: function (curve){
            var ret;
            var ellipse = As(curve, Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor);
            if (ellipse != null)
                ret = Microsoft.Msagl.Core.Geometry.Curves.Curve.RefineEllipse(ellipse);
            else {
                var poly = As(curve, Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
                if (poly != null)
                    return poly;
                var c = As(curve, Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor);
                if (c != null && Microsoft.Msagl.Core.Geometry.Curves.Curve.AllSegsAreLines(c)){
                    ret = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
                    var $it1246 = c.get_Segments().GetEnumerator();
                    while ($it1246.MoveNext()){
                        var ls = $it1246.get_Current();
                        ret.AddPoint$$Point(ls.get_Start());
                    }
                    ret.set_Closed(true);
                    if (!ret.IsClockwise())
                        ret = Cast(ret.Reverse(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
                }
                else
                    ret = Microsoft.Msagl.Core.Geometry.Curves.Curve.StandardRectBoundary(curve);
            }
            return ret;
        },
        AllSegsAreLines: function (c){
            var $it1247 = c.get_Segments().GetEnumerator();
            while ($it1247.MoveNext()){
                var s = $it1247.get_Current();
                if (!(Is(s, Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor)))
                    return false;
            }
            return true;
        },
        RefineEllipse: function (ellipse){
            var rect = Microsoft.Msagl.Core.Geometry.Curves.Curve.StandardRectBoundary(ellipse);
            var dict = new System.Collections.Generic.SortedDictionary$2.ctor(System.Double.ctor, Microsoft.Msagl.Core.Geometry.Point.ctor);
            var a = 0.785398163397448;
            var w = ellipse.get_BoundingBox().get_Width();
            var h = ellipse.get_BoundingBox().get_Height();
            var l = System.Math.Sqrt(w * w + h * h);
            for (var i = 0; i < 4; i++){
                var t = a + i * 3.14159265358979 / 2;
                var p = ellipse.get_Item$$Double(t);
                var tan = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(l, (ellipse.Derivative(t).Normalize()));
                var ls = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(p, tan), Microsoft.Msagl.Core.Geometry.Point.op_Addition(p, tan));
                var $it1248 = Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(rect, ls, true).GetEnumerator();
                while ($it1248.MoveNext()){
                    var ix = $it1248.get_Current();
                    dict.set_Item$$TKey(ix.get_Par0(), ix.get_IntersectionPoint());
                }
            }
            System.Diagnostics.Debug.Assert$$Boolean(dict.get_Count() > 0);
            return (function (){
                var $v127 = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor$$IEnumerable$1$Point(dict.get_Values());
                $v127.set_Closed(true);
                return $v127;
            })();
        },
        StandardRectBoundary: function (curve){
            var bbox = curve.get_BoundingBox();
            return bbox.Perimeter();
        },
        PolyFromBox: function (rectangle){
            var p = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
            p.AddPoint$$Point(rectangle.get_LeftTop());
            p.AddPoint$$Point(rectangle.get_RightTop());
            p.AddPoint$$Point(rectangle.get_RightBottom());
            p.AddPoint$$Point(rectangle.get_LeftBottom());
            p.set_Closed(true);
            return p;
        },
        CreateLineCurve: function (route){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(route, "route");
            var curve = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor$$Int32(route.get_Count());
            for (var i = 0; i + 1 < route.get_Count(); i++)
                curve.AddSegment(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(route.get_Item$$Int32(i), route.get_Item$$Int32(i + 1)));
            return curve;
        },
        LengthWithInterpolation: function (curve){
            var ret = 0;
            var $it1252 = Microsoft.Msagl.Core.Geometry.Curves.Curve.Interpolate$$ICurve$$Double(curve, Microsoft.Msagl.Core.Geometry.Curves.Curve.lineSegThreshold).GetEnumerator();
            while ($it1252.MoveNext()){
                var ls = $it1252.get_Current();
                ret += ls.get_Length();
            }
            return ret;
        },
        LengthWithInterpolationAndThreshold: function (curve, threshold){
            var ret = 0;
            var $it1253 = Microsoft.Msagl.Core.Geometry.Curves.Curve.Interpolate$$ICurve$$Double(curve, threshold).GetEnumerator();
            while ($it1253.MoveNext()){
                var ls = $it1253.get_Current();
                ret += ls.get_Length();
            }
            return ret;
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Core.Geometry.Curves.ICurve"],
    Kind: "Class",
    definition: {
        ctor: function (){
            this.pBNode = null;
            this.segs = null;
            this.parStart = 0;
            this.parEnd = 0;
            System.Object.ctor.call(this);
            this.segs = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor);
        },
        Reverse: function (){
            var ret = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor$$Int32(this.segs.get_Count());
            for (var i = this.segs.get_Count() - 1; i >= 0; i--)
                ret.AddSegment(this.segs.get_Item$$Int32(i).Reverse());
            return ret;
        },
        ctor$$Int32: function (segmentCapacity){
            this.pBNode = null;
            this.segs = null;
            this.parStart = 0;
            this.parEnd = 0;
            System.Object.ctor.call(this);
            this.segs = new System.Collections.Generic.List$1.ctor$$Int32(Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor, segmentCapacity);
        },
        ctor$$List$1$ICurve: function (segs){
            this.pBNode = null;
            this.segs = null;
            this.parStart = 0;
            this.parEnd = 0;
            System.Object.ctor.call(this);
            this.segs = segs;
            this.set_ParStart(0);
            var $it1216 = segs.GetEnumerator();
            while ($it1216.MoveNext()){
                var s = $it1216.get_Current();
                this.set_ParEnd(this.get_ParEnd() + s.get_ParEnd() - s.get_ParStart());
            }
        },
        Start$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Start: function (){
            return this.segs.get_Item$$Int32(0).get_Start();
        },
        End$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_End: function (){
            return this.segs.get_Item$$Int32(this.segs.get_Count() - 1).get_End();
        },
        Trim: function (start, end){
            (function (){
                var $1 = {
                    Value: start
                };
                var $2 = {
                    Value: end
                };
                var $res = this.AdjustStartEndEndParametersToDomain($1, $2);
                start = $1.Value;
                end = $2.Value;
                return $res;
            }).call(this);
            var sseg;
            var spar;
            (function (){
                var $1 = {
                    Value: spar
                };
                var $2 = {
                    Value: sseg
                };
                var $res = this.GetSegmentAndParameter$$Double$$Double$$Int32(start, $1, $2);
                spar = $1.Value;
                sseg = $2.Value;
                return $res;
            }).call(this);
            var eseg;
            var epar;
            (function (){
                var $1 = {
                    Value: epar
                };
                var $2 = {
                    Value: eseg
                };
                var $res = this.GetSegmentAndParameter$$Double$$Double$$Int32(end, $1, $2);
                epar = $1.Value;
                eseg = $2.Value;
                return $res;
            }).call(this);
            if (sseg == eseg)
                return this.get_Segments().get_Item$$Int32(sseg).Trim(spar, epar);
            var c = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor$$Int32(eseg - sseg + 1);
            if (spar < this.get_Segments().get_Item$$Int32(sseg).get_ParEnd())
                c = c.AddSegment(this.get_Segments().get_Item$$Int32(sseg).Trim(spar, this.get_Segments().get_Item$$Int32(sseg).get_ParEnd()));
            for (var i = sseg + 1; i < eseg; i++)
                c = c.AddSegment(this.get_Segments().get_Item$$Int32(i));
            if (this.get_Segments().get_Item$$Int32(eseg).get_ParStart() < epar)
                c = c.AddSegment(this.get_Segments().get_Item$$Int32(eseg).Trim(this.get_Segments().get_Item$$Int32(eseg).get_ParStart(), epar));
            return c;
        },
        AdjustStartEndEndParametersToDomain: function (start, end){
            if (start.Value > end.Value){
                var t = start.Value;
                start.Value = end.Value;
                end.Value = t;
            }
            if (start.Value < this.get_ParStart())
                start.Value = this.get_ParStart();
            if (end.Value > this.get_ParEnd())
                end.Value = this.get_ParEnd();
        },
        TrimWithWrap: function (start, end){
            System.Diagnostics.Debug.Assert$$Boolean(start >= this.get_ParStart() && start <= this.get_ParEnd());
            System.Diagnostics.Debug.Assert$$Boolean(end >= this.get_ParStart() && end <= this.get_ParEnd());
            if (start < end)
                return As(this.Trim(start, end), Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor);
            System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(this.get_Start(), this.get_End()), "Curve must be closed to wrap");
            var c = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor();
            c.AddSegment(As(this.Trim(start, this.get_ParEnd()), Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor));
            c.AddSegment(As(this.Trim(this.get_ParStart(), end), Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor));
            return c;
        },
        AddSegment: function (curve){
            if (curve == null)
                return this;
            this.set_ParStart(0);
            var c = As(curve, Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor);
            if (c == null){
                this.segs.Add(curve);
                this.set_ParEnd(this.get_ParEnd() + curve.get_ParEnd() - curve.get_ParStart());
            }
            else {
                this.IncreaseSegmentCapacity(c.get_Segments().get_Count());
                var $it1217 = c.get_Segments().GetEnumerator();
                while ($it1217.MoveNext()){
                    var cc = $it1217.get_Current();
                    this.segs.Add(cc);
                    this.set_ParEnd(this.get_ParEnd() + cc.get_ParEnd() - cc.get_ParStart());
                }
            }
            return this;
        },
        IncreaseSegmentCapacity: function (additionalAmount){
            var capacityNeeded = this.segs.get_Count() + additionalAmount;
            if (this.segs.get_Capacity() < capacityNeeded){
                var capacity = System.Math.Max$$Int32$$Int32(this.segs.get_Capacity(), 1);
                while (capacity < capacityNeeded)
                    capacity *= 2;
                this.segs.set_Capacity(capacity);
            }
        },
        AddSegs$$ICurve$$ICurve: function (a, b){
            var c = this.AddSegment(a);
            return c.AddSegment(b);
        },
        AddSegs$$ICurve$$ICurve$$ICurve$$ICurve: function (a, b, c, d){
            this.IncreaseSegmentCapacity(4);
            var r = this.AddSegment(a);
            r = r.AddSegment(b);
            r = r.AddSegment(c);
            return r.AddSegment(d);
        },
        Segments$$: "System.Collections.Generic.IList`1[[Microsoft.Msagl.Core.Geometry.Curves.ICurve]]",
        get_Segments: function (){
            return this.segs;
        },
        ParallelogramNodeOverICurve$$: "Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve",
        get_ParallelogramNodeOverICurve: function (){
            if (this.pBNode != null)
                return this.pBNode;
            this.pBNode = new Microsoft.Msagl.Core.Geometry.Curves.ParallelogramInternalTreeNode.ctor(this, Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.DefaultLeafBoxesOffset);
            var parallelograms = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.ctor);
            var $it1218 = this.segs.GetEnumerator();
            while ($it1218.MoveNext()){
                var curveSeg = $it1218.get_Current();
                var pBoxNode = curveSeg.get_ParallelogramNodeOverICurve();
                parallelograms.Add(pBoxNode.get_Parallelogram());
                this.pBNode.AddChild(pBoxNode);
            }
            this.pBNode.set_Parallelogram(Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.GetParallelogramOfAGroup(parallelograms));
            return this.pBNode;
        },
        GetSegmentAndParameter$$Double$$Double$$ICurve: function (t, par, segment){
            var u = this.get_ParStart();
            var $it1233 = this.segs.GetEnumerator();
            while ($it1233.MoveNext()){
                var sg = $it1233.get_Current();
                var domLen = sg.get_ParEnd() - sg.get_ParStart();
                if (t >= u && t <= u + domLen){
                    par.Value = t - u + sg.get_ParStart();
                    segment.Value = sg;
                    return;
                }
                u += domLen;
            }
            segment.Value = System.Linq.Enumerable.Last$1$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Curves.ICurve.ctor, this.segs);
            par.Value = segment.Value.get_ParEnd();
        },
        GetSegmentAndParameter$$Double$$Double$$Int32: function (t, par, segIndex){
            var u = 0;
            segIndex.Value = 0;
            par.Value = -1;
            for (var i = 0; i < this.segs.get_Count(); i++){
                var sg = this.segs.get_Item$$Int32(i);
                var domLen = sg.get_ParEnd() - sg.get_ParStart();
                if (t >= u && (t <= u + domLen || (i == this.segs.get_Count() - 1 && Microsoft.Msagl.Core.Geometry.ApproximateComparer.Compare(t, u + domLen) <= 0))){
                    par.Value = t - u + sg.get_ParStart();
                    return;
                }
                segIndex.Value++;
                u += domLen;
            }
            throw $CreateException(new System.InvalidOperationException.ctor$$String(System.String.Format$$String$$Object$Array("Check, args t:{0}, par:{1}, segIndex:{2} and u:{3}", [t, par.Value, segIndex.Value, u])), new Error());
        },
        Item$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Item$$Double: function (t){
            var par;
            var seg;
            (function (){
                var $1 = {
                    Value: par
                };
                var $2 = {
                    Value: seg
                };
                var $res = this.GetSegmentAndParameter$$Double$$Double$$ICurve(t, $1, $2);
                par = $1.Value;
                seg = $2.Value;
                return $res;
            }).call(this);
            return seg.get_Item$$Double(par);
        },
        Derivative: function (t){
            var par;
            var seg;
            (function (){
                var $1 = {
                    Value: par
                };
                var $2 = {
                    Value: seg
                };
                var $res = this.GetSegmentAndParameter$$Double$$Double$$ICurve(t, $1, $2);
                par = $1.Value;
                seg = $2.Value;
                return $res;
            }).call(this);
            return seg.Derivative(par);
        },
        SecondDerivative: function (t){
            var par;
            var seg;
            (function (){
                var $1 = {
                    Value: par
                };
                var $2 = {
                    Value: seg
                };
                var $res = this.GetSegmentAndParameter$$Double$$Double$$ICurve(t, $1, $2);
                par = $1.Value;
                seg = $2.Value;
                return $res;
            }).call(this);
            return seg.SecondDerivative(par);
        },
        ThirdDerivative: function (t){
            var par;
            var seg;
            (function (){
                var $1 = {
                    Value: par
                };
                var $2 = {
                    Value: seg
                };
                var $res = this.GetSegmentAndParameter$$Double$$Double$$ICurve(t, $1, $2);
                par = $1.Value;
                seg = $2.Value;
                return $res;
            }).call(this);
            return seg.ThirdDerivative(par);
        },
        OffsetCurve: function (offset, dir){
            return null;
        },
        BoundingBox$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_BoundingBox: function (){
            if (this.get_Segments().get_Count() == 0)
                return new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Double$$Double$$Double$$Double(0, 0, -1, -1);
            var b = this.get_Segments().get_Item$$Int32(0).get_BoundingBox();
            for (var i = 1; i < this.get_Segments().get_Count(); i++)
                b.Add$$Rectangle(this.get_Segments().get_Item$$Int32(i).get_BoundingBox());
            return b;
        },
        Clone: function (){
            var c = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor$$Int32(this.get_Segments().get_Count());
            var $it1236 = this.get_Segments().GetEnumerator();
            while ($it1236.MoveNext()){
                var seg = $it1236.get_Current();
                c.AddSegment(seg.Clone());
            }
            return c;
        },
        GetParameterAtLength: function (length){
            var parSpan = 0;
            var $it1237 = this.get_Segments().GetEnumerator();
            while ($it1237.MoveNext()){
                var seg = $it1237.get_Current();
                var segL = seg.get_Length();
                if (segL >= length)
                    return parSpan + seg.GetParameterAtLength(length);
                length -= segL;
                parSpan += seg.get_ParEnd() - seg.get_ParStart();
            }
            return this.get_ParEnd();
        },
        ClosestParameterWithinBounds: function (targetPoint, low, high){
            var par = 0;
            var dist = 1.79769313486232E+308;
            var offset = 0;
            var $it1238 = this.get_Segments().GetEnumerator();
            while ($it1238.MoveNext()){
                var seg = $it1238.get_Current();
                if (offset > high)
                    break;
                var segParamSpan = Microsoft.Msagl.Core.Geometry.Curves.Curve.ParamSpan(seg);
                var segEnd = offset + segParamSpan;
                if (segEnd >= low){
                    var segLow = System.Math.Max$$Double$$Double(seg.get_ParStart(), seg.get_ParStart() + (low - offset));
                    var segHigh = System.Math.Min$$Double$$Double(seg.get_ParEnd(), seg.get_ParStart() + (high - offset));
                    System.Diagnostics.Debug.Assert$$Boolean(segHigh >= segLow);
                    var t = seg.ClosestParameterWithinBounds(targetPoint, segLow, segHigh);
                    var d = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(targetPoint, seg.get_Item$$Double(t));
                    var dd = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(d, d);
                    if (dd < dist){
                        par = offset + t - seg.get_ParStart();
                        dist = dd;
                    }
                }
                offset += segParamSpan;
            }
            return par;
        },
        ClosestParameter: function (targetPoint){
            var par = 0;
            var dist = 1.79769313486232E+308;
            var offset = 0;
            var $it1239 = this.get_Segments().GetEnumerator();
            while ($it1239.MoveNext()){
                var c = $it1239.get_Current();
                var t = c.ClosestParameter(targetPoint);
                var d = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(targetPoint, c.get_Item$$Double(t));
                var dd = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(d, d);
                if (dd < dist){
                    par = offset + t - c.get_ParStart();
                    dist = dd;
                }
                offset += Microsoft.Msagl.Core.Geometry.Curves.Curve.ParamSpan(c);
            }
            return par;
        },
        LeftDerivative: function (t){
            var seg = this.TryToGetLeftSegment(t);
            if (seg != null)
                return seg.Derivative(seg.get_ParEnd());
            return this.Derivative(t);
        },
        RightDerivative: function (t){
            var seg = this.TryToGetRightSegment(t);
            if (seg != null)
                return seg.Derivative(seg.get_ParStart());
            return this.Derivative(t);
        },
        TryToGetLeftSegment: function (t){
            if (System.Math.Abs$$Double(t - this.get_ParStart()) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance()){
                if (Microsoft.Msagl.Core.Geometry.Point.op_Equality(this.get_Start(), this.get_End()))
                    return this.get_Segments().get_Item$$Int32(this.get_Segments().get_Count() - 1);
                return null;
            }
            var $it1240 = this.get_Segments().GetEnumerator();
            while ($it1240.MoveNext()){
                var seg = $it1240.get_Current();
                t -= Microsoft.Msagl.Core.Geometry.Curves.Curve.ParamSpan(seg);
                if (System.Math.Abs$$Double(t) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                    return seg;
            }
            return null;
        },
        TryToGetRightSegment: function (t){
            if (System.Math.Abs$$Double(t - this.get_ParEnd()) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance()){
                if (Microsoft.Msagl.Core.Geometry.Point.op_Equality(this.get_Start(), this.get_End()))
                    return this.get_Segments().get_Item$$Int32(0);
                return null;
            }
            var $it1241 = this.get_Segments().GetEnumerator();
            while ($it1241.MoveNext()){
                var seg = $it1241.get_Current();
                if (System.Math.Abs$$Double(t) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                    return seg;
                t -= Microsoft.Msagl.Core.Geometry.Curves.Curve.ParamSpan(seg);
            }
            return null;
        },
        Curvature: function (t){
            var seg;
            var par;
            (function (){
                var $1 = {
                    Value: par
                };
                var $2 = {
                    Value: seg
                };
                var $res = this.GetSegmentAndParameter$$Double$$Double$$ICurve(t, $1, $2);
                par = $1.Value;
                seg = $2.Value;
                return $res;
            }).call(this);
            return seg.Curvature(par);
        },
        CurvatureDerivative: function (t){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        CurvatureSecondDerivative: function (t){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        ParStart$$: "System.Double",
        get_ParStart: function (){
            return this.parStart;
        },
        set_ParStart: function (value){
            this.parStart = value;
        },
        ParEnd$$: "System.Double",
        get_ParEnd: function (){
            return this.parEnd;
        },
        set_ParEnd: function (value){
            this.parEnd = value;
        },
        Translate: function (delta){
            var $it1249 = this.segs.GetEnumerator();
            while ($it1249.MoveNext()){
                var s = $it1249.get_Current();
                s.Translate(delta);
            }
            this.pBNode = null;
        },
        ScaleFromOrigin: function (xScale, yScale){
            var c = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor$$Int32(this.segs.get_Count());
            var $it1250 = this.segs.GetEnumerator();
            while ($it1250.MoveNext()){
                var s = $it1250.get_Current();
                c.AddSegment(s.ScaleFromOrigin(xScale, yScale));
            }
            return c;
        },
        Transform: function (transformation){
            var c = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor$$Int32(this.segs.get_Count());
            var $it1251 = this.segs.GetEnumerator();
            while ($it1251.MoveNext()){
                var s = $it1251.get_Current();
                c.AddSegment(s.Transform(transformation));
            }
            return c;
        },
        LengthPartial: function (start, end){
            var s,e;
            var i,j;
            (function (){
                var $1 = {
                    Value: start
                };
                var $2 = {
                    Value: end
                };
                var $res = this.AdjustStartEndEndParametersToDomain($1, $2);
                start = $1.Value;
                end = $2.Value;
                return $res;
            }).call(this);
            (function (){
                var $1 = {
                    Value: s
                };
                var $2 = {
                    Value: i
                };
                var $res = this.GetSegmentAndParameter$$Double$$Double$$Int32(start, $1, $2);
                s = $1.Value;
                i = $2.Value;
                return $res;
            }).call(this);
            (function (){
                var $1 = {
                    Value: e
                };
                var $2 = {
                    Value: j
                };
                var $res = this.GetSegmentAndParameter$$Double$$Double$$Int32(end, $1, $2);
                e = $1.Value;
                j = $2.Value;
                return $res;
            }).call(this);
            var seg = this.segs.get_Item$$Int32(i);
            var ret = seg.LengthPartial(s, seg.get_ParEnd());
            for (var k = i + 1; k < j; k++)
                ret += this.segs.get_Item$$Int32(k).get_Length();
            seg = this.segs.get_Item$$Int32(j);
            return ret + seg.LengthPartial(seg.get_ParStart(), e);
        },
        Length$$: "System.Double",
        get_Length: function (){
            var ret = 0;
            var $it1254 = this.segs.GetEnumerator();
            while ($it1254.MoveNext()){
                var ic = $it1254.get_Current();
                ret += ic.get_Length();
            }
            return ret;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$Curve);
var Microsoft$Msagl$Core$Geometry$Curves$CurveFactory = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.CurveFactory",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.octagonPad = 0.25;
        },
        CreateEllipse: function (radiusInXDirection, radiusInYDirection, center){
            return new Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor$$Double$$Double$$Point(radiusInXDirection, radiusInYDirection, center);
        },
        CreateCircle: function (radius, center){
            return new Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor$$Double$$Double$$Point(radius, radius, center);
        },
        CreateRectangleWithRoundedCorners$$Double$$Double$$Double$$Double$$Point: function (width, height, radiusInXDirection, radiusInYDirection, center){
            var box = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Double$$Double$$Double$$Double(center.get_X() - width / 2, center.get_Y() - height / 2, center.get_X() + width / 2, center.get_Y() + height / 2);
            return new Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.ctor$$Rectangle$$Double$$Double(box, radiusInXDirection, radiusInYDirection);
        },
        CreateRectangleWithRoundedCorners$$Curve$$Double$$Double$$Double$$Double$$Point: function (c, width, height, radiusInXDirection, radiusInYDirection, center){
            if (radiusInXDirection == 0 || radiusInYDirection == 0){
                Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateRectangle$$Curve$$Double$$Double$$Point(c, width, height, center);
                return;
            }
            var w = width / 2;
            if (radiusInXDirection > w / 2)
                radiusInXDirection = w / 2;
            var h = height / 2;
            if (radiusInYDirection > h / 2)
                radiusInYDirection = h / 2;
            var x = center.get_X();
            var y = center.get_Y();
            var ox = w - radiusInXDirection;
            var oy = h - radiusInYDirection;
            var top = y + h;
            var bottom = y - h;
            var left = x - w;
            var right = x + w;
            var a = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(radiusInXDirection, 0);
            var b = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, radiusInYDirection);
            c.IncreaseSegmentCapacity(8);
            if (ox > 0)
                c.AddSegment(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x - ox, bottom), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x + ox, bottom)));
            c.AddSegment(new Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor$$Double$$Double$$Point$$Point$$Double$$Double(4.71238898038469, 6.28318530717959, a, b, x + ox, y - oy));
            if (oy > 0)
                c.AddSegment(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(right, y - oy), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(right, y + oy)));
            c.AddSegment(new Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor$$Double$$Double$$Point$$Point$$Double$$Double(0, 1.5707963267949, a, b, x + ox, y + oy));
            if (ox > 0)
                c.AddSegment(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x + ox, top), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x - ox, top)));
            c.AddSegment(new Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor$$Double$$Double$$Point$$Point$$Double$$Double(1.5707963267949, 3.14159265358979, a, b, x - ox, y + oy));
            if (oy > 0)
                c.AddSegment(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(left, y + oy), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(left, y - oy)));
            c.AddSegment(new Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor$$Double$$Double$$Point$$Point$$Double$$Double(3.14159265358979, 4.71238898038469, a, b, x - ox, y - oy));
        },
        CreateRectangle$$Double$$Double$$Point: function (width, height, center){
            var w = width / 2;
            var h = height / 2;
            var x = center.get_X();
            var y = center.get_Y();
            var c = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor();
            var p = [new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x - w, y - h), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x + w, y - h), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x + w, y + h), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x - w, y + h)];
            c.AddSegs$$ICurve$$ICurve$$ICurve$$ICurve(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(p[0], p[1]), new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(p[1], p[2]), new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(p[2], p[3]), new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(p[3], p[0]));
            return c;
        },
        CreateRectangle$$Curve$$Double$$Double$$Point: function (c, width, height, center){
            var w = width / 2;
            var h = height / 2;
            var x = center.get_X();
            var y = center.get_Y();
            var p = [new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x - w, y - h), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x + w, y - h), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x + w, y + h), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x - w, y + h)];
            c.AddSegs$$ICurve$$ICurve$$ICurve$$ICurve(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(p[0], p[1]), new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(p[1], p[2]), new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(p[2], p[3]), new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(p[3], p[0]));
        },
        CreateRectangle$$Rectangle: function (rectangle){
            return Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateRectangle$$Double$$Double$$Point(rectangle.get_Width(), rectangle.get_Height(), rectangle.get_Center());
        },
        CreateHouse: function (width, height, center){
            var w = width / 2;
            var h = height / 2;
            var x = center.get_X();
            var y = center.get_Y();
            var c = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor$$Int32(4);
            Microsoft.Msagl.Core.Geometry.Curves.Curve.AddLineSegment$$Curve$$Double$$Double$$Double$$Double(c, x - w, y - h, x + w, y - h);
            Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Double$$Double(c, x + w, y + h);
            Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Double$$Double(c, x, y + 2 * h);
            Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Double$$Double(c, x - w, y + h);
            Microsoft.Msagl.Core.Geometry.Curves.Curve.CloseCurve(c);
            return c;
        },
        CreateInteriorHouse: function (width, height, center){
            var w = width / 2;
            var h = height / 2;
            var x = center.get_X();
            var y = center.get_Y();
            var c = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor$$Int32(4);
            Microsoft.Msagl.Core.Geometry.Curves.Curve.AddLineSegment$$Curve$$Double$$Double$$Double$$Double(c, x - w, y - h, x + w, y - h);
            Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Double$$Double(c, x + w, y);
            Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Double$$Double(c, x, y + h);
            Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Double$$Double(c, x - w, y);
            Microsoft.Msagl.Core.Geometry.Curves.Curve.CloseCurve(c);
            return c;
        },
        CreateInvertedHouse: function (width, height, center){
            var shape = Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateHouse(width, height, center);
            return Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.RotateCurveAroundCenterByDegree(shape, center, 180);
        },
        CreateDiamond: function (width, height, center){
            var w = width;
            var h = height;
            var x = center.get_X();
            var y = center.get_Y();
            var c = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor();
            var p = [new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x, y - h), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x + w, y), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x, y + h), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x - w, y)];
            c.AddSegs$$ICurve$$ICurve$$ICurve$$ICurve(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(p[0], p[1]), new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(p[1], p[2]), new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(p[2], p[3]), new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(p[3], p[0]));
            return c;
        },
        CreateInteriorDiamond: function (width, height, center){
            return Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateDiamond(width / 2, height / 2, center);
        },
        CreateOctagon: function (width, height, center){
            var w = width / 2;
            var h = height / 2;
            var ps = new Array(8);
            ps[0] = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(w + (Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.octagonPad * w), h - (h * Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.octagonPad));
            ps[3] = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-ps[0].get_X(), ps[0].get_Y());
            ps[4] = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(ps[3].get_X(), -ps[3].get_Y());
            ps[7] = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(ps[0].get_X(), -ps[0].get_Y());
            ps[1] = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(w - (w * Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.octagonPad), h + (h * Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.octagonPad));
            ps[2] = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-ps[1].get_X(), ps[1].get_Y());
            ps[6] = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(ps[1].get_X(), -ps[1].get_Y());
            ps[5] = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(ps[2].get_X(), -ps[2].get_Y());
            for (var i = 0; i < 8; i++){
                ps[i] = Microsoft.Msagl.Core.Geometry.Point.op_Addition(ps[i], center);
            }
            var c = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor$$Int32(8);
            Microsoft.Msagl.Core.Geometry.Curves.Curve.AddLineSegment$$Curve$$Point$$Point(c, ps[0], ps[1]);
            for (var i = 2; i < 8; i++)
                Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Point(c, ps[i]);
            Microsoft.Msagl.Core.Geometry.Curves.Curve.CloseCurve(c);
            return c;
        },
        CreateHexagon: function (width, height, center){
            var w = width / 2;
            var ps = new Array(6);
            ps[0] = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(w, 0);
            for (var i = 1; i < 6; i++)
                ps[i] = ps[i - 1].Rotate(1.0471975511966);
            var al = height / width;
            for (var i = 0; i < 6; i++)
                ps[i].set_Y(ps[i].get_Y() * al);
            for (var i = 0; i < 6; i++)
                ps[i] = Microsoft.Msagl.Core.Geometry.Point.op_Addition(ps[i], center);
            var poly = (function (){
                var $v128 = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor$$Point$Array(ps);
                $v128.set_Closed(true);
                return $v128;
            })();
            return poly;
        },
        CreateInteriorOctagon: function (width, height, center){
            return Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateOctagon(width / (1 + Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.octagonPad), height / (1 + Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.octagonPad), center);
        },
        CreateTestShape: function (width, height){
            var mult = 1;
            var w = width * 3;
            var h = height * 3;
            var curve = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor$$Int32(9);
            Microsoft.Msagl.Core.Geometry.Curves.Curve.AddLineSegment$$Curve$$Double$$Double$$Double$$Double(curve, -w, -h, 0, -h / 2);
            Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Double$$Double(curve, w / 2, -0.75 * h);
            Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Double$$Double(curve, w, -h);
            Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Double$$Double(curve, 0.75 * w, -h / 2);
            Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Double$$Double(curve, w / 2, 0);
            Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Double$$Double(curve, w, h);
            Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Double$$Double(curve, 0, h / 2);
            Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Double$$Double(curve, -w, mult * h);
            Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Double$$Double(curve, -w / 3, 0);
            Microsoft.Msagl.Core.Geometry.Curves.Curve.CloseCurve(curve);
            return curve;
        },
        CreateInteriorTriangle: function (width, height, center){
            var w = width / 2;
            var h = height / 2;
            var x = center.get_X();
            var y = center.get_Y();
            var c = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor$$Int32(3);
            var p = [new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x - w, y - h), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x + w, y - h), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x, y + h)];
            c.AddSegment(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(p[0], p[1]));
            c.AddSegment(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(p[1], p[2]));
            c.AddSegment(new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(p[2], p[0]));
            return c;
        },
        RotateCurveAroundCenterByRadian: function (curve, center, angle){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(curve, "curve");
            var c = System.Math.Cos(angle);
            var s = System.Math.Sin(angle);
            var transform = Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$PlaneTransformation(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$PlaneTransformation(new Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.ctor$$Double$$Double$$Double$$Double$$Double$$Double(1, 0, center.get_X(), 0, 1, center.get_Y()), new Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.ctor$$Double$$Double$$Double$$Double$$Double$$Double(c, -s, 0, s, c, 0)), new Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.ctor$$Double$$Double$$Double$$Double$$Double$$Double(1, 0, -center.get_X(), 0, 1, -center.get_Y()));
            return curve.Transform(transform);
        },
        RotateCurveAroundCenterByDegree: function (curve, center, degree){
            return Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.RotateCurveAroundCenterByRadian(curve, center, degree * (0.0174532925199433));
        },
        CreateStar: function (width, center){
            var a = 1.25663706143592;
            var r2 = width / (2 * System.Math.Sin(a));
            var r = r2 / 2;
            return (function (){
                var $v129 = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor$$IEnumerable$1$Point(Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.StarPoints(r, r2, center, a));
                $v129.set_Closed(true);
                return $v129;
            })();
        },
        StarPoints: function (r, r2, center, a){
            var $yield = [];
            var ang = 1.5707963267949;
            var anghalf = a / 2;
            for (var i = 0; i < 5; i++){
                $yield.push(Microsoft.Msagl.Core.Geometry.Point.op_Addition(center, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(r2, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(System.Math.Cos(ang), System.Math.Sin(ang)))));
                $yield.push(Microsoft.Msagl.Core.Geometry.Point.op_Addition(center, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(r, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(System.Math.Cos(ang + anghalf), System.Math.Sin(ang + anghalf)))));
                ang += a;
            }
            return $yield;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$CurveFactory);
var Microsoft$Msagl$Core$Geometry$Curves$CurveTangent = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.CurveTangent",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (touch, direction){
            this.touchPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.direction = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            System.Object.ctor.call(this);
            this.touchPoint = touch;
            this.direction = direction;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$CurveTangent);
var Microsoft$Msagl$Core$Geometry$Curves$Ellipse = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.Ellipse",
    baseTypeName: "System.Object",
    staticDefinition: {
        CreateNodeWithSegmentSplit: function (start, end, seg, eps){
            var pBNode = new Microsoft.Msagl.Core.Geometry.Curves.ParallelogramInternalTreeNode.ctor(seg, eps);
            pBNode.AddChild(Microsoft.Msagl.Core.Geometry.Curves.Ellipse.CreateParallelogramNodeForCurveSeg$$Double$$Double$$Ellipse$$Double(start, 0.5 * (start + end), seg, eps));
            pBNode.AddChild(Microsoft.Msagl.Core.Geometry.Curves.Ellipse.CreateParallelogramNodeForCurveSeg$$Double$$Double$$Ellipse$$Double(0.5 * (start + end), end, seg, eps));
            var boxes = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.ctor);
            boxes.Add(pBNode.get_Children().get_Item$$Int32(0).get_Parallelogram());
            boxes.Add(pBNode.get_Children().get_Item$$Int32(1).get_Parallelogram());
            pBNode.set_Parallelogram(Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.GetParallelogramOfAGroup(boxes));
            return pBNode;
        },
        CreateParallelogramNodeForCurveSeg$$Double$$Double$$Ellipse$$Double: function (start, end, seg, eps){
            var closedSeg = (start == seg.get_ParStart() && end == seg.get_ParEnd() && Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(seg.get_Start(), seg.get_End()));
            if (closedSeg)
                return Microsoft.Msagl.Core.Geometry.Curves.Ellipse.CreateNodeWithSegmentSplit(start, end, seg, eps);
            var s = seg.get_Item$$Double(start);
            var e = seg.get_Item$$Double(end);
            var w = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(e, s);
            var middle = seg.get_Item$$Double((start + end) / 2);
            if (Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.DistToSegm(middle, s, e) <= Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_IntersectionEpsilon() && Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(w, w) < Microsoft.Msagl.Core.Geometry.Curves.Curve.get_LineSegmentThreshold() * Microsoft.Msagl.Core.Geometry.Curves.Curve.get_LineSegmentThreshold() && end - start < Microsoft.Msagl.Core.Geometry.Curves.Curve.get_LineSegmentThreshold()){
                var ls = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(s, e);
                var leaf = As(ls.get_ParallelogramNodeOverICurve(), Microsoft.Msagl.Core.Geometry.Curves.ParallelogramLeaf.ctor);
                leaf.set_Low(start);
                leaf.set_High(end);
                leaf.set_Seg(seg);
                leaf.set_Chord(ls);
                return leaf;
            }
            var we = Microsoft.Msagl.Core.Geometry.Curves.Ellipse.WithinEpsilon(seg, start, end, eps);
            var box = new Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.ctor();
            if (we && (function (){
                var $1 = {
                    Value: box
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.Ellipse.CreateParallelogramOnSubSeg(start, end, seg, $1);
                box = $1.Value;
                return $res;
            })()){
                return new Microsoft.Msagl.Core.Geometry.Curves.ParallelogramLeaf.ctor(start, end, box, seg, eps);
            }
            else {
                return Microsoft.Msagl.Core.Geometry.Curves.Ellipse.CreateNodeWithSegmentSplit(start, end, seg, eps);
            }
        },
        CreateParallelogramOnSubSeg: function (start, end, seg, box){
            var tan1 = seg.Derivative(start);
            var tan2 = seg.Derivative(end);
            var tan2Perp = Microsoft.Msagl.Core.Geometry.Point.P(-tan2.get_Y(), tan2.get_X());
            var corner = seg.get_Item$$Double(start);
            var e = seg.get_Item$$Double(end);
            var p = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(e, corner);
            var numerator = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(p, tan2Perp);
            var denumerator = (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(tan1, tan2Perp));
            var x;
            if (System.Math.Abs$$Double(numerator) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                x = 0;
            else if (System.Math.Abs$$Double(denumerator) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                return false;
            }
            else
                x = numerator / denumerator;
            tan1 = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(tan1, x);
            box.Value = new Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.ctor$$Point$$Point$$Point(corner, tan1, Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(e, corner), tan1));
            return true;
        },
        WithinEpsilon: function (seg, start, end, eps){
            var n = 3;
            var d = (end - start) / n;
            var s = seg.get_Item$$Double(start);
            var e = seg.get_Item$$Double(end);
            var d0 = Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.DistToSegm(seg.get_Item$$Double(start + d), s, e);
            if (d0 > eps)
                return false;
            var d1 = Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.DistToSegm(seg.get_Item$$Double(start + d * (n - 1)), s, e);
            return d1 <= eps;
        },
        CreateParallelogramNodeForCurveSeg$$Ellipse: function (seg){
            return Microsoft.Msagl.Core.Geometry.Curves.Ellipse.CreateParallelogramNodeForCurveSeg$$Double$$Double$$Ellipse$$Double(seg.get_ParStart(), seg.get_ParEnd(), seg, Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.DefaultLeafBoxesOffset);
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Core.Geometry.Curves.ICurve"],
    Kind: "Class",
    definition: {
        ctor$$Double$$Double$$Point$$Point$$Point: function (parStart, parEnd, axis0, axis1, center){
            this.box = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
            this.parallelogramNodeOverICurve = null;
            this.aAxis = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.bAxis = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.center = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.parStart = 0;
            this.parEnd = 0;
            System.Object.ctor.call(this);
            System.Diagnostics.Debug.Assert$$Boolean(parStart <= parEnd);
            this.set_ParStart(parStart);
            this.set_ParEnd(parEnd);
            this.set_AxisA(axis0);
            this.set_AxisB(axis1);
            this.center = center;
            this.SetBoundingBox();
        },
        OffsetCurve: function (offset, dir){
            var d = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(dir, this.center);
            var angle = Microsoft.Msagl.Core.Geometry.Point.Angle$$Point$$Point(this.aAxis, d);
            var s = Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(this.aAxis, System.Math.Cos(angle)), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(this.bAxis, System.Math.Sin(angle)));
            if (s.get_Length() < d.get_Length()){
                var al = this.aAxis.get_Length();
                var bl = this.bAxis.get_Length();
                return new Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor$$Point$$Point$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point((al + offset), this.aAxis.Normalize()), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point((bl + offset), this.bAxis.Normalize()), this.center);
            }
            var al = this.aAxis.get_Length();
            var bl = this.bAxis.get_Length();
            return new Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor$$Point$$Point$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point((al - offset), this.aAxis.Normalize()), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point((bl - offset), this.bAxis.Normalize()), this.center);
        },
        Reverse: function (){
            return null;
        },
        Start$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Start: function (){
            return this.get_Item$$Double(this.get_ParStart());
        },
        End$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_End: function (){
            return this.get_Item$$Double(this.get_ParEnd());
        },
        Trim: function (start, end){
            System.Diagnostics.Debug.Assert$$Boolean(start <= end);
            System.Diagnostics.Debug.Assert$$Boolean(start >= this.get_ParStart() - Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance());
            System.Diagnostics.Debug.Assert$$Boolean(end <= this.get_ParEnd() + Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance());
            return new Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor$$Double$$Double$$Point$$Point$$Point(System.Math.Max$$Double$$Double(start, this.get_ParStart()), System.Math.Min$$Double$$Double(end, this.get_ParEnd()), this.get_AxisA(), this.get_AxisB(), this.center);
        },
        TrimWithWrap: function (start, end){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        AxisA$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_AxisA: function (){
            return this.aAxis;
        },
        set_AxisA: function (value){
            this.aAxis = value;
        },
        AxisB$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_AxisB: function (){
            return this.bAxis;
        },
        set_AxisB: function (value){
            this.bAxis = value;
        },
        Center$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Center: function (){
            return this.center;
        },
        set_Center: function (value){
            this.center = value;
        },
        BoundingBox$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_BoundingBox: function (){
            return this.box;
        },
        Item$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Item$$Double: function (t){
            return Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.center, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(System.Math.Cos(t), this.aAxis)), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(System.Math.Sin(t), this.bAxis));
        },
        Derivative: function (t){
            return Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(-System.Math.Sin(t), this.aAxis), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(System.Math.Cos(t), this.bAxis));
        },
        SecondDerivative: function (t){
            return Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(-System.Math.Cos(t), this.aAxis), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(System.Math.Sin(t), this.bAxis));
        },
        ThirdDerivative: function (t){
            return Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(System.Math.Sin(t), this.aAxis), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(System.Math.Cos(t), this.bAxis));
        },
        ParallelogramNodeOverICurve$$: "Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve",
        get_ParallelogramNodeOverICurve: function (){
            if (this.parallelogramNodeOverICurve != null)
                return this.parallelogramNodeOverICurve;
            return this.parallelogramNodeOverICurve = Microsoft.Msagl.Core.Geometry.Curves.Ellipse.CreateParallelogramNodeForCurveSeg$$Ellipse(this);
        },
        ParStart$$: "System.Double",
        get_ParStart: function (){
            return this.parStart;
        },
        set_ParStart: function (value){
            this.parStart = value;
        },
        ParEnd$$: "System.Double",
        get_ParEnd: function (){
            return this.parEnd;
        },
        set_ParEnd: function (value){
            this.parEnd = value;
        },
        SetBoundingBox: function (){
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(this.get_ParStart(), 0) && Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(this.get_ParEnd(), 6.28318530717959))
                this.box = this.FullBox();
            else {
                this.box = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(this.get_Start(), this.get_End());
                var t;
                for (var i = (System.Math.Ceiling$$Double(this.get_ParStart() / (1.5707963267949))) | 0; (t = i * 3.14159265358979 / 2) < this.get_ParEnd(); i++)
                    if (t > this.parStart)
                        this.box.Add$$Point(this.get_Item$$Double(t));
            }
        },
        ctor$$Double$$Double$$Point$$Point$$Double$$Double: function (parStart, parEnd, axis0, axis1, centerX, centerY){
            this.box = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
            this.parallelogramNodeOverICurve = null;
            this.aAxis = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.bAxis = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.center = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.parStart = 0;
            this.parEnd = 0;
            Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor$$Double$$Double$$Point$$Point$$Point.call(this, parStart, parEnd, axis0, axis1, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(centerX, centerY));
        },
        ctor$$Point$$Point$$Point: function (axis0, axis1, center){
            this.box = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
            this.parallelogramNodeOverICurve = null;
            this.aAxis = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.bAxis = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.center = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.parStart = 0;
            this.parEnd = 0;
            Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor$$Double$$Double$$Point$$Point$$Point.call(this, 0, 6.28318530717959, axis0, axis1, center);
        },
        ctor$$Double$$Double$$Point: function (axisA, axisB, center){
            this.box = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor();
            this.parallelogramNodeOverICurve = null;
            this.aAxis = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.bAxis = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.center = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.parStart = 0;
            this.parEnd = 0;
            Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor$$Double$$Double$$Point$$Point$$Point.call(this, 0, 6.28318530717959, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(axisA, 0), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, axisB), center);
        },
        Translate: function (delta){
            this.center = Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.center, delta);
            this.box = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.center, this.bAxis), this.aAxis), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.center, this.bAxis), this.aAxis));
            this.parallelogramNodeOverICurve = null;
        },
        ScaleFromOrigin: function (xScale, yScale){
            return new Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor$$Double$$Double$$Point$$Point$$Point(this.parStart, this.parEnd, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(this.aAxis, xScale), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(this.bAxis, yScale), Microsoft.Msagl.Core.Geometry.Point.Scale(xScale, yScale, this.center));
        },
        GetParameterAtLength: function (length){
            var eps = 0.001;
            var l = this.get_ParStart();
            var u = this.get_ParEnd();
            var lenplus = length + eps;
            var lenminsu = length - eps;
            while (u - l > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                var m = 0.5 * (u + l);
                var len = this.LengthPartial(this.get_ParStart(), m);
                if (len > lenplus)
                    u = m;
                else if (len < lenminsu)
                    l = m;
                else
                    return m;
            }
            return (u + l) / 2;
        },
        Transform: function (transformation){
            if (Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Inequality(transformation, null)){
                var ap = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(transformation, this.aAxis), transformation.get_Offset());
                var bp = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(transformation, this.bAxis), transformation.get_Offset());
                return new Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor$$Double$$Double$$Point$$Point$$Point(this.parStart, this.parEnd, ap, bp, Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(transformation, this.center));
            }
            return this;
        },
        ClosestParameterWithinBounds: function (targetPoint, low, high){
            var numberOfTestPoints = 8;
            var t = (high - low) / 9;
            var closest = low;
            var minDist = 1.79769313486232E+308;
            for (var i = 0; i <= numberOfTestPoints; i++){
                var par = low + i * t;
                var p = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(targetPoint, this.get_Item$$Double(par));
                var d = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(p, p);
                if (d < minDist){
                    minDist = d;
                    closest = par;
                }
            }
            if (closest == 0 && high == 6.28318530717959)
                low = -3.14159265358979;
            var ret = Microsoft.Msagl.Core.Geometry.Curves.ClosestPointOnCurve.ClosestPoint(this, targetPoint, closest, low, high);
            if (ret < 0)
                ret += 6.28318530717959;
            return ret;
        },
        LengthPartial: function (start, end){
            return Microsoft.Msagl.Core.Geometry.Curves.Curve.LengthWithInterpolationAndThreshold(this.Trim(start, end), Microsoft.Msagl.Core.Geometry.Curves.Curve.get_LineSegmentThreshold() / 100);
        },
        Length$$: "System.Double",
        get_Length: function (){
            return Microsoft.Msagl.Core.Geometry.Curves.Curve.LengthWithInterpolation(this);
        },
        Clone: function (){
            return new Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor$$Double$$Double$$Point$$Point$$Point(this.parStart, this.parEnd, this.aAxis, this.bAxis, this.center);
        },
        ClosestParameter: function (targetPoint){
            var savedParStart = 0;
            var numberOfTestPoints = 8;
            var t = (this.get_ParEnd() - this.get_ParStart()) / 9;
            var closest = this.get_ParStart();
            var minDist = 1.79769313486232E+308;
            for (var i = 0; i <= numberOfTestPoints; i++){
                var par = this.get_ParStart() + i * t;
                var p = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(targetPoint, this.get_Item$$Double(par));
                var d = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(p, p);
                if (d < minDist){
                    minDist = d;
                    closest = par;
                }
            }
            var parStartWasChanged = false;
            if (closest == 0 && this.get_ParEnd() == 6.28318530717959){
                parStartWasChanged = true;
                savedParStart = this.get_ParStart();
                this.set_ParStart(-3.14159265358979);
            }
            var ret = Microsoft.Msagl.Core.Geometry.Curves.ClosestPointOnCurve.ClosestPoint(this, targetPoint, closest, this.get_ParStart(), this.get_ParEnd());
            if (ret < 0)
                ret += 6.28318530717959;
            if (parStartWasChanged)
                this.set_ParStart(savedParStart);
            return ret;
        },
        LeftDerivative: function (t){
            return this.Derivative(t);
        },
        RightDerivative: function (t){
            return this.Derivative(t);
        },
        Curvature: function (t){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        CurvatureDerivative: function (t){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        CurvatureSecondDerivative: function (t){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        OrientedCounterclockwise: function (){
            return this.get_AxisA().get_X() * this.get_AxisB().get_Y() - this.get_AxisB().get_X() * this.get_AxisA().get_Y() > 0;
        },
        FullBox: function (){
            var del = Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.get_AxisA(), this.get_AxisB());
            return new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.center, del), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.center, del));
        },
        IsArc: function (){
            return this.get_AxisA().get_X() == this.get_AxisB().get_Y() && this.get_AxisA().get_Y() == -this.get_AxisB().get_X();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$Ellipse);
var Microsoft$Msagl$Core$Geometry$Curves$ICurve = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.ICurve",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Interface"
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$ICurve);
var Microsoft$Msagl$Core$Geometry$Curves$IFunction = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.IFunction",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Interface"
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$IFunction);
var Microsoft$Msagl$Core$Geometry$Curves$IntersectionInfo = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (pr0, pr1, x, s0, s1){
            this.par0 = 0;
            this.par1 = 0;
            this.x = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.seg0 = null;
            this.seg1 = null;
            System.Object.ctor.call(this);
            this.par0 = pr0;
            this.par1 = pr1;
            this.x = x;
            this.seg0 = s0;
            this.seg1 = s1;
        },
        Par0$$: "System.Double",
        get_Par0: function (){
            return this.par0;
        },
        set_Par0: function (value){
            this.par0 = value;
        },
        Par1$$: "System.Double",
        get_Par1: function (){
            return this.par1;
        },
        set_Par1: function (value){
            this.par1 = value;
        },
        IntersectionPoint$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_IntersectionPoint: function (){
            return this.x;
        },
        set_IntersectionPoint: function (value){
            this.x = value;
        },
        Segment0$$: "Microsoft.Msagl.Core.Geometry.Curves.ICurve",
        get_Segment0: function (){
            return this.seg0;
        },
        set_Segment0: function (value){
            this.seg0 = value;
        },
        Segment1$$: "Microsoft.Msagl.Core.Geometry.Curves.ICurve",
        get_Segment1: function (){
            return this.seg1;
        },
        set_Segment1: function (value){
            this.seg1 = value;
        },
        toString: function (){
            return System.String.Format$$IFormatProvider$$String$$Object$Array(System.Globalization.CultureInfo.get_InvariantCulture(), "XX({0} {1} {2})", [this.par0, this.par1, this.x]);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$IntersectionInfo);
var Microsoft$Msagl$Core$Geometry$Curves$LinearSystem2 = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.LinearSystem2",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Core.Geometry.Curves.LinearSystem2.eps = 1E-08;
        },
        Eps$$: "System.Double",
        get_Eps: function (){
            return Microsoft.Msagl.Core.Geometry.Curves.LinearSystem2.eps;
        },
        Solve: function (a00, a01, b0, a10, a11, b1, x, y){
            var d = a00 * a11 - a10 * a01;
            if (System.Math.Abs$$Double(d) < Microsoft.Msagl.Core.Geometry.Curves.LinearSystem2.get_Eps()){
                x.Value = y.Value = 0;
                return false;
            }
            x.Value = (b0 * a11 - b1 * a01) / d;
            y.Value = (a00 * b1 - a10 * b0) / d;
            return true;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$LinearSystem2);
var Microsoft$Msagl$Core$Geometry$Curves$LineSegment = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.LineSegment",
    baseTypeName: "System.Object",
    staticDefinition: {
        Intersect: function (a, b, c, d, x){
            if (!Microsoft.Msagl.Core.Geometry.Point.LineLineIntersection(a, b, c, d, x))
                return false;
            return (function (){
                var $1 = {
                    Value: a
                };
                var $2 = {
                    Value: b
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.LineSegment.XIsBetweenPoints($1, $2, x);
                a = $1.Value;
                b = $2.Value;
                return $res;
            })() && (function (){
                var $1 = {
                    Value: c
                };
                var $2 = {
                    Value: d
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.LineSegment.XIsBetweenPoints($1, $2, x);
                c = $1.Value;
                d = $2.Value;
                return $res;
            })();
        },
        XIsBetweenPoints: function (a, b, x){
            return Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a.Value, x.Value)), (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b.Value, x.Value))) <= Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon;
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Core.Geometry.Curves.ICurve"],
    Kind: "Class",
    definition: {
        ctor$$Point$$Point: function (start, end){
            this.a = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.b = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            System.Object.ctor.call(this);
            this.a = start;
            this.b = end;
        },
        OffsetCurve: function (offset, dir){
            return null;
        },
        Start$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Start: function (){
            return this.a;
        },
        set_Start: function (value){
            this.a = value;
        },
        End$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_End: function (){
            return this.b;
        },
        set_End: function (value){
            this.b = value;
        },
        ParStart$$: "System.Double",
        get_ParStart: function (){
            return 0;
        },
        ParEnd$$: "System.Double",
        get_ParEnd: function (){
            return 1;
        },
        Trim: function (start, end){
            if (start > end)
                throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            var p1 = start <= this.get_ParStart() ? this.get_Start() : Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point((1 - start), this.a), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(start, this.b));
            var p2 = end >= this.get_ParEnd() ? this.get_End() : Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point((1 - end), this.a), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(end, this.b));
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(start, end)){
                return null;
            }
            return new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(p1, p2);
        },
        TrimWithWrap: function (start, end){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        ParallelogramNodeOverICurve$$: "Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve",
        get_ParallelogramNodeOverICurve: function (){
            var side = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(0.5, (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.b, this.a)));
            return new Microsoft.Msagl.Core.Geometry.Curves.ParallelogramLeaf.ctor(0, 1, new Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.ctor$$Point$$Point$$Point(this.a, side, side), this, 0);
        },
        Normal$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Normal: function (){
            var t = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.a, this.b);
            t = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(t, t.get_Length());
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-t.get_Y(), t.get_X());
        },
        ctor$$Point$$Double$$Double: function (a, x, y){
            this.a = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.b = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point.call(this, a, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x, y));
        },
        ctor$$Double$$Double$$Double$$Double: function (x0, y0, x1, y1){
            this.a = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.b = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point.call(this, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x0, y0), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x1, y1));
        },
        Item$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Item$$Double: function (t){
            return Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.a, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.b, this.a)), t));
        },
        Derivative: function (t){
            return Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.b, this.a);
        },
        SecondDerivative: function (t){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, 0);
        },
        ThirdDerivative: function (t){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, 0);
        },
        toString: function (){
            return "{" + this.a + "," + this.b + "}";
        },
        Reverse: function (){
            return new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(this.b, this.a);
        },
        Translate: function (delta){
            this.a = Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.a, delta);
            this.b = Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.b, delta);
        },
        ScaleFromOrigin: function (xScale, yScale){
            return new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(Microsoft.Msagl.Core.Geometry.Point.Scale(xScale, yScale, this.a), Microsoft.Msagl.Core.Geometry.Point.Scale(xScale, yScale, this.b));
        },
        GetParameterAtLength: function (length){
            var len = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.b, this.a)).get_Length();
            if (len < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                return 0;
            var t = length / len;
            return t > 1 ? 1 : (t < 0 ? 0 : t);
        },
        Transform: function (transformation){
            return new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(transformation, this.a), Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(transformation, this.b));
        },
        ClosestParameterWithinBounds: function (targetPoint, low, high){
            var t = this.ClosestParameter(targetPoint);
            if (t < low)
                t = low;
            if (t > high)
                t = high;
            return t;
        },
        LengthPartial: function (start, end){
            return (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.get_Item$$Double(end), this.get_Item$$Double(start))).get_Length();
        },
        Length$$: "System.Double",
        get_Length: function (){
            return (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.a, this.b)).get_Length();
        },
        BoundingBox$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_BoundingBox: function (){
            return new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(this.get_Start(), this.get_End());
        },
        Clone: function (){
            return new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(this.a, this.b);
        },
        ClosestParameter: function (targetPoint){
            return Microsoft.Msagl.Core.Geometry.Point.ClosestParameterOnLineSegment(targetPoint, this.get_Start(), this.get_End());
        },
        LeftDerivative: function (t){
            return this.Derivative(t);
        },
        RightDerivative: function (t){
            return this.Derivative(t);
        },
        Curvature: function (t){
            return 0;
        },
        CurvatureDerivative: function (t){
            return 0;
        },
        CurvatureSecondDerivative: function (t){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$LineSegment);
var Microsoft$Msagl$Core$Geometry$Curves$MinDistCurveCurve = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.MinDistCurveCurve",
    baseTypeName: "System.Object",
    staticDefinition: {
        Delta: function (x, y, u, w){
            return x * w - u * y;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (curveAPar, curveBPar, lowBound0, upperBound0, lowBound1, upperBound1, guess0, guess1){
            this.curveA = null;
            this.curveB = null;
            this.aMin = 0;
            this.aMax = 0;
            this.bMin = 0;
            this.bMax = 0;
            this.aGuess = 0;
            this.bGuess = 0;
            this.aSolution = 0;
            this.bSolution = 0;
            this.aPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.bPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.status = false;
            this.si = 0;
            this.ti = 0;
            this.a = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.b = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.a_b = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.ad = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.bd = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.add = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.bdd = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            System.Object.ctor.call(this);
            this.curveA = curveAPar;
            this.curveB = curveBPar;
            this.aMin = lowBound0;
            this.bMin = lowBound1;
            this.aMax = upperBound0;
            this.bMax = upperBound1;
            this.aGuess = guess0;
            this.bGuess = guess1;
            this.si = guess0;
            this.ti = guess1;
        },
        ASolution$$: "System.Double",
        get_ASolution: function (){
            return this.aSolution;
        },
        BSolution$$: "System.Double",
        get_BSolution: function (){
            return this.bSolution;
        },
        APoint$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_APoint: function (){
            return this.aPoint;
        },
        BPoint$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_BPoint: function (){
            return this.bPoint;
        },
        Status$$: "System.Boolean",
        get_Status: function (){
            return this.status;
        },
        InitValues: function (){
            this.a = this.curveA.get_Item$$Double(this.si);
            this.b = this.curveB.get_Item$$Double(this.ti);
            this.a_b = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.a, this.b);
            this.ad = this.curveA.Derivative(this.si);
            this.add = this.curveA.SecondDerivative(this.si);
            this.bd = this.curveB.Derivative(this.ti);
            this.bdd = this.curveB.SecondDerivative(this.ti);
        },
        Fs$$: "System.Double",
        get_Fs: function (){
            return Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.a_b, this.ad);
        },
        Fss$$: "System.Double",
        get_Fss: function (){
            return (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.a_b, this.add) + Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.ad, this.ad));
        },
        Fst$$: "System.Double",
        get_Fst: function (){
            return Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(this.bd), this.ad);
        },
        Ftt$$: "System.Double",
        get_Ftt: function (){
            return (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(this.a_b), this.bdd) + Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.bd, this.bd));
        },
        Ft$$: "System.Double",
        get_Ft: function (){
            return Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(this.a_b), this.bd);
        },
        Solve: function (){
            var numberOfBoundaryCrossings = 0;
            var maxNumberOfBoundaryCrossings = 10;
            var numberOfTotalReps = 0;
            var maxNumberOfTotalReps = 100;
            var abort = false;
            this.InitValues();
            if (Is(this.curveA, Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor) && Is(this.curveB, Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor)){
                var bd1 = this.curveB.Derivative(0);
                bd1 = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(bd1, bd1.get_Length());
                var an = (As(this.curveA, Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor)).get_Normal();
                var del = System.Math.Abs$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(an, bd1));
                if (System.Math.Abs$$Double(del) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon || Microsoft.Msagl.Core.Geometry.Curves.MinDistCurveCurve.Delta(this.get_Fss(), this.get_Fst(), this.get_Fst(), this.get_Ftt()) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance()){
                    this.status = true;
                    this.ParallelLineSegLineSegMinDist();
                    return;
                }
            }
            var ds,dt;
            do{
                var delta = Microsoft.Msagl.Core.Geometry.Curves.MinDistCurveCurve.Delta(this.get_Fss(), this.get_Fst(), this.get_Fst(), this.get_Ftt());
                if (System.Math.Abs$$Double(delta) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance()){
                    this.status = false;
                    abort = true;
                    break;
                }
                ds = Microsoft.Msagl.Core.Geometry.Curves.MinDistCurveCurve.Delta(-this.get_Fs(), this.get_Fst(), -this.get_Ft(), this.get_Ftt()) / delta;
                dt = Microsoft.Msagl.Core.Geometry.Curves.MinDistCurveCurve.Delta(this.get_Fss(), -this.get_Fs(), this.get_Fst(), -this.get_Ft()) / delta;
                var nsi = this.si + ds;
                var nti = this.ti + dt;
                var bc;
                if (nsi > this.aMax + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon || nsi < this.aMin - Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon || nti > this.bMax + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon || nti < this.bMin - Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                    numberOfBoundaryCrossings++;
                    (function (){
                        var $1 = {
                            Value: ds
                        };
                        var $2 = {
                            Value: dt
                        };
                        var $res = this.ChopDsDt($1, $2);
                        ds = $1.Value;
                        dt = $2.Value;
                        return $res;
                    }).call(this);
                    this.si += ds;
                    this.ti += dt;
                    bc = true;
                }
                else {
                    bc = false;
                    this.si = nsi;
                    this.ti = nti;
                    if (this.si > this.aMax)
                        this.si = this.aMax;
                    else if (this.si < this.aMin)
                        this.si = this.aMin;
                    if (this.ti > this.bMax)
                        this.ti = this.bMax;
                    else if (this.ti < this.bMin)
                        this.ti = this.bMin;
                }
                this.InitValues();
                numberOfTotalReps++;
                abort = numberOfBoundaryCrossings >= maxNumberOfBoundaryCrossings || numberOfTotalReps >= maxNumberOfTotalReps || (ds == 0 && dt == 0 && bc);
            }
            while ((System.Math.Abs$$Double(ds) >= Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance() || System.Math.Abs$$Double(dt) >= Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance()) && !abort)
            if (abort){
                var t = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.curveA.get_Item$$Double(this.aGuess), this.curveB.get_Item$$Double(this.bGuess));
                if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(t, t) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon * Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                    this.aSolution = this.aGuess;
                    this.bSolution = this.bGuess;
                    this.aPoint = this.curveA.get_Item$$Double(this.aGuess);
                    this.bPoint = this.curveB.get_Item$$Double(this.bGuess);
                    this.status = true;
                    return;
                }
            }
            this.aSolution = this.si;
            this.bSolution = this.ti;
            this.aPoint = this.a;
            this.bPoint = this.b;
            this.status = !abort;
        },
        ChopDsDt: function (ds, dt){
            if (ds.Value != 0 && dt.Value != 0){
                var k1 = 1;
                if (this.si + ds.Value > this.aMax)
                    k1 = (this.aMax - this.si) / ds.Value;
                else if (this.si + ds.Value < this.aMin)
                    k1 = (this.aMin - this.si) / ds.Value;
                var k2 = 1;
                if (this.ti + dt.Value > this.bMax)
                    k2 = (this.bMax - this.ti) / dt.Value;
                else if (this.ti + dt.Value < this.bMin)
                    k2 = (this.bMin - this.ti) / dt.Value;
                var k = System.Math.Min$$Double$$Double(k1, k2);
                ds.Value *= k;
                dt.Value *= k;
            }
            else if (ds.Value == 0){
                if (this.ti + dt.Value > this.bMax)
                    dt.Value = this.bMax - this.ti;
                else if (this.ti + dt.Value < this.bMin)
                    dt.Value = this.bMin - this.ti;
            }
            else {
                if (this.si + ds.Value > this.aMax)
                    ds.Value = this.aMax - this.si;
                else if (this.si + ds.Value < this.aMin)
                    ds.Value = this.aMin - this.si;
            }
        },
        ParallelLineSegLineSegMinDist: function (){
            var l0 = As(this.curveA, Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor);
            var l1 = As(this.curveB, Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor);
            var v0 = l0.get_Start();
            var v1 = l0.get_End();
            var v2 = l1.get_Start();
            var v3 = l1.get_End();
            var d0 = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v1, v0);
            var nd0 = d0.get_Length();
            var r0 = 0,r1,r2,r3;
            if (nd0 > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                d0 = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(d0, nd0);
                r1 = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(d0, (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v1, v0)));
                r2 = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(d0, (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v2, v0)));
                r3 = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(d0, (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v3, v0)));
                var swapped = false;
                if (r2 > r3){
                    swapped = true;
                    var t = r2;
                    r2 = r3;
                    r3 = t;
                }
                if (r3 < r0){
                    this.aSolution = 0;
                    this.bSolution = swapped ? 0 : 1;
                }
                else if (r2 > r1){
                    this.aSolution = 1;
                    this.bSolution = swapped ? 1 : 0;
                }
                else {
                    var r = System.Math.Min$$Double$$Double(r1, r3);
                    this.aSolution = r / (r1 - r0);
                    this.bSolution = (r - r2) / (r3 - r2);
                    if (swapped)
                        this.bSolution = 1 - this.bSolution;
                }
            }
            else {
                var d1 = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v3, v2);
                var nd1 = d1.get_Length();
                if (nd1 > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                    d1 = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double(d1, nd1);
                    r0 = 0;
                    r1 = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(d1, (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v3, v2)));
                    r2 = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(d1, (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v0, v2)));
                    if (r2 < r0){
                        this.bSolution = 0;
                        this.aSolution = 1;
                    }
                    else if (r2 > r1){
                        this.bSolution = 1;
                        this.aSolution = 0;
                    }
                    else {
                        var r = System.Math.Min$$Double$$Double(r1, r2);
                        this.bSolution = r / (r1 - r0);
                        this.aSolution = 0;
                    }
                }
                else {
                    this.aSolution = 0;
                    this.bSolution = 0;
                }
            }
            this.aPoint = this.curveA.get_Item$$Double(this.aSolution);
            this.bPoint = this.curveB.get_Item$$Double(this.bSolution);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$MinDistCurveCurve);
var Microsoft$Msagl$Core$Geometry$Curves$VertexId = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.VertexId",
    staticDefinition: {
        Corner: 0,
        VertexA: 1,
        OtherCorner: 2,
        VertexB: 3
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$VertexId);
var Microsoft$Msagl$Core$Geometry$Curves$Parallelogram = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.Parallelogram",
    baseTypeName: "System.ValueType",
    staticDefinition: {
        Intersect: function (parallelogram0, parallelogram1){
            var ret = !((function (){
                var $1 = {
                    Value: parallelogram0
                };
                var $2 = {
                    Value: parallelogram1
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.separByA($1, $2);
                parallelogram0 = $1.Value;
                parallelogram1 = $2.Value;
                return $res;
            })() || (function (){
                var $1 = {
                    Value: parallelogram1
                };
                var $2 = {
                    Value: parallelogram0
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.separByA($1, $2);
                parallelogram1 = $1.Value;
                parallelogram0 = $2.Value;
                return $res;
            })() || (function (){
                var $1 = {
                    Value: parallelogram0
                };
                var $2 = {
                    Value: parallelogram1
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.separByB($1, $2);
                parallelogram0 = $1.Value;
                parallelogram1 = $2.Value;
                return $res;
            })() || (function (){
                var $1 = {
                    Value: parallelogram1
                };
                var $2 = {
                    Value: parallelogram0
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.separByB($1, $2);
                parallelogram1 = $1.Value;
                parallelogram0 = $2.Value;
                return $res;
            })());
            if (ret == false)
                return false;
            if (!(parallelogram0.isSeg && parallelogram1.isSeg))
                return true;
            if (!Microsoft.Msagl.Core.Geometry.Point.ParallelWithinEpsilon(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(parallelogram0.get_OtherCorner(), parallelogram0.get_Corner()), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(parallelogram1.get_OtherCorner(), parallelogram1.get_Corner()), 1E-05))
                return true;
            return (function (){
                var $1 = {
                    Value: parallelogram1
                };
                var $2 = {
                    Value: parallelogram0
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.ParallelSegsIntersect($1, $2);
                parallelogram1 = $1.Value;
                parallelogram0 = $2.Value;
                return $res;
            })();
        },
        ParallelSegsIntersect: function (p0, p1){
            var v0 = p0.Value.get_Corner();
            var v1 = p0.Value.get_OtherCorner();
            var v2 = p1.Value.get_Corner();
            var v3 = p1.Value.get_OtherCorner();
            var d = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v1, v0);
            var r0 = 0;
            var r1 = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(d, d);
            var r2 = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v2, v0)), d);
            var r3 = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(v3, v0)), d);
            if (r2 > r3){
                var t = r2;
                r2 = r3;
                r3 = t;
            }
            return !(r3 < r0 - Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon || r2 > r1 + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon);
        },
        mult: function (a, b){
            return a.Value.get_X() * b.Value.get_X() + a.Value.get_Y() * b.Value.get_Y();
        },
        separByA: function (p0, p1){
            var eps = Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon;
            var t = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(p1.Value.corner.get_X() - p0.Value.corner.get_X(), p1.Value.corner.get_Y() - p0.Value.corner.get_Y());
            var p1a = (function (){
                var $1 = {
                    Value: t
                };
                var $2 = {
                    Value: p0.Value.aRot
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.mult($1, $2);
                t = $1.Value;
                p0.Value.aRot = $2.Value;
                return $res;
            })();
            if (p1a > p0.Value.baRot + eps){
                t.set_X(p1.Value.aPlusCorner.get_X() - p0.Value.corner.get_X());
                t.set_Y(p1.Value.aPlusCorner.get_Y() - p0.Value.corner.get_Y());
                if ((function (){
                    var $1 = {
                        Value: t
                    };
                    var $2 = {
                        Value: p0.Value.aRot
                    };
                    var $res = Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.mult($1, $2);
                    t = $1.Value;
                    p0.Value.aRot = $2.Value;
                    return $res;
                })() <= p0.Value.baRot + eps)
                    return false;
                t.set_X(p1.Value.bPlusCorner.get_X() - p0.Value.corner.get_X());
                t.set_Y(p1.Value.bPlusCorner.get_Y() - p0.Value.corner.get_Y());
                if ((function (){
                    var $1 = {
                        Value: t
                    };
                    var $2 = {
                        Value: p0.Value.aRot
                    };
                    var $res = Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.mult($1, $2);
                    t = $1.Value;
                    p0.Value.aRot = $2.Value;
                    return $res;
                })() <= p0.Value.baRot + eps)
                    return false;
                t.set_X(p1.Value.otherCorner.get_X() - p0.Value.corner.get_X());
                t.set_Y(p1.Value.otherCorner.get_Y() - p0.Value.corner.get_Y());
                if ((function (){
                    var $1 = {
                        Value: t
                    };
                    var $2 = {
                        Value: p0.Value.aRot
                    };
                    var $res = Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.mult($1, $2);
                    t = $1.Value;
                    p0.Value.aRot = $2.Value;
                    return $res;
                })() <= p0.Value.baRot + eps)
                    return false;
                return true;
            }
            else if (p1a < -eps){
                t.set_X(p1.Value.aPlusCorner.get_X() - p0.Value.corner.get_X());
                t.set_Y(p1.Value.aPlusCorner.get_Y() - p0.Value.corner.get_Y());
                if ((function (){
                    var $1 = {
                        Value: t
                    };
                    var $2 = {
                        Value: p0.Value.aRot
                    };
                    var $res = Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.mult($1, $2);
                    t = $1.Value;
                    p0.Value.aRot = $2.Value;
                    return $res;
                })() >= -eps)
                    return false;
                t.set_X(p1.Value.bPlusCorner.get_X() - p0.Value.corner.get_X());
                t.set_Y(p1.Value.bPlusCorner.get_Y() - p0.Value.corner.get_Y());
                if ((function (){
                    var $1 = {
                        Value: t
                    };
                    var $2 = {
                        Value: p0.Value.aRot
                    };
                    var $res = Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.mult($1, $2);
                    t = $1.Value;
                    p0.Value.aRot = $2.Value;
                    return $res;
                })() >= -eps)
                    return false;
                t.set_X(p1.Value.otherCorner.get_X() - p0.Value.corner.get_X());
                t.set_Y(p1.Value.otherCorner.get_Y() - p0.Value.corner.get_Y());
                if ((function (){
                    var $1 = {
                        Value: t
                    };
                    var $2 = {
                        Value: p0.Value.aRot
                    };
                    var $res = Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.mult($1, $2);
                    t = $1.Value;
                    p0.Value.aRot = $2.Value;
                    return $res;
                })() >= -eps)
                    return false;
                return true;
            }
            return false;
        },
        separByB: function (p0, p1){
            var eps = Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon;
            var p1a = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(p1.Value.Vertex(Microsoft.Msagl.Core.Geometry.Curves.VertexId.Corner), p0.Value.corner)), p0.Value.bRot);
            if (p1a > p0.Value.abRot + eps){
                var $it1255 = p1.Value.get_OtherVertices().GetEnumerator();
                while ($it1255.MoveNext()){
                    var i = $it1255.get_Current();
                    if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(i, p0.Value.corner)), p0.Value.bRot) <= p0.Value.abRot + eps)
                        return false;
                }
                return true;
            }
            else if (p1a < -eps){
                var $it1256 = p1.Value.get_OtherVertices().GetEnumerator();
                while ($it1256.MoveNext()){
                    var i = $it1256.get_Current();
                    if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(i, p0.Value.corner)), p0.Value.bRot) >= -eps)
                        return false;
                }
                return true;
            }
            return false;
        },
        GetParallelogramOfAGroup: function (boxes){
            var minX = 0,maxX = 0,minY = 0,maxY = 0;
            var firstTime = true;
            var $it1257 = boxes.GetEnumerator();
            while ($it1257.MoveNext()){
                var b = $it1257.get_Current();
                var $it1258 = b.get_AllVertices().GetEnumerator();
                while ($it1258.MoveNext()){
                    var v = $it1258.get_Current();
                    var x = v.get_X();
                    var y = v.get_Y();
                    if (firstTime){
                        firstTime = false;
                        minX = maxX = x;
                        minY = maxY = y;
                    }
                    else {
                        if (x < minX){
                            minX = x;
                        }
                        else if (x > maxX){
                            maxX = x;
                        }
                        if (y < minY){
                            minY = y;
                        }
                        else if (y > maxY){
                            maxY = y;
                        }
                    }
                }
            }
            return new Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.ctor$$Point$$Point$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(minX, minY), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, maxY - minY), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(maxX - minX, 0));
        },
        PumpMinMax: function (minX, maxX, minY, maxY, p){
            if (p.Value.get_X() < minX.Value){
                minX.Value = p.Value.get_X();
            }
            else if (p.Value.get_X() > maxX.Value){
                maxX.Value = p.Value.get_X();
            }
            if (p.Value.get_Y() < minY.Value){
                minY.Value = p.Value.get_Y();
            }
            else if (p.Value.get_Y() > maxY.Value){
                maxY.Value = p.Value.get_Y();
            }
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Struct",
    definition: {
        ctor$$Point$$Point$$Point: function (corner, sideA, sideB){
            this.isSeg = false;
            this.corner = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.a = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.b = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.otherCorner = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.aPlusCorner = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.bPlusCorner = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.aRot = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.bRot = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.abRot = 0;
            this.baRot = 0;
            System.ValueType.ctor.call(this);
            this.corner = corner;
            this.a = sideA;
            this.b = sideB;
            this.aRot = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-sideA.get_Y(), sideA.get_X());
            if (this.aRot.get_Length() > 0.5)
                this.aRot = this.aRot.Normalize();
            this.bRot = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-sideB.get_Y(), sideB.get_X());
            if (this.bRot.get_Length() > 0.5)
                this.bRot = this.bRot.Normalize();
            this.abRot = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(sideA, this.bRot);
            this.baRot = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(sideB, this.aRot);
            if (this.abRot < 0){
                this.abRot = -this.abRot;
                this.bRot = Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(this.bRot);
            }
            if (this.baRot < 0){
                this.baRot = -this.baRot;
                this.aRot = Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(this.aRot);
            }
            this.isSeg = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(sideA, sideB)).get_Length() < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon;
            this.aPlusCorner = Microsoft.Msagl.Core.Geometry.Point.op_Addition(sideA, corner);
            this.otherCorner = Microsoft.Msagl.Core.Geometry.Point.op_Addition(sideB, this.aPlusCorner);
            this.bPlusCorner = Microsoft.Msagl.Core.Geometry.Point.op_Addition(sideB, corner);
        },
        AllVertices$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Geometry.Point]]",
        get_AllVertices: function (){
            var $yield = [];
            $yield.push(this.corner);
            $yield.push(this.aPlusCorner);
            $yield.push(this.otherCorner);
            $yield.push(this.bPlusCorner);
            return $yield;
        },
        OtherVertices$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Geometry.Point]]",
        get_OtherVertices: function (){
            var $yield = [];
            $yield.push(this.aPlusCorner);
            $yield.push(this.otherCorner);
            $yield.push(this.bPlusCorner);
            return $yield;
        },
        Corner$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Corner: function (){
            return this.corner;
        },
        OtherCorner$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_OtherCorner: function (){
            return this.otherCorner;
        },
        toString: function (){
            return System.String.Format$$IFormatProvider$$String$$Object$Array(System.Globalization.CultureInfo.get_InvariantCulture(), "({0},{1},{2},{3})", [this.Vertex(Microsoft.Msagl.Core.Geometry.Curves.VertexId.Corner), this.Vertex(Microsoft.Msagl.Core.Geometry.Curves.VertexId.VertexA), this.Vertex(Microsoft.Msagl.Core.Geometry.Curves.VertexId.OtherCorner), this.Vertex(Microsoft.Msagl.Core.Geometry.Curves.VertexId.VertexB)]);
        },
        Contains: function (point){
            var g = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(point, this.corner);
            var e = Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon;
            var gbRot = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(g, this.bRot);
            if (gbRot > this.abRot + e || gbRot < -e)
                return false;
            var gaRot = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(g, this.aRot);
            return gaRot <= this.baRot + e && gaRot >= -e;
        },
        Area$$: "System.Double",
        get_Area: function (){
            return System.Math.Abs$$Double(this.a.get_X() * this.b.get_Y() - this.a.get_Y() * this.b.get_X());
        },
        Vertex: function (vertexPar){
            switch (vertexPar){
                case Microsoft.Msagl.Core.Geometry.Curves.VertexId.Corner:
                    return this.corner;
                case Microsoft.Msagl.Core.Geometry.Curves.VertexId.VertexA:
                    return this.aPlusCorner;
                case Microsoft.Msagl.Core.Geometry.Curves.VertexId.OtherCorner:
                    return this.get_OtherCorner();
                case Microsoft.Msagl.Core.Geometry.Curves.VertexId.VertexB:
                    return this.bPlusCorner;
                default:
                    throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            }
        },
        ctor$$Parallelogram$$Parallelogram: function (box0, box1){
            this.isSeg = false;
            this.corner = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.a = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.b = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.otherCorner = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.aPlusCorner = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.bPlusCorner = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.aRot = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.bRot = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.abRot = 0;
            this.baRot = 0;
            System.ValueType.ctor.call(this);
            var v = box0.get_Corner();
            var minX,maxX,minY,maxY;
            minX = maxX = v.get_X();
            minY = maxY = v.get_Y();
            (function (){
                var $1 = {
                    Value: minX
                };
                var $2 = {
                    Value: maxX
                };
                var $3 = {
                    Value: minY
                };
                var $4 = {
                    Value: maxY
                };
                var $5 = {
                    Value: box0.aPlusCorner
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.PumpMinMax($1, $2, $3, $4, $5);
                minX = $1.Value;
                maxX = $2.Value;
                minY = $3.Value;
                maxY = $4.Value;
                box0.aPlusCorner = $5.Value;
                return $res;
            }).call(this);
            (function (){
                var $1 = {
                    Value: minX
                };
                var $2 = {
                    Value: maxX
                };
                var $3 = {
                    Value: minY
                };
                var $4 = {
                    Value: maxY
                };
                var $5 = {
                    Value: box0.otherCorner
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.PumpMinMax($1, $2, $3, $4, $5);
                minX = $1.Value;
                maxX = $2.Value;
                minY = $3.Value;
                maxY = $4.Value;
                box0.otherCorner = $5.Value;
                return $res;
            }).call(this);
            (function (){
                var $1 = {
                    Value: minX
                };
                var $2 = {
                    Value: maxX
                };
                var $3 = {
                    Value: minY
                };
                var $4 = {
                    Value: maxY
                };
                var $5 = {
                    Value: box0.bPlusCorner
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.PumpMinMax($1, $2, $3, $4, $5);
                minX = $1.Value;
                maxX = $2.Value;
                minY = $3.Value;
                maxY = $4.Value;
                box0.bPlusCorner = $5.Value;
                return $res;
            }).call(this);
            (function (){
                var $1 = {
                    Value: minX
                };
                var $2 = {
                    Value: maxX
                };
                var $3 = {
                    Value: minY
                };
                var $4 = {
                    Value: maxY
                };
                var $5 = {
                    Value: box1.corner
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.PumpMinMax($1, $2, $3, $4, $5);
                minX = $1.Value;
                maxX = $2.Value;
                minY = $3.Value;
                maxY = $4.Value;
                box1.corner = $5.Value;
                return $res;
            }).call(this);
            (function (){
                var $1 = {
                    Value: minX
                };
                var $2 = {
                    Value: maxX
                };
                var $3 = {
                    Value: minY
                };
                var $4 = {
                    Value: maxY
                };
                var $5 = {
                    Value: box1.aPlusCorner
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.PumpMinMax($1, $2, $3, $4, $5);
                minX = $1.Value;
                maxX = $2.Value;
                minY = $3.Value;
                maxY = $4.Value;
                box1.aPlusCorner = $5.Value;
                return $res;
            }).call(this);
            (function (){
                var $1 = {
                    Value: minX
                };
                var $2 = {
                    Value: maxX
                };
                var $3 = {
                    Value: minY
                };
                var $4 = {
                    Value: maxY
                };
                var $5 = {
                    Value: box1.otherCorner
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.PumpMinMax($1, $2, $3, $4, $5);
                minX = $1.Value;
                maxX = $2.Value;
                minY = $3.Value;
                maxY = $4.Value;
                box1.otherCorner = $5.Value;
                return $res;
            }).call(this);
            (function (){
                var $1 = {
                    Value: minX
                };
                var $2 = {
                    Value: maxX
                };
                var $3 = {
                    Value: minY
                };
                var $4 = {
                    Value: maxY
                };
                var $5 = {
                    Value: box1.bPlusCorner
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.PumpMinMax($1, $2, $3, $4, $5);
                minX = $1.Value;
                maxX = $2.Value;
                minY = $3.Value;
                maxY = $4.Value;
                box1.bPlusCorner = $5.Value;
                return $res;
            }).call(this);
            this.corner = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(minX, minY);
            this.a = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(0, maxY - minY);
            this.b = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(maxX - minX, 0);
            this.aPlusCorner = Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.a, this.corner);
            this.otherCorner = Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.b, this.aPlusCorner);
            this.bPlusCorner = Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.b, this.corner);
            this.aRot = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-this.a.get_Y(), this.a.get_X());
            if (this.aRot.get_Length() > 0.5)
                this.aRot = this.aRot.Normalize();
            this.bRot = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-this.b.get_Y(), this.b.get_X());
            if (this.bRot.get_Length() > 0.5)
                this.bRot = this.bRot.Normalize();
            this.abRot = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.a, this.bRot);
            this.baRot = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.b, this.aRot);
            if (this.abRot < 0){
                this.abRot = -this.abRot;
                this.bRot = Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(this.bRot);
            }
            if (this.baRot < 0){
                this.baRot = -this.baRot;
                this.aRot = Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(this.aRot);
            }
            this.isSeg = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.a, this.b)).get_Length() < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon;
        },
        ctor: function (){
            this.isSeg = false;
            this.corner = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.a = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.b = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.otherCorner = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.aPlusCorner = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.bPlusCorner = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.aRot = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.bRot = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.abRot = 0;
            this.baRot = 0;
            System.ValueType.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$Parallelogram);
var Microsoft$Msagl$Core$Geometry$Curves$ParallelogramBinaryTreeNode = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.ParallelogramBinaryTreeNode",
    baseTypeName: "Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNode",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.leftSon = null;
            this.rightSon = null;
            Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNode.ctor.call(this);
        },
        LeftSon$$: "Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNode",
        get_LeftSon: function (){
            return this.leftSon;
        },
        set_LeftSon: function (value){
            this.leftSon = value;
        },
        RightSon$$: "Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNode",
        get_RightSon: function (){
            return this.rightSon;
        },
        set_RightSon: function (value){
            this.rightSon = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$ParallelogramBinaryTreeNode);
var Microsoft$Msagl$Core$Geometry$Curves$ParallelogramInternalTreeNode = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.ParallelogramInternalTreeNode",
    baseTypeName: "Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve",
    staticDefinition: {
        cctor: function (){
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (seg, leafBoxesOffset){
            this.children = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.ctor);
            Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.ctor.call(this, seg, leafBoxesOffset);
        },
        Children$$: "System.Collections.Generic.List`1[[Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve]]",
        get_Children: function (){
            return this.children;
        },
        AddChild: function (node){
            this.children.Add(node);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$ParallelogramInternalTreeNode);
var Microsoft$Msagl$Core$Geometry$Curves$ParallelogramLeaf = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.ParallelogramLeaf",
    baseTypeName: "Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve",
    staticDefinition: {
        cctor: function (){
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (low, high, box, seg, leafBoxesOffset){
            this.low = 0;
            this.high = 0;
            this.chord = null;
            Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.ctor.call(this, seg, leafBoxesOffset);
            this.low = low;
            this.high = high;
            this.set_Parallelogram(box);
        },
        Low$$: "System.Double",
        get_Low: function (){
            return this.low;
        },
        set_Low: function (value){
            this.low = value;
        },
        High$$: "System.Double",
        get_High: function (){
            return this.high;
        },
        set_High: function (value){
            this.high = value;
        },
        Chord$$: "Microsoft.Msagl.Core.Geometry.Curves.LineSegment",
        get_Chord: function (){
            return this.chord;
        },
        set_Chord: function (value){
            this.chord = value;
            if (!Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(this.get_Seg().get_Item$$Double(this.low), this.chord.get_Start()))
                throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$ParallelogramLeaf);
var Microsoft$Msagl$Core$Geometry$Curves$ParallelogramNode = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNode",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.parallelogram = new Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.ctor();
            System.Object.ctor.call(this);
        },
        Parallelogram$$: "Microsoft.Msagl.Core.Geometry.Curves.Parallelogram",
        get_Parallelogram: function (){
            return this.parallelogram;
        },
        set_Parallelogram: function (value){
            this.parallelogram = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$ParallelogramNode);
var Microsoft$Msagl$Core$Geometry$Curves$ParallelogramNodeOverICurve = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve",
    baseTypeName: "Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNode",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.DefaultLeafBoxesOffset = 0.5;
        },
        CreateParallelogramNodeForCurveSegment: function (segment){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(segment, "segment");
            return Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.CreateParallelogramNodeForCurveSeg(segment.get_ParStart(), segment.get_ParEnd(), segment, Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.DefaultLeafBoxesOffset);
        },
        WithinEpsilon: function (seg, start, end, eps){
            if (Is(seg, Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor))
                return true;
            var n = 3;
            var d = (end - start) / n;
            var s = seg.get_Item$$Double(start);
            var e = seg.get_Item$$Double(end);
            var d0 = Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.DistToSegm(seg.get_Item$$Double(start + d), s, e);
            var d1 = Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.DistToSegm(seg.get_Item$$Double(start + d * (n - 1)), s, e);
            return d0 < eps && d1 < eps;
        },
        DistToSegm: function (p, s, e){
            var l = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(e, s);
            if (l.get_Length() < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_IntersectionEpsilon())
                return (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(p, (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(0.5, (Microsoft.Msagl.Core.Geometry.Point.op_Addition(s, e)))))).get_Length();
            var perp = new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-l.get_Y(), l.get_X());
            perp = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(perp, (1 / perp.get_Length()));
            return System.Math.Abs$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(p, s)), perp));
        },
        CreateParallelogramOnSubSeg: function (start, end, seg, box, startPoint, endPoint){
            if (Is(seg, Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ctor))
                return Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.CreateParallelogramOnSubSegOnBezierSeg(start, end, seg, box);
            var tan1 = seg.Derivative(start);
            var tan2 = seg.Derivative(end);
            var tan2Perp = Microsoft.Msagl.Core.Geometry.Point.P(-tan2.get_Y(), tan2.get_X());
            var p = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(endPoint, startPoint);
            var numerator = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(p, tan2Perp);
            var denumerator = (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(tan1, tan2Perp));
            var x;
            if (System.Math.Abs$$Double(numerator) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                x = 0;
            else if (System.Math.Abs$$Double(denumerator) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                return false;
            }
            else
                x = numerator / denumerator;
            tan1 = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Double(tan1, x);
            box.Value = new Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.ctor$$Point$$Point$$Point(startPoint, tan1, Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(endPoint, startPoint), tan1));
            var delta = (end - start) / 64;
            for (var i = 1; i < 64; i++){
                if (!box.Value.Contains(seg.get_Item$$Double(start + delta * i)))
                    return false;
            }
            return true;
        },
        CreateParallelogramOnSubSegOnBezierSeg: function (start, end, seg, box){
            var trimSeg = As(seg.Trim(start, end), Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ctor);
            var b = $CreateDelegate(trimSeg, trimSeg.B);
            var a = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b(1), b(0));
            box.Value = new Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.ctor$$Point$$Point$$Point(b(0), a, Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b(3), b(0)));
            if (box.Value.Contains(b(2)))
                return true;
            box.Value = new Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.ctor$$Point$$Point$$Point(b(3), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b(2), b(3)), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b(0), b(3)));
            if (box.Value.Contains(b(1)))
                return true;
            return false;
        },
        CreateParallelogramNodeForCurveSeg: function (start, end, seg, eps){
            var closedSeg = (start == seg.get_ParStart() && end == seg.get_ParEnd() && Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(seg.get_Start(), seg.get_End()));
            if (closedSeg)
                return Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.CreateNodeWithSegmentSplit(start, end, seg, eps);
            var s = seg.get_Item$$Double(start);
            var e = seg.get_Item$$Double(end);
            var w = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(e, s);
            var middle = seg.get_Item$$Double((start + end) / 2);
            if (Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.DistToSegm(middle, s, e) <= Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_IntersectionEpsilon() && Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(w, w) < Microsoft.Msagl.Core.Geometry.Curves.Curve.get_LineSegmentThreshold() * Microsoft.Msagl.Core.Geometry.Curves.Curve.get_LineSegmentThreshold() && end - start < Microsoft.Msagl.Core.Geometry.Curves.Curve.get_LineSegmentThreshold()){
                var ls = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(s, e);
                var leaf = As(ls.get_ParallelogramNodeOverICurve(), Microsoft.Msagl.Core.Geometry.Curves.ParallelogramLeaf.ctor);
                leaf.set_Low(start);
                leaf.set_High(end);
                leaf.set_Seg(seg);
                leaf.set_Chord(ls);
                return leaf;
            }
            var we = Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.WithinEpsilon(seg, start, end, eps);
            var box = new Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.ctor();
            if (we && (function (){
                var $1 = {
                    Value: box
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.CreateParallelogramOnSubSeg(start, end, seg, $1, s, e);
                box = $1.Value;
                return $res;
            })())
                return new Microsoft.Msagl.Core.Geometry.Curves.ParallelogramLeaf.ctor(start, end, box, seg, eps);
            return Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.CreateNodeWithSegmentSplit(start, end, seg, eps);
        },
        CreateNodeWithSegmentSplit: function (start, end, seg, eps){
            var pBNode = new Microsoft.Msagl.Core.Geometry.Curves.ParallelogramInternalTreeNode.ctor(seg, eps);
            pBNode.AddChild(Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.CreateParallelogramNodeForCurveSeg(start, 0.5 * (start + end), seg, eps));
            pBNode.AddChild(Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.CreateParallelogramNodeForCurveSeg(0.5 * (start + end), end, seg, eps));
            var boxes = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.ctor);
            boxes.Add(pBNode.get_Children().get_Item$$Int32(0).get_Parallelogram());
            boxes.Add(pBNode.get_Children().get_Item$$Int32(1).get_Parallelogram());
            pBNode.set_Parallelogram(Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.GetParallelogramOfAGroup(boxes));
            return pBNode;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (s, leafBoxesOffset){
            this.seg = null;
            this.leafBoxesOffset = Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.DefaultLeafBoxesOffset;
            Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNode.ctor.call(this);
            this.seg = s;
            this.leafBoxesOffset = leafBoxesOffset;
        },
        Seg$$: "Microsoft.Msagl.Core.Geometry.Curves.ICurve",
        get_Seg: function (){
            return this.seg;
        },
        set_Seg: function (value){
            this.seg = value;
        },
        LeafBoxesOffset$$: "System.Double",
        get_LeafBoxesOffset: function (){
            return this.leafBoxesOffset;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$ParallelogramNodeOverICurve);
var Microsoft$Msagl$Core$Geometry$Curves$ParallelogramNodeOverICurve$B = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.B",
    Kind: "Delegate",
    definition: {
        ctor: function (obj, func){
            System.MulticastDelegate.ctor.call(this, obj, func);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$ParallelogramNodeOverICurve$B);
var Microsoft$Msagl$Core$Geometry$Curves$PenetrationDepth = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.PenetrationDepth",
    baseTypeName: "System.Object",
    staticDefinition: {
        PenetrationVector: function (curve0, curve1){
            return Microsoft.Msagl.Core.Geometry.Curves.PenetrationDepth.PenetrationDepthForPolylines(Microsoft.Msagl.Core.Geometry.Curves.PenetrationDepth.PolylineAroundClosedCurve(curve0), Microsoft.Msagl.Core.Geometry.Curves.PenetrationDepth.PolylineAroundClosedCurve(curve1));
        },
        PolylineAroundClosedCurve: function (curve){
            var poly = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
            var $it1259 = Microsoft.Msagl.Core.Geometry.Curves.PenetrationDepth.PointsOnAroundPolyline(curve).GetEnumerator();
            while ($it1259.MoveNext()){
                var point = $it1259.get_Current();
                poly.AddPoint$$Point(point);
            }
            if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(poly.get_StartPoint().get_Point(), poly.get_StartPoint().get_Next().get_Point(), poly.get_StartPoint().get_Next().get_Next().get_Point()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise)
                poly = Cast(poly.Reverse(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor);
            poly.set_Closed(true);
            return poly;
        },
        PointsOnAroundPolyline: function (curve){
            var $yield = [];
            var firstSide = true;
            var prevTangent = null;
            var firstCurveTangent = null;
            var $it1260 = Microsoft.Msagl.Core.Geometry.Curves.PenetrationDepth.TangentsAroundCurve(curve).GetEnumerator();
            while ($it1260.MoveNext()){
                var curveTangent = $it1260.get_Current();
                if (firstSide){
                    firstSide = false;
                    firstCurveTangent = prevTangent = curveTangent;
                }
                else {
                    if (!Microsoft.Msagl.Core.Geometry.Curves.PenetrationDepth.TangentsAreParallel(prevTangent, curveTangent))
                        $yield.push(Microsoft.Msagl.Core.Geometry.Curves.PenetrationDepth.TangentIntersection(prevTangent, curveTangent));
                    prevTangent = curveTangent;
                }
            }
            $yield.push(Microsoft.Msagl.Core.Geometry.Curves.PenetrationDepth.TangentIntersection(firstCurveTangent, prevTangent));
            return $yield;
        },
        TangentsAroundCurve: function (iCurve){
            var $yield = [];
            var c = As(iCurve, Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor);
            if (c != null){
                var $it1261 = c.get_Segments().GetEnumerator();
                while ($it1261.MoveNext()){
                    var seg = $it1261.get_Current();
                    var $it1262 = Microsoft.Msagl.Core.Geometry.Curves.PenetrationDepth.TangentsAroundCurve(seg).GetEnumerator();
                    while ($it1262.MoveNext()){
                        var ct = $it1262.get_Current();
                        $yield.push(ct);
                    }
                }
            }
            else {
                var ls = As(iCurve, Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor);
                if (ls != null)
                    $yield.push(new Microsoft.Msagl.Core.Geometry.Curves.CurveTangent.ctor(ls.get_Start(), ls.Derivative(0)));
                else {
                    var ellipse = As(iCurve, Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ctor);
                    if (ellipse != null){
                        var $it1263 = Microsoft.Msagl.Core.Geometry.Curves.PenetrationDepth.TangentsOfEllipse(ellipse).GetEnumerator();
                        while ($it1263.MoveNext()){
                            var ct = $it1263.get_Current();
                            $yield.push(ct);
                        }
                    }
                    else {
                        var bez = As(iCurve, Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ctor);
                        if (bez != null){
                            var $it1264 = Microsoft.Msagl.Core.Geometry.Curves.PenetrationDepth.TangentsOfBezier(bez).GetEnumerator();
                            while ($it1264.MoveNext()){
                                var ct = $it1264.get_Current();
                                $yield.push(ct);
                            }
                        }
                    }
                }
            }
            return $yield;
        },
        TangentsOfBezier: function (bez){
            var $yield = [];
            var numOfTangents = 8;
            var span = (bez.get_ParEnd() - bez.get_ParStart()) / 8;
            for (var i = 0; i < numOfTangents; i++)
                $yield.push(Microsoft.Msagl.Core.Geometry.Curves.PenetrationDepth.TangentOnICurve(span / 2 + bez.get_ParStart() + span * i, bez));
            return $yield;
        },
        TangentOnICurve: function (p, iCurve){
            return new Microsoft.Msagl.Core.Geometry.Curves.CurveTangent.ctor(iCurve.get_Item$$Double(p), iCurve.Derivative(p));
        },
        TangentsOfEllipse: function (ellipse){
            var $yield = [];
            var angle = 1.0471975511966;
            var numOfTangents = ((System.Math.Ceiling$$Double((ellipse.get_ParEnd() - ellipse.get_ParStart()) / angle)) | 0) + 1;
            var span = (ellipse.get_ParEnd() - ellipse.get_ParStart()) / numOfTangents;
            for (var i = 0; i < numOfTangents; i++)
                $yield.push(Microsoft.Msagl.Core.Geometry.Curves.PenetrationDepth.TangentOnICurve(span / 2 + ellipse.get_ParStart() + span * i, ellipse));
            return $yield;
        },
        TangentIntersection: function (tangentA, tangentB){
            var x;
            (function (){
                var $1 = {
                    Value: x
                };
                var $res = Microsoft.Msagl.Core.Geometry.Point.LineLineIntersection(tangentA.touchPoint, Microsoft.Msagl.Core.Geometry.Point.op_Addition(tangentA.touchPoint, tangentA.direction), tangentB.touchPoint, Microsoft.Msagl.Core.Geometry.Point.op_Addition(tangentB.touchPoint, tangentB.direction), $1);
                x = $1.Value;
                return $res;
            })();
            return x;
        },
        TangentsAreParallel: function (a, b){
            return System.Math.Abs$$Double(a.direction.get_X() * b.direction.get_Y() - a.direction.get_Y() * b.direction.get_X()) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon;
        },
        PenetrationDepthForPolylines: function (poly0, poly1){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(poly0, "poly0");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(poly1, "poly1");
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(poly0.get_Item$$Double(0), poly0.get_Item$$Double(1), poly0.get_Item$$Double(2)) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise && Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(poly1.get_Item$$Double(0), poly1.get_Item$$Double(1), poly1.get_Item$$Double(2)) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise);
            poly0 = Microsoft.Msagl.Core.Geometry.Curves.PenetrationDepth.FlipPolyline(poly0);
            var p0 = Microsoft.Msagl.Core.Geometry.Curves.PenetrationDepth.GetMostLeftLow(poly0);
            var p1 = Microsoft.Msagl.Core.Geometry.Curves.PenetrationDepth.GetMostLeftLow(poly1);
            var minkovski = Microsoft.Msagl.Core.Geometry.Curves.PenetrationDepth.Merge(p0, p1);
            var origin = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            var pp = minkovski.get_StartPoint();
            var d = Infinity;
            var ret = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            do{
                var pn = pp.get_Polyline().Next(pp);
                if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(origin, pp.get_Point(), pn.get_Point()) != Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise){
                    return new Microsoft.Msagl.Core.Geometry.Point.ctor();
                }
                var t;
                var dist = (function (){
                    var $1 = {
                        Value: t
                    };
                    var $res = Microsoft.Msagl.Core.Geometry.Point.DistToLineSegment(origin, pp.get_Point(), pn.get_Point(), $1);
                    t = $1.Value;
                    return $res;
                })();
                if (dist < d){
                    d = dist;
                    ret = Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point((1 - t), pp.get_Point()), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(t, pn.get_Point()));
                }
                pp = pn;
            }
            while (pp != minkovski.get_StartPoint())
            return ret;
        },
        Merge: function (p0, p1){
            var s0 = p0;
            var s1 = p1;
            var ret = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
            while (true){
                ret.AddPoint$$Point(Microsoft.Msagl.Core.Geometry.Point.op_Addition(p0.get_Point(), p1.get_Point()));
                (function (){
                    var $1 = {
                        Value: p0
                    };
                    var $2 = {
                        Value: p1
                    };
                    var $res = Microsoft.Msagl.Core.Geometry.Curves.PenetrationDepth.PickNextVertex($1, $2);
                    p0 = $1.Value;
                    p1 = $2.Value;
                    return $res;
                })();
                if (p0 == s0 && p1 == s1)
                    break;
            }
            ret.set_Closed(true);
            return ret;
        },
        PickNextVertex: function (p0, p1){
            var d = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(p1.Value.get_Point(), p0.Value.get_Point());
            var orient = Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(p1.Value.get_Point(), p1.Value.get_Polyline().Next(p1.Value).get_Point(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(p0.Value.get_Polyline().Next(p0.Value).get_Point(), d));
            if (orient == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise)
                p0.Value = p0.Value.get_Polyline().Next(p0.Value);
            else
                p1.Value = p1.Value.get_Polyline().Next(p1.Value);
        },
        FlipPolyline: function (poly){
            var ret = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
            for (var pp = poly.get_StartPoint(); pp != null; pp = pp.get_Next())
                ret.AddPoint$$Point(Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(pp.get_Point()));
            ret.set_Closed(true);
            return ret;
        },
        GetMostLeftLow: function (poly){
            var ret = poly.get_StartPoint();
            for (var p = ret.get_Next(); p != null; p = p.get_Next())
                if (p.get_Point().get_X() < ret.get_Point().get_X())
                    ret = p;
                else if (p.get_Point().get_X() == ret.get_Point().get_X())if (p.get_Point().get_Y() < ret.get_Point().get_Y())
                    ret = p;
            return ret;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$PenetrationDepth);
var Microsoft$Msagl$Core$Geometry$Curves$PlaneTransformation = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation",
    baseTypeName: "System.Object",
    staticDefinition: {
        op_Multiply$$PlaneTransformation$$Point: function (transformation, point){
            return Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.Multiply$$PlaneTransformation$$Point(transformation, point);
        },
        Multiply$$PlaneTransformation$$Point: function (transformation, point){
            if (Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Inequality(transformation, null))
                return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(transformation.get_Item$$Int32$$Int32(0, 0) * point.get_X() + transformation.get_Item$$Int32$$Int32(0, 1) * point.get_Y() + transformation.get_Item$$Int32$$Int32(0, 2), transformation.get_Item$$Int32$$Int32(1, 0) * point.get_X() + transformation.get_Item$$Int32$$Int32(1, 1) * point.get_Y() + transformation.get_Item$$Int32$$Int32(1, 2));
            return new Microsoft.Msagl.Core.Geometry.Point.ctor();
        },
        op_Multiply$$PlaneTransformation$$PlaneTransformation: function (transformation, transformation0){
            return Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.Multiply$$PlaneTransformation$$PlaneTransformation(transformation, transformation0);
        },
        Multiply$$PlaneTransformation$$PlaneTransformation: function (a, b){
            if (Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Inequality(a, null) && Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Inequality(b, null))
                return new Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.ctor$$Double$$Double$$Double$$Double$$Double$$Double(a.get_Item$$Int32$$Int32(0, 0) * b.get_Item$$Int32$$Int32(0, 0) + a.get_Item$$Int32$$Int32(0, 1) * b.get_Item$$Int32$$Int32(1, 0), a.get_Item$$Int32$$Int32(0, 0) * b.get_Item$$Int32$$Int32(0, 1) + a.get_Item$$Int32$$Int32(0, 1) * b.get_Item$$Int32$$Int32(1, 1), a.get_Item$$Int32$$Int32(0, 0) * b.get_Item$$Int32$$Int32(0, 2) + a.get_Item$$Int32$$Int32(0, 1) * b.get_Item$$Int32$$Int32(1, 2) + a.get_Item$$Int32$$Int32(0, 2), a.get_Item$$Int32$$Int32(1, 0) * b.get_Item$$Int32$$Int32(0, 0) + a.get_Item$$Int32$$Int32(1, 1) * b.get_Item$$Int32$$Int32(1, 0), a.get_Item$$Int32$$Int32(1, 0) * b.get_Item$$Int32$$Int32(0, 1) + a.get_Item$$Int32$$Int32(1, 1) * b.get_Item$$Int32$$Int32(1, 1), a.get_Item$$Int32$$Int32(1, 0) * b.get_Item$$Int32$$Int32(0, 2) + a.get_Item$$Int32$$Int32(1, 1) * b.get_Item$$Int32$$Int32(1, 2) + a.get_Item$$Int32$$Int32(1, 2));
            return null;
        },
        op_Division: function (transform0, transform1){
            if (Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Inequality(transform0, null) && Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Inequality(transform1, null))
                return Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$PlaneTransformation(transform0, transform1.get_Inverse());
            return null;
        },
        Divide: function (transformation0, transformation1){
            return Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Division(transformation0, transformation1);
        },
        UnitTransformation$$: "Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation",
        get_UnitTransformation: function (){
            return new Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.ctor$$Double$$Double$$Double$$Double$$Double$$Double(1, 0, 0, 0, 1, 0);
        },
        Rotation: function (angle){
            var cos = System.Math.Cos(angle);
            var sin = System.Math.Sin(angle);
            return new Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.ctor$$Double$$Double$$Double$$Double$$Double$$Double(cos, -sin, 0, sin, cos, 0);
        },
        op_Equality: function (a, b){
            if (a == null && b == null)
                return true;
            if (a == null)
                return false;
            if (b == null)
                return false;
            for (var i = 0; i < 2; i++)
                for (var j = 0; j < 3; j++)
                    if (a.get_Item$$Int32$$Int32(i, j) != b.get_Item$$Int32$$Int32(i, j))
                        return false;
            return true;
        },
        op_Inequality: function (a, b){
            return !(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Equality(a, b));
        },
        ScaleAroundCenterTransformation: function (scale, center){
            var d = 1 - scale;
            return new Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.ctor$$Double$$Double$$Double$$Double$$Double$$Double(scale, 0, d * center.get_X(), 0, scale, d * center.get_Y());
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.elements = new Array(2);
            System.Object.ctor.call(this);
            this.elements[0] = new Float64Array(3);
            this.elements[1] = new Float64Array(3);
            this.set_Item$$Int32$$Int32(0, 0, (function ($p51){
                this.set_Item$$Int32$$Int32(1, 1, $p51);
                return $p51;
            }).call(this, 1));
        },
        GetHashCode: function (){
            return (this.elements != null ? this.elements.GetHashCode() : 0);
        },
        Equals$$Object: function (obj){
            var t = As(obj, Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.ctor);
            return Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Inequality(t, null) && Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Equality(t, this);
        },
        Elements$$: "System.Double[][]",
        get_Elements: function (){
            return this.elements;
        },
        Item$$: "System.Double",
        get_Item$$Int32$$Int32: function (rowIndex, columnIndex){
            return this.get_Elements()[rowIndex][columnIndex];
        },
        set_Item$$Int32$$Int32: function (rowIndex, columnIndex, value){
            this.get_Elements()[rowIndex][columnIndex] = value;
        },
        ctor$$Double$$Double$$Double$$Double$$Double$$Double: function (matrixElement00, matrixElement01, matrixElement02, matrixElement10, matrixElement11, matrixElement12){
            this.elements = new Array(2);
            System.Object.ctor.call(this);
            this.elements[0] = new Float64Array(3);
            this.elements[1] = new Float64Array(3);
            this.elements[0][0] = matrixElement00;
            this.elements[0][1] = matrixElement01;
            this.elements[0][2] = matrixElement02;
            this.elements[1][0] = matrixElement10;
            this.elements[1][1] = matrixElement11;
            this.elements[1][2] = matrixElement12;
        },
        Inverse$$: "Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation",
        get_Inverse: function (){
            var det = this.get_Elements()[0][0] * this.get_Elements()[1][1] - this.get_Elements()[1][0] * this.get_Elements()[0][1];
            var a00 = this.get_Elements()[1][1] / det;
            var a01 = -this.get_Elements()[0][1] / det;
            var a10 = -this.get_Elements()[1][0] / det;
            var a11 = this.get_Elements()[0][0] / det;
            var a02 = -a00 * this.get_Elements()[0][2] - a01 * this.get_Elements()[1][2];
            var a12 = -a10 * this.get_Elements()[0][2] - a11 * this.get_Elements()[1][2];
            return new Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.ctor$$Double$$Double$$Double$$Double$$Double$$Double(a00, a01, a02, a10, a11, a12);
        },
        IsIdentity$$: "System.Boolean",
        get_IsIdentity: function (){
            return Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(this.get_Elements()[0][0], 1) && Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(this.get_Elements()[0][1], 0) && Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(this.get_Elements()[0][2], 0) && Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(this.get_Elements()[1][0], 0) && Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(this.get_Elements()[1][1], 1) && Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(this.get_Elements()[1][2], 0);
        },
        Offset$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Offset: function (){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.get_Elements()[0][2], this.get_Elements()[1][2]);
        },
        Clone: function (){
            return new Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.ctor$$Double$$Double$$Double$$Double$$Double$$Double(this.get_Item$$Int32$$Int32(0, 0), this.get_Item$$Int32$$Int32(0, 1), this.get_Item$$Int32$$Int32(0, 2), this.get_Item$$Int32$$Int32(1, 0), this.get_Item$$Int32$$Int32(1, 1), this.get_Item$$Int32$$Int32(1, 2));
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$PlaneTransformation);
var Microsoft$Msagl$Core$Geometry$Curves$PolylinePoint = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (p){
            this.point = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.next = null;
            this.prev = null;
            this.polyline = null;
            System.Object.ctor.call(this);
            this.set_Point(p);
        },
        Point$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Point: function (){
            return this.point;
        },
        set_Point: function (value){
            this.point = value;
            if (this.get_Polyline() != null)
                this.get_Polyline().RequireInit();
        },
        Next$$: "Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint",
        get_Next: function (){
            return this.next;
        },
        set_Next: function (value){
            this.next = value;
            if (this.get_Polyline() != null)
                this.get_Polyline().RequireInit();
        },
        Prev$$: "Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint",
        get_Prev: function (){
            return this.prev;
        },
        set_Prev: function (value){
            this.prev = value;
            if (this.get_Polyline() != null)
                this.get_Polyline().RequireInit();
        },
        Polyline$$: "Microsoft.Msagl.Core.Geometry.Curves.Polyline",
        get_Polyline: function (){
            return this.polyline;
        },
        set_Polyline: function (value){
            this.polyline = value;
        },
        toString: function (){
            return this.point.toString();
        },
        NextOnPolyline$$: "Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint",
        get_NextOnPolyline: function (){
            return this.get_Polyline().Next(this);
        },
        PrevOnPolyline$$: "Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint",
        get_PrevOnPolyline: function (){
            return this.get_Polyline().Prev(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$PolylinePoint);
var Microsoft$Msagl$Core$Geometry$Curves$PointLocation = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.PointLocation",
    staticDefinition: {
        Outside: 0,
        Boundary: 1,
        Inside: 2
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$PointLocation);
var Microsoft$Msagl$Core$Geometry$Curves$Polyline = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.Polyline",
    baseTypeName: "System.Object",
    staticDefinition: {
        ParallelogramOfLineSeg: function (a, b){
            var side = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(0.5, (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b, a)));
            return new Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.ctor$$Point$$Point$$Point(a, side, side);
        },
        PolylineFromCurve: function (curve){
            var ret = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
            ret.AddPoint$$Point(curve.get_Start());
            var $it1267 = curve.get_Segments().GetEnumerator();
            while ($it1267.MoveNext()){
                var ls = $it1267.get_Current();
                ret.AddPoint$$Point(ls.get_End());
            }
            ret.set_Closed(Microsoft.Msagl.Core.Geometry.Point.op_Equality(curve.get_Start(), curve.get_End()));
            return ret;
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Core.Geometry.Curves.ICurve", "System.Collections.Generic.IEnumerable$1"],
    Kind: "Class",
    definition: {
        ctor$$IEnumerable$1$Point: function (points){
            this.needToInit = true;
            this.pBNode = null;
            this.startPoint = null;
            this.endPoint = null;
            this.count = 0;
            this.closed = false;
            this.boundingBox = Microsoft.Msagl.Core.Geometry.Rectangle.CreateAnEmptyBox();
            System.Object.ctor.call(this);
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(points, "points");
            var $it1265 = points.GetEnumerator();
            while ($it1265.MoveNext()){
                var p = $it1265.get_Current();
                this.AddPoint$$Point(p);
            }
        },
        RequireInit: function (){
            this.needToInit = true;
        },
        NeedToInit$$: "System.Boolean",
        get_NeedToInit: function (){
            return this.needToInit;
        },
        set_NeedToInit: function (value){
            this.needToInit = value;
        },
        PolylinePoints$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint]]",
        get_PolylinePoints: function (){
            var $yield = [];
            var p = this.get_StartPoint();
            while (p != null){
                $yield.push(p);
                p = p.get_Next();
            }
            return $yield;
        },
        ToCurve: function (){
            var c = new Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor();
            Microsoft.Msagl.Core.Geometry.Curves.Curve.AddLineSegment$$Curve$$Point$$Point(c, this.get_StartPoint().get_Point(), this.get_StartPoint().get_Next().get_Point());
            var p = this.get_StartPoint().get_Next();
            while ((p = p.get_Next()) != null)
                Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Point(c, p.get_Point());
            if (this.get_Closed())
                Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment$$Curve$$Point(c, this.get_StartPoint().get_Point());
            return c;
        },
        StartPoint$$: "Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint",
        get_StartPoint: function (){
            return this.startPoint;
        },
        set_StartPoint: function (value){
            this.RequireInit();
            this.startPoint = value;
        },
        EndPoint$$: "Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint",
        get_EndPoint: function (){
            return this.endPoint;
        },
        set_EndPoint: function (value){
            this.RequireInit();
            this.endPoint = value;
        },
        Count$$: "System.Int32",
        get_Count: function (){
            if (this.needToInit)
                this.Init();
            return this.count;
        },
        Closed$$: "System.Boolean",
        get_Closed: function (){
            return this.closed;
        },
        set_Closed: function (value){
            if (this.closed != value){
                this.closed = value;
                this.RequireInit();
            }
        },
        Item$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Item$$Double: function (t){
            var a,b;
            if (this.get_NeedToInit())
                this.Init();
            (function (){
                var $1 = {
                    Value: t
                };
                var $2 = {
                    Value: a
                };
                var $3 = {
                    Value: b
                };
                var $res = this.GetAdjustedParamAndStartEndPoints($1, $2, $3);
                t = $1.Value;
                a = $2.Value;
                b = $3.Value;
                return $res;
            }).call(this);
            return Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point((1 - t), a), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(t, b));
        },
        GetAdjustedParamAndStartEndPoints: function (t, a, b){
            System.Diagnostics.Debug.Assert$$Boolean(t.Value >= -Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance());
            System.Diagnostics.Debug.Assert$$Boolean(this.get_StartPoint() != null);
            var s = this.get_StartPoint();
            while (s.get_Next() != null){
                if (t.Value <= 1){
                    a.Value = s.get_Point();
                    b.Value = s.get_Next().get_Point();
                    return;
                }
                s = s.get_Next();
                t.Value -= 1;
            }
            if (this.get_Closed()){
                if (t.Value <= 1){
                    a.Value = this.get_EndPoint().get_Point();
                    b.Value = this.get_StartPoint().get_Point();
                    return;
                }
            }
            throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
        },
        Derivative: function (t){
            var a,b;
            if (this.get_NeedToInit())
                this.Init();
            (function (){
                var $1 = {
                    Value: t
                };
                var $2 = {
                    Value: a
                };
                var $3 = {
                    Value: b
                };
                var $res = this.GetAdjustedParamAndStartEndPoints($1, $2, $3);
                t = $1.Value;
                a = $2.Value;
                b = $3.Value;
                return $res;
            }).call(this);
            return Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(b, a);
        },
        LeftDerivative: function (t){
            if (this.get_NeedToInit())
                this.Init();
            var pp = this.TryToGetPolylinePointCorrespondingToT(t);
            if (pp == null)
                return this.Derivative(t);
            var prev = this.TryToGetPrevPointToPolylinePoint(pp);
            if (prev != null)
                return Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(pp.get_Point(), prev.get_Point());
            return Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(pp.get_Next().get_Point(), pp.get_Point());
        },
        RightDerivative: function (t){
            if (this.get_NeedToInit())
                this.Init();
            var pp = this.TryToGetPolylinePointCorrespondingToT(t);
            if (pp == null)
                return this.Derivative(t);
            var next = this.TryToGetNextPointToPolylinePoint(pp);
            if (next != null)
                return Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(next.get_Point(), pp.get_Point());
            return Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(pp.get_Point(), pp.get_Prev().get_Point());
        },
        TryToGetPolylinePointCorrespondingToT: function (t){
            for (var p = this.get_StartPoint(); p != null; p = p.get_Next(), t--)
                if (System.Math.Abs$$Double(t) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                    return p;
            return null;
        },
        TryToGetPrevPointToPolylinePoint: function (p){
            if (p != this.get_StartPoint())
                return p.get_Prev();
            if (!this.get_Closed())
                return null;
            return this.get_EndPoint();
        },
        TryToGetNextPointToPolylinePoint: function (p){
            if (p != this.get_EndPoint())
                return p.get_Next();
            if (!this.get_Closed())
                return null;
            return this.get_StartPoint();
        },
        SecondDerivative: function (t){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor();
        },
        ThirdDerivative: function (t){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor();
        },
        ParallelogramNodeOverICurve$$: "Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve",
        get_ParallelogramNodeOverICurve: function (){
            if (this.get_NeedToInit())
                this.Init();
            return this.pBNode;
        },
        BoundingBox$$: "Microsoft.Msagl.Core.Geometry.Rectangle",
        get_BoundingBox: function (){
            if (this.get_NeedToInit())
                this.Init();
            return this.boundingBox;
        },
        Init: function (){
            this.boundingBox = new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point(this.get_StartPoint().get_Point());
            this.count = 1;
            var $it1266 = System.Linq.Enumerable.Skip$1(Microsoft.Msagl.Core.Geometry.Point.ctor, this, 1).GetEnumerator();
            while ($it1266.MoveNext()){
                var p = $it1266.get_Current();
                this.boundingBox.Add$$Point(p);
                this.count++;
            }
            this.CalculatePbNode();
            this.set_NeedToInit(false);
        },
        CalculatePbNode: function (){
            this.pBNode = new Microsoft.Msagl.Core.Geometry.Curves.ParallelogramInternalTreeNode.ctor(this, Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.DefaultLeafBoxesOffset);
            var parallelograms = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.ctor);
            var pp = this.get_StartPoint();
            var offset = 0;
            while (pp.get_Next() != null){
                var parallelogram = Microsoft.Msagl.Core.Geometry.Curves.Polyline.ParallelogramOfLineSeg(pp.get_Point(), pp.get_Next().get_Point());
                parallelograms.Add(parallelogram);
                this.pBNode.AddChild(new Microsoft.Msagl.Core.Geometry.Curves.ParallelogramLeaf.ctor(offset, offset + 1, parallelogram, this, 0));
                pp = pp.get_Next();
                offset++;
            }
            if (this.get_Closed()){
                var parallelogram = Microsoft.Msagl.Core.Geometry.Curves.Polyline.ParallelogramOfLineSeg(this.get_EndPoint().get_Point(), this.get_StartPoint().get_Point());
                parallelograms.Add(parallelogram);
                this.pBNode.AddChild(new Microsoft.Msagl.Core.Geometry.Curves.ParallelogramLeaf.ctor(offset, offset + 1, parallelogram, this, 0));
            }
            this.pBNode.set_Parallelogram(Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.GetParallelogramOfAGroup(parallelograms));
        },
        ParStart$$: "System.Double",
        get_ParStart: function (){
            return 0;
        },
        ParEnd$$: "System.Double",
        get_ParEnd: function (){
            return this.get_Closed() ? this.get_Count() : this.get_Count() - 1;
        },
        Trim: function (start, end){
            var curve = this.ToCurve();
            curve = Cast(curve.Trim(start, end), Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor);
            return Microsoft.Msagl.Core.Geometry.Curves.Polyline.PolylineFromCurve(curve);
        },
        TrimWithWrap: function (start, end){
            System.Diagnostics.Debug.Assert$$Boolean$$String((start < end) || this.get_Closed(), "Polyline must be closed to wrap");
            var curve = Cast(this.ToCurve().TrimWithWrap(start, end), Microsoft.Msagl.Core.Geometry.Curves.Curve.ctor);
            return Microsoft.Msagl.Core.Geometry.Curves.Polyline.PolylineFromCurve(curve);
        },
        Translate: function (delta){
            var polyPoint = this.get_StartPoint();
            while (polyPoint != null){
                polyPoint.set_Point(Microsoft.Msagl.Core.Geometry.Point.op_Addition(polyPoint.get_Point(), delta));
                polyPoint = polyPoint.get_Next();
            }
            this.RequireInit();
        },
        ScaleFromOrigin: function (xScale, yScale){
            var ret = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
            var polyPoint = this.get_StartPoint();
            while (polyPoint != null){
                ret.AddPoint$$Point(Microsoft.Msagl.Core.Geometry.Point.Scale(xScale, yScale, polyPoint.get_Point()));
                polyPoint = polyPoint.get_Next();
            }
            ret.set_Closed(this.get_Closed());
            return ret;
        },
        AddPoint$$Double$$Double: function (x, y){
            this.AddPoint$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x, y));
        },
        PrependPoint: function (p){
            System.Diagnostics.Debug.Assert$$Boolean(this.get_EndPoint() == null || !Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(p, this.get_EndPoint().get_Point()));
            var pp = (function (){
                var $v130 = new Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor(p);
                $v130.set_Polyline(this);
                return $v130;
            }).call(this);
            if (this.get_StartPoint() != null){
                if (!Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(p, this.get_StartPoint().get_Point())){
                    this.get_StartPoint().set_Prev(pp);
                    pp.set_Next(this.get_StartPoint());
                    this.set_StartPoint(pp);
                }
            }
            else {
                this.set_StartPoint((function ($p52){
                    this.set_EndPoint($p52);
                    return $p52;
                }).call(this, pp));
            }
            this.RequireInit();
        },
        AddPoint$$Point: function (point){
            var pp = (function (){
                var $v131 = new Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor(point);
                $v131.set_Polyline(this);
                return $v131;
            }).call(this);
            if (this.get_EndPoint() != null){
                this.get_EndPoint().set_Next(pp);
                pp.set_Prev(this.get_EndPoint());
                this.set_EndPoint(pp);
            }
            else {
                this.set_StartPoint((function ($p53){
                    this.set_EndPoint($p53);
                    return $p53;
                }).call(this, pp));
            }
            this.RequireInit();
        },
        Start$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Start: function (){
            return this.get_StartPoint().get_Point();
        },
        End$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_End: function (){
            return this.get_EndPoint().get_Point();
        },
        Reverse: function (){
            return this.ReversePolyline();
        },
        OffsetCurve: function (offset, dir){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        LengthPartial: function (start, end){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        Length$$: "System.Double",
        get_Length: function (){
            var ret = 0;
            if (this.get_StartPoint() != null && this.get_StartPoint().get_Next() != null){
                var p = this.get_StartPoint().get_Next();
                do{
                    ret += (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(p.get_Point(), p.get_Prev().get_Point())).get_Length();
                    p = p.get_Next();
                }
                while (p != null)
            }
            return ret;
        },
        GetParameterAtLength: function (length){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        Transform: function (transformation){
            if (Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Equality(transformation, null))
                return this;
            var poly = (function (){
                var $v132 = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
                $v132.set_Closed(this.get_Closed());
                return $v132;
            }).call(this);
            var $it1268 = this.GetEnumerator();
            while ($it1268.MoveNext()){
                var p = $it1268.get_Current();
                poly.AddPoint$$Point(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply$$PlaneTransformation$$Point(transformation, p));
            }
            return poly;
        },
        ClosestParameterWithinBounds: function (targetPoint, low, high){
            var ret = 0;
            var dist = 1.79769313486232E+308;
            var offset = 0;
            var pp = this.get_StartPoint();
            while (pp.get_Next() != null){
                if (offset <= high && offset + 1 >= low){
                    var lowLocal = System.Math.Max$$Double$$Double(0, low - offset);
                    var highLocal = System.Math.Min$$Double$$Double(1, high - offset);
                    var ls = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(pp.get_Point(), pp.get_Next().get_Point());
                    var t = ls.ClosestParameterWithinBounds(targetPoint, lowLocal, highLocal);
                    var delta = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(ls.get_Item$$Double(t), targetPoint);
                    var newDist = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(delta, delta);
                    if (newDist < dist){
                        dist = newDist;
                        ret = t + offset;
                    }
                }
                pp = pp.get_Next();
                offset++;
            }
            if (this.get_Closed()){
                if (offset <= high && offset + 1 >= low){
                    var lowLocal = System.Math.Max$$Double$$Double(0, low - offset);
                    var highLocal = System.Math.Min$$Double$$Double(1, high - offset);
                    var ls = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(this.get_EndPoint().get_Point(), this.get_StartPoint().get_Point());
                    var t = ls.ClosestParameterWithinBounds(targetPoint, lowLocal, highLocal);
                    var delta = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(ls.get_Item$$Double(t), targetPoint);
                    var newDist = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(delta, delta);
                    if (newDist < dist)
                        ret = t + offset;
                }
            }
            return ret;
        },
        ClosestParameter: function (targetPoint){
            var ret = 0;
            var dist = 1.79769313486232E+308;
            var offset = 0;
            var pp = this.get_StartPoint();
            while (pp.get_Next() != null){
                var ls = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(pp.get_Point(), pp.get_Next().get_Point());
                var t = ls.ClosestParameter(targetPoint);
                var delta = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(ls.get_Item$$Double(t), targetPoint);
                var newDist = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(delta, delta);
                if (newDist < dist){
                    dist = newDist;
                    ret = t + offset;
                }
                pp = pp.get_Next();
                offset++;
            }
            if (this.get_Closed()){
                var ls = new Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ctor$$Point$$Point(this.get_EndPoint().get_Point(), this.get_StartPoint().get_Point());
                var t = ls.ClosestParameter(targetPoint);
                var delta = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(ls.get_Item$$Double(t), targetPoint);
                var newDist = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(delta, delta);
                if (newDist < dist)
                    ret = t + offset;
            }
            return ret;
        },
        GetEnumerator: function (){
            return new Microsoft.Msagl.Core.Geometry.Curves.PolylineIterator.ctor(this);
        },
        ReversePolyline: function (){
            var ret = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
            var pp = this.get_EndPoint();
            while (pp.get_Prev() != null){
                ret.AddPoint$$Point(pp.get_Point());
                pp = pp.get_Prev();
            }
            ret.AddPoint$$Point(this.get_StartPoint().get_Point());
            ret.set_Closed(this.get_Closed());
            return ret;
        },
        Next: function (a){
            return (a.get_Next() != null ? a.get_Next() : (this.get_Closed() ? this.get_StartPoint() : null));
        },
        Prev: function (a){
            return (a.get_Prev() != null ? a.get_Prev() : (this.get_Closed() ? this.get_EndPoint() : null));
        },
        ctor$$Point$$Point: function (a, b){
            this.needToInit = true;
            this.pBNode = null;
            this.startPoint = null;
            this.endPoint = null;
            this.count = 0;
            this.closed = false;
            this.boundingBox = Microsoft.Msagl.Core.Geometry.Rectangle.CreateAnEmptyBox();
            System.Object.ctor.call(this);
            this.AddPoint$$Point(a);
            this.AddPoint$$Point(b);
        },
        ctor: function (){
            this.needToInit = true;
            this.pBNode = null;
            this.startPoint = null;
            this.endPoint = null;
            this.count = 0;
            this.closed = false;
            this.boundingBox = Microsoft.Msagl.Core.Geometry.Rectangle.CreateAnEmptyBox();
            System.Object.ctor.call(this);
        },
        ctor$$Point$Array: function (points){
            this.needToInit = true;
            this.pBNode = null;
            this.startPoint = null;
            this.endPoint = null;
            this.count = 0;
            this.closed = false;
            this.boundingBox = Microsoft.Msagl.Core.Geometry.Rectangle.CreateAnEmptyBox();
            Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor$$IEnumerable$1$Point.call(this, points);
        },
        IsClockwise: function (){
            return Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(this.get_StartPoint().get_Point(), this.get_StartPoint().get_Next().get_Point(), this.get_StartPoint().get_Next().get_Next().get_Point()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise;
        },
        RemoveStartPoint: function (){
            var p = this.get_StartPoint().get_Next();
            p.set_Prev(null);
            this.set_StartPoint(p);
            this.RequireInit();
        },
        RemoveEndPoint: function (){
            var p = this.get_EndPoint().get_Prev();
            p.set_Next(null);
            this.set_EndPoint(p);
            this.RequireInit();
        },
        GetPointLocation$$Point$$PolylinePoint: function (point, witness){
            System.Diagnostics.Debug.Assert$$Boolean(this.get_Closed() && this.IsClockwise());
            witness.Value = null;
            var $it1269 = this.get_PolylinePoints().GetEnumerator();
            while ($it1269.MoveNext()){
                var polyPoint = $it1269.get_Current();
                var secondPoint = this.Next(polyPoint);
                var triangleOrientation = Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(point, polyPoint.get_Point(), secondPoint.get_Point());
                if (triangleOrientation == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise)
                    return Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside;
                if (triangleOrientation == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Collinear)if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(point, polyPoint.get_Point())), (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(secondPoint.get_Point(), point))) >= 0){
                    witness.Value = polyPoint;
                    return Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Boundary;
                }
            }
            return Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Inside;
        },
        GetPointLocation$$Point$$Point$$Point: function (point, edgeStart, edgeEnd){
            var start;
            edgeStart.Value = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            edgeEnd.Value = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            var loc = (function (){
                var $1 = {
                    Value: start
                };
                var $res = this.GetPointLocation$$Point$$PolylinePoint(point, $1);
                start = $1.Value;
                return $res;
            }).call(this);
            if (Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Boundary == loc){
                edgeStart.Value = start.get_Point();
                edgeEnd.Value = start.get_NextOnPolyline().get_Point();
            }
            return loc;
        },
        Shift: function (delta){
            for (var pp = this.get_StartPoint(); pp != null; pp = pp.get_Next())
                pp.set_Point(Microsoft.Msagl.Core.Geometry.Point.op_Addition(pp.get_Point(), delta));
        },
        Curvature: function (t){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        CurvatureDerivative: function (t){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        CurvatureSecondDerivative: function (t){
            throw $CreateException(new System.NotImplementedException.ctor(), new Error());
        },
        AddRangeOfPoints: function (points){
            var $it1270 = points.GetEnumerator();
            while ($it1270.MoveNext()){
                var point = $it1270.get_Current();
                this.AddPoint$$Point(point);
            }
        },
        GetPolylinePoint: function (i){
            for (var p = this.startPoint; p != null; p = p.get_Next(), i--)
                if (i == 0)
                    return p;
            return null;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$Polyline);
var Microsoft$Msagl$Core$Geometry$Curves$PolylineIterator = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.PolylineIterator",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IEnumerator$1"],
    Kind: "Class",
    definition: {
        ctor: function (poly){
            this.polyline = null;
            this.currentPolyPoint = null;
            System.Object.ctor.call(this);
            this.polyline = poly;
        },
        Current$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Current: function (){
            return this.currentPolyPoint.get_Point();
        },
        MoveNext: function (){
            if (this.currentPolyPoint == null){
                this.currentPolyPoint = this.polyline.get_StartPoint();
                return this.currentPolyPoint != null;
            }
            if (this.currentPolyPoint == this.polyline.get_EndPoint())
                return false;
            this.currentPolyPoint = this.currentPolyPoint.get_Next();
            return true;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$PolylineIterator);
var Microsoft$Msagl$Core$Geometry$Rectangle = {
    fullname: "Microsoft.Msagl.Core.Geometry.Rectangle",
    baseTypeName: "System.ValueType",
    staticDefinition: {
        CreateAnEmptyBox: function (){
            return new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Double$$Double$$Point(0, 0, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-1, -1));
        },
        op_Equality: function (rectangle0, rectangle1){
            return rectangle0.Equals$$Rectangle(rectangle1);
        },
        op_Inequality: function (rectangle0, rectangle1){
            return !rectangle0.Equals$$Rectangle(rectangle1);
        },
        Translate: function (rectangle, delta){
            rectangle.set_Center(Microsoft.Msagl.Core.Geometry.Point.op_Addition(rectangle.get_Center(), delta));
            return rectangle;
        },
        Intersect: function (rect1, rect2){
            if (rect1.Intersects(rect2))
                return new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(System.Math.Max$$Double$$Double(rect1.get_Left(), rect2.get_Left()), System.Math.Max$$Double$$Double(rect1.get_Bottom(), rect2.get_Bottom())), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(System.Math.Min$$Double$$Double(rect1.get_Right(), rect2.get_Right()), System.Math.Min$$Double$$Double(rect1.get_Top(), rect2.get_Top())));
            return Microsoft.Msagl.Core.Geometry.Rectangle.CreateAnEmptyBox();
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Struct",
    definition: {
        ctor$$Point$$Point: function (point0, point1){
            this.left = 0;
            this.right = 0;
            this.top = 0;
            this.bottom = 0;
            System.ValueType.ctor.call(this);
            this.left = this.right = point0.get_X();
            this.top = this.bottom = point0.get_Y();
            this.Add$$Point(point1);
        },
        toString: function (){
            return "(" + this.get_LeftBottom() + " " + this.get_RightTop() + ")";
        },
        Intersects: function (rectangle){
            return this.IntersectsOnX(rectangle) && this.IntersectsOnY(rectangle);
        },
        Center$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Center: function (){
            return Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(0.5, (Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.get_LeftTop(), this.get_RightBottom())));
        },
        set_Center: function (value){
            var shift = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(value, this.get_Center());
            this.set_LeftTop(Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.get_LeftTop(), shift));
            this.set_RightBottom(Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.get_RightBottom(), shift));
        },
        IntersectsOnY: function (r){
            if (r.get_Bottom() > this.top + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return false;
            if (r.get_Top() < this.bottom - Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return false;
            return true;
        },
        IntersectsOnX: function (r){
            if (r.get_Left() > this.right + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return false;
            if (r.get_Right() < this.left - Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                return false;
            return true;
        },
        Equals$$Object: function (obj){
            if (Is(obj, Microsoft.Msagl.Core.Geometry.Rectangle.ctor))
                this.Equals$$Rectangle(Cast(obj, Microsoft.Msagl.Core.Geometry.Rectangle.ctor));
            return false;
        },
        Equals$$Rectangle: function (rec){
            return rec.get_Left() == this.get_Left() && rec.get_Right() == this.get_Right() && rec.get_Top() == this.get_Top() && rec.get_Bottom() == this.get_Bottom();
        },
        GetHashCode: function (){
            return System.ValueType.commonPrototype.GetHashCode.call(this);
        },
        Left$$: "System.Double",
        get_Left: function (){
            return this.left;
        },
        set_Left: function (value){
            this.left = value;
        },
        Right$$: "System.Double",
        get_Right: function (){
            return this.right;
        },
        set_Right: function (value){
            this.right = value;
        },
        Top$$: "System.Double",
        get_Top: function (){
            return this.top;
        },
        set_Top: function (value){
            this.top = value;
        },
        Bottom$$: "System.Double",
        get_Bottom: function (){
            return this.bottom;
        },
        set_Bottom: function (value){
            this.bottom = value;
        },
        LeftBottom$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_LeftBottom: function (){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.get_Left(), this.get_Bottom());
        },
        RightTop$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_RightTop: function (){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.get_Right(), this.get_Top());
        },
        LeftTop$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_LeftTop: function (){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.left, this.top);
        },
        set_LeftTop: function (value){
            this.left = value.get_X();
            this.top = value.get_Y();
        },
        RightBottom$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_RightBottom: function (){
            return new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(this.right, this.bottom);
        },
        set_RightBottom: function (value){
            this.right = value.get_X();
            this.set_Bottom(value.get_Y());
        },
        ctor$$Point: function (point){
            this.left = 0;
            this.right = 0;
            this.top = 0;
            this.bottom = 0;
            System.ValueType.ctor.call(this);
            this.left = this.right = point.get_X();
            this.top = this.bottom = point.get_Y();
        },
        ctor$$Double$$Double$$Point: function (left, bottom, sizeF){
            this.left = 0;
            this.right = 0;
            this.top = 0;
            this.bottom = 0;
            System.ValueType.ctor.call(this);
            this.left = left;
            this.bottom = bottom;
            this.right = left + sizeF.get_X();
            this.top = bottom + sizeF.get_Y();
        },
        ctor$$Double$$Double$$Double$$Double: function (x0, y0, x1, y1){
            this.left = 0;
            this.right = 0;
            this.top = 0;
            this.bottom = 0;
            System.ValueType.ctor.call(this);
            this.left = this.right = x0;
            this.top = this.bottom = y0;
            this.Add$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(x1, y1));
        },
        ctor$$IEnumerable$1$Point: function (points){
            this.left = 0;
            this.right = 0;
            this.top = 0;
            this.bottom = 0;
            Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Double$$Double$$Point.call(this, 0, 0, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-1, -1));
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(points, "points");
            var $it1271 = points.GetEnumerator();
            while ($it1271.MoveNext()){
                var p = $it1271.get_Current();
                this.Add$$Point(p);
            }
        },
        ctor$$IEnumerable$1$Rectangle: function (rectangles){
            this.left = 0;
            this.right = 0;
            this.top = 0;
            this.bottom = 0;
            Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Double$$Double$$Point.call(this, 0, 0, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(-1, -1));
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(rectangles, "rectangles");
            var $it1272 = rectangles.GetEnumerator();
            while ($it1272.MoveNext()){
                var r = $it1272.get_Current();
                this.Add$$Rectangle(r);
            }
        },
        Width$$: "System.Double",
        get_Width: function (){
            return this.right - this.left;
        },
        set_Width: function (value){
            var hw = value / 2;
            var cx = (this.left + this.right) / 2;
            this.left = cx - hw;
            this.right = cx + hw;
        },
        IsEmpty$$: "System.Boolean",
        get_IsEmpty: function (){
            return this.get_Width() < 0;
        },
        SetToEmpty: function (){
            this.set_Left(0);
            this.set_Right(-1);
        },
        Height$$: "System.Double",
        get_Height: function (){
            return this.top - this.bottom;
        },
        set_Height: function (value){
            var hw = value / 2;
            var cx = (this.top + this.bottom) / 2;
            this.top = cx + hw;
            this.bottom = cx - hw;
        },
        ctor$$Rectangle$$Rectangle: function (rectangle0, rectangle1){
            this.left = 0;
            this.right = 0;
            this.top = 0;
            this.bottom = 0;
            System.ValueType.ctor.call(this);
            this.left = rectangle0.left;
            this.right = rectangle0.right;
            this.top = rectangle0.top;
            this.bottom = rectangle0.bottom;
            this.Add$$Rectangle(rectangle1);
        },
        Contains$$Point$$Double: function (point, padding){
            return this.left - padding - Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon <= point.get_X() && point.get_X() <= this.right + padding + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon && this.bottom - padding - Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon <= point.get_Y() && point.get_Y() <= this.top + padding + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon;
        },
        Area$$: "System.Double",
        get_Area: function (){
            return (this.right - this.left) * (this.top - this.bottom);
        },
        Add$$Point: function (point){
            if (!this.get_IsEmpty()){
                if (this.left > point.get_X())
                    this.left = point.get_X();
                if (this.top < point.get_Y())
                    this.top = point.get_Y();
                if (this.right < point.get_X())
                    this.right = point.get_X();
                if (this.bottom > point.get_Y())
                    this.bottom = point.get_Y();
            }
            else {
                this.left = this.right = point.get_X();
                this.top = this.bottom = point.get_Y();
            }
        },
        AddWithCheck: function (point){
            var wider;
            if (wider = (point.get_X() < this.left))
                this.left = point.get_X();
            else if (wider = (this.right < point.get_X()))
                this.right = point.get_X();
            var higher;
            if (higher = (point.get_Y() > this.top))
                this.top = point.get_Y();
            else if (higher = (this.bottom > point.get_Y()))
                this.bottom = point.get_Y();
            return wider || higher;
        },
        Add$$Rectangle: function (rectangle){
            this.Add$$Point(rectangle.get_LeftTop());
            this.Add$$Point(rectangle.get_RightBottom());
        },
        Contains$$Point: function (point){
            return (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Compare(this.left, point.get_X()) <= 0) && (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Compare(this.right, point.get_X()) >= 0) && (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Compare(this.top, point.get_Y()) >= 0) && (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Compare(this.bottom, point.get_Y()) <= 0);
        },
        Contains$$Rectangle: function (rect){
            return this.Contains$$Point(rect.get_LeftTop()) && this.Contains$$Point(rect.get_RightBottom());
        },
        Diagonal$$: "System.Double",
        get_Diagonal: function (){
            return System.Math.Sqrt(this.get_Width() * this.get_Width() + this.get_Height() * this.get_Height());
        },
        PadWidth: function (padding){
            this.set_Left(this.get_Left() - padding);
            this.set_Right(this.get_Right() + padding);
        },
        PadHeight: function (padding){
            this.set_Top(this.get_Top() + padding);
            this.set_Bottom(this.get_Bottom() - padding);
        },
        Pad$$Double: function (padding){
            if (padding < -this.get_Width() / 2)
                padding = -this.get_Width() / 2;
            if (padding < -this.get_Height() / 2)
                padding = -this.get_Height() / 2;
            this.PadWidth(padding);
            this.PadHeight(padding);
        },
        Pad$$Double$$Double$$Double$$Double: function (left, bottom, right, top){
            this.set_Left(this.get_Left() - left);
            this.set_Right(this.get_Right() + right);
            this.set_Bottom(this.get_Bottom() - bottom);
            this.set_Top(this.get_Top() + top);
        },
        Perimeter: function (){
            var poly = new Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor();
            poly.AddPoint$$Point(this.get_LeftTop());
            poly.AddPoint$$Point(this.get_RightTop());
            poly.AddPoint$$Point(this.get_RightBottom());
            poly.AddPoint$$Point(this.get_LeftBottom());
            poly.set_Closed(true);
            return poly;
        },
        ScaleAroundCenter: function (scale){
            this.set_Width(this.get_Width() * scale);
            this.set_Height(this.get_Height() * scale);
        },
        Clone: function (){
            return new Microsoft.Msagl.Core.Geometry.Rectangle.ctor$$Point$$Point(this.get_LeftTop(), this.get_RightBottom());
        },
        Size$$: "Microsoft.Msagl.Core.DataStructures.Size",
        get_Size: function (){
            return new Microsoft.Msagl.Core.DataStructures.Size.ctor$$Double$$Double(this.get_Width(), this.get_Height());
        },
        set_Size: function (value){
            this.set_Width(value.get_Width());
            this.set_Height(value.get_Height());
        },
        ctor$$Size$$Point: function (size, center){
            this.left = 0;
            this.right = 0;
            this.top = 0;
            this.bottom = 0;
            System.ValueType.ctor.call(this);
            var w = size.get_Width() / 2;
            this.left = center.get_X() - w;
            this.right = center.get_X() + w;
            var h = size.get_Height() / 2;
            this.bottom = center.get_Y() - h;
            this.top = center.get_Y() + h;
        },
        Add$$Size$$Point: function (size, point){
            var w = size.get_Width() / 2;
            var h = size.get_Height() / 2;
            this.Add$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(point.get_X() - w, point.get_Y() - h));
            this.Add$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(point.get_X() + w, point.get_Y() - h));
            this.Add$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(point.get_X() - w, point.get_Y() + h));
            this.Add$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(point.get_X() + w, point.get_Y() + h));
        },
        ctor: function (){
            this.left = 0;
            this.right = 0;
            this.top = 0;
            this.bottom = 0;
            System.ValueType.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Rectangle);
var Microsoft$Msagl$Core$Geometry$Curves$RootFinder = {
    fullname: "Microsoft.Msagl.Core.Geometry.Curves.RootFinder",
    baseTypeName: "System.Object",
    staticDefinition: {
        TryToFindRoot: function (f, start, end, guess, x){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(f, "f");
            System.Diagnostics.Debug.Assert$$Boolean(start >= f.get_ParStart() && end <= f.get_ParEnd());
            System.Diagnostics.Debug.Assert$$Boolean(start <= guess && end >= guess);
            var numberOfBoundaryCrossings = 0;
            var maxNumberOfBoundaryCrossings = 10;
            var numberOfTotalReps = 0;
            var maxNumberOfTotalReps = 100;
            x.Value = guess;
            var dx;
            var abort = false;
            do{
                var fp = f.Derivative(x.Value);
                if (System.Math.Abs$$Double(fp) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance()){
                    abort = true;
                    break;
                }
                dx = -f.get_Item$$Double(x.Value) / fp;
                x.Value += dx;
                if (x.Value < start - Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                    x.Value = start;
                    numberOfBoundaryCrossings++;
                }
                else if (x.Value > end + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                    x.Value = end;
                    numberOfBoundaryCrossings++;
                }
                numberOfTotalReps++;
                abort = numberOfBoundaryCrossings >= maxNumberOfBoundaryCrossings || numberOfTotalReps >= maxNumberOfTotalReps || dx == 0;
            }
            while (System.Math.Abs$$Double(dx) >= Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance() && !abort)
            if (abort){
                if (System.Math.Abs$$Double(f.get_Item$$Double(guess)) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                    x.Value = guess;
                    return true;
                }
                return false;
            }
            if (x.Value < start)
                x.Value = start;
            else if (x.Value > end)
                x.Value = end;
            return true;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$Geometry$Curves$RootFinder);
var Microsoft$Msagl$Routing$Visibility$ActiveDiagonalComparerWithRay = {
    fullname: "Microsoft.Msagl.Routing.Visibility.ActiveDiagonalComparerWithRay",
    baseTypeName: "System.Object",
    staticDefinition: {
        BelongsToTheDiagonal: function (IntersectionOfTheRayAndInsertedEdge, start, end){
            return Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(IntersectionOfTheRayAndInsertedEdge, Microsoft.Msagl.Core.Geometry.Point.ClosestPointAtLineSegment(IntersectionOfTheRayAndInsertedEdge, start, end));
        },
        IntersectDiagonalWithRay: function (pivot, pointOnRay, diagonal){
            var ray = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(pointOnRay, pivot);
            var source = diagonal.get_Start();
            var target = diagonal.get_End();
            var x,y;
            var result = (function (){
                var $1 = {
                    Value: x
                };
                var $2 = {
                    Value: y
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.LinearSystem2.Solve(target.get_X() - source.get_X(), -ray.get_X(), pivot.get_X() - source.get_X(), target.get_Y() - source.get_Y(), -ray.get_Y(), pivot.get_Y() - source.get_Y(), $1, $2);
                x = $1.Value;
                y = $2.Value;
                return $res;
            })();
            System.Diagnostics.Debug.Assert$$Boolean(result && -Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance() <= x && x <= 1 + Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance());
            return Microsoft.Msagl.Core.Geometry.Point.op_Addition(pivot, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(y, ray));
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IComparer$1"],
    Kind: "Class",
    definition: {
        ctor: function (){
            this.pointOnTheRay = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            System.Object.ctor.call(this);
        },
        PointOnTangentAndInsertedDiagonal$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_PointOnTangentAndInsertedDiagonal: function (){
            return this.pointOnTheRay;
        },
        set_PointOnTangentAndInsertedDiagonal: function (value){
            this.pointOnTheRay = value;
        },
        Compare: function (x, y){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(x, "x");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(y, "y");
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Routing.Visibility.ActiveDiagonalComparerWithRay.BelongsToTheDiagonal(this.get_PointOnTangentAndInsertedDiagonal(), x.get_Start(), x.get_End()));
            if (Microsoft.Msagl.Core.Geometry.Point.op_Inequality(x.get_Start(), y.get_Start()))
                switch (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(this.get_PointOnTangentAndInsertedDiagonal(), y.get_Start(), y.get_End())){
                    case Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise:
                        return -1;
                    default:
                        return 1;
                }
            else {
                return 0;
            }
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Visibility$ActiveDiagonalComparerWithRay);
var Microsoft$Msagl$Routing$Visibility$ActiveEdgeComparerWithRay = {
    fullname: "Microsoft.Msagl.Routing.Visibility.ActiveEdgeComparerWithRay",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IComparer$1"],
    Kind: "Class",
    definition: {
        ctor$$Point$$Point: function (pivot, pointOnTheRay){
            this.pivot = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.pointOnTheRay = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            System.Object.ctor.call(this);
            this.pivot = pivot;
            this.pointOnTheRay = pointOnTheRay;
        },
        Pivot$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Pivot: function (){
            return this.pivot;
        },
        set_Pivot: function (value){
            this.pivot = value;
        },
        IntersectionOfTheRayAndInsertedEdge$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_IntersectionOfTheRayAndInsertedEdge: function (){
            return this.pointOnTheRay;
        },
        set_IntersectionOfTheRayAndInsertedEdge: function (value){
            this.pointOnTheRay = value;
        },
        IntersectionPointBelongsToTheInsertedEdge: function (x){
            var a = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(x.get_Point(), this.get_IntersectionOfTheRayAndInsertedEdge());
            var b = Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(x.get_NextOnPolyline().get_Point(), this.get_IntersectionOfTheRayAndInsertedEdge());
            return System.Math.Abs$$Double(a.get_X() * b.get_Y() - b.get_X() * a.get_Y()) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon;
        },
        IntersectEdgeWithRay$$Point$$Point$$Point: function (source, target, ray){
            var x,y;
            var result = (function (){
                var $1 = {
                    Value: x
                };
                var $2 = {
                    Value: y
                };
                var $res = Microsoft.Msagl.Core.Geometry.Curves.LinearSystem2.Solve(target.get_X() - source.get_X(), -ray.get_X(), this.get_Pivot().get_X() - source.get_X(), target.get_Y() - source.get_Y(), -ray.get_Y(), this.get_Pivot().get_Y() - source.get_Y(), $1, $2);
                x = $1.Value;
                y = $2.Value;
                return $res;
            }).call(this);
            if (!(-Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance() <= x && x <= 1 + Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance()))
                throw $CreateException(new System.Exception.ctor(), new Error());
            if (!result)
                throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            return Microsoft.Msagl.Core.Geometry.Point.op_Addition(this.get_Pivot(), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(y, ray));
        },
        IntersectEdgeWithRay$$PolylinePoint$$Point: function (side, ray){
            return this.IntersectEdgeWithRay$$Point$$Point$$Point(side.get_Point(), side.get_NextOnPolyline().get_Point(), ray);
        },
        ctor: function (){
            this.pivot = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.pointOnTheRay = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Visibility$ActiveEdgeComparerWithRay);
var Microsoft$Msagl$Routing$Visibility$BimodalSequence = {
    fullname: "Microsoft.Msagl.Routing.Visibility.BimodalSequence",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (sequence, length){
            this.sequence = null;
            this.length = 0;
            System.Object.ctor.call(this);
            this.sequence = sequence;
            this.length = length;
        },
        Sequence$$: "System.Func`2[[System.Int32],[System.Double]]",
        get_Sequence: function (){
            return this.sequence;
        },
        Length$$: "System.Int32",
        get_Length: function (){
            return this.length;
        },
        FindMinimum: function (){
            if (this.sequence(0) == this.sequence(this.get_Length() - 1))
                return (new Microsoft.Msagl.Routing.Visibility.UnimodalSequence.ctor(this.sequence, this.get_Length())).FindMinimum();
            return (new Microsoft.Msagl.Routing.Visibility.UnimodalSequence.ctor(this.GetAdjustedSequenceForMinimum(), this.get_Length())).FindMinimum();
        },
        GetAdjustedSequenceForMinimum: function (){
            var leftVal = this.get_Sequence()(0);
            var rightVal = this.get_Sequence()(this.get_Length() - 1);
            var k = (rightVal - leftVal) / (this.get_Length() - 1);
            return $CreateAnonymousDelegate(this, function (i){
                return System.Math.Min$$Double$$Double(this.get_Sequence()(i), leftVal + k * i);
            });
        },
        FindMaximum: function (){
            if (this.sequence(0) == this.sequence(this.get_Length() - 1))
                return (new Microsoft.Msagl.Routing.Visibility.UnimodalSequence.ctor(this.sequence, this.get_Length())).FindMaximum();
            return (new Microsoft.Msagl.Routing.Visibility.UnimodalSequence.ctor(this.GetAdjustedSequenceForMaximum(), this.get_Length())).FindMaximum();
        },
        GetAdjustedSequenceForMaximum: function (){
            var leftVal = this.get_Sequence()(0);
            var rightVal = this.get_Sequence()(this.get_Length() - 1);
            var k = (rightVal - leftVal) / (this.get_Length() - 1);
            return $CreateAnonymousDelegate(this, function (i){
                return System.Math.Max$$Double$$Double(this.get_Sequence()(i), leftVal + k * i);
            });
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Visibility$BimodalSequence);
var Microsoft$Msagl$Routing$Spline$ConeSpanner$IConeSweeper = {
    fullname: "Microsoft.Msagl.Routing.Spline.ConeSpanner.IConeSweeper",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Interface"
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$ConeSpanner$IConeSweeper);
var Microsoft$Msagl$Routing$Spline$ConeSpanner$LeftIntersectionEvent = {
    fullname: "Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftIntersectionEvent",
    baseTypeName: "Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (coneLeftSide, intersectionPoint, endVertex){
            this.coneLeftSide = null;
            this.intersectionPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.endVertex = null;
            Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent.ctor.call(this);
            this.coneLeftSide = coneLeftSide;
            this.intersectionPoint = intersectionPoint;
            this.endVertex = endVertex;
        },
        EndVertex$$: "Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint",
        get_EndVertex: function (){
            return this.endVertex;
        },
        Site$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Site: function (){
            return this.intersectionPoint;
        },
        toString: function (){
            return "LeftIntersectionEvent " + this.intersectionPoint;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$ConeSpanner$LeftIntersectionEvent);
var Microsoft$Msagl$Routing$Spline$ConeSpanner$LeftObstacleSide = {
    fullname: "Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftObstacleSide",
    baseTypeName: "Microsoft.Msagl.Routing.Spline.ConeSpanner.ObstacleSide",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (startVertex){
            this.end = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            Microsoft.Msagl.Routing.Spline.ConeSpanner.ObstacleSide.ctor.call(this, startVertex);
            this.end = startVertex.get_NextOnPolyline().get_Point();
        },
        End$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_End: function (){
            return this.end;
        },
        EndVertex$$: "Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint",
        get_EndVertex: function (){
            return this.get_StartVertex().get_NextOnPolyline();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$ConeSpanner$LeftObstacleSide);
var Microsoft$Msagl$Routing$Spline$ConeSpanner$LineSweeperForPortLocations = {
    fullname: "Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeperForPortLocations",
    baseTypeName: "Microsoft.Msagl.Routing.Visibility.LineSweeperBase",
    staticDefinition: {
        Sweep: function (obstacles, direction, coneAngle, visibilityGraph, portLocations){
            var cs = new Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeperForPortLocations.ctor(obstacles, direction, direction.Rotate(-coneAngle / 2), direction.Rotate(coneAngle / 2), visibilityGraph, portLocations);
            cs.Calculate();
        },
        PointIsToTheLeftOfSegment: function (p, seg){
            return (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(seg.get_Start(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(seg.get_Start(), seg.get_Direction()), p) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise);
        },
        PointIsToTheRightOfSegment: function (p, seg){
            return (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(seg.get_Start(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(seg.get_Start(), seg.get_Direction()), p) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise);
        },
        VertexIsToTheLeftOfSegment: function (vertexEvent, seg){
            return (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(seg.get_Start(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(seg.get_Start(), seg.get_Direction()), vertexEvent.get_Site()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise);
        },
        VertexIsToTheRightOfSegment: function (vertexEvent, seg){
            return (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(seg.get_Start(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(seg.get_Start(), seg.get_Direction()), vertexEvent.get_Site()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise);
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Routing.Spline.ConeSpanner.IConeSweeper"],
    Kind: "Class",
    definition: {
        ctor: function (obstacles, direction, coneRsDir, coneLsDir, visibilityGraph, portLocations){
            this.coneSideComparer = null;
            this.visibilityGraph = null;
            this.rightConeSides = null;
            this.leftConeSides = null;
            this._ConeRightSideDirection = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._ConeLeftSideDirection = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._PortLocations = null;
            Microsoft.Msagl.Routing.Visibility.LineSweeperBase.ctor.call(this, obstacles, direction);
            this.visibilityGraph = visibilityGraph;
            this.set_ConeRightSideDirection(coneRsDir);
            this.set_ConeLeftSideDirection(coneLsDir);
            this.coneSideComparer = new Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSideComparer.ctor(this);
            this.leftConeSides = new Microsoft.Msagl.Core.DataStructures.RbTree$1.ctor$$IComparer$1(Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSide.ctor, this.coneSideComparer);
            this.rightConeSides = new Microsoft.Msagl.Core.DataStructures.RbTree$1.ctor$$IComparer$1(Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSide.ctor, this.coneSideComparer);
            this.set_PortLocations(portLocations);
        },
        ConeRightSideDirection$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_ConeRightSideDirection: function (){
            return this._ConeRightSideDirection;
        },
        set_ConeRightSideDirection: function (value){
            this._ConeRightSideDirection = value;
        },
        ConeLeftSideDirection$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_ConeLeftSideDirection: function (){
            return this._ConeLeftSideDirection;
        },
        set_ConeLeftSideDirection: function (value){
            this._ConeLeftSideDirection = value;
        },
        PortLocations$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Geometry.Point]]",
        get_PortLocations: function (){
            return this._PortLocations;
        },
        set_PortLocations: function (value){
            this._PortLocations = value;
        },
        Calculate: function (){
            this.InitQueueOfEvents();
            var $it1273 = this.get_PortLocations().GetEnumerator();
            while ($it1273.MoveNext()){
                var portLocation = $it1273.get_Current();
                this.EnqueueEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.PortLocationEvent.ctor(portLocation));
            }
            while (this.get_EventQueue().get_Count() > 0)
                this.ProcessEvent(this.get_EventQueue().Dequeue());
        },
        ProcessEvent: function (p){
            var vertexEvent = As(p, Microsoft.Msagl.Routing.Spline.ConeSpanner.VertexEvent.ctor);
            if (vertexEvent != null)
                this.ProcessVertexEvent(vertexEvent);
            else {
                var rightIntersectionEvent = As(p, Microsoft.Msagl.Routing.Spline.ConeSpanner.RightIntersectionEvent.ctor);
                if (rightIntersectionEvent != null)
                    this.ProcessRightIntersectionEvent(rightIntersectionEvent);
                else {
                    var leftIntersectionEvent = As(p, Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftIntersectionEvent.ctor);
                    if (leftIntersectionEvent != null)
                        this.ProcessLeftIntersectionEvent(leftIntersectionEvent);
                    else {
                        var coneClosure = As(p, Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeClosureEvent.ctor);
                        if (coneClosure != null){
                            if (!coneClosure.get_ConeToClose().get_Removed())
                                this.RemoveCone(coneClosure.get_ConeToClose());
                        }
                        else {
                            var portLocationEvent = As(p, Microsoft.Msagl.Routing.Spline.ConeSpanner.PortLocationEvent.ctor);
                            if (portLocationEvent != null)
                                this.ProcessPortLocationEvent(portLocationEvent);
                            else
                                this.ProcessPointObstacleEvent(Cast(p, Microsoft.Msagl.Routing.Visibility.PortObstacleEvent.ctor));
                        }
                        this.set_Z(this.GetZ$$SweepEvent(p));
                    }
                }
            }
        },
        ProcessPointObstacleEvent: function (portObstacleEvent){
            this.set_Z(this.GetZ$$SweepEvent(portObstacleEvent));
            this.GoOverConesSeeingVertexEvent(portObstacleEvent);
        },
        CreateConeOnPortLocation: function (sweepEvent){
            var cone = new Microsoft.Msagl.Routing.Spline.ConeSpanner.Cone.ctor(sweepEvent.get_Site(), this);
            var leftNode = this.InsertToTree(this.leftConeSides, cone.set_LeftSide(new Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeLeftSide.ctor(cone)));
            var rightNode = this.InsertToTree(this.rightConeSides, cone.set_RightSide(new Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeRightSide.ctor(cone)));
            this.LookForIntersectionWithConeRightSide(rightNode);
            this.LookForIntersectionWithConeLeftSide(leftNode);
        },
        ProcessPortLocationEvent: function (portEvent){
            this.set_Z(this.GetZ$$SweepEvent(portEvent));
            this.GoOverConesSeeingVertexEvent(portEvent);
            this.CreateConeOnPortLocation(portEvent);
        },
        ProcessLeftIntersectionEvent: function (leftIntersectionEvent){
            if (leftIntersectionEvent.coneLeftSide.get_Removed() == false){
                if (System.Math.Abs$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(leftIntersectionEvent.get_EndVertex().get_Point(), leftIntersectionEvent.get_Site())), this.get_SweepDirection())) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                    this.RemoveCone(leftIntersectionEvent.coneLeftSide.get_Cone());
                }
                else {
                    this.RemoveSegFromLeftTree(leftIntersectionEvent.coneLeftSide);
                    this.set_Z(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.get_SweepDirection(), leftIntersectionEvent.get_Site()));
                    var leftSide = new Microsoft.Msagl.Routing.Spline.ConeSpanner.BrokenConeSide.ctor(leftIntersectionEvent.get_Site(), leftIntersectionEvent.get_EndVertex(), leftIntersectionEvent.coneLeftSide);
                    this.InsertToTree(this.leftConeSides, leftSide);
                    leftIntersectionEvent.coneLeftSide.get_Cone().set_LeftSide(leftSide);
                    this.LookForIntersectionOfObstacleSideAndLeftConeSide(leftIntersectionEvent.get_Site(), leftIntersectionEvent.get_EndVertex());
                    this.TryCreateConeClosureForLeftSide(leftSide);
                }
            }
            else
                this.set_Z(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.get_SweepDirection(), leftIntersectionEvent.get_Site()));
        },
        TryCreateConeClosureForLeftSide: function (leftSide){
            var coneRightSide = As(leftSide.get_Cone().get_RightSide(), Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeRightSide.ctor);
            if (coneRightSide != null)if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(coneRightSide.get_Start(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(coneRightSide.get_Start(), coneRightSide.get_Direction()), leftSide.get_EndVertex().get_Point()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise)
                this.CreateConeClosureEvent(leftSide, coneRightSide);
        },
        CreateConeClosureEvent: function (brokenConeSide, otherSide){
            var x;
            var r = (function (){
                var $1 = {
                    Value: x
                };
                var $res = Microsoft.Msagl.Core.Geometry.Point.RayIntersectsRayInteriors(brokenConeSide.start, brokenConeSide.get_Direction(), otherSide.get_Start(), otherSide.get_Direction(), $1);
                x = $1.Value;
                return $res;
            }).call(this);
            System.Diagnostics.Debug.Assert$$Boolean(r);
            this.EnqueueEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeClosureEvent.ctor(x, brokenConeSide.get_Cone()));
        },
        ProcessRightIntersectionEvent: function (rightIntersectionEvent){
            if (rightIntersectionEvent.coneRightSide.get_Removed() == false){
                this.RemoveSegFromRightTree(rightIntersectionEvent.coneRightSide);
                this.set_Z(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.get_SweepDirection(), rightIntersectionEvent.get_Site()));
                var rightSide = new Microsoft.Msagl.Routing.Spline.ConeSpanner.BrokenConeSide.ctor(rightIntersectionEvent.get_Site(), rightIntersectionEvent.get_EndVertex(), rightIntersectionEvent.coneRightSide);
                this.InsertToTree(this.rightConeSides, rightSide);
                rightIntersectionEvent.coneRightSide.get_Cone().set_RightSide(rightSide);
                this.LookForIntersectionOfObstacleSideAndRightConeSide(rightIntersectionEvent.get_Site(), rightIntersectionEvent.get_EndVertex());
                this.TryCreateConeClosureForRightSide(rightSide);
            }
            else
                this.set_Z(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.get_SweepDirection(), rightIntersectionEvent.get_Site()));
        },
        TryCreateConeClosureForRightSide: function (rightSide){
            var coneLeftSide = As(rightSide.get_Cone().get_LeftSide(), Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeLeftSide.ctor);
            if (coneLeftSide != null)if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(coneLeftSide.get_Start(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(coneLeftSide.get_Start(), coneLeftSide.get_Direction()), rightSide.get_EndVertex().get_Point()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise)
                this.CreateConeClosureEvent(rightSide, coneLeftSide);
        },
        RemoveConesClosedBySegment: function (leftPoint, rightPoint){
            this.CloseConesCoveredBySegment(leftPoint, rightPoint, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.get_SweepDirection(), leftPoint) > Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.get_SweepDirection(), rightPoint) ? this.leftConeSides : this.rightConeSides);
        },
        CloseConesCoveredBySegment: function (leftPoint, rightPoint, tree){
            var node = tree.FindFirst$$Func$2($CreateAnonymousDelegate(this, function (s){
                return Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(s.get_Start(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(s.get_Start(), s.get_Direction()), leftPoint) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise;
            }));
            var x;
            if (node == null || !(function (){
                var $1 = {
                    Value: x
                };
                var $res = Microsoft.Msagl.Core.Geometry.Point.IntervalIntersectsRay(leftPoint, rightPoint, node.Item.get_Start(), node.Item.get_Direction(), $1);
                x = $1.Value;
                return $res;
            }).call(this))
                return;
            var conesToRemove = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Spline.ConeSpanner.Cone.ctor);
            do{
                conesToRemove.Add(node.Item.get_Cone());
                node = tree.Next(node);
            }
            while (node != null && (function (){
                var $1 = {
                    Value: x
                };
                var $res = Microsoft.Msagl.Core.Geometry.Point.IntervalIntersectsRay(leftPoint, rightPoint, node.Item.get_Start(), node.Item.get_Direction(), $1);
                x = $1.Value;
                return $res;
            }).call(this))
            var $it1274 = conesToRemove.GetEnumerator();
            while ($it1274.MoveNext()){
                var cone = $it1274.get_Current();
                this.RemoveCone(cone);
            }
        },
        ProcessVertexEvent: function (vertexEvent){
            this.set_Z(this.GetZ$$SweepEvent(vertexEvent));
            this.GoOverConesSeeingVertexEvent(vertexEvent);
            this.AddConeAndEnqueueEvents(vertexEvent);
        },
        AddConeAndEnqueueEvents: function (vertexEvent){
            var leftVertexEvent = As(vertexEvent, Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftVertexEvent.ctor);
            if (leftVertexEvent != null){
                var nextPoint = vertexEvent.get_Vertex().get_NextOnPolyline();
                this.CloseConesAtLeftVertex(leftVertexEvent, nextPoint);
            }
            else {
                var rightVertexEvent = As(vertexEvent, Microsoft.Msagl.Routing.Spline.ConeSpanner.RightVertexEvent.ctor);
                if (rightVertexEvent != null){
                    var nextPoint = vertexEvent.get_Vertex().get_PrevOnPolyline();
                    this.CloseConesAtRightVertex(rightVertexEvent, nextPoint);
                }
                else {
                    this.CloseConesAtLeftVertex(vertexEvent, vertexEvent.get_Vertex().get_NextOnPolyline());
                    this.CloseConesAtRightVertex(vertexEvent, vertexEvent.get_Vertex().get_PrevOnPolyline());
                }
            }
        },
        CloseConesAtRightVertex: function (rightVertexEvent, nextVertex){
            var prevSite = rightVertexEvent.get_Vertex().get_NextOnPolyline().get_Point();
            var prevZ = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(prevSite, this.get_SweepDirection());
            if (prevZ <= this.get_Z() && this.get_Z() - prevZ < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                this.RemoveConesClosedBySegment(prevSite, rightVertexEvent.get_Vertex().get_Point());
            var site = rightVertexEvent.get_Site();
            var coneLp = Microsoft.Msagl.Core.Geometry.Point.op_Addition(site, this.get_ConeLeftSideDirection());
            var coneRp = Microsoft.Msagl.Core.Geometry.Point.op_Addition(site, this.get_ConeRightSideDirection());
            var nextSite = nextVertex.get_Point();
            if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(site, prevSite)), this.get_SweepDirection()) > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                this.RemoveRightSide(new Microsoft.Msagl.Routing.Spline.ConeSpanner.RightObstacleSide.ctor(rightVertexEvent.get_Vertex().get_NextOnPolyline()));
            if (this.GetZ$$Point(nextSite) + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon < this.GetZ$$SweepEvent(rightVertexEvent))
                return;
            if (!Microsoft.Msagl.Core.Geometry.Point.PointToTheRightOfLineOrOnLine(nextSite, site, coneLp)){
                if (Microsoft.Msagl.Core.Geometry.Point.PointToTheLeftOfLineOrOnLine(Microsoft.Msagl.Core.Geometry.Point.op_Addition(nextSite, this.get_DirectionPerp()), nextSite, site))
                    this.EnqueueEvent$$RightVertexEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.RightVertexEvent.ctor(nextVertex));
            }
            else if (Microsoft.Msagl.Core.Geometry.Point.PointToTheLeftOfLineOrOnLine(nextSite, site, coneRp)){
                this.CaseToTheLeftOfLineOrOnLineConeRp(rightVertexEvent, nextVertex);
            }
            else {
                if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(nextSite, site)), this.get_SweepDirection()) > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                    this.LookForIntersectionOfObstacleSideAndLeftConeSide(rightVertexEvent.get_Site(), nextVertex);
                    this.InsertRightSide(new Microsoft.Msagl.Routing.Spline.ConeSpanner.RightObstacleSide.ctor(rightVertexEvent.get_Vertex()));
                }
                this.EnqueueEvent$$RightVertexEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.RightVertexEvent.ctor(nextVertex));
            }
        },
        CaseToTheLeftOfLineOrOnLineConeRp: function (rightVertexEvent, nextVertex){
            this.EnqueueEvent$$RightVertexEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.RightVertexEvent.ctor(nextVertex));
            var lnode = this.leftConeSides.FindFirst$$Func$2($CreateAnonymousDelegate(this, function (side){
                return Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeperForPortLocations.PointIsToTheLeftOfSegment(rightVertexEvent.get_Site(), side);
            }));
            this.FixConeLeftSideIntersections(rightVertexEvent.get_Vertex(), nextVertex, lnode);
            if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(nextVertex.get_Point(), rightVertexEvent.get_Site())), this.get_SweepDirection()) > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                this.InsertRightSide(new Microsoft.Msagl.Routing.Spline.ConeSpanner.RightObstacleSide.ctor(rightVertexEvent.get_Vertex()));
        },
        LookForIntersectionOfObstacleSideAndRightConeSide: function (obstacleSideStart, obstacleSideVertex){
            var node = this.GetLastNodeToTheLeftOfPointInRightSegmentTree(obstacleSideStart);
            if (node != null){
                var coneRightSide = As(node.Item, Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeRightSide.ctor);
                if (coneRightSide != null){
                    var intersection;
                    if ((function (){
                        var $1 = {
                            Value: intersection
                        };
                        var $res = Microsoft.Msagl.Core.Geometry.Point.IntervalIntersectsRay(obstacleSideStart, obstacleSideVertex.get_Point(), coneRightSide.get_Start(), this.get_ConeRightSideDirection(), $1);
                        intersection = $1.Value;
                        return $res;
                    }).call(this) && this.SegmentIsNotHorizontal(intersection, obstacleSideVertex.get_Point())){
                        this.EnqueueEvent(this.CreateRightIntersectionEvent(coneRightSide, intersection, obstacleSideVertex));
                    }
                }
            }
        },
        CreateRightIntersectionEvent: function (coneRightSide, intersection, obstacleSideVertex){
            System.Diagnostics.Debug.Assert$$Boolean(System.Math.Abs$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(obstacleSideVertex.get_Point(), intersection)), this.get_SweepDirection())) > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon);
            return new Microsoft.Msagl.Routing.Spline.ConeSpanner.RightIntersectionEvent.ctor(coneRightSide, intersection, obstacleSideVertex);
        },
        GetLastNodeToTheLeftOfPointInRightSegmentTree: function (obstacleSideStart){
            return this.rightConeSides.FindLast$$Func$2($CreateAnonymousDelegate(this, function (s){
                return Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeperForPortLocations.PointIsToTheRightOfSegment(obstacleSideStart, s);
            }));
        },
        LookForIntersectionOfObstacleSideAndLeftConeSide: function (obstacleSideStart, obstacleSideVertex){
            var node = this.GetFirstNodeToTheRightOfPoint(obstacleSideStart);
            if (node == null)
                return;
            var coneLeftSide = As(node.Item, Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeLeftSide.ctor);
            if (coneLeftSide == null)
                return;
            var intersection;
            if ((function (){
                var $1 = {
                    Value: intersection
                };
                var $res = Microsoft.Msagl.Core.Geometry.Point.IntervalIntersectsRay(obstacleSideStart, obstacleSideVertex.get_Point(), coneLeftSide.get_Start(), this.get_ConeLeftSideDirection(), $1);
                intersection = $1.Value;
                return $res;
            }).call(this)){
                this.EnqueueEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftIntersectionEvent.ctor(coneLeftSide, intersection, obstacleSideVertex));
            }
        },
        GetFirstNodeToTheRightOfPoint: function (p){
            return this.leftConeSides.FindFirst$$Func$2($CreateAnonymousDelegate(this, function (s){
                return Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeperForPortLocations.PointIsToTheLeftOfSegment(p, s);
            }));
        },
        FixConeLeftSideIntersections: function (obstSideStart, obstSideEnd, rbNode){
            if (rbNode != null){
                var intersection;
                var seg = As(rbNode.Item, Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeLeftSide.ctor);
                if (seg != null && (function (){
                    var $1 = {
                        Value: intersection
                    };
                    var $res = Microsoft.Msagl.Core.Geometry.Point.IntervalIntersectsRay(obstSideStart.get_Point(), obstSideEnd.get_Point(), seg.get_Start(), seg.get_Direction(), $1);
                    intersection = $1.Value;
                    return $res;
                }).call(this)){
                    this.EnqueueEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftIntersectionEvent.ctor(seg, intersection, obstSideEnd));
                }
            }
        },
        InsertToTree: function (tree, coneSide){
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(coneSide.get_Direction(), this.get_SweepDirection()) > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon);
            this.coneSideComparer.SetOperand(coneSide);
            return tree.Insert(coneSide);
        },
        CloseConesAtLeftVertex: function (leftVertexEvent, nextVertex){
            var prevSite = leftVertexEvent.get_Vertex().get_PrevOnPolyline().get_Point();
            var prevZ = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(prevSite, this.get_SweepDirection());
            if (prevZ <= this.get_Z() && this.get_Z() - prevZ < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                this.RemoveConesClosedBySegment(leftVertexEvent.get_Vertex().get_Point(), prevSite);
            }
            var site = leftVertexEvent.get_Site();
            var coneLp = Microsoft.Msagl.Core.Geometry.Point.op_Addition(site, this.get_ConeLeftSideDirection());
            var coneRp = Microsoft.Msagl.Core.Geometry.Point.op_Addition(site, this.get_ConeRightSideDirection());
            var nextSite = nextVertex.get_Point();
            if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(site, prevSite)), this.get_SweepDirection()) > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                this.RemoveLeftSide(new Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftObstacleSide.ctor(leftVertexEvent.get_Vertex().get_PrevOnPolyline()));
            if (Microsoft.Msagl.Core.Geometry.Point.PointToTheRightOfLineOrOnLine(nextSite, site, Microsoft.Msagl.Core.Geometry.Point.op_Addition(site, this.get_DirectionPerp()))){
            }
            else if (!Microsoft.Msagl.Core.Geometry.Point.PointToTheLeftOfLineOrOnLine(nextSite, site, coneRp)){
                this.EnqueueEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftVertexEvent.ctor(nextVertex));
            }
            else if (!Microsoft.Msagl.Core.Geometry.Point.PointToTheLeftOfLineOrOnLine(nextSite, site, coneLp)){
                this.EnqueueEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftVertexEvent.ctor(nextVertex));
                var rbNode = this.rightConeSides.FindLast$$Func$2($CreateAnonymousDelegate(this, function (s){
                    return Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeperForPortLocations.PointIsToTheRightOfSegment(site, s);
                }));
                this.FixConeRightSideIntersections(leftVertexEvent.get_Vertex(), nextVertex, rbNode);
                if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(nextVertex.get_Point(), leftVertexEvent.get_Site())), this.get_SweepDirection()) > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                    this.InsertLeftSide(new Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftObstacleSide.ctor(leftVertexEvent.get_Vertex()));
            }
            else {
                this.EnqueueEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftVertexEvent.ctor(nextVertex));
                if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(nextVertex.get_Point(), leftVertexEvent.get_Site())), this.get_SweepDirection()) > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                    this.LookForIntersectionOfObstacleSideAndRightConeSide(leftVertexEvent.get_Site(), nextVertex);
                    this.InsertLeftSide(new Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftObstacleSide.ctor(leftVertexEvent.get_Vertex()));
                }
            }
        },
        RemoveCone: function (cone){
            System.Diagnostics.Debug.Assert$$Boolean(cone.get_Removed() == false);
            cone.set_Removed(true);
            this.RemoveSegFromLeftTree(cone.get_LeftSide());
            this.RemoveSegFromRightTree(cone.get_RightSide());
        },
        RemoveSegFromRightTree: function (coneSide){
            System.Diagnostics.Debug.Assert$$Boolean(coneSide.get_Removed() == false);
            this.coneSideComparer.SetOperand(coneSide);
            var b = this.rightConeSides.Remove(coneSide);
            coneSide.set_Removed(true);
            if (b == null){
                var tmpZ = this.get_Z();
                this.set_Z(System.Math.Max$$Double$$Double(this.GetZ$$Point(coneSide.get_Start()), this.get_Z() - 0.01));
                this.coneSideComparer.SetOperand(coneSide);
                this.rightConeSides.Remove(coneSide);
                this.set_Z(tmpZ);
            }
            System.Diagnostics.Debug.Assert$$Boolean(b != null);
        },
        RemoveSegFromLeftTree: function (coneSide){
            System.Diagnostics.Debug.Assert$$Boolean(coneSide.get_Removed() == false);
            coneSide.set_Removed(true);
            this.coneSideComparer.SetOperand(coneSide);
            var b = this.leftConeSides.Remove(coneSide);
            if (b == null){
                var tmpZ = this.get_Z();
                this.set_Z(System.Math.Max$$Double$$Double(this.GetZ$$Point(coneSide.get_Start()), this.get_Z() - 0.01));
                this.coneSideComparer.SetOperand(coneSide);
                this.leftConeSides.Remove(coneSide);
                this.set_Z(tmpZ);
            }
            System.Diagnostics.Debug.Assert$$Boolean(b != null);
        },
        FixConeRightSideIntersections: function (obstSideStartVertex, obstSideEndVertex, rbNode){
            if (rbNode != null){
                var intersection;
                var seg = As(rbNode.Item, Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeRightSide.ctor);
                if (seg != null && (function (){
                    var $1 = {
                        Value: intersection
                    };
                    var $res = Microsoft.Msagl.Core.Geometry.Point.IntervalIntersectsRay(obstSideStartVertex.get_Point(), obstSideEndVertex.get_Point(), seg.get_Start(), seg.get_Direction(), $1);
                    intersection = $1.Value;
                    return $res;
                }).call(this)){
                    this.EnqueueEvent(this.CreateRightIntersectionEvent(seg, intersection, obstSideEndVertex));
                }
            }
        },
        LookForIntersectionWithConeLeftSide: function (leftNode){
            var coneLeftSide = As(leftNode.Item, Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeLeftSide.ctor);
            if (coneLeftSide != null){
                var rightObstacleSide = this.FindFirstObstacleSideToTheLeftOfPoint(coneLeftSide.get_Start());
                if (rightObstacleSide != null)
                    this.TryIntersectionOfConeLeftSideAndObstacleSide(coneLeftSide, rightObstacleSide);
            }
            else {
                var seg = Cast(leftNode.Item, Microsoft.Msagl.Routing.Spline.ConeSpanner.BrokenConeSide.ctor);
                leftNode = this.leftConeSides.Next(leftNode);
                if (leftNode != null){
                    coneLeftSide = As(leftNode.Item, Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeLeftSide.ctor);
                    if (coneLeftSide != null)
                        this.TryIntersectionOfConeLeftSideAndObstacleConeSide(coneLeftSide, seg);
                }
            }
        },
        LookForIntersectionWithConeRightSide: function (rightNode){
            var coneRightSide = As(rightNode.Item, Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeRightSide.ctor);
            if (coneRightSide != null){
                var leftObstacleSide = this.FindFirstObstacleSideToToTheRightOfPoint(coneRightSide.get_Start());
                if (leftObstacleSide != null)
                    this.TryIntersectionOfConeRightSideAndObstacleSide(coneRightSide, leftObstacleSide);
            }
            else {
                var seg = Cast(rightNode.Item, Microsoft.Msagl.Routing.Spline.ConeSpanner.BrokenConeSide.ctor);
                rightNode = this.rightConeSides.Previous(rightNode);
                if (rightNode != null){
                    coneRightSide = As(rightNode.Item, Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeRightSide.ctor);
                    if (coneRightSide != null)
                        this.TryIntersectionOfConeRightSideAndObstacleConeSide(coneRightSide, seg);
                }
            }
        },
        TryIntersectionOfConeRightSideAndObstacleConeSide: function (coneRightSide, seg){
            var x;
            if ((function (){
                var $1 = {
                    Value: x
                };
                var $res = Microsoft.Msagl.Core.Geometry.Point.IntervalIntersectsRay(seg.get_Start(), seg.get_End(), coneRightSide.get_Start(), coneRightSide.get_Direction(), $1);
                x = $1.Value;
                return $res;
            }).call(this)){
                this.EnqueueEvent(this.CreateRightIntersectionEvent(coneRightSide, x, seg.get_EndVertex()));
            }
        },
        TryIntersectionOfConeRightSideAndObstacleSide: function (coneRightSide, side){
            var x;
            if ((function (){
                var $1 = {
                    Value: x
                };
                var $res = Microsoft.Msagl.Core.Geometry.Point.IntervalIntersectsRay(side.get_Start(), side.get_End(), coneRightSide.get_Start(), coneRightSide.get_Direction(), $1);
                x = $1.Value;
                return $res;
            }).call(this)){
                this.EnqueueEvent(this.CreateRightIntersectionEvent(coneRightSide, x, side.get_EndVertex()));
            }
        },
        TryIntersectionOfConeLeftSideAndObstacleConeSide: function (coneLeftSide, seg){
            var x;
            if ((function (){
                var $1 = {
                    Value: x
                };
                var $res = Microsoft.Msagl.Core.Geometry.Point.IntervalIntersectsRay(seg.get_Start(), seg.get_End(), coneLeftSide.get_Start(), coneLeftSide.get_Direction(), $1);
                x = $1.Value;
                return $res;
            }).call(this)){
                this.EnqueueEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftIntersectionEvent.ctor(coneLeftSide, x, seg.get_EndVertex()));
            }
        },
        TryIntersectionOfConeLeftSideAndObstacleSide: function (coneLeftSide, side){
            var x;
            if ((function (){
                var $1 = {
                    Value: x
                };
                var $res = Microsoft.Msagl.Core.Geometry.Point.IntervalIntersectsRay(side.get_Start(), side.get_End(), coneLeftSide.get_Start(), coneLeftSide.get_Direction(), $1);
                x = $1.Value;
                return $res;
            }).call(this)){
                this.EnqueueEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftIntersectionEvent.ctor(coneLeftSide, x, side.get_EndVertex()));
            }
        },
        GoOverConesSeeingVertexEvent: function (vertexEvent){
            var rbNode = this.FindFirstSegmentInTheRightTreeNotToTheLeftOfVertex(vertexEvent);
            if (rbNode == null)
                return;
            var coneRightSide = rbNode.Item;
            var cone = coneRightSide.get_Cone();
            var leftConeSide = cone.get_LeftSide();
            if (Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeperForPortLocations.VertexIsToTheLeftOfSegment(vertexEvent, leftConeSide))
                return;
            var visibleCones = (function (){
                var $v133 = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Spline.ConeSpanner.Cone.ctor);
                $v133.Add(cone);
                return $v133;
            }).call(this);
            this.coneSideComparer.SetOperand(leftConeSide);
            rbNode = this.leftConeSides.Find$$T(leftConeSide);
            if (rbNode == null){
                var tmpZ = this.get_Z();
                this.set_Z(System.Math.Max$$Double$$Double(this.GetZ$$Point(leftConeSide.get_Start()), this.PreviousZ));
                this.coneSideComparer.SetOperand(leftConeSide);
                rbNode = this.leftConeSides.Find$$T(leftConeSide);
                this.set_Z(tmpZ);
            }
            rbNode = this.leftConeSides.Next(rbNode);
            while (rbNode != null && !Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeperForPortLocations.VertexIsToTheLeftOfSegment(vertexEvent, rbNode.Item)){
                visibleCones.Add(rbNode.Item.get_Cone());
                rbNode = this.leftConeSides.Next(rbNode);
            }
            var $it1275 = visibleCones.GetEnumerator();
            while ($it1275.MoveNext()){
                var c = $it1275.get_Current();
                this.AddEdge(c.get_Apex(), vertexEvent.get_Site());
                this.RemoveCone(c);
            }
        },
        AddEdge: function (a, b){
            System.Diagnostics.Debug.Assert$$Boolean(System.Linq.Enumerable.Contains$1$$IEnumerable$1$$TSource(Microsoft.Msagl.Core.Geometry.Point.ctor, this.get_PortLocations(), a));
            var ab = this.visibilityGraph.AddEdge$$Point$$Point(a, b);
            var av = ab.get_Source();
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.Point.op_Equality(av.Point, a) && Microsoft.Msagl.Core.Geometry.Point.op_Equality(ab.get_TargetPoint(), b));
            var edgesToFix = System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor, System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor, av.get_InEdges(), $CreateAnonymousDelegate(this, function (e){
                return e != ab;
            })), System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor, av.get_OutEdges(), $CreateAnonymousDelegate(this, function (e){
                return e != ab;
            }))));
            for (var $i1277 = 0,$l1277 = edgesToFix.length,edge = edgesToFix[$i1277]; $i1277 < $l1277; $i1277++, edge = edgesToFix[$i1277]){
                var c = (edge.get_Target() == av ? edge.get_Source() : edge.get_Target()).Point;
                Microsoft.Msagl.Routing.Visibility.VisibilityGraph.RemoveEdge$$VisibilityEdge(edge);
                this.visibilityGraph.AddEdge$$Point$$Point(c, b);
            }
        },
        FindFirstSegmentInTheRightTreeNotToTheLeftOfVertex: function (vertexEvent){
            return this.rightConeSides.FindFirst$$Func$2($CreateAnonymousDelegate(this, function (s){
                return !Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeperForPortLocations.VertexIsToTheRightOfSegment(vertexEvent, s);
            }));
        },
        EnqueueEvent$$RightVertexEvent: function (vertexEvent){
            if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.get_SweepDirection(), (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(vertexEvent.get_Site(), vertexEvent.get_Vertex().get_PrevOnPolyline().get_Point()))) > Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                return;
            Microsoft.Msagl.Routing.Visibility.LineSweeperBase.commonPrototype.EnqueueEvent.call(this, vertexEvent);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$ConeSpanner$LineSweeperForPortLocations);
var Microsoft$Msagl$Routing$Spline$ConeSpanner$PortLocationEvent = {
    fullname: "Microsoft.Msagl.Routing.Spline.ConeSpanner.PortLocationEvent",
    baseTypeName: "Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (portLocation){
            this._PortLocation = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent.ctor.call(this);
            this.set_PortLocation(portLocation);
        },
        Site$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Site: function (){
            return this.get_PortLocation();
        },
        PortLocation$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_PortLocation: function (){
            return this._PortLocation;
        },
        set_PortLocation: function (value){
            this._PortLocation = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$ConeSpanner$PortLocationEvent);
var Microsoft$Msagl$Routing$Visibility$LineSweeperBase = {
    fullname: "Microsoft.Msagl.Routing.Visibility.LineSweeperBase",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IComparer$1"],
    Kind: "Class",
    definition: {
        ctor: function (obstacles, sweepDirection){
            this.directionPerp = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.eventQueue = null;
            this.Ports = null;
            this.PreviousZ = -Infinity;
            this.z = 0;
            this._LeftObstacleSideTree = null;
            this._ObstacleSideComparer = null;
            this._RightObstacleSideTree = null;
            this._SweepDirection = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._Obstacles = null;
            System.Object.ctor.call(this);
            this.set_Obstacles(obstacles);
            this.set_SweepDirection(sweepDirection);
            this.set_DirectionPerp(sweepDirection.Rotate(-1.5707963267949));
            this.set_EventQueue(new Microsoft.Msagl.Core.DataStructures.BinaryHeapWithComparer$1.ctor(Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent.ctor, this));
            this.set_ObstacleSideComparer(new Microsoft.Msagl.Routing.Visibility.ObstacleSideComparer.ctor(this));
            this.set_LeftObstacleSideTree(new Microsoft.Msagl.Core.DataStructures.RbTree$1.ctor$$IComparer$1(Microsoft.Msagl.Routing.Visibility.SegmentBase.ctor, this.get_ObstacleSideComparer()));
            this.set_RightObstacleSideTree(new Microsoft.Msagl.Core.DataStructures.RbTree$1.ctor$$IComparer$1(Microsoft.Msagl.Routing.Visibility.SegmentBase.ctor, this.get_ObstacleSideComparer()));
        },
        LeftObstacleSideTree$$: "Microsoft.Msagl.Core.DataStructures.RbTree`1[[Microsoft.Msagl.Routing.Visibility.SegmentBase]]",
        get_LeftObstacleSideTree: function (){
            return this._LeftObstacleSideTree;
        },
        set_LeftObstacleSideTree: function (value){
            this._LeftObstacleSideTree = value;
        },
        ObstacleSideComparer$$: "Microsoft.Msagl.Routing.Visibility.ObstacleSideComparer",
        get_ObstacleSideComparer: function (){
            return this._ObstacleSideComparer;
        },
        set_ObstacleSideComparer: function (value){
            this._ObstacleSideComparer = value;
        },
        RightObstacleSideTree$$: "Microsoft.Msagl.Core.DataStructures.RbTree`1[[Microsoft.Msagl.Routing.Visibility.SegmentBase]]",
        get_RightObstacleSideTree: function (){
            return this._RightObstacleSideTree;
        },
        set_RightObstacleSideTree: function (value){
            this._RightObstacleSideTree = value;
        },
        EventQueue$$: "Microsoft.Msagl.Core.DataStructures.BinaryHeapWithComparer`1[[Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent]]",
        get_EventQueue: function (){
            return this.eventQueue;
        },
        set_EventQueue: function (value){
            this.eventQueue = value;
        },
        SweepDirection$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_SweepDirection: function (){
            return this._SweepDirection;
        },
        set_SweepDirection: function (value){
            this._SweepDirection = value;
        },
        DirectionPerp$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_DirectionPerp: function (){
            return this.directionPerp;
        },
        set_DirectionPerp: function (value){
            this.directionPerp = value;
        },
        Z$$: "System.Double",
        get_Z: function (){
            return this.z;
        },
        set_Z: function (value){
            if (value > this.z + Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                this.PreviousZ = this.z;
            this.z = value;
        },
        Obstacles$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Geometry.Curves.Polyline]]",
        get_Obstacles: function (){
            return this._Obstacles;
        },
        set_Obstacles: function (value){
            this._Obstacles = value;
        },
        GetZ$$SweepEvent: function (eve){
            return Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.get_SweepDirection(), eve.get_Site());
        },
        GetZ$$Point: function (point){
            return Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.get_SweepDirection(), point);
        },
        SegmentIsNotHorizontal: function (a, b){
            return System.Math.Abs$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a, b)), this.get_SweepDirection())) > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon;
        },
        SegmentIsHorizontal: function (a, b){
            return System.Math.Abs$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(a, b)), this.get_SweepDirection())) <= Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon;
        },
        RemoveLeftSide: function (side){
            this.get_ObstacleSideComparer().SetOperand(side);
            this.get_LeftObstacleSideTree().Remove(side);
        },
        RemoveRightSide: function (side){
            this.get_ObstacleSideComparer().SetOperand(side);
            this.get_RightObstacleSideTree().Remove(side);
        },
        InsertLeftSide: function (side){
            this.get_ObstacleSideComparer().SetOperand(side);
            this.get_LeftObstacleSideTree().Insert((side));
        },
        InsertRightSide: function (side){
            this.get_ObstacleSideComparer().SetOperand(side);
            this.get_RightObstacleSideTree().Insert(side);
        },
        FindFirstObstacleSideToTheLeftOfPoint: function (point){
            var node = this.get_RightObstacleSideTree().FindLast$$Func$2($CreateAnonymousDelegate(this, function (s){
                return Microsoft.Msagl.Core.Geometry.Point.PointToTheRightOfLineOrOnLine(point, s.get_Start(), s.get_End());
            }));
            return node == null ? null : Cast((node.Item), Microsoft.Msagl.Routing.Spline.ConeSpanner.RightObstacleSide.ctor);
        },
        FindFirstObstacleSideToToTheRightOfPoint: function (point){
            var node = this.get_LeftObstacleSideTree().FindFirst$$Func$2($CreateAnonymousDelegate(this, function (s){
                return !Microsoft.Msagl.Core.Geometry.Point.PointToTheRightOfLineOrOnLine(point, s.get_Start(), s.get_End());
            }));
            return node == null ? null : Cast(node.Item, Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftObstacleSide.ctor);
        },
        EnqueueEvent: function (eve){
            System.Diagnostics.Debug.Assert$$Boolean(this.GetZ$$Point(eve.get_Site()) >= this.PreviousZ);
            this.eventQueue.Enqueue(eve);
        },
        InitQueueOfEvents: function (){
            var $it1277 = this.get_Obstacles().GetEnumerator();
            while ($it1277.MoveNext()){
                var obstacle = $it1277.get_Current();
                this.EnqueueLowestPointsOnObstacles(obstacle);
            }
            if (Microsoft.Msagl.Core.DataStructures.Set$1.op_Inequality(this.Ports, null)){
                var $it1278 = this.Ports.GetEnumerator();
                while ($it1278.MoveNext()){
                    var point = $it1278.get_Current();
                    this.EnqueueEvent(new Microsoft.Msagl.Routing.Visibility.PortObstacleEvent.ctor(point));
                }
            }
        },
        EnqueueLowestPointsOnObstacles: function (poly){
            var candidate = this.GetLowestPoint(poly);
            this.EnqueueEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.LowestVertexEvent.ctor(candidate));
        },
        GetLowestPoint: function (poly){
            var candidate = poly.get_StartPoint();
            var pp = poly.get_StartPoint().get_Next();
            for (; pp != null; pp = pp.get_Next())
                if (this.Less(pp.get_Point(), candidate.get_Point()))
                    candidate = pp;
            return candidate;
        },
        Compare: function (a, b){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(a, "a");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(b, "b");
            var aSite = a.get_Site();
            var bSite = b.get_Site();
            return (function (){
                var $1 = {
                    Value: aSite
                };
                var $2 = {
                    Value: bSite
                };
                var $res = this.ComparePoints($1, $2);
                aSite = $1.Value;
                bSite = $2.Value;
                return $res;
            }).call(this);
        },
        Less: function (a, b){
            return (function (){
                var $1 = {
                    Value: a
                };
                var $2 = {
                    Value: b
                };
                var $res = this.ComparePoints($1, $2);
                a = $1.Value;
                b = $2.Value;
                return $res;
            }).call(this) < 0;
        },
        ComparePoints: function (aSite, bSite){
            var aProjection = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.get_SweepDirection(), aSite.Value);
            var bProjection = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.get_SweepDirection(), bSite.Value);
            if (aProjection < bProjection)
                return -1;
            if (aProjection > bProjection)
                return 1;
            aProjection = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.directionPerp, aSite.Value);
            bProjection = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.directionPerp, bSite.Value);
            if (aProjection < bProjection)
                return -1;
            return aProjection > bProjection ? 1 : 0;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Visibility$LineSweeperBase);
var Microsoft$Msagl$Routing$Spline$ConeSpanner$LowestVertexEvent = {
    fullname: "Microsoft.Msagl.Routing.Spline.ConeSpanner.LowestVertexEvent",
    baseTypeName: "Microsoft.Msagl.Routing.Spline.ConeSpanner.VertexEvent",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (p){
            Microsoft.Msagl.Routing.Spline.ConeSpanner.VertexEvent.ctor.call(this, p);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$ConeSpanner$LowestVertexEvent);
var Microsoft$Msagl$Routing$Spline$ConeSpanner$ObstacleSide = {
    fullname: "Microsoft.Msagl.Routing.Spline.ConeSpanner.ObstacleSide",
    baseTypeName: "Microsoft.Msagl.Routing.Visibility.SegmentBase",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (startVertex){
            this._StartVertex = null;
            Microsoft.Msagl.Routing.Visibility.SegmentBase.ctor.call(this);
            this.set_StartVertex(startVertex);
        },
        StartVertex$$: "Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint",
        get_StartVertex: function (){
            return this._StartVertex;
        },
        set_StartVertex: function (value){
            this._StartVertex = value;
        },
        EndVertex$$: "Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint",
        Polyline$$: "Microsoft.Msagl.Core.Geometry.Curves.Polyline",
        get_Polyline: function (){
            return this.get_StartVertex().get_Polyline();
        },
        Start$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Start: function (){
            return this.get_StartVertex().get_Point();
        },
        End$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_End: function (){
            return this.get_EndVertex().get_Point();
        },
        toString: function (){
            var typeString = this.GetType().toString();
            var lastDotLoc = typeString.lastIndexOf(".");
            if (lastDotLoc >= 0){
                typeString = typeString.substr(lastDotLoc + 1);
            }
            return typeString + " [" + this.get_Start().toString() + " -> " + this.get_End().toString() + "]";
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$ConeSpanner$ObstacleSide);
var Microsoft$Msagl$Routing$Visibility$ObstacleSideComparer = {
    fullname: "Microsoft.Msagl.Routing.Visibility.ObstacleSideComparer",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IComparer$1"],
    Kind: "Class",
    definition: {
        ctor: function (lineSweeper){
            this.lineSweeper = null;
            this.x = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            System.Object.ctor.call(this);
            this.lineSweeper = lineSweeper;
        },
        Compare: function (a, b){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(b, "b");
            var orient = Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(b.get_Start(), b.get_End(), this.x);
            switch (orient){
                case Microsoft.Msagl.Core.Geometry.TriangleOrientation.Collinear:
                    return 0;
                case Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise:
                    return 1;
                default:
                    return -1;
            }
        },
        SetOperand: function (side){
            this.x = this.IntersectionOfSideAndSweepLine(side);
        },
        IntersectionOfSideAndSweepLine: function (obstacleSide){
            var den = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(obstacleSide.get_Direction(), this.lineSweeper.get_SweepDirection());
            System.Diagnostics.Debug.Assert$$Boolean(System.Math.Abs$$Double(den) > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon);
            var t = (this.lineSweeper.get_Z() - Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(obstacleSide.get_Start(), this.lineSweeper.get_SweepDirection())) / den;
            return Microsoft.Msagl.Core.Geometry.Point.op_Addition(obstacleSide.get_Start(), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(t, obstacleSide.get_Direction()));
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Visibility$ObstacleSideComparer);
var Microsoft$Msagl$Routing$Spline$ConeSpanner$RightIntersectionEvent = {
    fullname: "Microsoft.Msagl.Routing.Spline.ConeSpanner.RightIntersectionEvent",
    baseTypeName: "Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (coneRightSide, intersectionPoint, endVertex){
            this.coneRightSide = null;
            this.intersectionPoint = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.endVertex = null;
            Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent.ctor.call(this);
            this.coneRightSide = coneRightSide;
            this.intersectionPoint = intersectionPoint;
            this.endVertex = endVertex;
        },
        EndVertex$$: "Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint",
        get_EndVertex: function (){
            return this.endVertex;
        },
        set_EndVertex: function (value){
            this.endVertex = value;
        },
        Site$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Site: function (){
            return this.intersectionPoint;
        },
        toString: function (){
            return "RightIntersectionEvent " + this.intersectionPoint;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$ConeSpanner$RightIntersectionEvent);
var Microsoft$Msagl$Routing$Spline$ConeSpanner$LeftVertexEvent = {
    fullname: "Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftVertexEvent",
    baseTypeName: "Microsoft.Msagl.Routing.Spline.ConeSpanner.VertexEvent",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (p){
            Microsoft.Msagl.Routing.Spline.ConeSpanner.VertexEvent.ctor.call(this, p);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$ConeSpanner$LeftVertexEvent);
var Microsoft$Msagl$Routing$Spline$ConeSpanner$LineSweeper = {
    fullname: "Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeper",
    baseTypeName: "Microsoft.Msagl.Routing.Visibility.LineSweeperBase",
    staticDefinition: {
        Sweep: function (obstacles, direction, coneAngle, visibilityGraph, ports, borderPolyline){
            var cs = new Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeper.ctor(obstacles, direction, direction.Rotate(-coneAngle / 2), direction.Rotate(coneAngle / 2), visibilityGraph, ports, borderPolyline);
            cs.Calculate();
        },
        FindInsidePoint: function (leftPoint, rightPoint, cone){
            return Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeper.FindInsidePointBool(leftPoint, rightPoint, cone.get_Apex(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(cone.get_Apex(), cone.get_LeftSideDirection()), Microsoft.Msagl.Core.Geometry.Point.op_Addition(cone.get_Apex(), cone.get_RightSideDirection()));
        },
        FindInsidePointBool: function (leftPoint, rightPoint, apex, leftSideConePoint, rightSideConePoint){
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(leftPoint, rightPoint))
                return leftPoint;
            if (Microsoft.Msagl.Core.Geometry.Point.PointIsInsideCone(leftPoint, apex, leftSideConePoint, rightSideConePoint))
                return leftPoint;
            if (Microsoft.Msagl.Core.Geometry.Point.PointIsInsideCone(rightPoint, apex, leftSideConePoint, rightSideConePoint))
                return rightPoint;
            var m = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(0.5, (Microsoft.Msagl.Core.Geometry.Point.op_Addition(leftPoint, rightPoint)));
            if (Microsoft.Msagl.Core.Geometry.Point.PointToTheLeftOfLine(m, apex, leftSideConePoint))
                return Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeper.FindInsidePointBool(m, rightPoint, apex, leftSideConePoint, rightSideConePoint);
            return Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeper.FindInsidePointBool(leftPoint, m, apex, leftSideConePoint, rightSideConePoint);
        },
        GetSign: function (p, a, b){
            var d = Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(a, b, p.get_Point());
            if (d < 0)
                return 1;
            return d > 0 ? -1 : 0;
        },
        InsertPointIntoPolylineAfter: function (borderPolyline, insertAfter, pointToInsert){
            var np;
            if (insertAfter.get_Next() != null){
                np = (function (){
                    var $v134 = new Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor(pointToInsert);
                    $v134.set_Prev(insertAfter);
                    $v134.set_Next(insertAfter.get_Next());
                    $v134.set_Polyline(borderPolyline);
                    return $v134;
                })();
                insertAfter.get_Next().set_Prev(np);
                insertAfter.set_Next(np);
            }
            else {
                np = (function (){
                    var $v135 = new Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor(pointToInsert);
                    $v135.set_Prev(insertAfter);
                    $v135.set_Polyline(borderPolyline);
                    return $v135;
                })();
                insertAfter.set_Next(np);
                borderPolyline.set_EndPoint(np);
            }
            System.Diagnostics.Debug.Assert$$Boolean(!(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(np.get_Point(), np.get_PrevOnPolyline().get_Point()) || Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(np.get_Point(), np.get_NextOnPolyline().get_Point())));
            borderPolyline.RequireInit();
            return np;
        },
        PointIsToTheLeftOfSegment: function (p, seg){
            return (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(seg.get_Start(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(seg.get_Start(), seg.get_Direction()), p) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise);
        },
        PointIsToTheRightOfSegment: function (p, seg){
            return (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(seg.get_Start(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(seg.get_Start(), seg.get_Direction()), p) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise);
        },
        VertexIsToTheLeftOfSegment: function (vertexEvent, seg){
            return (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(seg.get_Start(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(seg.get_Start(), seg.get_Direction()), vertexEvent.get_Site()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise);
        },
        VertexIsToTheRightOfSegment: function (vertexEvent, seg){
            return (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(seg.get_Start(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(seg.get_Start(), seg.get_Direction()), vertexEvent.get_Site()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise);
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["Microsoft.Msagl.Routing.Spline.ConeSpanner.IConeSweeper"],
    Kind: "Class",
    definition: {
        ctor: function (obstacles, direction, coneRsDir, coneLsDir, visibilityGraph, ports, borderPolyline){
            this.coneSideComparer = null;
            this.visibilityGraph = null;
            this.rightConeSides = null;
            this.leftConeSides = null;
            this.portEdgesGraph = null;
            this._ConeRightSideDirection = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._ConeLeftSideDirection = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._PortEdgesCreator = null;
            this._BorderPolyline = null;
            Microsoft.Msagl.Routing.Visibility.LineSweeperBase.ctor.call(this, obstacles, direction);
            this.visibilityGraph = visibilityGraph;
            this.set_ConeRightSideDirection(coneRsDir);
            this.set_ConeLeftSideDirection(coneLsDir);
            this.coneSideComparer = new Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSideComparer.ctor(this);
            this.leftConeSides = new Microsoft.Msagl.Core.DataStructures.RbTree$1.ctor$$IComparer$1(Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSide.ctor, this.coneSideComparer);
            this.rightConeSides = new Microsoft.Msagl.Core.DataStructures.RbTree$1.ctor$$IComparer$1(Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSide.ctor, this.coneSideComparer);
            this.Ports = ports;
            this.set_BorderPolyline(borderPolyline);
            this.set_PortEdgesCreator($CreateAnonymousDelegate(this, function (a, b){
                return new Microsoft.Msagl.Routing.Visibility.TollFreeVisibilityEdge.ctor$$VisibilityVertex$$VisibilityVertex(a, b);
            }));
        },
        ConeRightSideDirection$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_ConeRightSideDirection: function (){
            return this._ConeRightSideDirection;
        },
        set_ConeRightSideDirection: function (value){
            this._ConeRightSideDirection = value;
        },
        ConeLeftSideDirection$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_ConeLeftSideDirection: function (){
            return this._ConeLeftSideDirection;
        },
        set_ConeLeftSideDirection: function (value){
            this._ConeLeftSideDirection = value;
        },
        PortEdgesCreator$$: "System.Func`3[[Microsoft.Msagl.Routing.Visibility.VisibilityVertex],[Microsoft.Msagl.Routing.Visibility.VisibilityVertex],[Microsoft.Msagl.Routing.Visibility.VisibilityEdge]]",
        get_PortEdgesCreator: function (){
            return this._PortEdgesCreator;
        },
        set_PortEdgesCreator: function (value){
            this._PortEdgesCreator = value;
        },
        BorderPolyline$$: "Microsoft.Msagl.Core.Geometry.Curves.Polyline",
        get_BorderPolyline: function (){
            return this._BorderPolyline;
        },
        set_BorderPolyline: function (value){
            this._BorderPolyline = value;
        },
        Calculate: function (){
            this.InitQueueOfEvents();
            while (this.get_EventQueue().get_Count() > 0)
                this.ProcessEvent(this.get_EventQueue().Dequeue());
            if (this.get_BorderPolyline() != null)
                this.CloseRemainingCones();
            this.CreatePortEdges();
        },
        CreatePortEdges: function (){
            if (this.portEdgesGraph != null){
                var $it1279 = this.portEdgesGraph.get_Edges().GetEnumerator();
                while ($it1279.MoveNext()){
                    var edge = $it1279.get_Current();
                    this.visibilityGraph.AddEdge$$Point$$Point$$Func$3$VisibilityVertex$VisibilityVertex$VisibilityEdge(edge.get_SourcePoint(), edge.get_TargetPoint(), this.get_PortEdgesCreator());
                }
            }
        },
        CloseRemainingCones: function (){
            if (this.leftConeSides.get_Count() == 0)
                return;
            System.Diagnostics.Debug.Assert$$Boolean(this.leftConeSides.get_Count() == this.rightConeSides.get_Count());
            var p = this.get_BorderPolyline().get_StartPoint();
            var steps = this.leftConeSides.get_Count();
            do{
                var cone = this.leftConeSides.TreeMinimum().Item.get_Cone();
                p = this.FindPolylineSideIntersectingConeRightSide(p, cone);
                p = this.GetPolylinePointInsideOfConeAndRemoveCones(p, cone);
                steps--;
            }
            while (this.leftConeSides.get_Count() > 0 && steps > 0)
        },
        GetPolylinePointInsideOfConeAndRemoveCones: function (p, cone){
            var pn = p.get_NextOnPolyline();
            var insidePoint = Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeper.FindInsidePoint(p.get_Point(), pn.get_Point(), cone);
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(insidePoint, p.get_Point())){
                this.AddEdgeAndRemoveCone(cone, p.get_Point());
                this.AddEdgesAndRemoveRemainingConesByPoint(p.get_Point());
            }
            else if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(insidePoint, pn.get_Point())){
                this.AddEdgeAndRemoveCone(cone, pn.get_Point());
                this.AddEdgesAndRemoveRemainingConesByPoint(pn.get_Point());
                p = pn;
            }
            else {
                p = Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeper.InsertPointIntoPolylineAfter(this.get_BorderPolyline(), p, insidePoint);
                this.AddEdgeAndRemoveCone(cone, p.get_Point());
                this.AddEdgesAndRemoveRemainingConesByPoint(p.get_Point());
            }
            return p;
        },
        AddEdgesAndRemoveRemainingConesByPoint: function (point){
            var conesToRemove = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Spline.ConeSpanner.Cone.ctor);
            var $it1280 = this.leftConeSides.GetEnumerator();
            while ($it1280.MoveNext()){
                var leftConeSide = $it1280.get_Current();
                if (Microsoft.Msagl.Core.Geometry.Point.PointToTheRightOfLineOrOnLine(point, leftConeSide.get_Start(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(leftConeSide.get_Start(), leftConeSide.get_Direction())))
                    conesToRemove.Add(leftConeSide.get_Cone());
                else
                    break;
            }
            var $it1281 = conesToRemove.GetEnumerator();
            while ($it1281.MoveNext()){
                var cone = $it1281.get_Current();
                this.AddEdgeAndRemoveCone(cone, point);
            }
        },
        FindPolylineSideIntersectingConeRightSide: function (p, cone){
            var startPoint = p;
            var a = cone.get_Apex();
            var b = Microsoft.Msagl.Core.Geometry.Point.op_Addition(cone.get_Apex(), this.get_ConeRightSideDirection());
            var pSign = Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeper.GetSign(p, a, b);
            do{
                var pn = p.get_NextOnPolyline();
                var pnSigh = Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeper.GetSign(pn, a, b);
                if (pnSigh - pSign > 0)
                    return p;
                p = pn;
                pSign = pnSigh;
                if (p == startPoint)
                    throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
            }
            while (true)
        },
        AddEdgeAndRemoveCone: function (cone, p){
            if (Microsoft.Msagl.Core.DataStructures.Set$1.op_Inequality(this.Ports, null) && this.Ports.Contains$$T(cone.get_Apex()))
                this.CreatePortEdge(cone, p);
            else
                this.visibilityGraph.AddEdge$$Point$$Point(cone.get_Apex(), p);
            this.RemoveCone(cone);
        },
        CreatePortEdge: function (cone, p){
            if (this.portEdgesGraph == null)
                this.portEdgesGraph = new Microsoft.Msagl.Routing.Visibility.VisibilityGraph.ctor();
            var coneApexVert = this.portEdgesGraph.FindVertex(cone.get_Apex());
            var edgesToFix = (coneApexVert != null) ? System.Linq.Enumerable.ToArray$1(Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor, System.Linq.Enumerable.Concat$1(Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor, coneApexVert.get_InEdges(), coneApexVert.get_OutEdges())) : null;
            if (edgesToFix != null)
                for (var $i1283 = 0,$l1283 = edgesToFix.length,edge = edgesToFix[$i1283]; $i1283 < $l1283; $i1283++, edge = edgesToFix[$i1283]){
                    var otherPort = (edge.get_Target() == coneApexVert ? edge.get_Source() : edge.get_Target()).Point;
                    Microsoft.Msagl.Routing.Visibility.VisibilityGraph.RemoveEdge$$VisibilityEdge(edge);
                    this.portEdgesGraph.AddEdge$$Point$$Point(otherPort, p);
                }
            this.portEdgesGraph.AddEdge$$Point$$Point(cone.get_Apex(), p);
        },
        ProcessEvent: function (p){
            var vertexEvent = As(p, Microsoft.Msagl.Routing.Spline.ConeSpanner.VertexEvent.ctor);
            if (vertexEvent != null)
                this.ProcessVertexEvent(vertexEvent);
            else {
                var rightIntersectionEvent = As(p, Microsoft.Msagl.Routing.Spline.ConeSpanner.RightIntersectionEvent.ctor);
                if (rightIntersectionEvent != null)
                    this.ProcessRightIntersectionEvent(rightIntersectionEvent);
                else {
                    var leftIntersectionEvent = As(p, Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftIntersectionEvent.ctor);
                    if (leftIntersectionEvent != null)
                        this.ProcessLeftIntersectionEvent(leftIntersectionEvent);
                    else {
                        var coneClosure = As(p, Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeClosureEvent.ctor);
                        if (coneClosure != null){
                            if (!coneClosure.get_ConeToClose().get_Removed())
                                this.RemoveCone(coneClosure.get_ConeToClose());
                        }
                        else
                            this.ProcessPortObstacleEvent(Cast(p, Microsoft.Msagl.Routing.Visibility.PortObstacleEvent.ctor));
                        this.set_Z(this.GetZ$$SweepEvent(p));
                    }
                }
            }
        },
        ProcessPortObstacleEvent: function (portObstacleEvent){
            this.set_Z(this.GetZ$$SweepEvent(portObstacleEvent));
            this.GoOverConesSeeingVertexEvent(portObstacleEvent);
            this.CreateConeOnVertex(portObstacleEvent);
        },
        ProcessLeftIntersectionEvent: function (leftIntersectionEvent){
            if (leftIntersectionEvent.coneLeftSide.get_Removed() == false){
                if (System.Math.Abs$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(leftIntersectionEvent.get_EndVertex().get_Point(), leftIntersectionEvent.get_Site())), this.get_SweepDirection())) < Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                    this.RemoveCone(leftIntersectionEvent.coneLeftSide.get_Cone());
                }
                else {
                    this.RemoveSegFromLeftTree(leftIntersectionEvent.coneLeftSide);
                    this.set_Z(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.get_SweepDirection(), leftIntersectionEvent.get_Site()));
                    var leftSide = new Microsoft.Msagl.Routing.Spline.ConeSpanner.BrokenConeSide.ctor(leftIntersectionEvent.get_Site(), leftIntersectionEvent.get_EndVertex(), leftIntersectionEvent.coneLeftSide);
                    this.InsertToTree(this.leftConeSides, leftSide);
                    leftIntersectionEvent.coneLeftSide.get_Cone().set_LeftSide(leftSide);
                    this.LookForIntersectionOfObstacleSideAndLeftConeSide(leftIntersectionEvent.get_Site(), leftIntersectionEvent.get_EndVertex());
                    this.TryCreateConeClosureForLeftSide(leftSide);
                }
            }
            else
                this.set_Z(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.get_SweepDirection(), leftIntersectionEvent.get_Site()));
        },
        TryCreateConeClosureForLeftSide: function (leftSide){
            var coneRightSide = As(leftSide.get_Cone().get_RightSide(), Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeRightSide.ctor);
            if (coneRightSide != null)if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(coneRightSide.get_Start(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(coneRightSide.get_Start(), coneRightSide.get_Direction()), leftSide.get_EndVertex().get_Point()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise)
                this.CreateConeClosureEvent(leftSide, coneRightSide);
        },
        CreateConeClosureEvent: function (brokenConeSide, otherSide){
            var x;
            (function (){
                var $1 = {
                    Value: x
                };
                var $res = Microsoft.Msagl.Core.Geometry.Point.RayIntersectsRayInteriors(brokenConeSide.start, brokenConeSide.get_Direction(), otherSide.get_Start(), otherSide.get_Direction(), $1);
                x = $1.Value;
                return $res;
            }).call(this);
            this.EnqueueEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeClosureEvent.ctor(x, brokenConeSide.get_Cone()));
        },
        ProcessRightIntersectionEvent: function (rightIntersectionEvent){
            if (rightIntersectionEvent.coneRightSide.get_Removed() == false){
                this.RemoveSegFromRightTree(rightIntersectionEvent.coneRightSide);
                this.set_Z(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.get_SweepDirection(), rightIntersectionEvent.get_Site()));
                var rightSide = new Microsoft.Msagl.Routing.Spline.ConeSpanner.BrokenConeSide.ctor(rightIntersectionEvent.get_Site(), rightIntersectionEvent.get_EndVertex(), rightIntersectionEvent.coneRightSide);
                this.InsertToTree(this.rightConeSides, rightSide);
                rightIntersectionEvent.coneRightSide.get_Cone().set_RightSide(rightSide);
                this.LookForIntersectionOfObstacleSideAndRightConeSide(rightIntersectionEvent.get_Site(), rightIntersectionEvent.get_EndVertex());
                this.TryCreateConeClosureForRightSide(rightSide);
            }
            else
                this.set_Z(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.get_SweepDirection(), rightIntersectionEvent.get_Site()));
        },
        TryCreateConeClosureForRightSide: function (rightSide){
            var coneLeftSide = As(rightSide.get_Cone().get_LeftSide(), Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeLeftSide.ctor);
            if (coneLeftSide != null)if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(coneLeftSide.get_Start(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(coneLeftSide.get_Start(), coneLeftSide.get_Direction()), rightSide.get_EndVertex().get_Point()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise)
                this.CreateConeClosureEvent(rightSide, coneLeftSide);
        },
        RemoveConesClosedBySegment: function (leftPoint, rightPoint){
            this.CloseConesCoveredBySegment(leftPoint, rightPoint, Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.get_SweepDirection(), leftPoint) > Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.get_SweepDirection(), rightPoint) ? this.leftConeSides : this.rightConeSides);
        },
        CloseConesCoveredBySegment: function (leftPoint, rightPoint, tree){
            var node = tree.FindFirst$$Func$2($CreateAnonymousDelegate(this, function (s){
                return Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(s.get_Start(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(s.get_Start(), s.get_Direction()), leftPoint) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise;
            }));
            var x;
            if (node == null || !(function (){
                var $1 = {
                    Value: x
                };
                var $res = Microsoft.Msagl.Core.Geometry.Point.IntervalIntersectsRay(leftPoint, rightPoint, node.Item.get_Start(), node.Item.get_Direction(), $1);
                x = $1.Value;
                return $res;
            }).call(this))
                return;
            var conesToRemove = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Spline.ConeSpanner.Cone.ctor);
            do{
                conesToRemove.Add(node.Item.get_Cone());
                node = tree.Next(node);
            }
            while (node != null && (function (){
                var $1 = {
                    Value: x
                };
                var $res = Microsoft.Msagl.Core.Geometry.Point.IntervalIntersectsRay(leftPoint, rightPoint, node.Item.get_Start(), node.Item.get_Direction(), $1);
                x = $1.Value;
                return $res;
            }).call(this))
            var $it1283 = conesToRemove.GetEnumerator();
            while ($it1283.MoveNext()){
                var cone = $it1283.get_Current();
                this.RemoveCone(cone);
            }
        },
        ProcessVertexEvent: function (vertexEvent){
            this.set_Z(this.GetZ$$SweepEvent(vertexEvent));
            this.GoOverConesSeeingVertexEvent(vertexEvent);
            this.AddConeAndEnqueueEvents(vertexEvent);
        },
        AddConeAndEnqueueEvents: function (vertexEvent){
            var leftVertexEvent = As(vertexEvent, Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftVertexEvent.ctor);
            if (leftVertexEvent != null){
                var nextPoint = vertexEvent.get_Vertex().get_NextOnPolyline();
                this.CloseConesAddConeAtLeftVertex(leftVertexEvent, nextPoint);
            }
            else {
                var rightVertexEvent = As(vertexEvent, Microsoft.Msagl.Routing.Spline.ConeSpanner.RightVertexEvent.ctor);
                if (rightVertexEvent != null){
                    var nextPoint = vertexEvent.get_Vertex().get_PrevOnPolyline();
                    this.CloseConesAddConeAtRightVertex(rightVertexEvent, nextPoint);
                }
                else {
                    this.CloseConesAddConeAtLeftVertex(vertexEvent, vertexEvent.get_Vertex().get_NextOnPolyline());
                    this.CloseConesAddConeAtRightVertex(vertexEvent, vertexEvent.get_Vertex().get_PrevOnPolyline());
                }
            }
        },
        CloseConesAddConeAtRightVertex: function (rightVertexEvent, nextVertex){
            var prevSite = rightVertexEvent.get_Vertex().get_NextOnPolyline().get_Point();
            var prevZ = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(prevSite, this.get_SweepDirection());
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(prevZ, this.get_Z()))
                this.RemoveConesClosedBySegment(prevSite, rightVertexEvent.get_Vertex().get_Point());
            var site = rightVertexEvent.get_Site();
            var coneLp = Microsoft.Msagl.Core.Geometry.Point.op_Addition(site, this.get_ConeLeftSideDirection());
            var coneRp = Microsoft.Msagl.Core.Geometry.Point.op_Addition(site, this.get_ConeRightSideDirection());
            var nextSite = nextVertex.get_Point();
            if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(site, prevSite)), this.get_SweepDirection()) > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                this.RemoveRightSide(new Microsoft.Msagl.Routing.Spline.ConeSpanner.RightObstacleSide.ctor(rightVertexEvent.get_Vertex().get_NextOnPolyline()));
            if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(site, nextVertex.get_Point())), this.get_SweepDirection()) > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                this.RemoveLeftSide(new Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftObstacleSide.ctor(nextVertex));
            if (this.GetZ$$Point(nextSite) + Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon < this.GetZ$$SweepEvent(rightVertexEvent))
                this.CreateConeOnVertex(rightVertexEvent);
            if (!Microsoft.Msagl.Core.Geometry.Point.PointToTheRightOfLineOrOnLine(nextSite, site, coneLp)){
                this.CreateConeOnVertex(rightVertexEvent);
                if (Microsoft.Msagl.Core.Geometry.Point.PointToTheLeftOfLineOrOnLine(Microsoft.Msagl.Core.Geometry.Point.op_Addition(nextSite, this.get_DirectionPerp()), nextSite, site))
                    this.EnqueueEvent$$RightVertexEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.RightVertexEvent.ctor(nextVertex));
            }
            else if (Microsoft.Msagl.Core.Geometry.Point.PointToTheLeftOfLineOrOnLine(nextSite, site, coneRp))
                this.CaseToTheLeftOfLineOrOnLineConeRp(rightVertexEvent, nextVertex);
            else {
                if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(nextSite, site)), this.get_SweepDirection()) > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                    this.LookForIntersectionOfObstacleSideAndLeftConeSide(rightVertexEvent.get_Site(), nextVertex);
                    this.InsertRightSide(new Microsoft.Msagl.Routing.Spline.ConeSpanner.RightObstacleSide.ctor(rightVertexEvent.get_Vertex()));
                }
                this.EnqueueEvent$$RightVertexEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.RightVertexEvent.ctor(nextVertex));
            }
        },
        CaseToTheLeftOfLineOrOnLineConeRp: function (rightVertexEvent, nextVertex){
            this.EnqueueEvent$$RightVertexEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.RightVertexEvent.ctor(nextVertex));
            var cone = new Microsoft.Msagl.Routing.Spline.ConeSpanner.Cone.ctor(rightVertexEvent.get_Vertex().get_Point(), this);
            var obstacleSideSeg = new Microsoft.Msagl.Routing.Spline.ConeSpanner.BrokenConeSide.ctor(cone.get_Apex(), nextVertex, new Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeLeftSide.ctor(cone));
            cone.set_LeftSide(obstacleSideSeg);
            cone.set_RightSide(new Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeRightSide.ctor(cone));
            var rnode = this.InsertToTree(this.rightConeSides, cone.get_RightSide());
            this.LookForIntersectionWithConeRightSide(rnode);
            var lnode = this.InsertToTree(this.leftConeSides, cone.get_LeftSide());
            this.FixConeLeftSideIntersections(obstacleSideSeg, lnode);
            if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(nextVertex.get_Point(), rightVertexEvent.get_Site())), this.get_SweepDirection()) > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                this.InsertRightSide(new Microsoft.Msagl.Routing.Spline.ConeSpanner.RightObstacleSide.ctor(rightVertexEvent.get_Vertex()));
        },
        LookForIntersectionOfObstacleSideAndRightConeSide: function (obstacleSideStart, obstacleSideVertex){
            var node = this.GetLastNodeToTheLeftOfPointInRightSegmentTree(obstacleSideStart);
            if (node != null){
                var coneRightSide = As(node.Item, Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeRightSide.ctor);
                if (coneRightSide != null){
                    var intersection;
                    if ((function (){
                        var $1 = {
                            Value: intersection
                        };
                        var $res = Microsoft.Msagl.Core.Geometry.Point.IntervalIntersectsRay(obstacleSideStart, obstacleSideVertex.get_Point(), coneRightSide.get_Start(), this.get_ConeRightSideDirection(), $1);
                        intersection = $1.Value;
                        return $res;
                    }).call(this) && this.SegmentIsNotHorizontal(intersection, obstacleSideVertex.get_Point())){
                        this.EnqueueEvent(this.CreateRightIntersectionEvent(coneRightSide, intersection, obstacleSideVertex));
                    }
                }
            }
        },
        CreateRightIntersectionEvent: function (coneRightSide, intersection, obstacleSideVertex){
            System.Diagnostics.Debug.Assert$$Boolean(System.Math.Abs$$Double(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(obstacleSideVertex.get_Point(), intersection)), this.get_SweepDirection())) > 0);
            return new Microsoft.Msagl.Routing.Spline.ConeSpanner.RightIntersectionEvent.ctor(coneRightSide, intersection, obstacleSideVertex);
        },
        GetLastNodeToTheLeftOfPointInRightSegmentTree: function (obstacleSideStart){
            return this.rightConeSides.FindLast$$Func$2($CreateAnonymousDelegate(this, function (s){
                return Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeper.PointIsToTheRightOfSegment(obstacleSideStart, s);
            }));
        },
        LookForIntersectionOfObstacleSideAndLeftConeSide: function (obstacleSideStart, obstacleSideVertex){
            var node = this.GetFirstNodeToTheRightOfPoint(obstacleSideStart);
            if (node == null)
                return;
            var coneLeftSide = As(node.Item, Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeLeftSide.ctor);
            if (coneLeftSide == null)
                return;
            var intersection;
            if ((function (){
                var $1 = {
                    Value: intersection
                };
                var $res = Microsoft.Msagl.Core.Geometry.Point.IntervalIntersectsRay(obstacleSideStart, obstacleSideVertex.get_Point(), coneLeftSide.get_Start(), this.get_ConeLeftSideDirection(), $1);
                intersection = $1.Value;
                return $res;
            }).call(this)){
                this.EnqueueEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftIntersectionEvent.ctor(coneLeftSide, intersection, obstacleSideVertex));
            }
        },
        GetFirstNodeToTheRightOfPoint: function (p){
            return this.leftConeSides.FindFirst$$Func$2($CreateAnonymousDelegate(this, function (s){
                return Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeper.PointIsToTheLeftOfSegment(p, s);
            }));
        },
        FixConeLeftSideIntersections: function (leftSide, rbNode){
            System.Diagnostics.Debug.Assert$$Boolean(rbNode != null);
            do{
                rbNode = this.leftConeSides.Next(rbNode);
            }
            while (rbNode != null && Microsoft.Msagl.Core.Geometry.Point.PointToTheRightOfLineOrOnLine(leftSide.get_Start(), rbNode.Item.get_Start(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(rbNode.Item.get_Start(), rbNode.Item.get_Direction())))
            if (rbNode != null){
                var intersection;
                var seg = As(rbNode.Item, Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeLeftSide.ctor);
                if (seg != null && (function (){
                    var $1 = {
                        Value: intersection
                    };
                    var $res = Microsoft.Msagl.Core.Geometry.Point.IntervalIntersectsRay(leftSide.get_Start(), leftSide.get_End(), seg.get_Start(), seg.get_Direction(), $1);
                    intersection = $1.Value;
                    return $res;
                }).call(this)){
                    this.EnqueueEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftIntersectionEvent.ctor(seg, intersection, leftSide.get_EndVertex()));
                }
            }
        },
        InsertToTree: function (tree, coneSide){
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(coneSide.get_Direction(), this.get_SweepDirection()) > 0);
            this.coneSideComparer.SetOperand(coneSide);
            return tree.Insert(coneSide);
        },
        CloseConesAddConeAtLeftVertex: function (leftVertexEvent, nextVertex){
            var prevSite = leftVertexEvent.get_Vertex().get_PrevOnPolyline().get_Point();
            var prevZ = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(prevSite, this.get_SweepDirection());
            if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(prevZ, this.get_Z()) && Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(prevSite, leftVertexEvent.get_Site())), this.get_DirectionPerp()) > 0){
                this.RemoveConesClosedBySegment(leftVertexEvent.get_Vertex().get_Point(), prevSite);
            }
            var site = leftVertexEvent.get_Site();
            var coneLp = Microsoft.Msagl.Core.Geometry.Point.op_Addition(site, this.get_ConeLeftSideDirection());
            var coneRp = Microsoft.Msagl.Core.Geometry.Point.op_Addition(site, this.get_ConeRightSideDirection());
            var nextSite = nextVertex.get_Point();
            if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(site, prevSite)), this.get_SweepDirection()) > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                this.RemoveLeftSide(new Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftObstacleSide.ctor(leftVertexEvent.get_Vertex().get_PrevOnPolyline()));
            var nextDelZ = this.GetZ$$Point(nextSite) - this.get_Z();
            if (nextDelZ < -Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                this.RemoveRightSide(new Microsoft.Msagl.Routing.Spline.ConeSpanner.RightObstacleSide.ctor(nextVertex));
            if (nextDelZ < -Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon || Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Double$$Double(nextDelZ, 0) && Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(nextSite, leftVertexEvent.get_Site())), this.get_DirectionPerp()) > 0){
                this.CreateConeOnVertex(leftVertexEvent);
            }
            else if (!Microsoft.Msagl.Core.Geometry.Point.PointToTheLeftOfLineOrOnLine(nextSite, site, coneRp)){
                this.CreateConeOnVertex(leftVertexEvent);
                this.EnqueueEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftVertexEvent.ctor(nextVertex));
            }
            else if (!Microsoft.Msagl.Core.Geometry.Point.PointToTheLeftOfLineOrOnLine(nextSite, site, coneLp)){
                this.EnqueueEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftVertexEvent.ctor(nextVertex));
                var cone = new Microsoft.Msagl.Routing.Spline.ConeSpanner.Cone.ctor(leftVertexEvent.get_Vertex().get_Point(), this);
                var rightSide = new Microsoft.Msagl.Routing.Spline.ConeSpanner.BrokenConeSide.ctor(leftVertexEvent.get_Vertex().get_Point(), nextVertex, new Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeRightSide.ctor(cone));
                cone.set_RightSide(rightSide);
                cone.set_LeftSide(new Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeLeftSide.ctor(cone));
                this.LookForIntersectionWithConeLeftSide(this.InsertToTree(this.leftConeSides, cone.get_LeftSide()));
                var rbNode = this.InsertToTree(this.rightConeSides, rightSide);
                this.FixConeRightSideIntersections(rightSide, rbNode);
                if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(nextVertex.get_Point(), leftVertexEvent.get_Site())), this.get_SweepDirection()) > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon)
                    this.InsertLeftSide(new Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftObstacleSide.ctor(leftVertexEvent.get_Vertex()));
            }
            else {
                this.EnqueueEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftVertexEvent.ctor(nextVertex));
                if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(nextVertex.get_Point(), leftVertexEvent.get_Site())), this.get_SweepDirection()) > Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon){
                    this.LookForIntersectionOfObstacleSideAndRightConeSide(leftVertexEvent.get_Site(), nextVertex);
                    this.InsertLeftSide(new Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftObstacleSide.ctor(leftVertexEvent.get_Vertex()));
                }
            }
        },
        RemoveCone: function (cone){
            cone.set_Removed(true);
            this.RemoveSegFromLeftTree(cone.get_LeftSide());
            this.RemoveSegFromRightTree(cone.get_RightSide());
        },
        RemoveSegFromRightTree: function (coneSide){
            System.Diagnostics.Debug.Assert$$Boolean(coneSide.get_Removed() == false);
            this.coneSideComparer.SetOperand(coneSide);
            var b = this.rightConeSides.Remove(coneSide);
            coneSide.set_Removed(true);
            if (b == null){
                var tmpZ = this.get_Z();
                this.set_Z(System.Math.Max$$Double$$Double(this.GetZ$$Point(coneSide.get_Start()), this.get_Z() - 0.01));
                this.coneSideComparer.SetOperand(coneSide);
                b = this.rightConeSides.Remove(coneSide);
                this.set_Z(tmpZ);
            }
        },
        RemoveSegFromLeftTree: function (coneSide){
            System.Diagnostics.Debug.Assert$$Boolean(coneSide.get_Removed() == false);
            coneSide.set_Removed(true);
            this.coneSideComparer.SetOperand(coneSide);
            var b = this.leftConeSides.Remove(coneSide);
            if (b == null){
                var tmpZ = this.get_Z();
                this.set_Z(System.Math.Max$$Double$$Double(this.GetZ$$Point(coneSide.get_Start()), this.get_Z() - 0.01));
                this.coneSideComparer.SetOperand(coneSide);
                this.leftConeSides.Remove(coneSide);
                this.set_Z(tmpZ);
            }
            System.Diagnostics.Debug.Assert$$Boolean(b != null);
        },
        FixConeRightSideIntersections: function (rightSide, rbNode){
            System.Diagnostics.Debug.Assert$$Boolean(rbNode != null);
            do{
                rbNode = this.rightConeSides.Previous(rbNode);
            }
            while (rbNode != null && Microsoft.Msagl.Core.Geometry.Point.PointToTheLeftOfLineOrOnLine(rightSide.get_Start(), rbNode.Item.get_Start(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(rbNode.Item.get_Start(), rbNode.Item.get_Direction())))
            if (rbNode != null){
                var intersection;
                var seg = As(rbNode.Item, Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeRightSide.ctor);
                if (seg != null && (function (){
                    var $1 = {
                        Value: intersection
                    };
                    var $res = Microsoft.Msagl.Core.Geometry.Point.IntervalIntersectsRay(rightSide.get_Start(), rightSide.get_End(), seg.get_Start(), seg.get_Direction(), $1);
                    intersection = $1.Value;
                    return $res;
                }).call(this)){
                    this.EnqueueEvent(this.CreateRightIntersectionEvent(seg, intersection, rightSide.get_EndVertex()));
                }
            }
        },
        CreateConeOnVertex: function (sweepEvent){
            var cone = new Microsoft.Msagl.Routing.Spline.ConeSpanner.Cone.ctor(sweepEvent.get_Site(), this);
            cone.set_LeftSide(new Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeLeftSide.ctor(cone));
            cone.set_RightSide(new Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeRightSide.ctor(cone));
            var leftNode = this.InsertToTree(this.leftConeSides, cone.get_LeftSide());
            var rightNode = this.InsertToTree(this.rightConeSides, cone.get_RightSide());
            this.LookForIntersectionWithConeRightSide(rightNode);
            this.LookForIntersectionWithConeLeftSide(leftNode);
        },
        LookForIntersectionWithConeLeftSide: function (leftNode){
            var coneLeftSide = As(leftNode.Item, Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeLeftSide.ctor);
            if (coneLeftSide != null){
                var rightObstacleSide = this.FindFirstObstacleSideToTheLeftOfPoint(coneLeftSide.get_Start());
                if (rightObstacleSide != null)
                    this.TryIntersectionOfConeLeftSideAndObstacleSide(coneLeftSide, rightObstacleSide);
            }
            else {
                var seg = Cast(leftNode.Item, Microsoft.Msagl.Routing.Spline.ConeSpanner.BrokenConeSide.ctor);
                leftNode = this.leftConeSides.Next(leftNode);
                if (leftNode != null){
                    coneLeftSide = As(leftNode.Item, Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeLeftSide.ctor);
                    if (coneLeftSide != null)
                        this.TryIntersectionOfConeLeftSideAndObstacleConeSide(coneLeftSide, seg);
                }
            }
        },
        LookForIntersectionWithConeRightSide: function (rightNode){
            var coneRightSide = As(rightNode.Item, Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeRightSide.ctor);
            if (coneRightSide != null){
                var leftObstacleSide = this.FindFirstObstacleSideToToTheRightOfPoint(coneRightSide.get_Start());
                if (leftObstacleSide != null)
                    this.TryIntersectionOfConeRightSideAndObstacleSide(coneRightSide, leftObstacleSide);
            }
            else {
                var seg = Cast(rightNode.Item, Microsoft.Msagl.Routing.Spline.ConeSpanner.BrokenConeSide.ctor);
                rightNode = this.rightConeSides.Previous(rightNode);
                if (rightNode != null){
                    coneRightSide = As(rightNode.Item, Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeRightSide.ctor);
                    if (coneRightSide != null)
                        this.TryIntersectionOfConeRightSideAndObstacleConeSide(coneRightSide, seg);
                }
            }
        },
        TryIntersectionOfConeRightSideAndObstacleConeSide: function (coneRightSide, seg){
            var x;
            if ((function (){
                var $1 = {
                    Value: x
                };
                var $res = Microsoft.Msagl.Core.Geometry.Point.IntervalIntersectsRay(seg.get_Start(), seg.get_End(), coneRightSide.get_Start(), coneRightSide.get_Direction(), $1);
                x = $1.Value;
                return $res;
            }).call(this)){
                this.EnqueueEvent(this.CreateRightIntersectionEvent(coneRightSide, x, seg.get_EndVertex()));
            }
        },
        TryIntersectionOfConeRightSideAndObstacleSide: function (coneRightSide, side){
            var x;
            if ((function (){
                var $1 = {
                    Value: x
                };
                var $res = Microsoft.Msagl.Core.Geometry.Point.IntervalIntersectsRay(side.get_Start(), side.get_End(), coneRightSide.get_Start(), coneRightSide.get_Direction(), $1);
                x = $1.Value;
                return $res;
            }).call(this)){
                this.EnqueueEvent(this.CreateRightIntersectionEvent(coneRightSide, x, side.get_EndVertex()));
            }
        },
        TryIntersectionOfConeLeftSideAndObstacleConeSide: function (coneLeftSide, seg){
            var x;
            if ((function (){
                var $1 = {
                    Value: x
                };
                var $res = Microsoft.Msagl.Core.Geometry.Point.IntervalIntersectsRay(seg.get_Start(), seg.get_End(), coneLeftSide.get_Start(), coneLeftSide.get_Direction(), $1);
                x = $1.Value;
                return $res;
            }).call(this)){
                this.EnqueueEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftIntersectionEvent.ctor(coneLeftSide, x, seg.get_EndVertex()));
            }
        },
        TryIntersectionOfConeLeftSideAndObstacleSide: function (coneLeftSide, side){
            var x;
            if ((function (){
                var $1 = {
                    Value: x
                };
                var $res = Microsoft.Msagl.Core.Geometry.Point.IntervalIntersectsRay(side.get_Start(), side.get_End(), coneLeftSide.get_Start(), coneLeftSide.get_Direction(), $1);
                x = $1.Value;
                return $res;
            }).call(this)){
                this.EnqueueEvent(new Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftIntersectionEvent.ctor(coneLeftSide, x, side.get_EndVertex()));
            }
        },
        GoOverConesSeeingVertexEvent: function (vertexEvent){
            var rbNode = this.FindFirstSegmentInTheRightTreeNotToTheLeftOfVertex(vertexEvent);
            if (rbNode == null)
                return;
            var coneRightSide = rbNode.Item;
            var cone = coneRightSide.get_Cone();
            var leftConeSide = cone.get_LeftSide();
            if (Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeper.VertexIsToTheLeftOfSegment(vertexEvent, leftConeSide))
                return;
            var visibleCones = (function (){
                var $v136 = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Spline.ConeSpanner.Cone.ctor);
                $v136.Add(cone);
                return $v136;
            }).call(this);
            this.coneSideComparer.SetOperand(leftConeSide);
            rbNode = this.leftConeSides.Find$$T(leftConeSide);
            if (rbNode == null){
                var tmpZ = this.get_Z();
                this.set_Z(System.Math.Max$$Double$$Double(this.GetZ$$Point(leftConeSide.get_Start()), this.PreviousZ));
                this.coneSideComparer.SetOperand(leftConeSide);
                rbNode = this.leftConeSides.Find$$T(leftConeSide);
                this.set_Z(tmpZ);
            }
            if (rbNode == null){
                rbNode = this.GetRbNodeEmergency(rbNode, leftConeSide);
            }
            if (rbNode == null)
                return;
            rbNode = this.leftConeSides.Next(rbNode);
            while (rbNode != null && !Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeper.VertexIsToTheLeftOfSegment(vertexEvent, rbNode.Item)){
                visibleCones.Add(rbNode.Item.get_Cone());
                rbNode = this.leftConeSides.Next(rbNode);
            }
            var $it1284 = visibleCones.GetEnumerator();
            while ($it1284.MoveNext()){
                var visCone = $it1284.get_Current();
                this.AddEdgeAndRemoveCone(visCone, vertexEvent.get_Site());
            }
        },
        GetRbNodeEmergency: function (rbNode, leftConeSide){
            for (var node = this.leftConeSides.TreeMinimum(); node != null; node = this.leftConeSides.Next(node))
                if (node.Item == leftConeSide){
                    rbNode = node;
                    break;
                }
            return rbNode;
        },
        FindFirstSegmentInTheRightTreeNotToTheLeftOfVertex: function (vertexEvent){
            return this.rightConeSides.FindFirst$$Func$2($CreateAnonymousDelegate(this, function (s){
                return !Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeper.VertexIsToTheRightOfSegment(vertexEvent, s);
            }));
        },
        EnqueueEvent$$RightVertexEvent: function (vertexEvent){
            if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(this.get_SweepDirection(), (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(vertexEvent.get_Site(), vertexEvent.get_Vertex().get_PrevOnPolyline().get_Point()))) > Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                return;
            Microsoft.Msagl.Routing.Visibility.LineSweeperBase.commonPrototype.EnqueueEvent.call(this, vertexEvent);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$ConeSpanner$LineSweeper);
var Microsoft$Msagl$Routing$Spline$ConeSpanner$SweepEvent = {
    fullname: "Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        },
        Site$$: "Microsoft.Msagl.Core.Geometry.Point",
        toString: function (){
            var typeString = this.GetType().toString();
            var lastDotLoc = typeString.lastIndexOf(".");
            if (lastDotLoc >= 0){
                typeString = typeString.substr(lastDotLoc + 1);
            }
            return System.String.Format$$String$$Object$$Object("{0} {1}", typeString, this.get_Site());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$ConeSpanner$SweepEvent);
var Microsoft$Msagl$Routing$Spline$ConeSpanner$BrokenConeSide = {
    fullname: "Microsoft.Msagl.Routing.Spline.ConeSpanner.BrokenConeSide",
    baseTypeName: "Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSide",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (start, end, coneSide){
            this.start = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this._ConeSide = null;
            this._EndVertex = null;
            Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSide.ctor.call(this);
            this.start = start;
            this.set_EndVertex(end);
            this.set_ConeSide(coneSide);
        },
        Start$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Start: function (){
            return this.start;
        },
        ConeSide$$: "Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSide",
        get_ConeSide: function (){
            return this._ConeSide;
        },
        set_ConeSide: function (value){
            this._ConeSide = value;
        },
        EndVertex$$: "Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint",
        get_EndVertex: function (){
            return this._EndVertex;
        },
        set_EndVertex: function (value){
            this._EndVertex = value;
        },
        End$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_End: function (){
            return this.get_EndVertex().get_Point();
        },
        Direction$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Direction: function (){
            return Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.get_End(), this.get_Start());
        },
        toString: function (){
            return "BrokenConeSide: " + this.get_Start() + "," + this.get_End();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$ConeSpanner$BrokenConeSide);
var Microsoft$Msagl$Routing$Spline$ConeSpanner$RightObstacleSide = {
    fullname: "Microsoft.Msagl.Routing.Spline.ConeSpanner.RightObstacleSide",
    baseTypeName: "Microsoft.Msagl.Routing.Spline.ConeSpanner.ObstacleSide",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (startVertex){
            this.end = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            Microsoft.Msagl.Routing.Spline.ConeSpanner.ObstacleSide.ctor.call(this, startVertex);
            this.end = startVertex.get_PrevOnPolyline().get_Point();
        },
        End$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_End: function (){
            return this.end;
        },
        EndVertex$$: "Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint",
        get_EndVertex: function (){
            return this.get_StartVertex().get_PrevOnPolyline();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$ConeSpanner$RightObstacleSide);
var Microsoft$Msagl$Routing$Spline$ConeSpanner$RightVertexEvent = {
    fullname: "Microsoft.Msagl.Routing.Spline.ConeSpanner.RightVertexEvent",
    baseTypeName: "Microsoft.Msagl.Routing.Spline.ConeSpanner.VertexEvent",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (p){
            Microsoft.Msagl.Routing.Spline.ConeSpanner.VertexEvent.ctor.call(this, p);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$ConeSpanner$RightVertexEvent);
var Microsoft$Msagl$Routing$Spline$ConeSpanner$ConeSide = {
    fullname: "Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSide",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this._Cone = null;
            this._Removed = false;
            System.Object.ctor.call(this);
        },
        Start$$: "Microsoft.Msagl.Core.Geometry.Point",
        Direction$$: "Microsoft.Msagl.Core.Geometry.Point",
        Cone$$: "Microsoft.Msagl.Routing.Spline.ConeSpanner.Cone",
        get_Cone: function (){
            return this._Cone;
        },
        set_Cone: function (value){
            this._Cone = value;
        },
        Removed$$: "System.Boolean",
        get_Removed: function (){
            return this._Removed;
        },
        set_Removed: function (value){
            this._Removed = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$ConeSpanner$ConeSide);
var Microsoft$Msagl$Routing$Spline$ConeSpanner$ConeSideComparer = {
    fullname: "Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSideComparer",
    baseTypeName: "System.Object",
    staticDefinition: {
        CompareNotIntersectingSegs: function (a, b){
            var signedArea = Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(a.get_Start(), b.get_Start(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(b.get_Start(), b.get_Direction()));
            switch (signedArea){
                case Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise:
                    return -1;
                case Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise:
                    return 1;
                default:
                    return 0;
            }
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IComparer$1"],
    Kind: "Class",
    definition: {
        ctor: function (coneSweeper){
            this.x = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.coneSweeper = null;
            System.Object.ctor.call(this);
            this.coneSweeper = coneSweeper;
        },
        SetOperand: function (activeElement){
            this.x = this.IntersectionOfSegmentAndSweepLine((activeElement));
        },
        Compare: function (a, b){
            var aObst = As(a, Microsoft.Msagl.Routing.Spline.ConeSpanner.BrokenConeSide.ctor);
            var bObst = As(b, Microsoft.Msagl.Routing.Spline.ConeSpanner.BrokenConeSide.ctor);
            if (aObst != null){
                return bObst != null ? this.CompareBrokenSides(aObst, bObst) : this.CompareObstacleSideAndConeSide(b);
            }
            else {
                return bObst != null ? this.CompareConeSideAndObstacleSide(a, bObst) : Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSideComparer.CompareNotIntersectingSegs(a, b);
            }
        },
        CompareObstacleSideAndConeSide: function (coneSide){
            var orientation = Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(this.x, coneSide.get_Start(), Microsoft.Msagl.Core.Geometry.Point.op_Addition(coneSide.get_Start(), coneSide.get_Direction()));
            if (orientation == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise)
                return -1;
            if (orientation == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise)
                return 1;
            return Is(coneSide, Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeLeftSide.ctor) ? -1 : 1;
        },
        CompareConeSideAndObstacleSide: function (coneSide, brokenConeSide){
            var orientation = Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(this.x, brokenConeSide.get_Start(), brokenConeSide.get_End());
            if (orientation == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise)
                return -1;
            if (orientation == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise)
                return 1;
            return Is(coneSide, Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeLeftSide.ctor) ? 1 : -1;
        },
        IntersectionOfSegmentAndSweepLine: function (obstacleSide){
            var den = Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(obstacleSide.get_Direction(), this.coneSweeper.get_SweepDirection());
            System.Diagnostics.Debug.Assert$$Boolean(System.Math.Abs$$Double(den) > 0);
            var t = (this.coneSweeper.get_Z() - Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point(obstacleSide.get_Start(), this.coneSweeper.get_SweepDirection())) / den;
            return Microsoft.Msagl.Core.Geometry.Point.op_Addition(obstacleSide.get_Start(), Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Double$$Point(t, obstacleSide.get_Direction()));
        },
        CompareBrokenSides: function (aObst, bObst){
            if (aObst.get_EndVertex() == bObst.get_EndVertex())
                return Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSideComparer.CompareNotIntersectingSegs(aObst.get_ConeSide(), bObst.get_ConeSide());
            if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(this.x, bObst.get_Start(), bObst.get_EndVertex().get_Point()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise)
                return -1;
            return 1;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$ConeSpanner$ConeSideComparer);
var Microsoft$Msagl$Routing$Spline$ConeSpanner$VertexEvent = {
    fullname: "Microsoft.Msagl.Routing.Spline.ConeSpanner.VertexEvent",
    baseTypeName: "Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (p){
            this.vertex = null;
            Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent.ctor.call(this);
            this.vertex = p;
        },
        Vertex$$: "Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint",
        get_Vertex: function (){
            return this.vertex;
        },
        set_Vertex: function (value){
            this.vertex = value;
        },
        Site$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Site: function (){
            return this.vertex.get_Point();
        },
        Polyline$$: "Microsoft.Msagl.Core.Geometry.Curves.Polyline",
        get_Polyline: function (){
            return this.vertex.get_Polyline();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Spline$ConeSpanner$VertexEvent);
var Microsoft$Msagl$Routing$Visibility$Diagonal = {
    fullname: "Microsoft.Msagl.Routing.Visibility.Diagonal",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (leftTangent, rightTangent){
            this.leftTangent = null;
            this.rightTangent = null;
            this.rbNode = null;
            System.Object.ctor.call(this);
            this.set_LeftTangent(leftTangent);
            this.set_RightTangent(rightTangent);
        },
        toString: function (){
            return System.String.Format$$IFormatProvider$$String$$Object$Array(System.Globalization.CultureInfo.get_InvariantCulture(), "{0},{1}", [this.get_Start(), this.get_End()]);
        },
        Start$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Start: function (){
            return this.leftTangent.get_End().get_Point();
        },
        End$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_End: function (){
            return this.rightTangent.get_End().get_Point();
        },
        LeftTangent$$: "Microsoft.Msagl.Routing.Visibility.Tangent",
        get_LeftTangent: function (){
            return this.leftTangent;
        },
        set_LeftTangent: function (value){
            this.leftTangent = value;
        },
        RightTangent$$: "Microsoft.Msagl.Routing.Visibility.Tangent",
        get_RightTangent: function (){
            return this.rightTangent;
        },
        set_RightTangent: function (value){
            this.rightTangent = value;
        },
        RbNode$$: "Microsoft.Msagl.Core.DataStructures.RBNode`1[[Microsoft.Msagl.Routing.Visibility.Diagonal]]",
        get_RbNode: function (){
            return this.rbNode;
        },
        set_RbNode: function (value){
            this.rbNode = value;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Visibility$Diagonal);
var Microsoft$Msagl$Routing$Visibility$InteractiveTangentVisibilityGraphCalculator = {
    fullname: "Microsoft.Msagl.Routing.Visibility.InteractiveTangentVisibilityGraphCalculator",
    baseTypeName: "Microsoft.Msagl.Core.AlgorithmBase",
    staticDefinition: {
        cctor: function (){
        },
        MarkDiagonalAsActiveInTangents: function (diagonal){
            diagonal.get_LeftTangent().set_Diagonal(diagonal);
            diagonal.get_RightTangent().set_Diagonal(diagonal);
        },
        RayIntersectDiagonal: function (pivot, pointOnRay, diagonal){
            var a = diagonal.get_Start();
            var b = diagonal.get_End();
            return Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(pivot, a, b) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise && Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(pivot, pointOnRay, a) != Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise && Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(pivot, pointOnRay, b) != Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (holes, addedPolygons, visibilityGraph){
            this.polygons = null;
            this.addedPolygons = null;
            this.visibilityGraph = null;
            this.diagonals = null;
            this.tangents = null;
            this.activeDiagonalTree = null;
            this.currentPolygon = null;
            this.activeDiagonalComparer = new Microsoft.Msagl.Routing.Visibility.ActiveDiagonalComparerWithRay.ctor();
            this.useLeftPTangents = false;
            Microsoft.Msagl.Core.AlgorithmBase.ctor.call(this);
            this.polygons = holes;
            this.visibilityGraph = visibilityGraph;
            this.addedPolygons = addedPolygons;
        },
        RunInternal: function (){
            this.useLeftPTangents = true;
            this.CalculateAndAddEdges();
            this.useLeftPTangents = false;
            this.CalculateAndAddEdges();
        },
        CalculateAndAddEdges: function (){
            var $it1285 = this.addedPolygons.GetEnumerator();
            while ($it1285.MoveNext()){
                var p = $it1285.get_Current();
                this.CalculateVisibleTangentsFromPolygon(p);
                this.ProgressStep();
            }
        },
        CalculateVisibleTangentsFromPolygon: function (polygon){
            this.currentPolygon = polygon;
            this.AllocateDataStructures();
            this.OrganizeTangents();
            this.InitActiveDiagonals();
            this.Sweep();
        },
        AllocateDataStructures: function (){
            this.tangents = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Visibility.Tangent.ctor);
            this.diagonals = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Visibility.Diagonal.ctor);
            this.activeDiagonalTree = new Microsoft.Msagl.Core.DataStructures.RbTree$1.ctor$$IComparer$1(Microsoft.Msagl.Routing.Visibility.Diagonal.ctor, this.activeDiagonalComparer);
        },
        Sweep: function (){
            if (this.tangents.get_Count() < 2)
                return;
            for (var i = 1; i < this.tangents.get_Count(); i++){
                var t = this.tangents.get_Item$$Int32(i);
                if (t.get_Diagonal() != null){
                    if (t.get_Diagonal().get_RbNode() == this.activeDiagonalTree.TreeMinimum())
                        this.AddVisibleEdge(t);
                    if (t.get_IsHigh())
                        this.RemoveDiagonalFromActiveNodes(t.get_Diagonal());
                }
                else {
                    if (t.get_IsLow()){
                        this.activeDiagonalComparer.set_PointOnTangentAndInsertedDiagonal(t.get_End().get_Point());
                        this.InsertActiveDiagonal(new Microsoft.Msagl.Routing.Visibility.Diagonal.ctor(t, t.get_Comp()));
                        if (t.get_Diagonal().get_RbNode() == this.activeDiagonalTree.TreeMinimum())
                            this.AddVisibleEdge(t);
                    }
                }
            }
        },
        AddVisibleEdge: function (t){
            Microsoft.Msagl.Routing.Visibility.VisibilityGraph.AddEdge$$VisibilityVertex$$VisibilityVertex(this.visibilityGraph.GetVertex(t.get_Start()), this.visibilityGraph.GetVertex(t.get_End()));
        },
        InitActiveDiagonals: function (){
            if (this.tangents.get_Count() == 0)
                return;
            var firstTangent = this.tangents.get_Item$$Int32(0);
            var firstTangentStart = firstTangent.get_Start().get_Point();
            var firstTangentEnd = firstTangent.get_End().get_Point();
            var $it1286 = this.diagonals.GetEnumerator();
            while ($it1286.MoveNext()){
                var diagonal = $it1286.get_Current();
                if (Microsoft.Msagl.Routing.Visibility.InteractiveTangentVisibilityGraphCalculator.RayIntersectDiagonal(firstTangentStart, firstTangentEnd, diagonal)){
                    this.activeDiagonalComparer.set_PointOnTangentAndInsertedDiagonal(Microsoft.Msagl.Routing.Visibility.ActiveDiagonalComparerWithRay.IntersectDiagonalWithRay(firstTangentStart, firstTangentEnd, diagonal));
                    this.InsertActiveDiagonal(diagonal);
                }
            }
            if (firstTangent.get_Diagonal().get_RbNode() == this.activeDiagonalTree.TreeMinimum())
                this.AddVisibleEdge(firstTangent);
            if (firstTangent.get_IsLow() == false){
                var diag = firstTangent.get_Diagonal();
                this.RemoveDiagonalFromActiveNodes(diag);
            }
        },
        RemoveDiagonalFromActiveNodes: function (diag){
            var changedNode = this.activeDiagonalTree.DeleteSubtree(diag.get_RbNode());
            if (changedNode != null)if (changedNode.Item != null)
                changedNode.Item.set_RbNode(changedNode);
            diag.get_LeftTangent().set_Diagonal(null);
            diag.get_RightTangent().set_Diagonal(null);
        },
        InsertActiveDiagonal: function (diagonal){
            diagonal.set_RbNode(this.activeDiagonalTree.Insert(diagonal));
            Microsoft.Msagl.Routing.Visibility.InteractiveTangentVisibilityGraphCalculator.MarkDiagonalAsActiveInTangents(diagonal);
        },
        TangentComparison: function (e0, e1){
            return Microsoft.Msagl.Routing.Visibility.StemStartPointComparer.CompareVectorsByAngleToXAxis(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(e0.get_End().get_Point(), e0.get_Start().get_Point()), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(e1.get_End().get_Point(), e1.get_Start().get_Point()));
        },
        AllObstacles$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Routing.Visibility.Polygon]]",
        get_AllObstacles: function (){
            var $yield = [];
            var $it1287 = this.addedPolygons.GetEnumerator();
            while ($it1287.MoveNext()){
                var p = $it1287.get_Current();
                $yield.push(p);
            }
            var $it1288 = this.polygons.GetEnumerator();
            while ($it1288.MoveNext()){
                var p = $it1288.get_Current();
                $yield.push(p);
            }
            return $yield;
        },
        OrganizeTangents: function (){
            var $it1289 = this.get_AllObstacles().GetEnumerator();
            while ($it1289.MoveNext()){
                var q = $it1289.get_Current();
                if (q != this.currentPolygon)
                    this.ProcessPolygonQ(q);
            }
            this.tangents.Sort$$Comparison$1($CreateDelegate(this, this.TangentComparison));
        },
        ProcessPolygonQ: function (q){
            var tangentPair = new Microsoft.Msagl.Routing.Visibility.TangentPair.ctor(this.currentPolygon, q);
            if (this.useLeftPTangents)
                tangentPair.CalculateLeftTangents();
            else
                tangentPair.CalculateRightTangents();
            var couple = this.useLeftPTangents ? tangentPair.leftPLeftQ : tangentPair.rightPLeftQ;
            var t0 = new Microsoft.Msagl.Routing.Visibility.Tangent.ctor(this.currentPolygon.get_Item$$Int32(couple.get_Item1()), q.get_Item$$Int32(couple.get_Item2()));
            t0.set_IsLow(true);
            t0.set_SeparatingPolygons(!this.useLeftPTangents);
            couple = this.useLeftPTangents ? tangentPair.leftPRightQ : tangentPair.rightPRightQ;
            var t1 = new Microsoft.Msagl.Routing.Visibility.Tangent.ctor(this.currentPolygon.get_Item$$Int32(couple.get_Item1()), q.get_Item$$Int32(couple.get_Item2()));
            t1.set_IsLow(false);
            t1.set_SeparatingPolygons(this.useLeftPTangents);
            t0.set_Comp(t1);
            t1.set_Comp(t0);
            this.tangents.Add(t0);
            this.tangents.Add(t1);
            this.diagonals.Add(new Microsoft.Msagl.Routing.Visibility.Diagonal.ctor(t0, t1));
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Visibility$InteractiveTangentVisibilityGraphCalculator);
var Microsoft$Msagl$Routing$Visibility$InteractiveTangentVisibilityGraphCalculator$FilterVisibleEdgesDelegate = {
    fullname: "Microsoft.Msagl.Routing.Visibility.InteractiveTangentVisibilityGraphCalculator.FilterVisibleEdgesDelegate",
    Kind: "Delegate",
    definition: {
        ctor: function (obj, func){
            System.MulticastDelegate.ctor.call(this, obj, func);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Visibility$InteractiveTangentVisibilityGraphCalculator$FilterVisibleEdgesDelegate);
var Microsoft$Msagl$Routing$Rectilinear$PointComparer = {
    fullname: "Microsoft.Msagl.Routing.Rectilinear.PointComparer",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Routing.Rectilinear.PointComparer.differenceEpsilon = Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon / 2;
        },
        DifferenceEpsilon$$: "System.Double",
        get_DifferenceEpsilon: function (){
            return Microsoft.Msagl.Routing.Rectilinear.PointComparer.differenceEpsilon;
        },
        Equal$$Point$$Point: function (a, b){
            return Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Double$$Double(a.get_X(), b.get_X()) && Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal$$Double$$Double(a.get_Y(), b.get_Y());
        },
        Equal$$Double$$Double: function (x, y){
            return (0 == Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Double$$Double(x, y));
        },
        Compare$$Double$$Double: function (lhs, rhs){
            Microsoft.Msagl.Routing.Rectilinear.PointComparer.Assert_Rounded$$Double(lhs);
            Microsoft.Msagl.Routing.Rectilinear.PointComparer.Assert_Rounded$$Double(rhs);
            var cmp = 0;
            if (lhs + Microsoft.Msagl.Routing.Rectilinear.PointComparer.get_DifferenceEpsilon() < rhs){
                cmp = -1;
            }
            else if (rhs + Microsoft.Msagl.Routing.Rectilinear.PointComparer.get_DifferenceEpsilon() < lhs){
                cmp = 1;
            }
            System.Diagnostics.Debug.Assert$$Boolean((cmp < 0) == (Microsoft.Msagl.Core.Geometry.Directions.East == Microsoft.Msagl.Core.Geometry.CompassVector.VectorDirection$$Point$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(lhs, 0), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(rhs, 0))));
            System.Diagnostics.Debug.Assert$$Boolean((0 == cmp) == (Microsoft.Msagl.Core.Geometry.Directions.None == Microsoft.Msagl.Core.Geometry.CompassVector.VectorDirection$$Point$$Point(new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(lhs, 0), new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(rhs, 0))));
            return cmp;
        },
        Compare$$Point$$Point: function (lhs, rhs){
            var cmp = Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Double$$Double(lhs.get_X(), rhs.get_X());
            if (0 == cmp){
                cmp = Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Double$$Double(lhs.get_Y(), rhs.get_Y());
            }
            return cmp;
        },
        LessOrEqual: function (a, b){
            var comp = Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Double$$Double(a, b);
            return comp < 0 || comp == 0;
        },
        Less: function (a, b){
            return Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare$$Double$$Double(a, b) < 0;
        },
        Assert_Rounded$$Double: function (d){
            if (System.Math.Log10(System.Math.Abs$$Double(d)) < (14 - Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_DistanceEpsilonPrecision())){
                System.Diagnostics.Debug.Assert$$Boolean$$String(System.Math.Abs$$Double(Microsoft.Msagl.Core.Geometry.ApproximateComparer.Round$$Double(d) - d) < Microsoft.Msagl.Routing.Rectilinear.PointComparer.get_DifferenceEpsilon(), "unRounded value passed");
            }
        },
        Assert_Rounded$$Point: function (p){
            Microsoft.Msagl.Routing.Rectilinear.PointComparer.Assert_Rounded$$Double(p.get_X());
            Microsoft.Msagl.Routing.Rectilinear.PointComparer.Assert_Rounded$$Double(p.get_Y());
        },
        GetDirections$$Point$$Point: function (a, b){
            Microsoft.Msagl.Routing.Rectilinear.PointComparer.Assert_Rounded$$Point(a);
            Microsoft.Msagl.Routing.Rectilinear.PointComparer.Assert_Rounded$$Point(b);
            return Microsoft.Msagl.Core.Geometry.CompassVector.DirectionsFromPointToPoint(a, b);
        },
        GetPureDirection$$Point$$Point: function (a, b){
            Microsoft.Msagl.Routing.Rectilinear.PointComparer.Assert_Rounded$$Point(a);
            Microsoft.Msagl.Routing.Rectilinear.PointComparer.Assert_Rounded$$Point(b);
            var dir = Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(a, b);
            System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Core.Geometry.CompassVector.IsPureDirection$$Directions(dir), "Impure direction found");
            return dir;
        },
        IsPureDirection$$Point$$Point: function (a, b){
            Microsoft.Msagl.Routing.Rectilinear.PointComparer.Assert_Rounded$$Point(a);
            Microsoft.Msagl.Routing.Rectilinear.PointComparer.Assert_Rounded$$Point(b);
            return Microsoft.Msagl.Core.Geometry.CompassVector.IsPureDirection$$Directions(Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(a, b));
        },
        IsPureDirection$$Directions: function (dir){
            return Microsoft.Msagl.Core.Geometry.CompassVector.IsPureDirection$$Directions(dir);
        },
        IsPureLower: function (a, b){
            Microsoft.Msagl.Routing.Rectilinear.PointComparer.Assert_Rounded$$Point(a);
            Microsoft.Msagl.Routing.Rectilinear.PointComparer.Assert_Rounded$$Point(b);
            var dir = Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(a, b);
            return (Microsoft.Msagl.Core.Geometry.Directions.East == dir) || (Microsoft.Msagl.Core.Geometry.Directions.North == dir);
        },
        GetPureDirection$$VisibilityVertex$$VisibilityVertex: function (first, second){
            Microsoft.Msagl.Routing.Rectilinear.PointComparer.Assert_Rounded$$Point(first.Point);
            Microsoft.Msagl.Routing.Rectilinear.PointComparer.Assert_Rounded$$Point(second.Point);
            return Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetPureDirection$$Point$$Point(first.Point, second.Point);
        },
        GetDirections$$VisibilityVertex$$VisibilityVertex: function (first, second){
            Microsoft.Msagl.Routing.Rectilinear.PointComparer.Assert_Rounded$$Point(first.Point);
            Microsoft.Msagl.Routing.Rectilinear.PointComparer.Assert_Rounded$$Point(second.Point);
            return Microsoft.Msagl.Routing.Rectilinear.PointComparer.GetDirections$$Point$$Point(first.Point, second.Point);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Rectilinear$PointComparer);
var Microsoft$Msagl$Routing$Visibility$PointVisibilityCalculator = {
    fullname: "Microsoft.Msagl.Routing.Visibility.PointVisibilityCalculator",
    baseTypeName: "System.Object",
    staticDefinition: {
        CalculatePointVisibilityGraph: function (listOfHoles, visibilityGraph, point, visibilityKind, qVertex){
            var qv = visibilityGraph.FindVertex(point);
            if (qv != null){
                qVertex.Value = qv;
                return;
            }
            var calculator = new Microsoft.Msagl.Routing.Visibility.PointVisibilityCalculator.ctor(listOfHoles, visibilityGraph, point, visibilityKind);
            calculator.FillGraph();
            qVertex.Value = calculator.get_QVertex();
            System.Diagnostics.Debug.Assert$$Boolean(qVertex.Value != null);
        },
        LineTouchesPolygon: function (a, p){
            var prev = p.get_Polyline().Prev(p).get_Point();
            var next = p.get_Polyline().Next(p).get_Point();
            var v = p.get_Point();
            return Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(a, v, prev) * Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(a, v, next) >= 0;
        },
        GetIncomingSide: function (v){
            return v.get_PrevOnPolyline();
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (holes, visibilityGraph, point, visibilityKind){
            this.activeEdgeComparer = null;
            this.activeSidesTree = null;
            this.sideNodes = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor, Microsoft.Msagl.Core.DataStructures.RBNode$1.ctor);
            this.heapForSorting = null;
            this.visibilityGraph = null;
            this.visibilityKind = Microsoft.Msagl.Routing.Visibility.VisibilityKind.Regular;
            this.visibleBoundaries = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, Microsoft.Msagl.Routing.Visibility.Stem.ctor);
            this.q = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.qPolylinePoint = null;
            this.sortedListOfPolypoints = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor);
            this.holes = null;
            this._QVertex = null;
            System.Object.ctor.call(this);
            this.holes = holes;
            this.visibilityGraph = visibilityGraph;
            this.q = point;
            this.qPolylinePoint = new Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor(this.q);
            this.set_QVertex(this.visibilityGraph.AddVertex$$PolylinePoint(this.qPolylinePoint));
            this.visibilityKind = visibilityKind;
            this.heapForSorting = new Microsoft.Msagl.Core.DataStructures.BinaryHeapWithComparer$1.ctor(Microsoft.Msagl.Routing.Visibility.Stem.ctor, new Microsoft.Msagl.Routing.Visibility.StemStartPointComparer.ctor(this.q));
        },
        QVertex$$: "Microsoft.Msagl.Routing.Visibility.VisibilityVertex",
        get_QVertex: function (){
            return this._QVertex;
        },
        set_QVertex: function (value){
            this._QVertex = value;
        },
        FillGraph: function (){
            this.ComputeHoleBoundariesPossiblyVisibleFromQ();
            if (this.visibleBoundaries.get_Count() > 0){
                this.SortSAndInitActiveSides();
                this.Sweep();
            }
        },
        SortSAndInitActiveSides: function (){
            this.InitHeapAndInsertActiveSides();
            for (var stem = this.heapForSorting.GetMinimum(); ; stem = this.heapForSorting.GetMinimum()){
                this.sortedListOfPolypoints.Add(stem.get_Start());
                if (stem.MoveStartClockwise())
                    this.heapForSorting.ChangeMinimum(stem);
                else
                    this.heapForSorting.Dequeue();
                if (this.heapForSorting.get_Count() == 0)
                    break;
            }
        },
        InitHeapAndInsertActiveSides: function (){
            var $it1290 = this.GetInitialVisibleBoundaryStemsAndInsertActiveSides().GetEnumerator();
            while ($it1290.MoveNext()){
                var pp = $it1290.get_Current();
                this.heapForSorting.Enqueue(pp);
            }
        },
        GetInitialVisibleBoundaryStemsAndInsertActiveSides: function (){
            var $yield = [];
            var $it1291 = this.visibleBoundaries.GetEnumerator();
            while ($it1291.MoveNext()){
                var keyValuePair = $it1291.get_Current();
                var hole = keyValuePair.get_Key();
                var stem = keyValuePair.get_Value();
                var crosses = false;
                var $it1292 = stem.get_Sides().GetEnumerator();
                while ($it1292.MoveNext()){
                    var side = $it1292.get_Current();
                    var source = side;
                    if (source.get_Point().get_Y() < this.q.get_Y()){
                        if (side.get_NextOnPolyline().get_Point().get_Y() >= this.q.get_Y()){
                            var orientation = Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(this.q, source.get_Point(), side.get_NextOnPolyline().get_Point());
                            if (orientation == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise || orientation == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Collinear){
                                crosses = true;
                                $yield.push(new Microsoft.Msagl.Routing.Visibility.Stem.ctor(stem.get_Start(), side));
                                $yield.push(new Microsoft.Msagl.Routing.Visibility.Stem.ctor(side.get_NextOnPolyline(), stem.get_End()));
                                this.RegisterActiveSide(side);
                                break;
                            }
                        }
                    }
                    else if (source.get_Point().get_Y() > this.q.get_Y())
                        break;
                    else if (side.get_Point().get_X() >= this.q.get_X()){
                        crosses = true;
                        $yield.push(new Microsoft.Msagl.Routing.Visibility.Stem.ctor(side, stem.get_End()));
                        if (side != stem.get_Start())
                            $yield.push(new Microsoft.Msagl.Routing.Visibility.Stem.ctor(stem.get_Start(), hole.Prev(source)));
                        this.RegisterActiveSide(side);
                        break;
                    }
                }
                if (!crosses)
                    $yield.push(stem);
            }
            return $yield;
        },
        RegisterActiveSide: function (side){
            this.activeEdgeComparer.set_IntersectionOfTheRayAndInsertedEdge(this.activeEdgeComparer.IntersectEdgeWithRay$$PolylinePoint$$Point(side, new Microsoft.Msagl.Core.Geometry.Point.ctor$$Double$$Double(1, 0)));
            this.sideNodes.set_Item$$TKey(side, this.activeSidesTree.Insert(side));
        },
        Sweep: function (){
            var $it1293 = this.sortedListOfPolypoints.GetEnumerator();
            while ($it1293.MoveNext()){
                var polylinePoint = $it1293.get_Current();
                this.SweepPolylinePoint(polylinePoint);
            }
        },
        SweepPolylinePoint: function (v){
            var inSide = Microsoft.Msagl.Routing.Visibility.PointVisibilityCalculator.GetIncomingSide(v);
            var outSide = this.GetOutgoingSide(v);
            this.activeEdgeComparer.set_IntersectionOfTheRayAndInsertedEdge(v.get_Point());
            var node;
            if ((function (){
                var $1 = {
                    Value: node
                };
                var $res = this.sideNodes.TryGetValue(inSide, $1);
                node = $1.Value;
                return $res;
            }).call(this) && node != null){
                if (node == this.activeSidesTree.TreeMinimum())
                    this.AddEdge(v);
                if (outSide != null){
                    node.Item = outSide;
                    this.sideNodes.set_Item$$TKey(outSide, node);
                }
                else {
                    var changedNode = this.activeSidesTree.DeleteSubtree(node);
                    if (changedNode != null)if (changedNode.Item != null)
                        this.sideNodes.set_Item$$TKey(changedNode.Item, changedNode);
                }
                this.sideNodes.Remove(inSide);
            }
            else if (outSide != null){
                var outsideNode;
                if (!(function (){
                    var $1 = {
                        Value: outsideNode
                    };
                    var $res = this.sideNodes.TryGetValue(outSide, $1);
                    outsideNode = $1.Value;
                    return $res;
                }).call(this) || outsideNode == null){
                    outsideNode = this.activeSidesTree.Insert(outSide);
                    this.sideNodes.set_Item$$TKey(outSide, outsideNode);
                    if (outsideNode == this.activeSidesTree.TreeMinimum())
                        this.AddEdge(v);
                }
            }
            else
                throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
        },
        AddEdge: function (v){
            if (this.visibilityKind == Microsoft.Msagl.Routing.Visibility.VisibilityKind.Regular || (this.visibilityKind == Microsoft.Msagl.Routing.Visibility.VisibilityKind.Tangent && Microsoft.Msagl.Routing.Visibility.PointVisibilityCalculator.LineTouchesPolygon(this.get_QVertex().Point, v))){
                this.visibilityGraph.AddEdge$$Point$$Point$$Func$3$VisibilityVertex$VisibilityVertex$VisibilityEdge(this.get_QVertex().Point, v.get_Point(), ($CreateAnonymousDelegate(this, function (a, b){
                    return new Microsoft.Msagl.Routing.Visibility.TollFreeVisibilityEdge.ctor$$VisibilityVertex$$VisibilityVertex(a, b);
                })));
            }
        },
        GetOutgoingSide: function (v){
            var visibleStem = this.visibleBoundaries.get_Item$$TKey(v.get_Polyline());
            if (v == visibleStem.get_End())
                return null;
            return v;
        },
        ComputeHoleBoundariesPossiblyVisibleFromQ: function (){
            this.InitActiveEdgesAndActiveEdgesComparer();
            var $it1294 = this.holes.GetEnumerator();
            while ($it1294.MoveNext()){
                var hole = $it1294.get_Current();
                this.ComputeVisiblePartOfTheHole(hole);
            }
        },
        InitActiveEdgesAndActiveEdgesComparer: function (){
            this.activeEdgeComparer = (function (){
                var $v137 = new Microsoft.Msagl.Routing.Visibility.ActiveEdgeComparerWithRay.ctor();
                $v137.set_Pivot(this.q);
                return $v137;
            }).call(this);
            this.activeSidesTree = new Microsoft.Msagl.Core.DataStructures.RbTree$1.ctor$$IComparer$1(Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ctor, this.activeEdgeComparer);
        },
        ComputeVisiblePartOfTheHole: function (hole){
            var a;
            var needToGoCounterclockWise = true;
            for (a = hole.get_StartPoint(); !this.HoleSideIsVisibleFromQ(hole, a); a = hole.Next(a)){
                System.Diagnostics.Debug.Assert$$Boolean(needToGoCounterclockWise || a != hole.get_StartPoint());
                needToGoCounterclockWise = false;
            }
            var b = hole.Next(a);
            if (needToGoCounterclockWise)
                while (this.HoleSideIsVisibleFromQ(hole, hole.Prev(a)))
                    a = hole.Prev(a);
            for (; this.HoleSideIsVisibleFromQ(hole, b); b = hole.Next(b)){
            }
            this.visibleBoundaries.set_Item$$TKey(hole, new Microsoft.Msagl.Routing.Visibility.Stem.ctor(a, b));
        },
        HoleSideIsVisibleFromQ: function (hole, b){
            return Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(this.q, b.get_Point(), hole.Next(b).get_Point()) >= -Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_SquareOfDistanceEpsilon();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Visibility$PointVisibilityCalculator);
var Microsoft$Msagl$Routing$Visibility$Polygon = {
    fullname: "Microsoft.Msagl.Routing.Visibility.Polygon",
    baseTypeName: "System.Object",
    staticDefinition: {
        Distance$$Polygon$$Polygon$$Point$$Point: function (a, b, p, q){
            var tp = new Microsoft.Msagl.Routing.Visibility.TangentPair.ctor(a, b);
            tp.FindClosestPoints$$Point$$Point(p, q);
            return (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(p.Value, q.Value)).get_Length();
        },
        Distance$$Polygon$$Polygon: function (a, b){
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Routing.Visibility.Polygon.PolygonIsLegalDebug(a));
            System.Diagnostics.Debug.Assert$$Boolean(Microsoft.Msagl.Routing.Visibility.Polygon.PolygonIsLegalDebug(b));
            var p,q;
            return (function (){
                var $1 = {
                    Value: p
                };
                var $2 = {
                    Value: q
                };
                var $res = Microsoft.Msagl.Routing.Visibility.Polygon.Distance$$Polygon$$Polygon$$Point$$Point(a, b, $1, $2);
                p = $1.Value;
                q = $2.Value;
                return $res;
            })();
        },
        PolygonIsLegalDebug: function (a){
            var poly = a.get_Polyline();
            for (var p = poly.get_StartPoint(); p.get_Next() != null && p.get_Next().get_Next() != null; p = p.get_Next())
                if (Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(p.get_Point(), p.get_Next().get_Point(), p.get_Next().get_Next().get_Point()) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Collinear)
                    return false;
            return true;
        },
        Distance$$Polygon$$Point: function (poly, b){
            var res = Infinity;
            for (var i = 0; i < poly.get_Count(); i++){
                var par;
                var dist = (function (){
                    var $1 = {
                        Value: par
                    };
                    var $res = Microsoft.Msagl.Core.Geometry.Point.DistToLineSegment(b, poly.points[i].get_Point(), poly.points[(i + 1) % poly.get_Count()].get_Point(), $1);
                    par = $1.Value;
                    return $res;
                })();
                res = System.Math.Min$$Double$$Double(res, dist);
            }
            return res;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (polyline){
            this.polyline = null;
            this.points = null;
            System.Object.ctor.call(this);
            this.polyline = polyline;
            this.points = new Array(polyline.get_Count());
            var i = 0;
            var pp = polyline.get_StartPoint();
            for (; i < polyline.get_Count(); i++, pp = pp.get_Next())
                this.points[i] = pp;
        },
        Polyline$$: "Microsoft.Msagl.Core.Geometry.Curves.Polyline",
        get_Polyline: function (){
            return this.polyline;
        },
        Next: function (i){
            return this.Module(i + 1);
        },
        Prev: function (i){
            return this.Module(i - 1);
        },
        Count$$: "System.Int32",
        get_Count: function (){
            return this.get_Polyline().get_Count();
        },
        Module: function (i){
            if (i < 0)
                return i + this.get_Count();
            if (i < this.get_Count())
                return i;
            return i - this.get_Count();
        },
        Item$$: "Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint",
        get_Item$$Int32: function (i){
            return this.points[this.Module(i)];
        },
        Pnt: function (i){
            return this.get_Item$$Int32(i).get_Point();
        },
        toString: function (){
            return this.polyline.toString();
        },
        Median: function (p1, p2){
            System.Diagnostics.Debug.Assert$$Boolean(p1 != p2);
            if (p2 > p1)
                return ((p2 + p1) / 2) | 0;
            return this.Module(((p2 + this.get_Count() + p1) / 2) | 0);
        },
        FindTheFurthestVertexFromBisector: function (p1, p2, bisectorPivot, bisectorRay){
            var directionToTheHill = bisectorRay.Rotate(1.5707963267949);
            if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.polyline.get_StartPoint().get_Point(), bisectorPivot)), directionToTheHill) < 0)
                directionToTheHill = Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(directionToTheHill);
            if (p1 == p2)
                p2 = this.Next(p1);
            do{
                var m = this.Median(p2, p1);
                var mp = this.Pnt(m);
                if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.Pnt(this.Next(m)), mp)), directionToTheHill) >= 0)
                    p2 = this.Next(m);
                else if (Microsoft.Msagl.Core.Geometry.Point.op_Multiply$$Point$$Point((Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.Pnt(this.Prev(m)), mp)), directionToTheHill) >= 0)
                    p1 = this.Prev(m);
                else
                    p1 = p2 = m;
            }
            while (p1 != p2)
            return p1;
        },
        GetTangentPoints: function (leftTangentPoint, rightTangentPoint, point){
            var bimodalSequence = new Microsoft.Msagl.Routing.Visibility.BimodalSequence.ctor(this.GetSequenceDelegate(point), this.get_Count());
            leftTangentPoint.Value = bimodalSequence.FindMaximum();
            rightTangentPoint.Value = bimodalSequence.FindMinimum();
        },
        GetSequenceDelegate: function (point){
            var pointOfP = this.Pnt(0);
            return $CreateAnonymousDelegate(this, function (i){
                var d = Microsoft.Msagl.Core.Geometry.Point.Angle$$Point$$Point$$Point(pointOfP, point, this.Pnt(i));
                return d < 3.14159265358979 ? d : d - 6.28318530717959;
            });
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Visibility$Polygon);
var Microsoft$Msagl$Routing$Visibility$SegmentBase = {
    fullname: "Microsoft.Msagl.Routing.Visibility.SegmentBase",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        },
        Start$$: "Microsoft.Msagl.Core.Geometry.Point",
        End$$: "Microsoft.Msagl.Core.Geometry.Point",
        Direction$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_Direction: function (){
            return Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.get_End(), this.get_Start());
        },
        toString: function (){
            return this.get_Start() + " " + this.get_End();
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Visibility$SegmentBase);
var Microsoft$Msagl$Routing$Visibility$StemStartPointComparer = {
    fullname: "Microsoft.Msagl.Routing.Visibility.StemStartPointComparer",
    baseTypeName: "System.Object",
    staticDefinition: {
        CompareVectorsByAngleToXAxis: function (a, b){
            if (a.get_Y() >= 0){
                if (b.get_Y() < 0)
                    return -1;
                return (function (){
                    var $1 = {
                        Value: a
                    };
                    var $2 = {
                        Value: b
                    };
                    var $res = Microsoft.Msagl.Routing.Visibility.StemStartPointComparer.CompareVectorsPointingToTheSameYHalfPlane($1, $2);
                    a = $1.Value;
                    b = $2.Value;
                    return $res;
                })();
            }
            else {
                if (b.get_Y() >= 0)
                    return 1;
                return (function (){
                    var $1 = {
                        Value: a
                    };
                    var $2 = {
                        Value: b
                    };
                    var $res = Microsoft.Msagl.Routing.Visibility.StemStartPointComparer.CompareVectorsPointingToTheSameYHalfPlane($1, $2);
                    a = $1.Value;
                    b = $2.Value;
                    return $res;
                })();
            }
            throw $CreateException(new System.InvalidOperationException.ctor(), new Error());
        },
        CompareVectorsPointingToTheSameYHalfPlane: function (a, b){
            var sign = a.Value.get_X() * b.Value.get_Y() - a.Value.get_Y() * b.Value.get_X();
            if (sign > Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                return -1;
            if (sign < -Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance())
                return 1;
            if (a.Value.get_X() >= 0){
                if (b.Value.get_X() < 0)
                    return -1;
            }
            else if (b.Value.get_X() >= 0)
                return 1;
            var del = System.Math.Abs$$Double(a.Value.get_X()) - System.Math.Abs$$Double(b.Value.get_X());
            if (del < 0)
                return -1;
            if (del > 0)
                return 1;
            del = System.Math.Abs$$Double(a.Value.get_Y()) - System.Math.Abs$$Double(b.Value.get_Y());
            if (del < 0)
                return -1;
            if (del > 0)
                return 1;
            return 0;
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IComparer$1"],
    Kind: "Class",
    definition: {
        ctor: function (pivotPoint){
            this.pivot = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            System.Object.ctor.call(this);
            this.pivot = pivotPoint;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Visibility$StemStartPointComparer);
var Microsoft$Msagl$Routing$Visibility$UnimodalSequence = {
    fullname: "Microsoft.Msagl.Routing.Visibility.UnimodalSequence",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (sequenceDelegate, length){
            this.sequence = null;
            this.length = 0;
            System.Object.ctor.call(this);
            this.set_Sequence(sequenceDelegate);
            this.set_Length(length);
        },
        Sequence$$: "System.Func`2[[System.Int32],[System.Double]]",
        get_Sequence: function (){
            return this.sequence;
        },
        set_Sequence: function (value){
            this.sequence = value;
        },
        Length$$: "System.Int32",
        get_Length: function (){
            return this.length;
        },
        set_Length: function (value){
            this.length = value;
        },
        FindMinimum: function (){
            var a = 0;
            var b = this.get_Length() - 1;
            var m = a + ((b - a) / 2) | 0;
            var valAtM = this.get_Sequence()(m);
            if (valAtM >= this.get_Sequence()(0) && valAtM >= this.get_Sequence()(this.get_Length() - 1))
                return this.get_Sequence()(0) < this.get_Sequence()(this.get_Length() - 1) ? 0 : this.get_Length() - 1;
            while (b - a > 1){
                m = a + ((b - a) / 2) | 0;
                switch (this.BehaviourAtIndex(m)){
                    case Microsoft.Msagl.Routing.Visibility.UnimodalSequence.Behavior.Decreasing:
                        a = m;
                        break;
                    case Microsoft.Msagl.Routing.Visibility.UnimodalSequence.Behavior.Increasing:
                        b = m;
                        break;
                    case Microsoft.Msagl.Routing.Visibility.UnimodalSequence.Behavior.Extremum:
                        return m;
                }
            }
            if (a == b)
                return a;
            return this.get_Sequence()(a) <= this.get_Sequence()(b) ? a : b;
        },
        BehaviourAtIndex: function (m){
            var seqAtM = this.get_Sequence()(m);
            if (m == 0){
                var seqAt1 = this.get_Sequence()(1);
                if (seqAt1 == seqAtM)
                    return Microsoft.Msagl.Routing.Visibility.UnimodalSequence.Behavior.Extremum;
                return seqAt1 > seqAtM ? Microsoft.Msagl.Routing.Visibility.UnimodalSequence.Behavior.Increasing : Microsoft.Msagl.Routing.Visibility.UnimodalSequence.Behavior.Decreasing;
            }
            if (m == this.get_Length() - 1){
                var seqAt1 = this.get_Sequence()(this.get_Length() - 2);
                if (seqAt1 == seqAtM)
                    return Microsoft.Msagl.Routing.Visibility.UnimodalSequence.Behavior.Extremum;
                return seqAt1 > seqAtM ? Microsoft.Msagl.Routing.Visibility.UnimodalSequence.Behavior.Decreasing : Microsoft.Msagl.Routing.Visibility.UnimodalSequence.Behavior.Increasing;
            }
            var delLeft = seqAtM - this.get_Sequence()(m - 1);
            var delRight = this.get_Sequence()(m + 1) - seqAtM;
            if (delLeft * delRight <= 0)
                return Microsoft.Msagl.Routing.Visibility.UnimodalSequence.Behavior.Extremum;
            return delLeft > 0 ? Microsoft.Msagl.Routing.Visibility.UnimodalSequence.Behavior.Increasing : Microsoft.Msagl.Routing.Visibility.UnimodalSequence.Behavior.Decreasing;
        },
        FindMaximum: function (){
            var a = 0;
            var b = this.get_Length() - 1;
            var m = a + ((b - a) / 2) | 0;
            var valAtM = this.get_Sequence()(m);
            if (valAtM <= this.get_Sequence()(0) && valAtM <= this.get_Sequence()(this.get_Length() - 1))
                return this.get_Sequence()(0) > this.get_Sequence()(this.get_Length() - 1) ? 0 : this.get_Length() - 1;
            while (b - a > 1){
                m = a + ((b - a) / 2) | 0;
                switch (this.BehaviourAtIndex(m)){
                    case Microsoft.Msagl.Routing.Visibility.UnimodalSequence.Behavior.Decreasing:
                        b = m;
                        break;
                    case Microsoft.Msagl.Routing.Visibility.UnimodalSequence.Behavior.Increasing:
                        a = m;
                        break;
                    case Microsoft.Msagl.Routing.Visibility.UnimodalSequence.Behavior.Extremum:
                        return m;
                }
            }
            if (a == b)
                return a;
            return this.get_Sequence()(a) >= this.get_Sequence()(b) ? a : b;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Visibility$UnimodalSequence);
var Microsoft$Msagl$Routing$Visibility$UnimodalSequence$Behavior = {
    fullname: "Microsoft.Msagl.Routing.Visibility.UnimodalSequence.Behavior",
    staticDefinition: {
        Increasing: 0,
        Decreasing: 1,
        Extremum: 2
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Routing$Visibility$UnimodalSequence$Behavior);
var Microsoft$Msagl$Routing$Visibility$VisibilityKind = {
    fullname: "Microsoft.Msagl.Routing.Visibility.VisibilityKind",
    staticDefinition: {
        Regular: 0,
        Tangent: 1
    },
    Kind: "Enum"
};
JsTypes.push(Microsoft$Msagl$Routing$Visibility$VisibilityKind);
var Microsoft$Msagl$Routing$Visibility$VisibilityEdge = {
    fullname: "Microsoft.Msagl.Routing.Visibility.VisibilityEdge",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Routing.Visibility.VisibilityEdge.DefaultWeight = 1;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this.LengthMultiplier = 1;
            this._Weight = 0;
            this._IsPassable = null;
            this._Source = null;
            this._Target = null;
            System.Object.ctor.call(this);
        },
        ctor$$VisibilityVertex$$VisibilityVertex$$Double: function (source, target, weight){
            this.LengthMultiplier = 1;
            this._Weight = 0;
            this._IsPassable = null;
            this._Source = null;
            this._Target = null;
            System.Object.ctor.call(this);
            System.Diagnostics.Debug.Assert$$Boolean$$String(Microsoft.Msagl.Core.Geometry.Point.op_Inequality(source.Point, target.Point), "Self-edges are not allowed");
            this.set_Source(source);
            this.set_Target(target);
            this.set_Weight(weight);
        },
        ctor$$VisibilityVertex$$VisibilityVertex: function (source, target){
            this.LengthMultiplier = 1;
            this._Weight = 0;
            this._IsPassable = null;
            this._Source = null;
            this._Target = null;
            Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor$$VisibilityVertex$$VisibilityVertex$$Double.call(this, source, target, 1);
        },
        Weight$$: "System.Double",
        get_Weight: function (){
            return this._Weight;
        },
        set_Weight: function (value){
            this._Weight = value;
        },
        IsPassable$$: "System.Func`1[[System.Boolean]]",
        get_IsPassable: function (){
            return this._IsPassable;
        },
        set_IsPassable: function (value){
            this._IsPassable = value;
        },
        SourcePoint$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_SourcePoint: function (){
            return this.get_Source().Point;
        },
        TargetPoint$$: "Microsoft.Msagl.Core.Geometry.Point",
        get_TargetPoint: function (){
            return this.get_Target().Point;
        },
        Source$$: "Microsoft.Msagl.Routing.Visibility.VisibilityVertex",
        get_Source: function (){
            return this._Source;
        },
        set_Source: function (value){
            this._Source = value;
        },
        Target$$: "Microsoft.Msagl.Routing.Visibility.VisibilityVertex",
        get_Target: function (){
            return this._Target;
        },
        set_Target: function (value){
            this._Target = value;
        },
        Length$$: "System.Double",
        get_Length: function (){
            return (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(this.get_SourcePoint(), this.get_TargetPoint())).get_Length() * this.LengthMultiplier;
        },
        toString: function (){
            return System.String.Format$$IFormatProvider$$String$$Object$Array(System.Globalization.CultureInfo.get_InvariantCulture(), "{0}->{1} ({2})", [this.get_Source(), this.get_Target(), this.get_Weight().ToString$$String$$IFormatProvider("0.0###", System.Globalization.CultureInfo.get_InvariantCulture())]);
        },
        ReversedClone: function (){
            return new Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor$$VisibilityVertex$$VisibilityVertex(this.get_Target(), this.get_Source());
        },
        Clone: function (){
            return new Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor$$VisibilityVertex$$VisibilityVertex(this.get_Source(), this.get_Target());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Visibility$VisibilityEdge);
var Microsoft$Msagl$Routing$Visibility$VisibilityGraph = {
    fullname: "Microsoft.Msagl.Routing.Visibility.VisibilityGraph",
    baseTypeName: "System.Object",
    staticDefinition: {
        GetVisibilityGraphForShortestPath: function (pathStart, pathEnd, obstacles, sourceVertex, targetVertex){
            var holes = new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, Microsoft.Msagl.Routing.Visibility.VisibilityGraph.OrientHolesClockwise(obstacles));
            var visibilityGraph = Microsoft.Msagl.Routing.Visibility.VisibilityGraph.CalculateGraphOfBoundaries(holes);
            var polygons = System.Linq.Enumerable.ToList$1(Microsoft.Msagl.Routing.Visibility.Polygon.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, Microsoft.Msagl.Routing.Visibility.Polygon.ctor, holes, function (hole){
                return new Microsoft.Msagl.Routing.Visibility.Polygon.ctor(hole);
            }));
            Microsoft.Msagl.Routing.Visibility.TangentVisibilityGraphCalculator.AddTangentVisibilityEdgesToGraph(polygons, visibilityGraph);
            Microsoft.Msagl.Routing.Visibility.PointVisibilityCalculator.CalculatePointVisibilityGraph(holes, visibilityGraph, pathStart, Microsoft.Msagl.Routing.Visibility.VisibilityKind.Tangent, sourceVertex);
            Microsoft.Msagl.Routing.Visibility.PointVisibilityCalculator.CalculatePointVisibilityGraph(holes, visibilityGraph, pathEnd, Microsoft.Msagl.Routing.Visibility.VisibilityKind.Tangent, targetVertex);
            return visibilityGraph;
        },
        FillVisibilityGraphForShortestPath: function (obstacles){
            var holes = new System.Collections.Generic.List$1.ctor$$IEnumerable$1(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, Microsoft.Msagl.Routing.Visibility.VisibilityGraph.OrientHolesClockwise(obstacles));
            var visibilityGraph = Microsoft.Msagl.Routing.Visibility.VisibilityGraph.CalculateGraphOfBoundaries(holes);
            var polygons = System.Linq.Enumerable.ToList$1(Microsoft.Msagl.Routing.Visibility.Polygon.ctor, System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor, Microsoft.Msagl.Routing.Visibility.Polygon.ctor, holes, function (hole){
                return new Microsoft.Msagl.Routing.Visibility.Polygon.ctor(hole);
            }));
            Microsoft.Msagl.Routing.Visibility.TangentVisibilityGraphCalculator.AddTangentVisibilityEdgesToGraph(polygons, visibilityGraph);
            return visibilityGraph;
        },
        CalculateGraphOfBoundaries: function (holes){
            var graphOfHoleBoundaries = new Microsoft.Msagl.Routing.Visibility.VisibilityGraph.ctor();
            var $it1295 = holes.GetEnumerator();
            while ($it1295.MoveNext()){
                var polyline = $it1295.get_Current();
                graphOfHoleBoundaries.AddHole(polyline);
            }
            return graphOfHoleBoundaries;
        },
        OrientHolesClockwise: function (holes){
            var $yield = [];
            var $it1296 = holes.GetEnumerator();
            while ($it1296.MoveNext()){
                var poly = $it1296.get_Current();
                for (var p = poly.get_StartPoint(); ; p = p.get_Next()){
                    var orientation = Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(p.get_Point(), p.get_Next().get_Point(), p.get_Next().get_Next().get_Point());
                    if (orientation != Microsoft.Msagl.Core.Geometry.TriangleOrientation.Collinear){
                        $yield.push(orientation == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise ? poly : Cast(poly.Reverse(), Microsoft.Msagl.Core.Geometry.Curves.Polyline.ctor));
                        break;
                    }
                }
            }
            return $yield;
        },
        AddEdge$$VisibilityVertex$$VisibilityVertex: function (source, target){
            var visEdge;
            if ((function (){
                var $1 = {
                    Value: visEdge
                };
                var $res = source.TryGetEdge(target, $1);
                visEdge = $1.Value;
                return $res;
            })())
                return visEdge;
            System.Diagnostics.Debug.Assert$$Boolean$$String(source != target, "Self-edges are not allowed");
            var edge = new Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor$$VisibilityVertex$$VisibilityVertex(source, target);
            source.get_OutEdges().Insert(edge);
            target.get_InEdges().Add(edge);
            return edge;
        },
        AddEdge$$VisibilityEdge: function (edge){
            System.Diagnostics.Debug.Assert$$Boolean(edge.get_Source() != edge.get_Target());
            edge.get_Source().get_OutEdges().Insert(edge);
            edge.get_Target().get_InEdges().Add(edge);
        },
        FindEdge$$VisibilityEdge: function (edge){
            if ((function (){
                var $1 = {
                    Value: edge
                };
                var $res = edge.get_Source().TryGetEdge(edge.get_Target(), $1);
                edge = $1.Value;
                return $res;
            })())
                return edge;
            return null;
        },
        RemoveEdge$$VisibilityEdge: function (edge){
            edge.get_Source().get_OutEdges().Remove(edge);
            edge.get_Target().get_InEdges().Remove(edge);
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            this._prevEdgesDictionary = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor, Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor);
            this.vertexFactory = ($CreateAnonymousDelegate(this, function (point){
                return new Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor(point);
            }));
            this.pointToVertexMap = new System.Collections.Generic.Dictionary$2.ctor(Microsoft.Msagl.Core.Geometry.Point.ctor, Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor);
            System.Object.ctor.call(this);
        },
        ClearPrevEdgesTable: function (){
            this._prevEdgesDictionary.Clear();
        },
        ShrinkLengthOfPrevEdge: function (v){
            var prev = this._prevEdgesDictionary.get_Item$$TKey(v);
            if (prev.LengthMultiplier == 1)
                prev.LengthMultiplier = 0.5;
        },
        PreviosVertex: function (v){
            var prev;
            if (!(function (){
                var $1 = {
                    Value: prev
                };
                var $res = this._prevEdgesDictionary.TryGetValue(v, $1);
                prev = $1.Value;
                return $res;
            }).call(this))
                return null;
            if (prev.get_Source() == v)
                return prev.get_Target();
            return prev.get_Source();
        },
        SetPreviousEdge: function (v, e){
            System.Diagnostics.Debug.Assert$$Boolean(v == e.get_Source() || v == e.get_Target());
            this._prevEdgesDictionary.set_Item$$TKey(v, e);
        },
        VertexFactory$$: "System.Func`2[[Microsoft.Msagl.Core.Geometry.Point],[Microsoft.Msagl.Routing.Visibility.VisibilityVertex]]",
        get_VertexFactory: function (){
            return this.vertexFactory;
        },
        set_VertexFactory: function (value){
            this.vertexFactory = value;
        },
        AddHole: function (polyline){
            var p = polyline.get_StartPoint();
            while (p != polyline.get_EndPoint()){
                this.AddEdge$$PolylinePoint$$PolylinePoint(p, p.get_Next());
                p = p.get_Next();
            }
            this.AddEdge$$PolylinePoint$$PolylinePoint(polyline.get_EndPoint(), polyline.get_StartPoint());
        },
        Edges$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Routing.Visibility.VisibilityEdge]]",
        get_Edges: function (){
            return System.Linq.Enumerable.SelectMany$2$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor, Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor, this.get_PointToVertexMap().get_Values(), $CreateAnonymousDelegate(this, function (vertex){
                return vertex.get_OutEdges();
            }));
        },
        PointToVertexMap$$: "System.Collections.Generic.Dictionary`2[[Microsoft.Msagl.Core.Geometry.Point],[Microsoft.Msagl.Routing.Visibility.VisibilityVertex]]",
        get_PointToVertexMap: function (){
            return this.pointToVertexMap;
        },
        VertexCount$$: "System.Int32",
        get_VertexCount: function (){
            return this.get_PointToVertexMap().get_Count();
        },
        AddVertex$$PolylinePoint: function (polylinePoint){
            return this.AddVertex$$Point(polylinePoint.get_Point());
        },
        AddVertex$$Point: function (point){
            var currentVertex;
            if ((function (){
                var $1 = {
                    Value: currentVertex
                };
                var $res = this.get_PointToVertexMap().TryGetValue(point, $1);
                currentVertex = $1.Value;
                return $res;
            }).call(this))
                return currentVertex;
            var newVertex = this.get_VertexFactory()(point);
            this.get_PointToVertexMap().set_Item$$TKey(point, newVertex);
            return newVertex;
        },
        AddVertex$$VisibilityVertex: function (vertex){
            System.Diagnostics.Debug.Assert$$Boolean$$String(!this.get_PointToVertexMap().ContainsKey(vertex.Point), "A vertex already exists at this location");
            this.get_PointToVertexMap().set_Item$$TKey(vertex.Point, vertex);
        },
        ContainsVertex: function (point){
            return this.get_PointToVertexMap().ContainsKey(point);
        },
        AddEdge$$PolylinePoint$$PolylinePoint: function (source, target){
            this.AddEdge$$Point$$Point(source.get_Point(), target.get_Point());
        },
        AddEdge$$Point$$Point: function (source, target){
            var edge;
            var sourceV = this.FindVertex(source);
            var targetV = null;
            if (sourceV != null){
                targetV = this.FindVertex(target);
                if (targetV != null && (function (){
                    var $1 = {
                        Value: edge
                    };
                    var $res = sourceV.TryGetEdge(targetV, $1);
                    edge = $1.Value;
                    return $res;
                }).call(this))
                    return edge;
            }
            if (sourceV == null){
                sourceV = this.AddVertex$$Point(source);
                targetV = this.AddVertex$$Point(target);
            }
            else if (targetV == null)
                targetV = this.AddVertex$$Point(target);
            edge = new Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor$$VisibilityVertex$$VisibilityVertex(sourceV, targetV);
            sourceV.get_OutEdges().Insert(edge);
            targetV.get_InEdges().Add(edge);
            return edge;
        },
        AddEdge$$Point$$Point$$Func$3$VisibilityVertex$VisibilityVertex$VisibilityEdge: function (source, target, edgeCreator){
            var edge;
            var sourceV = this.FindVertex(source);
            var targetV = null;
            if (sourceV != null){
                targetV = this.FindVertex(target);
                if (targetV != null && (function (){
                    var $1 = {
                        Value: edge
                    };
                    var $res = sourceV.TryGetEdge(targetV, $1);
                    edge = $1.Value;
                    return $res;
                }).call(this))
                    return edge;
            }
            if (sourceV == null){
                sourceV = this.AddVertex$$Point(source);
                targetV = this.AddVertex$$Point(target);
            }
            else if (targetV == null)
                targetV = this.AddVertex$$Point(target);
            edge = edgeCreator(sourceV, targetV);
            sourceV.get_OutEdges().Insert(edge);
            targetV.get_InEdges().Add(edge);
            return edge;
        },
        FindVertex: function (point){
            var v;
            return (function (){
                var $1 = {
                    Value: v
                };
                var $res = this.get_PointToVertexMap().TryGetValue(point, $1);
                v = $1.Value;
                return $res;
            }).call(this) ? v : null;
        },
        GetVertex: function (polylinePoint){
            return this.FindVertex(polylinePoint.get_Point());
        },
        Vertices: function (){
            return this.get_PointToVertexMap().get_Values();
        },
        RemoveVertex: function (vertex){
            var $it1297 = vertex.get_OutEdges().GetEnumerator();
            while ($it1297.MoveNext()){
                var edge = $it1297.get_Current();
                edge.get_Target().RemoveInEdge(edge);
            }
            var $it1298 = vertex.get_InEdges().GetEnumerator();
            while ($it1298.MoveNext()){
                var edge = $it1298.get_Current();
                edge.get_Source().RemoveOutEdge(edge);
            }
            this.get_PointToVertexMap().Remove(vertex.Point);
        },
        RemoveEdge$$VisibilityVertex$$VisibilityVertex: function (v1, v2){
            this.RemoveEdge$$Point$$Point(v1.Point, v2.Point);
        },
        RemoveEdge$$Point$$Point: function (p1, p2){
            var edge = this.FindEdge$$Point$$Point(p1, p2);
            if (edge != null){
                edge.get_Source().RemoveOutEdge(edge);
                edge.get_Target().RemoveInEdge(edge);
            }
        },
        FindEdge$$Point$$Point: function (source, target){
            var sourceV = this.FindVertex(source);
            if (sourceV == null)
                return null;
            var targetV = this.FindVertex(target);
            if (targetV == null)
                return null;
            var edge;
            if ((function (){
                var $1 = {
                    Value: edge
                };
                var $res = sourceV.TryGetEdge(targetV, $1);
                edge = $1.Value;
                return $res;
            }).call(this))
                return edge;
            return null;
        },
        EdgeCount$$: "System.Int32",
        get_EdgeCount: function (){
            return System.Linq.Enumerable.Sum$1$$IEnumerable$1$$Func$2(Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ctor, this.Vertices(), $CreateAnonymousDelegate(this, function (v){
                return v.get_InEdges().get_Count();
            }));
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Visibility$VisibilityGraph);
var Microsoft$Msagl$Routing$Visibility$VisibilityVertex = {
    fullname: "Microsoft.Msagl.Routing.Visibility.VisibilityVertex",
    baseTypeName: "System.Object",
    staticDefinition: {
        FindFirst$$RbTree$1$VisibilityEdge$$Point: function (tree, targetPoint){
            return Microsoft.Msagl.Routing.Visibility.VisibilityVertex.FindFirst$$RBNode$1$VisibilityEdge$$RbTree$1$VisibilityEdge$$Point(tree.get_Root(), tree, targetPoint);
        },
        FindFirst$$RBNode$1$VisibilityEdge$$RbTree$1$VisibilityEdge$$Point: function (n, tree, targetPoint){
            if (n == tree.get_Nil())
                return null;
            var good = null;
            while (n != tree.get_Nil())
                n = Microsoft.Msagl.Core.Geometry.Point.op_GreaterThanOrEqual(n.Item.get_TargetPoint(), targetPoint) ? (good = n).left : n.right;
            return good;
        }
    },
    assemblyName: "Microsoft.Msagl",
    interfaceNames: ["System.Collections.Generic.IComparer$1"],
    Kind: "Class",
    definition: {
        ctor: function (point){
            this.Point = new Microsoft.Msagl.Core.Geometry.Point.ctor();
            this.inEdges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor);
            this.outEdges = null;
            this._Distance = 0;
            System.Object.ctor.call(this);
            this.outEdges = new Microsoft.Msagl.Core.DataStructures.RbTree$1.ctor$$IComparer$1(Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ctor, this);
            this.Point = point;
        },
        InEdges$$: "System.Collections.Generic.List`1[[Microsoft.Msagl.Routing.Visibility.VisibilityEdge]]",
        get_InEdges: function (){
            return this.inEdges;
        },
        OutEdges$$: "Microsoft.Msagl.Core.DataStructures.RbTree`1[[Microsoft.Msagl.Routing.Visibility.VisibilityEdge]]",
        get_OutEdges: function (){
            return this.outEdges;
        },
        Degree$$: "System.Int32",
        get_Degree: function (){
            return this.get_InEdges().get_Count() + this.get_OutEdges().get_Count();
        },
        Distance$$: "System.Double",
        get_Distance: function (){
            return this._Distance;
        },
        set_Distance: function (value){
            this._Distance = value;
        },
        toString: function (){
            return this.Point.toString();
        },
        RemoveOutEdge: function (edge){
            this.get_OutEdges().Remove(edge);
        },
        RemoveInEdge: function (edge){
            for (var ii = this.get_InEdges().get_Count() - 1; ii >= 0; --ii){
                if (this.get_InEdges().get_Item$$Int32(ii) == edge){
                    this.get_InEdges().RemoveAt(ii);
                    break;
                }
            }
        },
        TryGetEdge: function (target, visEdge){
            var node = Microsoft.Msagl.Routing.Visibility.VisibilityVertex.FindFirst$$RbTree$1$VisibilityEdge$$Point(this.get_OutEdges(), target.Point);
            if (node != null){
                if (node.Item.get_Target() == target){
                    visEdge.Value = node.Item;
                    return true;
                }
            }
            node = Microsoft.Msagl.Routing.Visibility.VisibilityVertex.FindFirst$$RbTree$1$VisibilityEdge$$Point(target.get_OutEdges(), this.Point);
            if (node != null){
                if (node.Item.get_Target() == this){
                    visEdge.Value = node.Item;
                    return true;
                }
            }
            visEdge.Value = null;
            return false;
        },
        Compare: function (a, b){
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(a, "a");
            Microsoft.Msagl.Core.ValidateArg.IsNotNull(b, "b");
            return a.get_TargetPoint().CompareTo(b.get_TargetPoint());
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Visibility$VisibilityVertex);
var Microsoft$Msagl$Routing$Visibility$Stem = {
    fullname: "Microsoft.Msagl.Routing.Visibility.Stem",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (start, end){
            this.start = null;
            this.end = null;
            System.Object.ctor.call(this);
            System.Diagnostics.Debug.Assert$$Boolean(start.get_Polyline() == end.get_Polyline());
            this.start = start;
            this.end = end;
        },
        Start$$: "Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint",
        get_Start: function (){
            return this.start;
        },
        set_Start: function (value){
            this.start = value;
        },
        End$$: "Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint",
        get_End: function (){
            return this.end;
        },
        set_End: function (value){
            this.end = value;
        },
        Sides$$: "System.Collections.Generic.IEnumerable`1[[Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint]]",
        get_Sides: function (){
            var $yield = [];
            var v = this.start;
            while (v != this.end){
                var side = v;
                $yield.push(side);
                v = side.get_NextOnPolyline();
            }
            return $yield;
        },
        MoveStartClockwise: function (){
            if (this.get_Start() != this.get_End()){
                this.set_Start(this.get_Start().get_NextOnPolyline());
                return true;
            }
            return false;
        },
        toString: function (){
            return System.String.Format$$IFormatProvider$$String$$Object$Array(System.Globalization.CultureInfo.get_InvariantCulture(), "Stem({0},{1})", [this.get_Start(), this.get_End()]);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Visibility$Stem);
var Microsoft$Msagl$Routing$Visibility$Tangent = {
    fullname: "Microsoft.Msagl.Routing.Visibility.Tangent",
    baseTypeName: "System.Object",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (start, end){
            this.comp = null;
            this.lowTangent = false;
            this.separatingPolygons = false;
            this.diagonal = null;
            this.start = null;
            this.end = null;
            System.Object.ctor.call(this);
            this.set_Start(start);
            this.set_End(end);
        },
        Comp$$: "Microsoft.Msagl.Routing.Visibility.Tangent",
        get_Comp: function (){
            return this.comp;
        },
        set_Comp: function (value){
            this.comp = value;
        },
        IsHigh$$: "System.Boolean",
        get_IsHigh: function (){
            return !this.get_IsLow();
        },
        IsLow$$: "System.Boolean",
        get_IsLow: function (){
            return this.lowTangent;
        },
        set_IsLow: function (value){
            this.lowTangent = value;
        },
        SeparatingPolygons$$: "System.Boolean",
        get_SeparatingPolygons: function (){
            return this.separatingPolygons;
        },
        set_SeparatingPolygons: function (value){
            this.separatingPolygons = value;
        },
        Diagonal$$: "Microsoft.Msagl.Routing.Visibility.Diagonal",
        get_Diagonal: function (){
            return this.diagonal;
        },
        set_Diagonal: function (value){
            this.diagonal = value;
        },
        Start$$: "Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint",
        get_Start: function (){
            return this.start;
        },
        set_Start: function (value){
            this.start = value;
        },
        End$$: "Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint",
        get_End: function (){
            return this.end;
        },
        set_End: function (value){
            this.end = value;
        },
        toString: function (){
            return System.String.Format$$IFormatProvider$$String$$Object$Array(System.Globalization.CultureInfo.get_InvariantCulture(), "{0},{1}", [this.get_Start(), this.get_End()]);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Visibility$Tangent);
var Microsoft$Msagl$Routing$Visibility$TangentPair = {
    fullname: "Microsoft.Msagl.Routing.Visibility.TangentPair",
    baseTypeName: "System.Object",
    staticDefinition: {
        Swap$$Double$$Double: function (a1, a2){
            var t = a1.Value;
            a1.Value = a2.Value;
            a2.Value = t;
        },
        Swap$$Int32$$Int32: function (a1, a2){
            var t = a1.Value;
            a1.Value = a2.Value;
            a2.Value = t;
        },
        OneOfChunksContainsOnlyOneVertex: function (p2, p1, q2, q1, mp, mq, a1, b1){
            if (p1.Value == p2.Value){
                if (b1 >= 1.5707963267949)
                    q1.Value = mq;
                else
                    q2.Value = mq;
                return true;
            }
            if (q1.Value == q2.Value){
                if (a1 >= 1.5707963267949)
                    p1.Value = mp;
                else
                    p2.Value = mp;
                return true;
            }
            return false;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (polygonP, polygonQ){
            this.P = null;
            this.Q = null;
            this.leftPLeftQ = null;
            this.leftPRightQ = null;
            this.lowerBranchOnQ = false;
            this.rightPLeftQ = null;
            this.rightPRightQ = null;
            this.upperBranchOnP = false;
            System.Object.ctor.call(this);
            this.set_PPolygon(polygonP);
            this.set_QPolygon(polygonQ);
        },
        PPolygon$$: "Microsoft.Msagl.Routing.Visibility.Polygon",
        set_PPolygon: function (value){
            this.P = value;
        },
        QPolygon$$: "Microsoft.Msagl.Routing.Visibility.Polygon",
        set_QPolygon: function (value){
            this.Q = value;
        },
        LeftFromLineOnP: function (vertexIndex, lineStart, lineEnd){
            var p = this.P.Pnt(vertexIndex);
            if (this.upperBranchOnP)
                return Microsoft.Msagl.Core.Geometry.Point.PointToTheLeftOfLineOrOnLine(lineEnd, p, lineStart);
            return Microsoft.Msagl.Core.Geometry.Point.PointToTheRightOfLineOrOnLine(lineEnd, p, lineStart);
        },
        LeftFromLineOnQ: function (vertexIndex, lineStart, lineEnd){
            var point = this.Q.Pnt(vertexIndex);
            if (this.lowerBranchOnQ)
                return Microsoft.Msagl.Core.Geometry.Point.PointToTheLeftOfLineOrOnLine(lineEnd, point, lineStart);
            return Microsoft.Msagl.Core.Geometry.Point.PointToTheRightOfLineOrOnLine(lineEnd, point, lineStart);
        },
        PrevOnP: function (i){
            if (this.upperBranchOnP)
                return this.P.Prev(i);
            return this.P.Next(i);
        },
        PrevOnQ: function (i){
            if (this.lowerBranchOnQ)
                return this.Q.Prev(i);
            return this.Q.Next(i);
        },
        NextOnP: function (i){
            if (this.upperBranchOnP)
                return this.P.Next(i);
            return this.P.Prev(i);
        },
        NextOnQ: function (i){
            if (this.lowerBranchOnQ)
                return this.Q.Next(i);
            return this.Q.Prev(i);
        },
        MedianOnP: function (i, j){
            if (this.upperBranchOnP)
                return this.P.Median(i, j);
            return this.P.Median(j, i);
        },
        MedianOnQ: function (i, j){
            if (this.lowerBranchOnQ)
                return this.Q.Median(i, j);
            return this.Q.Median(j, i);
        },
        ModuleP: function (p0, p1){
            if (this.upperBranchOnP)
                return this.P.Module(p1 - p0);
            return this.P.Module(p0 - p1);
        },
        ModuleQ: function (q0, q1){
            if (this.lowerBranchOnQ)
                return this.Q.Module(q1 - q0);
            return this.Q.Module(q0 - q1);
        },
        TangentBetweenBranches: function (p0, p1, q0, q1){
            while (p1 != p0 || q1 != q0){
                var mp = p1 != p0 ? this.MedianOnP(p0, p1) : p0;
                var mq = q1 != q0 ? this.MedianOnQ(q0, q1) : q0;
                var mpp = this.P.Pnt(mp);
                var mqp = this.Q.Pnt(mq);
                var moveOnP = true;
                if (this.ModuleP(p0, p1) > 1){
                    if (this.LeftFromLineOnP(this.NextOnP(mp), mpp, mqp))
                        p0 = mp;
                    else if (this.LeftFromLineOnP(this.PrevOnP(mp), mpp, mqp))
                        p1 = mp;
                    else
                        moveOnP = false;
                }
                else if (p1 != p0){
                    if (this.LeftFromLineOnP(p1, this.P.Pnt(p0), mqp))
                        p0 = p1;
                    else if (this.LeftFromLineOnP(p0, this.P.Pnt(p1), mqp))
                        p1 = p0;
                    else
                        moveOnP = false;
                }
                else
                    moveOnP = false;
                var moveOnQ = true;
                if (this.ModuleQ(q0, q1) > 1){
                    if (this.LeftFromLineOnQ(this.NextOnQ(mq), mqp, mpp))
                        q0 = mq;
                    else if (this.LeftFromLineOnQ(this.PrevOnQ(mq), mqp, mpp))
                        q1 = mq;
                    else
                        moveOnQ = false;
                }
                else if (q1 != q0){
                    if (this.LeftFromLineOnQ(q1, this.Q.Pnt(q0), mpp))
                        q0 = q1;
                    else if (this.LeftFromLineOnQ(q0, this.Q.Pnt(q1), mpp))
                        q1 = q0;
                    else
                        moveOnQ = false;
                }
                else
                    moveOnQ = false;
                if (!moveOnP && !moveOnQ){
                    p1 = p0 = mp;
                    q1 = q0 = mq;
                }
            }
            return new System.Tuple$2.ctor(System.Int32.ctor, System.Int32.ctor, p0, q1);
        },
        FindDividingBisector: function (bisectorPivot, bisectorRay, p1, p2, q1, q2){
            var pClosest;
            var qClosest;
            (function (){
                var $1 = {
                    Value: pClosest
                };
                var $2 = {
                    Value: qClosest
                };
                var $res = this.FindClosestFeatures(p1, p2, q1, q2, $1, $2);
                pClosest = $1.Value;
                qClosest = $2.Value;
                return $res;
            }).call(this);
            bisectorPivot.Value = Microsoft.Msagl.Core.Geometry.Point.op_Division$$Point$$Double((Microsoft.Msagl.Core.Geometry.Point.op_Addition(pClosest, qClosest)), 2);
            bisectorRay.Value = (Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(pClosest, qClosest)).Rotate(1.5707963267949);
        },
        FindClosestPoints$$Point$$Point: function (pClosest, qClosest){
            var p1,p2,q1,q2;
            (function (){
                var $1 = {
                    Value: p1
                };
                var $2 = {
                    Value: p2
                };
                var $3 = {
                    Value: q1
                };
                var $4 = {
                    Value: q2
                };
                var $res = this.FindClosestFeatures($1, $2, $3, $4, pClosest, qClosest);
                p1 = $1.Value;
                p2 = $2.Value;
                q1 = $3.Value;
                q2 = $4.Value;
                return $res;
            }).call(this);
        },
        FindClosestFeatures: function (p1, p2, q1, q2, pClosest, qClosest){
            this.P.GetTangentPoints(p2, p1, this.Q.get_Item$$Int32(0).get_Point());
            if (p2.Value == p1.Value)
                p2.Value += this.P.get_Count();
            this.Q.GetTangentPoints(q1, q2, this.P.get_Item$$Int32(0).get_Point());
            if (q2.Value == q1.Value)
                q1.Value += this.Q.get_Count();
            this.FindClosestPoints$$Int32$$Int32$$Int32$$Int32$$Point$$Point(p1, p2, q2, q1, pClosest, qClosest);
        },
        FindClosestPoints$$Int32$$Int32$$Int32$$Int32$$Point$$Point: function (p1, p2, q2, q1, pClosest, qClosest){
            while (this.ChunksAreLong(p2.Value, p1.Value, q2.Value, q1.Value))
                this.ShrinkChunks(p2, p1, q2, q1);
            if (p1.Value == p2.Value){
                pClosest.Value = this.P.get_Item$$Int32(p2.Value).get_Point();
                if (q1.Value == q2.Value)
                    qClosest.Value = this.Q.get_Item$$Int32(q1.Value).get_Point();
                else {
                    qClosest.Value = Microsoft.Msagl.Core.Geometry.Point.ClosestPointAtLineSegment(pClosest.Value, this.Q.get_Item$$Int32(q1.Value).get_Point(), this.Q.get_Item$$Int32(q2.Value).get_Point());
                    if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(qClosest.Value, this.Q.Pnt(q1.Value)))
                        q2.Value = q1.Value;
                    else if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(qClosest.Value, this.Q.Pnt(q2.Value)))
                        q1.Value = q2.Value;
                }
            }
            else {
                System.Diagnostics.Debug.Assert$$Boolean(q1.Value == q2.Value);
                qClosest.Value = this.Q.get_Item$$Int32(q1.Value).get_Point();
                pClosest.Value = Microsoft.Msagl.Core.Geometry.Point.ClosestPointAtLineSegment(qClosest.Value, this.P.get_Item$$Int32(p1.Value).get_Point(), this.P.get_Item$$Int32(p2.Value).get_Point());
                if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(pClosest.Value, this.P.Pnt(p1.Value)))
                    p2.Value = p1.Value;
                else if (Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close$$Point$$Point(qClosest.Value, this.P.Pnt(p2.Value)))
                    p1.Value = p2.Value;
            }
        },
        ChunksAreLong: function (p2, p1, q2, q1){
            var pLength = this.P.Module(p2 - p1) + 1;
            if (pLength > 2)
                return true;
            var qLength = this.Q.Module(q1 - q2) + 1;
            if (qLength > 2)
                return true;
            if (pLength == 2 && qLength == 2)
                return true;
            return false;
        },
        ShrinkChunks: function (p2, p1, q2, q1){
            var mp = p1.Value == p2.Value ? p1.Value : this.P.Median(p1.Value, p2.Value);
            var mq = q1.Value == q2.Value ? q1.Value : this.Q.Median(q2.Value, q1.Value);
            var mP = this.P.get_Item$$Int32(mp).get_Point();
            var mQ = this.Q.get_Item$$Int32(mq).get_Point();
            var a1;
            var a2;
            var b1;
            var b2;
            (function (){
                var $1 = {
                    Value: mP
                };
                var $2 = {
                    Value: mQ
                };
                var $3 = {
                    Value: a1
                };
                var $4 = {
                    Value: a2
                };
                var $5 = {
                    Value: b1
                };
                var $6 = {
                    Value: b2
                };
                var $res = this.GetAnglesAtTheMedian(mp, mq, $1, $2, $3, $4, $5, $6);
                mP = $1.Value;
                mQ = $2.Value;
                a1 = $3.Value;
                a2 = $4.Value;
                b1 = $5.Value;
                b2 = $6.Value;
                return $res;
            }).call(this);
            if (this.InternalCut(p1, p2, q1, q2, mp, mq, a1, a2, b1, b2)){
                return;
            }
            if (Microsoft.Msagl.Routing.Visibility.TangentPair.OneOfChunksContainsOnlyOneVertex(p2, p1, q2, q1, mp, mq, a1, b1))
                return;
            if (this.OnlyOneChunkContainsExactlyTwoVertices(p2, p1, q2, q1, mp, mq, a1, b1, a2, b2))
                return;
            if (p2.Value == this.P.Next(p1.Value) && q1.Value == this.Q.Next(q2.Value)){
                var psol,qsol;
                (function (){
                    var $1 = {
                        Value: psol
                    };
                    var $2 = {
                        Value: qsol
                    };
                    var $res = Microsoft.Msagl.Core.Geometry.Point.MinDistBetweenLineSegments(this.P.Pnt(p1.Value), this.P.Pnt(p2.Value), this.Q.Pnt(q1.Value), this.Q.Pnt(q2.Value), $1, $2);
                    psol = $1.Value;
                    qsol = $2.Value;
                    return $res;
                }).call(this);
                if (psol == 0)
                    p2.Value = p1.Value;
                else if (psol == 1)
                    p1.Value = p2.Value;
                else if (qsol == 0)
                    q2.Value = q1.Value;
                else if (qsol == 1)
                    q1.Value = q2.Value;
                System.Diagnostics.Debug.Assert$$Boolean(p1.Value == p2.Value || q1.Value == q2.Value);
                return;
            }
            if (a1 <= 3.14159265358979 && a2 <= 3.14159265358979 && b1 <= 3.14159265358979 && b2 <= 3.14159265358979){
                if (a1 + b1 > 3.14159265358979){
                    if (a1 >= 1.5707963267949)
                        p1.Value = mp;
                    else
                        q1.Value = mq;
                }
                else {
                    System.Diagnostics.Debug.Assert$$Boolean(a2 + b2 >= 3.14159265358979 - Microsoft.Msagl.Core.Geometry.ApproximateComparer.get_Tolerance());
                    if (a2 >= 1.5707963267949)
                        p2.Value = mp;
                    else
                        q2.Value = mq;
                }
            }
            else {
                if (a1 > 3.14159265358979)
                    p1.Value = mp;
                else if (a2 > 3.14159265358979)
                    p2.Value = mp;
                else if (b1 > 3.14159265358979)
                    q1.Value = mq;
                else {
                    System.Diagnostics.Debug.Assert$$Boolean(b2 > 3.14159265358979);
                    q2.Value = mq;
                }
            }
        },
        InternalCut: function (p1, p2, q1, q2, mp, mq, a1, a2, b1, b2){
            var ret = false;
            if (a1 >= 3.14159265358979 && a2 >= 3.14159265358979){
                var mpp = this.P.get_Item$$Int32(mp).get_Point();
                var mqp = this.Q.get_Item$$Int32(mq).get_Point();
                var mpnp = this.P.get_Item$$Int32(this.P.Next(mp)).get_Point();
                var orientation = Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(mpp, mqp, this.Q.get_Item$$Int32(0).get_Point());
                var nextOrientation = Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(mpp, mqp, mpnp);
                if (orientation == nextOrientation)
                    p1.Value = this.P.Next(mp);
                else
                    p2.Value = this.P.Prev(mp);
                ret = true;
            }
            if (b1 >= 3.14159265358979 && b2 >= 3.14159265358979){
                var mpp = this.P.get_Item$$Int32(mp).get_Point();
                var mqp = this.Q.get_Item$$Int32(mq).get_Point();
                var mqnp = this.Q.get_Item$$Int32(this.Q.Next(mq)).get_Point();
                var orientation = Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(mpp, mqp, this.P.get_Item$$Int32(0).get_Point());
                var nextOrientation = Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(mpp, mqp, mqnp);
                if (orientation == nextOrientation)
                    q2.Value = this.Q.Next(mq);
                else
                    q1.Value = this.Q.Prev(mq);
                ret = true;
            }
            return ret;
        },
        GetAnglesAtTheMedian: function (mp, mq, mP, mQ, a1, a2, b1, b2){
            a1.Value = Microsoft.Msagl.Core.Geometry.Point.Angle$$Point$$Point$$Point(mQ.Value, mP.Value, this.P.Pnt(this.P.Prev(mp)));
            a2.Value = Microsoft.Msagl.Core.Geometry.Point.Angle$$Point$$Point$$Point(this.P.Pnt(this.P.Next(mp)), mP.Value, mQ.Value);
            b1.Value = Microsoft.Msagl.Core.Geometry.Point.Angle$$Point$$Point$$Point(this.Q.Pnt(this.Q.Next(mq)), mQ.Value, mP.Value);
            b2.Value = Microsoft.Msagl.Core.Geometry.Point.Angle$$Point$$Point$$Point(mP.Value, mQ.Value, this.Q.Pnt(this.Q.Prev(mq)));
        },
        OnlyOneChunkContainsExactlyTwoVertices: function (p2, p1, q2, q1, mp, mq, a1, b1, a2, b2){
            var pSideIsShort = p2.Value == this.P.Next(p1.Value);
            var qSideIsShort = q1.Value == this.Q.Next(q2.Value);
            if (pSideIsShort && !qSideIsShort){
                this.ProcessShortSide(p2, p1, q2, q1, mp, mq, a1, b1, a2, b2);
                return true;
            }
            if (qSideIsShort && !pSideIsShort){
                (function (){
                    var $1 = {
                        Value: mp
                    };
                    var $2 = {
                        Value: mq
                    };
                    var $3 = {
                        Value: a1
                    };
                    var $4 = {
                        Value: b1
                    };
                    var $5 = {
                        Value: a2
                    };
                    var $6 = {
                        Value: b2
                    };
                    var $res = this.SwapEverything(p2, p1, q2, q1, $1, $2, $3, $4, $5, $6);
                    mp = $1.Value;
                    mq = $2.Value;
                    a1 = $3.Value;
                    b1 = $4.Value;
                    a2 = $5.Value;
                    b2 = $6.Value;
                    return $res;
                }).call(this);
                this.ProcessShortSide(p2, p1, q2, q1, mp, mq, a1, b1, a2, b2);
                (function (){
                    var $1 = {
                        Value: mp
                    };
                    var $2 = {
                        Value: mq
                    };
                    var $3 = {
                        Value: a1
                    };
                    var $4 = {
                        Value: b1
                    };
                    var $5 = {
                        Value: a2
                    };
                    var $6 = {
                        Value: b2
                    };
                    var $res = this.SwapEverything(p2, p1, q2, q1, $1, $2, $3, $4, $5, $6);
                    mp = $1.Value;
                    mq = $2.Value;
                    a1 = $3.Value;
                    b1 = $4.Value;
                    a2 = $5.Value;
                    b2 = $6.Value;
                    return $res;
                }).call(this);
                return true;
            }
            return false;
        },
        SwapEverything: function (p2, p1, q2, q1, mp, mq, a1, b1, a2, b2){
            this.SwapPq();
            Microsoft.Msagl.Routing.Visibility.TangentPair.Swap$$Int32$$Int32(q1, p2);
            Microsoft.Msagl.Routing.Visibility.TangentPair.Swap$$Int32$$Int32(q2, p1);
            Microsoft.Msagl.Routing.Visibility.TangentPair.Swap$$Int32$$Int32(mp, mq);
            Microsoft.Msagl.Routing.Visibility.TangentPair.Swap$$Double$$Double(b1, a2);
            Microsoft.Msagl.Routing.Visibility.TangentPair.Swap$$Double$$Double(a1, b2);
        },
        ProcessShortSide: function (p2, p1, q2, q1, mp, mq, a1, b1, a2, b2){
            if (mp == p2.Value)
                this.ProcessSide(p2, p1, q2, q1, mq, a1, b1, b2);
            else {
                if (a2 <= 3.14159265358979){
                    if (a2 + b2 >= 3.14159265358979){
                        if (a2 >= 1.5707963267949)
                            p2.Value = p1.Value;
                        else
                            q2.Value = mq;
                    }
                    else {
                        if (b1 >= 1.5707963267949)
                            q1.Value = mq;
                        else if (a2 < b2){
                            if (Microsoft.Msagl.Core.Geometry.Point.CanProject(this.Q.Pnt(mq), this.P.get_Item$$Int32(p1.Value).get_Point(), this.P.get_Item$$Int32(p2.Value).get_Point()))
                                q1.Value = mq;
                            else
                                p1.Value = p2.Value;
                        }
                    }
                }
                else {
                    if (a1 + b1 <= 3.14159265358979)
                        p1.Value = p2.Value;
                    else
                        p2.Value = p1.Value;
                }
            }
        },
        SwapPq: function (){
            var t = this.P;
            this.P = this.Q;
            this.Q = t;
        },
        ProcessSide: function (p2, p1, q2, q1, mq, a1, b1, b2){
            var mQ = this.Q.Pnt(mq);
            if (a1 <= 3.14159265358979){
                if (a1 + b1 >= 3.14159265358979){
                    if (a1 >= 1.5707963267949)
                        p1.Value = p2.Value;
                    else
                        q1.Value = mq;
                }
                else if (b2 >= 1.5707963267949)
                    q2.Value = mq;
                else if (a1 < b2){
                    if (Microsoft.Msagl.Core.Geometry.Point.CanProject(mQ, this.P.get_Item$$Int32(p1.Value).get_Point(), this.P.get_Item$$Int32(p2.Value).get_Point()))
                        q2.Value = mq;
                    else
                        p2.Value = p1.Value;
                }
            }
            else {
                p2.Value = p1.Value;
                if (b1 >= 3.14159265358979)
                    q1.Value = mq;
                else if (b2 >= 3.14159265358979)
                    q2.Value = mq;
            }
        },
        CalculateLeftTangents: function (){
            var bisectorPivot;
            var bisectorRay;
            var p1;
            var p2;
            var q1;
            var q2;
            (function (){
                var $1 = {
                    Value: bisectorPivot
                };
                var $2 = {
                    Value: bisectorRay
                };
                var $3 = {
                    Value: p1
                };
                var $4 = {
                    Value: p2
                };
                var $5 = {
                    Value: q1
                };
                var $6 = {
                    Value: q2
                };
                var $res = this.FindDividingBisector($1, $2, $3, $4, $5, $6);
                bisectorPivot = $1.Value;
                bisectorRay = $2.Value;
                p1 = $3.Value;
                p2 = $4.Value;
                q1 = $5.Value;
                q2 = $6.Value;
                return $res;
            }).call(this);
            var pFurthest = this.P.FindTheFurthestVertexFromBisector(p1, p2, bisectorPivot, bisectorRay);
            var qFurthest = this.Q.FindTheFurthestVertexFromBisector(q2, q1, bisectorPivot, bisectorRay);
            this.upperBranchOnP = false;
            this.lowerBranchOnQ = true;
            this.leftPLeftQ = this.TangentBetweenBranches(pFurthest, p1, qFurthest, q1);
            this.lowerBranchOnQ = false;
            this.leftPRightQ = this.TangentBetweenBranches(pFurthest, p1, qFurthest, q2);
        },
        CalculateRightTangents: function (){
            var bisectorPivot;
            var bisectorRay;
            var p1;
            var p2;
            var q1;
            var q2;
            (function (){
                var $1 = {
                    Value: bisectorPivot
                };
                var $2 = {
                    Value: bisectorRay
                };
                var $3 = {
                    Value: p1
                };
                var $4 = {
                    Value: p2
                };
                var $5 = {
                    Value: q1
                };
                var $6 = {
                    Value: q2
                };
                var $res = this.FindDividingBisector($1, $2, $3, $4, $5, $6);
                bisectorPivot = $1.Value;
                bisectorRay = $2.Value;
                p1 = $3.Value;
                p2 = $4.Value;
                q1 = $5.Value;
                q2 = $6.Value;
                return $res;
            }).call(this);
            var pFurthest = this.P.FindTheFurthestVertexFromBisector(p1, p2, bisectorPivot, bisectorRay);
            var qFurthest = this.Q.FindTheFurthestVertexFromBisector(q2, q1, bisectorPivot, bisectorRay);
            this.upperBranchOnP = true;
            this.lowerBranchOnQ = true;
            this.rightPLeftQ = this.TangentBetweenBranches(pFurthest, p2, qFurthest, q1);
            this.lowerBranchOnQ = false;
            this.rightPRightQ = this.TangentBetweenBranches(pFurthest, p2, qFurthest, q2);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Visibility$TangentPair);
var Microsoft$Msagl$Routing$Visibility$TangentVisibilityGraphCalculator = {
    fullname: "Microsoft.Msagl.Routing.Visibility.TangentVisibilityGraphCalculator",
    baseTypeName: "System.Object",
    staticDefinition: {
        AddTangentVisibilityEdgesToGraph: function (holes, visibilityGraph){
            if (holes.get_Count() > 1){
                var calculator = new Microsoft.Msagl.Routing.Visibility.TangentVisibilityGraphCalculator.ctor(holes, visibilityGraph, true);
                calculator.CalculateAndAddEdges();
                calculator = new Microsoft.Msagl.Routing.Visibility.TangentVisibilityGraphCalculator.ctor(holes, visibilityGraph, false);
                calculator.CalculateAndAddEdges();
            }
        },
        MarkDiagonalAsActiveInTangents: function (diagonal){
            diagonal.get_LeftTangent().set_Diagonal(diagonal);
            diagonal.get_RightTangent().set_Diagonal(diagonal);
        },
        RayIntersectDiagonal: function (pivot, pointOnRay, diagonal){
            var a = diagonal.get_Start();
            var b = diagonal.get_End();
            return Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(pivot, a, b) == Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise && Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(pivot, pointOnRay, a) != Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise && Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(pivot, pointOnRay, b) != Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (holes, visibilityGraph, useLeftPTangents){
            this.polygons = null;
            this.visibilityGraph = null;
            this.diagonals = null;
            this.tangents = null;
            this.activeDiagonalTree = null;
            this.currentPolygon = null;
            this.activeDiagonalComparer = new Microsoft.Msagl.Routing.Visibility.ActiveDiagonalComparerWithRay.ctor();
            this.useLeftPTangents = false;
            System.Object.ctor.call(this);
            this.polygons = holes;
            this.visibilityGraph = visibilityGraph;
            this.useLeftPTangents = useLeftPTangents;
        },
        CalculateAndAddEdges: function (){
            for (var i = 0; i < this.polygons.get_Count(); i++)
                this.CalculateVisibleTangentsFromPolygon(i);
        },
        CalculateVisibleTangentsFromPolygon: function (i){
            this.AllocateDataStructures(i);
            this.OrganizeTangents();
            this.InitActiveDiagonals();
            this.Sweep();
        },
        AllocateDataStructures: function (i){
            this.tangents = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Visibility.Tangent.ctor);
            this.diagonals = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Routing.Visibility.Diagonal.ctor);
            this.activeDiagonalTree = new Microsoft.Msagl.Core.DataStructures.RbTree$1.ctor$$IComparer$1(Microsoft.Msagl.Routing.Visibility.Diagonal.ctor, this.activeDiagonalComparer);
            this.currentPolygon = this.polygons.get_Item$$Int32(i);
        },
        Sweep: function (){
            if (this.tangents.get_Count() < 2)
                return;
            for (var i = 1; i < this.tangents.get_Count(); i++){
                var t = this.tangents.get_Item$$Int32(i);
                if (t.get_Diagonal() != null){
                    if (t.get_Diagonal().get_RbNode() == this.activeDiagonalTree.TreeMinimum())
                        this.AddVisibleEdge(t);
                    if (t.get_IsHigh())
                        this.RemoveDiagonalFromActiveNodes(t.get_Diagonal());
                }
                else {
                    if (t.get_IsLow()){
                        this.activeDiagonalComparer.set_PointOnTangentAndInsertedDiagonal(t.get_End().get_Point());
                        this.InsertActiveDiagonal(new Microsoft.Msagl.Routing.Visibility.Diagonal.ctor(t, t.get_Comp()));
                        if (t.get_Diagonal().get_RbNode() == this.activeDiagonalTree.TreeMinimum())
                            this.AddVisibleEdge(t);
                    }
                }
            }
        },
        AddVisibleEdge: function (t){
            Microsoft.Msagl.Routing.Visibility.VisibilityGraph.AddEdge$$VisibilityVertex$$VisibilityVertex(this.visibilityGraph.GetVertex(t.get_Start()), this.visibilityGraph.GetVertex(t.get_End()));
        },
        InitActiveDiagonals: function (){
            var firstTangent = this.tangents.get_Item$$Int32(0);
            var firstTangentStart = firstTangent.get_Start().get_Point();
            var firstTangentEnd = firstTangent.get_End().get_Point();
            var $it1299 = this.diagonals.GetEnumerator();
            while ($it1299.MoveNext()){
                var diagonal = $it1299.get_Current();
                if (Microsoft.Msagl.Routing.Visibility.TangentVisibilityGraphCalculator.RayIntersectDiagonal(firstTangentStart, firstTangentEnd, diagonal)){
                    this.activeDiagonalComparer.set_PointOnTangentAndInsertedDiagonal(Microsoft.Msagl.Routing.Visibility.ActiveDiagonalComparerWithRay.IntersectDiagonalWithRay(firstTangentStart, firstTangentEnd, diagonal));
                    this.InsertActiveDiagonal(diagonal);
                }
            }
            if (firstTangent.get_Diagonal().get_RbNode() == this.activeDiagonalTree.TreeMinimum())
                this.AddVisibleEdge(firstTangent);
            if (firstTangent.get_IsLow() == false){
                var diag = firstTangent.get_Diagonal();
                this.RemoveDiagonalFromActiveNodes(diag);
            }
        },
        RemoveDiagonalFromActiveNodes: function (diag){
            var changedNode = this.activeDiagonalTree.DeleteSubtree(diag.get_RbNode());
            if (changedNode != null)if (changedNode.Item != null)
                changedNode.Item.set_RbNode(changedNode);
            diag.get_LeftTangent().set_Diagonal(null);
            diag.get_RightTangent().set_Diagonal(null);
        },
        InsertActiveDiagonal: function (diagonal){
            diagonal.set_RbNode(this.activeDiagonalTree.Insert(diagonal));
            Microsoft.Msagl.Routing.Visibility.TangentVisibilityGraphCalculator.MarkDiagonalAsActiveInTangents(diagonal);
        },
        TangentComparison: function (e0, e1){
            return Microsoft.Msagl.Routing.Visibility.StemStartPointComparer.CompareVectorsByAngleToXAxis(Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(e0.get_End().get_Point(), e0.get_Start().get_Point()), Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(e1.get_End().get_Point(), e1.get_Start().get_Point()));
        },
        OrganizeTangents: function (){
            var $it1300 = this.polygons.GetEnumerator();
            while ($it1300.MoveNext()){
                var q = $it1300.get_Current();
                if (q != this.currentPolygon)
                    this.ProcessPolygonQ(q);
            }
            this.tangents.Sort$$Comparison$1($CreateDelegate(this, this.TangentComparison));
        },
        ProcessPolygonQ: function (q){
            var tangentPair = new Microsoft.Msagl.Routing.Visibility.TangentPair.ctor(this.currentPolygon, q);
            if (this.useLeftPTangents)
                tangentPair.CalculateLeftTangents();
            else
                tangentPair.CalculateRightTangents();
            var couple = this.useLeftPTangents ? tangentPair.leftPLeftQ : tangentPair.rightPLeftQ;
            var t0 = new Microsoft.Msagl.Routing.Visibility.Tangent.ctor(this.currentPolygon.get_Item$$Int32(couple.get_Item1()), q.get_Item$$Int32(couple.get_Item2()));
            t0.set_IsLow(true);
            t0.set_SeparatingPolygons(!this.useLeftPTangents);
            couple = this.useLeftPTangents ? tangentPair.leftPRightQ : tangentPair.rightPRightQ;
            var t1 = new Microsoft.Msagl.Routing.Visibility.Tangent.ctor(this.currentPolygon.get_Item$$Int32(couple.get_Item1()), q.get_Item$$Int32(couple.get_Item2()));
            t1.set_IsLow(false);
            t1.set_SeparatingPolygons(this.useLeftPTangents);
            t0.set_Comp(t1);
            t1.set_Comp(t0);
            this.tangents.Add(t0);
            this.tangents.Add(t1);
            this.diagonals.Add(new Microsoft.Msagl.Routing.Visibility.Diagonal.ctor(t0, t1));
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Visibility$TangentVisibilityGraphCalculator);
var Microsoft$Msagl$Routing$Visibility$TangentVisibilityGraphCalculator$FilterVisibleEdgesDelegate = {
    fullname: "Microsoft.Msagl.Routing.Visibility.TangentVisibilityGraphCalculator.FilterVisibleEdgesDelegate",
    Kind: "Delegate",
    definition: {
        ctor: function (obj, func){
            System.MulticastDelegate.ctor.call(this, obj, func);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Routing$Visibility$TangentVisibilityGraphCalculator$FilterVisibleEdgesDelegate);
var Microsoft$Msagl$Layout$Layered$XCoordsWithAlignment = {
    fullname: "Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment",
    baseTypeName: "System.Object",
    staticDefinition: {
        cctor: function (){
            Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.infinity = 1.79769313486232E+308;
        },
        CalculateXCoordinates: function (layerArrays, layeredGraph, nOfOriginalVs, anchors, nodeSeparation){
            var x = new Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.ctor(layerArrays, layeredGraph, nOfOriginalVs, anchors, nodeSeparation);
            x.Calculate();
        },
        IsLeftMostAssignment: function (i){
            return i == 0 || i == 2;
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (layerArrays, layeredGraph, nOfOriginalVs, anchorsP, ns){
            this.la = null;
            this.graph = null;
            this.nOfOriginalVertices = 0;
            this.root = null;
            this.align = null;
            this.nOfVertices = 0;
            this.anchors = null;
            this.nodeSep = 0;
            this.lowMedians = null;
            this.upperMedians = null;
            this.markedEdges = new Microsoft.Msagl.Core.DataStructures.Set$1.ctor(Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor);
            this.h = 0;
            this.LR = false;
            this.BT = false;
            this.xCoords = new Array(4);
            this.x = null;
            System.Object.ctor.call(this);
            this.la = layerArrays;
            this.graph = layeredGraph;
            this.nOfOriginalVertices = nOfOriginalVs;
            this.nOfVertices = this.graph.get_NodeCount();
            this.h = this.la.get_Layers().length;
            this.root = new Int32Array(this.nOfVertices);
            this.align = new Int32Array(this.nOfVertices);
            this.anchors = anchorsP;
            this.nodeSep = ns;
        },
        EnumRightUp$$: "System.Int32",
        get_EnumRightUp: function (){
            return (this.LR ? 0 : 1) + 2 * (this.BT ? 0 : 1);
        },
        IsVirtual: function (v){
            return v >= this.nOfOriginalVertices;
        },
        Source: function (edge){
            return this.BT ? edge.get_Source() : edge.get_Target();
        },
        Target: function (edge){
            return this.BT ? edge.get_Target() : edge.get_Source();
        },
        Calculate: function (){
            this.SortInAndOutEdges();
            this.RightUpSetup();
            this.CalcBiasedAlignment();
            this.LeftUpSetup();
            this.CalcBiasedAlignment();
            this.RightDownSetup();
            this.CalcBiasedAlignment();
            this.LeftDownSetup();
            this.CalcBiasedAlignment();
            this.HorizontalBalancing();
        },
        SortInAndOutEdges: function (){
            this.FillLowMedians();
            this.FillUpperMedins();
        },
        FillUpperMedins: function (){
            this.upperMedians = new Array(this.graph.get_NodeCount());
            for (var i = 0; i < this.graph.get_NodeCount(); i++)
                this.FillUpperMediansForNode(i);
        },
        CompareByX: function (a, b){
            return this.la.get_X()[a] - this.la.get_X()[b];
        },
        FillUpperMediansForNode: function (i){
            var count = this.graph.InEdgesCount(i);
            if (count > 0){
                var predecessors = new Int32Array(count);
                count = 0;
                var $it1301 = this.graph.InEdges(i).GetEnumerator();
                while ($it1301.MoveNext()){
                    var e = $it1301.get_Current();
                    predecessors[count++] = e.get_Source();
                }
                System.Array.Sort$1$$T$Array$$Comparison$1(System.Int32.ctor, predecessors, $CreateDelegate(this, this.CompareByX));
                var m = (count / 2) | 0;
                if (m * 2 == count){
                    this.upperMedians[i] = new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(predecessors[m - 1], predecessors[m]);
                }
                else
                    this.upperMedians[i] = predecessors[m];
            }
            else
                this.upperMedians[i] = -1;
        },
        FillLowMedians: function (){
            this.lowMedians = new Array(this.graph.get_NodeCount());
            for (var i = 0; i < this.graph.get_NodeCount(); i++)
                this.FillLowMediansForNode(i);
        },
        FillLowMediansForNode: function (i){
            var count = this.graph.OutEdgesCount(i);
            if (count > 0){
                var successors = new Int32Array(count);
                count = 0;
                var $it1302 = this.graph.OutEdges(i).GetEnumerator();
                while ($it1302.MoveNext()){
                    var e = $it1302.get_Current();
                    successors[count++] = e.get_Target();
                }
                System.Array.Sort$1$$T$Array$$Comparison$1(System.Int32.ctor, successors, $CreateDelegate(this, this.CompareByX));
                var m = (count / 2) | 0;
                if (m * 2 == count){
                    this.lowMedians[i] = new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(successors[m - 1], successors[m]);
                }
                else
                    this.lowMedians[i] = successors[m];
            }
            else
                this.lowMedians[i] = -1;
        },
        HorizontalBalancing: function (){
            var leastWidthAssignment = -1;
            var a = new Float64Array(4);
            var b = new Float64Array(4);
            var leastWidth = 1.79769313486232E+308;
            for (var i = 0; i < 4; i++){
                (function (){
                    var $1 = {
                        Value: a[i]
                    };
                    var $2 = {
                        Value: b[i]
                    };
                    var $res = this.AssignmentBounds(i, a[i], b[i]);
                    a[i] = $1.Value;
                    b[i] = $2.Value;
                    return $res;
                }).call(this);
                var w = b[i] - a[i];
                if (w < leastWidth){
                    leastWidthAssignment = i;
                    leastWidth = w;
                }
            }
            for (var i = 0; i < 4; i++){
                var delta;
                if (Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.IsLeftMostAssignment(i))
                    delta = a[leastWidthAssignment] - a[i];
                else
                    delta = b[leastWidthAssignment] - b[i];
                this.x = this.xCoords[i];
                if (delta != 0)
                    for (var j = 0; j < this.nOfVertices; j++)
                        this.x[j] += delta;
            }
            var arr = new Float64Array(4);
            for (var v = 0; v < this.nOfVertices; v++){
                arr[0] = this.xCoords[0][v];
                arr[1] = this.xCoords[1][v];
                arr[2] = this.xCoords[2][v];
                arr[3] = this.xCoords[3][v];
                System.Array.Sort$1$$T$Array(System.Double.ctor, arr);
                this.anchors[v].set_X((arr[1] + arr[2]) / 2);
            }
        },
        AssignmentBounds: function (i, a, b){
            if (this.nOfVertices == 0){
                a.Value = 0;
                b.Value = 0;
            }
            else {
                this.x = this.xCoords[i];
                a.Value = b.Value = this.x[0];
                for (var j = 1; j < this.nOfVertices; j++){
                    var r = this.x[j];
                    if (r < a.Value)
                        a.Value = r;
                    else if (r > b.Value)
                        b.Value = r;
                }
            }
        },
        CalcBiasedAlignment: function (){
            this.ConflictElimination();
            this.Align();
        },
        LeftUpSetup: function (){
            this.LR = false;
            this.BT = true;
        },
        LeftDownSetup: function (){
            this.LR = false;
            this.BT = false;
        },
        RightDownSetup: function (){
            this.LR = true;
            this.BT = false;
        },
        RightUpSetup: function (){
            this.LR = true;
            this.BT = true;
        },
        ConflictElimination: function (){
            this.RemoveMarksFromEdges();
            this.MarkConflictingEdges();
        },
        UpperEdgeMedians: function (target){
            var $yield = [];
            var medians = this.BT ? this.upperMedians[target] : this.lowMedians[target];
            var ip = As(medians, Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor);
            if (ip != null){
                if (this.LR){
                    $yield.push(ip.get_First());
                    $yield.push(ip.get_Second());
                }
                else {
                    $yield.push(ip.get_Second());
                    $yield.push(ip.get_First());
                }
            }
            else {
                var i = medians;
                if (i >= 0)
                    $yield.push(i);
            }
            return $yield;
        },
        MarkConflictingEdges: function (){
            var i = this.LowerOf(0, this.h - 1);
            var lowest = i;
            var upperBound = this.UpperOf(0, this.h - 1);
            var nextBelowUpperBound = this.NextLower(upperBound);
            for (; this.IsBelow(i, upperBound); i = this.NextUpper(i)){
                if (this.IsBelow(lowest, i) && this.IsBelow(i, nextBelowUpperBound))
                    this.ConflictsWithAtLeastOneInnerEdgeForALayer(i);
            }
        },
        NextUpper: function (i){
            return this.BT ? i + 1 : i - 1;
        },
        NextLower: function (i){
            return this.BT ? i - 1 : i + 1;
        },
        UpperOf: function (i, j){
            return this.BT ? System.Math.Max$$Int32$$Int32(i, j) : System.Math.Min$$Int32$$Int32(i, j);
        },
        LowerOf: function (i, j){
            return this.BT ? System.Math.Min$$Int32$$Int32(i, j) : System.Math.Max$$Int32$$Int32(i, j);
        },
        IsBelow: function (i, j){
            return this.BT ? i < j : j < i;
        },
        LeftMost$$Int32$$Int32: function (pos0, pos1){
            return this.LR ? System.Math.Min$$Int32$$Int32(pos0, pos1) : System.Math.Max$$Int32$$Int32(pos0, pos1);
        },
        LeftMost$$Double$$Double: function (pos0, pos1){
            return this.LR ? System.Math.Min$$Double$$Double(pos0, pos1) : System.Math.Max$$Double$$Double(pos0, pos1);
        },
        RightMost$$Int32$$Int32: function (pos0, pos1){
            return this.LR ? System.Math.Max$$Int32$$Int32(pos0, pos1) : System.Math.Min$$Int32$$Int32(pos0, pos1);
        },
        RightMost$$Double$$Double: function (pos0, pos1){
            return this.LR ? System.Math.Max$$Double$$Double(pos0, pos1) : System.Math.Min$$Double$$Double(pos0, pos1);
        },
        IsNotRightFrom: function (i, pos){
            return this.LR ? i <= pos : pos <= i;
        },
        IsLeftFrom: function (i, j){
            return this.LR ? i < j : j < i;
        },
        NextRight: function (i){
            return this.LR ? i + 1 : i - 1;
        },
        NextLeft: function (i){
            return this.LR ? i - 1 : i + 1;
        },
        ConflictsWithAtLeastOneInnerEdgeForALayer: function (layerIndex){
            if (layerIndex >= 0 && layerIndex < this.la.get_Layers().length){
                var lowerLayer = this.la.get_Layers()[layerIndex];
                var innerEdge = null;
                var targetPos = this.LeftMost$$Int32$$Int32(0, lowerLayer.length - 1);
                var lastTargetPos = this.RightMost$$Int32$$Int32(0, lowerLayer.length - 1);
                for (; this.IsNotRightFrom(targetPos, lastTargetPos) && innerEdge == null; targetPos = this.NextRight(targetPos))
                    innerEdge = this.InnerEdgeByTarget(lowerLayer[targetPos]);
                if (innerEdge != null){
                    var positionOfInnerEdgeSource = this.Pos(this.Source(innerEdge));
                    for (var j = this.LeftMost$$Int32$$Int32(0, lowerLayer.length - 1); this.IsLeftFrom(j, targetPos); j = this.NextRight(j)){
                        var $it1303 = this.InEdges(lowerLayer[j]).GetEnumerator();
                        while ($it1303.MoveNext()){
                            var ie = $it1303.get_Current();
                            if (this.IsLeftFrom(positionOfInnerEdgeSource, this.Pos(this.Source(ie))))
                                this.MarkEdge(ie);
                        }
                    }
                    var innerSourcePos = this.Pos(this.Source(innerEdge));
                    while (this.IsNotRightFrom(targetPos, lastTargetPos)){
                        var newInnerEdge = this.AlignmentToTheRightOfInner(lowerLayer, targetPos, positionOfInnerEdgeSource);
                        targetPos = this.NextRight(targetPos);
                        if (newInnerEdge != null){
                            var newInnerSourcePos = this.Pos(this.Source(newInnerEdge));
                            this.MarkEdgesBetweenInnerAndNewInnerEdges(lowerLayer, innerEdge, newInnerEdge, innerSourcePos, newInnerSourcePos);
                            innerEdge = newInnerEdge;
                            innerSourcePos = newInnerSourcePos;
                        }
                    }
                    positionOfInnerEdgeSource = this.Pos(this.Source(innerEdge));
                    for (var k = this.NextRight(this.Pos(this.Target(innerEdge))); this.IsNotRightFrom(k, lastTargetPos); k = this.NextRight(k)){
                        var $it1304 = this.InEdges(lowerLayer[k]).GetEnumerator();
                        while ($it1304.MoveNext()){
                            var ie = $it1304.get_Current();
                            if (this.IsLeftFrom(this.Pos(this.Source(ie)), this.Pos(this.Source(innerEdge))))
                                this.MarkEdge(ie);
                        }
                    }
                }
            }
        },
        InEdgeOfVirtualNode: function (v){
            return (this.BT ? this.graph.InEdgeOfVirtualNode(v) : this.graph.OutEdgeOfVirtualNode(v));
        },
        InEdges: function (v){
            return this.BT ? this.graph.InEdges(v) : this.graph.OutEdges(v);
        },
        MarkEdgesBetweenInnerAndNewInnerEdges: function (lowerLayer, innerEdge, newInnerEdge, innerEdgeSourcePos, newInnerEdgeSourcePos){
            var u = this.NextRight(this.Pos(this.Target(innerEdge)));
            for (; this.IsLeftFrom(u, this.Pos(this.Target(newInnerEdge))); u = this.NextRight(u)){
                var $it1305 = this.InEdges(lowerLayer[u]).GetEnumerator();
                while ($it1305.MoveNext()){
                    var ie = $it1305.get_Current();
                    var ieSourcePos = this.Pos(this.Source(ie));
                    if (this.IsLeftFrom(ieSourcePos, innerEdgeSourcePos))
                        this.MarkEdge(ie);
                    else if (this.IsLeftFrom(newInnerEdgeSourcePos, ieSourcePos))
                        this.MarkEdge(ie);
                }
            }
        },
        AlignmentToTheRightOfInner: function (lowLayer, i, posInnerSource){
            var numOfInEdges = this.NumberOfInEdges(lowLayer[i]);
            if (numOfInEdges == 1){
                var ie = null;
                var $it1306 = this.InEdges(lowLayer[i]).GetEnumerator();
                while ($it1306.MoveNext()){
                    var e = $it1306.get_Current();
                    ie = e;
                }
                if (this.IsInnerEdge(ie) && this.IsLeftFrom(posInnerSource, this.Pos(ie.get_Source())))
                    return ie;
                return null;
            }
            return null;
        },
        NumberOfInEdges: function (v){
            return this.BT ? this.graph.InEdgesCount(v) : this.graph.OutEdgesCount(v);
        },
        Pos: function (v){
            return this.la.get_X()[v];
        },
        InnerEdgeByTarget: function (v){
            if (this.IsVirtual(v)){
                var ie = this.InEdgeOfVirtualNode(v);
                if (this.IsVirtual(this.Source(ie)))
                    return ie;
            }
            return null;
        },
        IsInnerEdge: function (e){
            return this.IsVirtual(e.get_Source()) && this.IsVirtual(e.get_Target());
        },
        RemoveMarksFromEdges: function (){
            this.markedEdges.Clear();
        },
        Align: function (){
            this.CreateBlocks();
            this.AssignCoordinatesByLongestPath();
        },
        AssignCoordinatesByLongestPath: function (){
            this.x = this.xCoords[this.get_EnumRightUp()] = new Float64Array(this.nOfVertices);
            var edges = new System.Collections.Generic.List$1.ctor(Microsoft.Msagl.Layout.Layered.IntEdge.ctor);
            for (var v = 0; v < this.nOfVertices; v++){
                if (v == this.root[v]){
                    var w = v;
                    do{
                        var rightNeighbor;
                        if ((function (){
                            var $1 = {
                                Value: rightNeighbor
                            };
                            var $res = this.TryToGetRightNeighbor(w, $1);
                            rightNeighbor = $1.Value;
                            return $res;
                        }).call(this))
                            edges.Add(new Microsoft.Msagl.Layout.Layered.IntEdge.ctor$$Int32$$Int32(v, this.root[rightNeighbor]));
                        w = this.align[w];
                    }
                    while (w != v)
                }
            }
            var blockGraph = new Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph$1.ctor$$IEnumerable$1$$Int32(Microsoft.Msagl.Layout.Layered.IntEdge.ctor, edges, this.nOfVertices);
            var topoSort = Microsoft.Msagl.Layout.Layered.IntEdge.GetOrder(blockGraph);
            for (var $i1308 = 0,$l1308 = topoSort.length,v = topoSort[$i1308]; $i1308 < $l1308; $i1308++, v = topoSort[$i1308]){
                if (v == this.root[v]){
                    var vx = 0;
                    var vIsLeftMost = true;
                    var w = v;
                    do{
                        var wLeftNeighbor;
                        if ((function (){
                            var $1 = {
                                Value: wLeftNeighbor
                            };
                            var $res = this.TryToGetLeftNeighbor(w, $1);
                            wLeftNeighbor = $1.Value;
                            return $res;
                        }).call(this)){
                            if (vIsLeftMost){
                                vx = this.x[this.root[wLeftNeighbor]] + this.DeltaBetweenVertices(wLeftNeighbor, w);
                                vIsLeftMost = false;
                            }
                            else
                                vx = this.RightMost$$Double$$Double(vx, this.x[this.root[wLeftNeighbor]] + this.DeltaBetweenVertices(wLeftNeighbor, w));
                        }
                        w = this.align[w];
                    }
                    while (w != v)
                    this.x[v] = vx;
                }
            }
            for (var $i1309 = 0,$l1309 = topoSort.length,v = topoSort[$i1309]; $i1309 < $l1309; $i1309++, v = topoSort[$i1309]){
                if (v == this.root[v])if (blockGraph.InEdges(v).get_Count() == 0){
                    var w = v;
                    var xLeftMost = this.RightMost$$Double$$Double(-1.79769313486232E+308, 1.79769313486232E+308);
                    var xl = xLeftMost;
                    do{
                        var wRightNeigbor;
                        if ((function (){
                            var $1 = {
                                Value: wRightNeigbor
                            };
                            var $res = this.TryToGetRightNeighbor(w, $1);
                            wRightNeigbor = $1.Value;
                            return $res;
                        }).call(this))
                            xLeftMost = this.LeftMost$$Double$$Double(xLeftMost, this.x[this.root[wRightNeigbor]] - this.DeltaBetweenVertices(w, wRightNeigbor));
                        w = this.align[w];
                    }
                    while (w != v)
                    if (xl != xLeftMost)
                        this.x[v] = xLeftMost;
                }
            }
            for (var v = 0; v < this.nOfVertices; v++){
                if (v != this.root[v])
                    this.x[v] = this.x[this.root[v]];
            }
        },
        TryToGetRightNeighbor: function (u, neighbor){
            var neighborPos = this.NextRight(this.Pos(u));
            var layer = this.la.get_Layers()[this.la.Y[u]];
            if (neighborPos >= 0 && neighborPos < layer.length){
                neighbor.Value = layer[neighborPos];
                return true;
            }
            else {
                neighbor.Value = 0;
                return false;
            }
        },
        TryToGetLeftNeighbor: function (u, neighbor){
            var neighborPos = this.NextLeft(this.Pos(u));
            var layer = this.la.get_Layers()[this.la.Y[u]];
            if (neighborPos >= 0 && neighborPos < layer.length){
                neighbor.Value = layer[neighborPos];
                return true;
            }
            else {
                neighbor.Value = 0;
                return false;
            }
        },
        CreateBlocks: function (){
            for (var v = 0; v < this.nOfVertices; v++)
                this.root[v] = this.align[v] = v;
            var lowBound = this.LowerOf(0, this.h - 1);
            for (var i = this.NextLower(this.UpperOf(0, this.h - 1)); !this.IsBelow(i, lowBound); i = this.NextLower(i)){
                var layer = this.la.get_Layers()[i];
                var r = this.LeftMost$$Int32$$Int32(-1, this.la.get_Layers()[this.NextUpper(i)].length);
                var rightBound = this.RightMost$$Int32$$Int32(0, layer.length - 1);
                for (var k = this.LeftMost$$Int32$$Int32(0, layer.length - 1); this.IsNotRightFrom(k, rightBound); k = this.NextRight(k)){
                    var vk = layer[k];
                    var $it1309 = this.UpperEdgeMedians(vk).GetEnumerator();
                    while ($it1309.MoveNext()){
                        var upperNeighborOfVk = $it1309.get_Current();
                        if (!this.IsMarked(vk, upperNeighborOfVk)){
                            if (this.IsLeftFrom(r, this.Pos(upperNeighborOfVk))){
                                this.align[upperNeighborOfVk] = vk;
                                this.align[vk] = this.root[vk] = this.root[upperNeighborOfVk];
                                r = this.Pos(upperNeighborOfVk);
                                break;
                            }
                        }
                    }
                }
            }
        },
        IsMarked: function (source, target){
            if (this.BT)
                return this.markedEdges.Contains$$T(new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(target, source));
            else
                return this.markedEdges.Contains$$T(new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(source, target));
        },
        MarkEdge: function (ie){
            this.markedEdges.Insert(new Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ctor(ie.get_Source(), ie.get_Target()));
        },
        DeltaBetweenVertices: function (u, v){
            var sign = 1;
            if (this.Pos(u) > this.Pos(v)){
                var t = u;
                u = v;
                v = t;
                sign = -1;
            }
            var anchorSepar = this.anchors[u].get_RightAnchor() + this.anchors[v].get_LeftAnchor();
            return (anchorSepar + this.nodeSep) * sign;
        }
    }
};
JsTypes.push(Microsoft$Msagl$Layout$Layered$XCoordsWithAlignment);
var Microsoft$Msagl$Core$ValidateArg = {
    fullname: "Microsoft.Msagl.Core.ValidateArg",
    baseTypeName: "System.Object",
    staticDefinition: {
        IsNotNull: function (arg, parameterName){
            if (arg == null){
                throw $CreateException(new System.ArgumentNullException.ctor$$String(parameterName), new Error());
            }
        },
        IsPositive: function (value, parameterName){
            if (value < 0){
                throw $CreateException(new System.ArgumentOutOfRangeException.ctor$$String$$String(parameterName, "The argument must be positive"), new Error());
            }
        },
        IsNotEmpty$1: function (T, enumerable, parameterName){
            if (enumerable == null){
                throw $CreateException(new System.ArgumentNullException.ctor$$String(parameterName), new Error());
            }
            if (!System.Linq.Enumerable.Any$1$$IEnumerable$1(T, enumerable)){
                throw $CreateException(new System.ArgumentException.ctor$$String$$String("The argument enumerable must not be empty", parameterName), new Error());
            }
        }
    },
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Object.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$ValidateArg);
var Microsoft$Msagl$Core$ValidateArg$ValidatedNotNullAttribute = {
    fullname: "Microsoft.Msagl.Core.ValidateArg.ValidatedNotNullAttribute",
    baseTypeName: "System.Attribute",
    assemblyName: "Microsoft.Msagl",
    Kind: "Class",
    definition: {
        ctor: function (){
            System.Attribute.ctor.call(this);
        }
    }
};
JsTypes.push(Microsoft$Msagl$Core$ValidateArg$ValidatedNotNullAttribute);

